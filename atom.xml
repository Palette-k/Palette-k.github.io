<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Palette</title>
  <icon>https://www.gravatar.com/avatar/f6d0550c9229791f51dcfd63ef1e86d9</icon>
  <subtitle>个人博客</subtitle>
  <link href="https://palette-k.github.io/atom.xml" rel="self"/>
  
  <link href="https://palette-k.github.io/"/>
  <updated>2024-02-18T10:38:09.647Z</updated>
  <id>https://palette-k.github.io/</id>
  
  <author>
    <name>Palette</name>
    <email>1148432487@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx的使用</title>
    <link href="https://palette-k.github.io/2024/02/18/nginx%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://palette-k.github.io/2024/02/18/nginx%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2024-02-18T10:37:44.000Z</published>
    <updated>2024-02-18T10:38:09.647Z</updated>
    
    <content type="html"><![CDATA[<p>nginx进阶：</p><p>·    正向代理和反向代理</p><p>正向代理指的是代理客户端， 代替用户向服务器发送请求， 从而隐藏用户的信息。</p><p>反向代理指的是代理服务器， 通过反向代理，服务器可以分流请求， 而且实际执行请求的服务器处于内网时， 通过反向代理服务器，也能将请求从公网转到内网。 同时隐藏了内网服务器的信息。</p><p>keepAlive</p><p>busybox</p><p>Docker desktop — 搭一个 nginx 验证</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;nginx进阶：&lt;/p&gt;
&lt;p&gt;·    正向代理和反向代理&lt;/p&gt;
&lt;p&gt;正向代理指的是代理客户端， 代替用户向服务器发送请求， 从而隐藏用户的信息。&lt;/p&gt;
&lt;p&gt;反向代理指的是代理服务器， 通过反向代理，服务器可以分流请求， 而且实际执行请求的服务器处于内网时， 通过</summary>
      
    
    
    
    
    <category term="nginx" scheme="https://palette-k.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>了解Quartz</title>
    <link href="https://palette-k.github.io/2024/02/18/%E4%BA%86%E8%A7%A3quartz/"/>
    <id>https://palette-k.github.io/2024/02/18/%E4%BA%86%E8%A7%A3quartz/</id>
    <published>2024-02-18T07:49:29.000Z</published>
    <updated>2024-02-18T08:33:40.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h1><p><strong>Quartz</strong>是一款轻量级且特性丰富的任务调度库，它是基于<strong>Java</strong>实现的调度框架，本文会针对日常任务调度的使用场景来演示<strong>Quartz</strong>的使用姿势。</p><h1 id="源码角度分析"><a href="#源码角度分析" class="headerlink" title="源码角度分析"></a>源码角度分析</h1><p>都说<strong>Quartz</strong>是任务调度框架，从源码就可以看出其本质也就是工作线程轮询并执行继续的调度任务。</p><p><strong>Quartz</strong>将任务定义为<strong>Job</strong>，Job是工作任务调度的接口，该接口定义了<strong>execute</strong>方法，所以当我们需要提交任务给<strong>Quartz</strong>时，就需要继承<strong>Job</strong>接口并在<strong>execute</strong>方法里告知要执行的任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now()</span><br><span class="line">                .format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        log.info(<span class="string">&quot;任务执行时间:&#123;&#125;&quot;</span>, dateTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了<strong>Job</strong>，就需要安排调度计划，在<strong>Quartz</strong>这个框架中，<strong>Trigger</strong>就是告知调度器如何进行任务触发的触发器，使用代码如下所示:</p><ol><li>基于<strong>JobBuilder</strong>创建job，并声称<strong>job</strong>的名称。</li><li>定义触发器，该触发器立即启动并设置名称为<strong>testTrigger</strong>，触发器属于<strong>testTriggerGroup</strong>分组中，执行计划为1秒1次。</li></ol><p>最后就是声明<strong>scheduler</strong>将触发器和任务关联，通过<strong>scheduler</strong>的<strong>scheduleJob</strong>方法关联，就会形成一个以<strong>Job</strong>为工作内容，并按照触发器的安排进行任务的调度的任务定时被调度器执行。 注意该方法还会返回第一次执行的时间，一旦调用<strong>start</strong>，当前方法调度工作就正式开始了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">// 获取任务调度的实例</span></span><br><span class="line">       <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 定义任务调度实例, 并与TestJob绑定</span></span><br><span class="line">       <span class="type">JobDetail</span> <span class="variable">job</span> <span class="operator">=</span> JobBuilder.newJob(MyJob.class)</span><br><span class="line">               .withIdentity(<span class="string">&quot;myJob&quot;</span>, <span class="string">&quot;myJobGroup&quot;</span>)</span><br><span class="line">               .build();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 定义触发器, 会马上执行一次, 接着1秒执行一次</span></span><br><span class="line">       <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">               .withIdentity(<span class="string">&quot;testTrigger&quot;</span>, <span class="string">&quot;testTriggerGroup&quot;</span>)</span><br><span class="line">               .startNow()</span><br><span class="line">               .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(<span class="number">1</span>))</span><br><span class="line">               .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用触发器调度任务的执行 获取任务调度时间</span></span><br><span class="line">       <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span>scheduler.scheduleJob(job, trigger);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 开启任务</span></span><br><span class="line">       scheduler.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看出<strong>Quartz</strong>的工作核心就是，通过<strong>Job</strong>来指定任务的详情，结合触发器<strong>Trigger</strong>指定任务的执行时间和间隔还有次数等信息，再让调度器<strong>scheduler</strong>定期去执行前两者关联而生成的定时任务。</p><h1 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h1><h2 id="Quartz横向扩展带来的问题"><a href="#Quartz横向扩展带来的问题" class="headerlink" title="Quartz横向扩展带来的问题"></a>Quartz横向扩展带来的问题</h2><p>虽说<strong>Quartz</strong>支持集群模式实现横向扩展，也就是我们常说的分布式调度，但需要业务方面通过一些手段实现节点任务执行的互斥和安全，从而避免任务重复执行等一些问题，常见的解决方案分别由数据库锁和分布式锁两种:</p><p>在调度进行任务争抢时先对数据库表上锁，只有拿到锁的节点才可以进行获取任务并调度，这种是常规情况下的解决方案，但这种实现方式有着很强的侵入性，且在高并发的场景性能表现也不是很出色，所以大部分情况下，我们不是很推荐通过数据表的形式实现分布式任务调度一致性。</p><p>通常情况下，采用<strong>redis分布式锁</strong>是针对<strong>Quartz</strong>框架分布式任务调度的较好解决方案，通过在内存中进行任务争抢，大大提分布式调度性能，但还是存在调度空跑问题，即先抢到锁的节点获取仅有的任务，而其他节点随后得锁后却没有执行任务，造成一次空跑。</p><h2 id="任务分片问题"><a href="#任务分片问题" class="headerlink" title="任务分片问题"></a>任务分片问题</h2><p>试想一个场景，原本一个节点负责调度全国系统的所有任务，随着业务激增我们将<strong>Quartz</strong>设置为集群模式，希望各个节点负责执行不同省份的任务。其他调度框架例如<strong>XXL-JOB</strong>，可以通过配置中心决定这个调度规则例如工具任务的编号知晓省份通过hash取模分配给不同的省份。</p><p><img src="https://qiniuyun.sharkchili.com/img202401081220268.png" alt="在这里插入图片描述"></p><p>而<strong>Quartz</strong>因为没有对应的页面和配置中心，所以实现任务分片需要通过硬编码的形式来实现，有着很强的代码侵入以及实现的复杂性。</p><h1 id="横向对比其他方案"><a href="#横向对比其他方案" class="headerlink" title="横向对比其他方案"></a>横向对比其他方案</h1><p>所以对于简单且较为轻量的任务调度场景，我们可优先考虑<strong>Quartz</strong>，若希望在集群环境下实现分布式调度以及任务分片等复杂的需求时，可参照下面酌情考虑这些更高效中心化的任务调度中心<strong>xxl-job</strong>或者<strong>elastic-job</strong>：</p><table><thead><tr><th>对比项</th><th align="center">Quartz</th><th align="center">elastic-job</th><th align="center">xxl-job</th></tr></thead><tbody><tr><td>集群、弹性扩容</td><td align="center">多节点，部署，通过竞争数据库锁来保证只有一个节点执行任务</td><td align="center">通过zookeeper的注册与发现，可以动态的添加服务器。支持水平扩容</td><td align="center">使用Quartz基于数据库的分布式功能，服务器超出一定数量会给数据库造成一定的压力</td></tr><tr><td>任务分片</td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td>管理界面</td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td>高级功能</td><td align="center">❌</td><td align="center">弹性扩容，多种作业模式，失效转移，运行状态收集，多线程处理数据，幂等性，容错处理，spring命名空间支持</td><td align="center">弹性扩容，分片广播，故障转移，Rolling实时日志，GLUE（支持在线编辑代码，免发布），任务进度监控，任务依赖，数据加密，邮件报警，运行报表，国际化</td></tr><tr><td>缺点</td><td align="center">没有管理界面，以及不支持任务分片等。不适用于分布式场景</td><td align="center">需要引入zookeeper，mesos，增加系统复杂度，学习成本较高</td><td align="center">调度中心通过获取DB锁来保证集群中执行任务的唯一性，如果短任务很多，随着调度中心集群数量增加，那么数据库的锁竞争会比较厉害，性能不好。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概述&quot;&gt;&lt;a href=&quot;#基本概述&quot; class=&quot;headerlink&quot; title=&quot;基本概述&quot;&gt;&lt;/a&gt;基本概述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Quartz&lt;/strong&gt;是一款轻量级且特性丰富的任务调度库，它是基于&lt;strong&gt;Java&lt;/str</summary>
      
    
    
    
    
    <category term="xxl-job" scheme="https://palette-k.github.io/tags/xxl-job/"/>
    
    <category term="quartz" scheme="https://palette-k.github.io/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>xxl-job的策略解析</title>
    <link href="https://palette-k.github.io/2024/02/09/xxl-job%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/"/>
    <id>https://palette-k.github.io/2024/02/09/xxl-job%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/</id>
    <published>2024-02-09T09:23:54.000Z</published>
    <updated>2024-02-18T11:07:45.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阻塞处理策略"><a href="#阻塞处理策略" class="headerlink" title="阻塞处理策略"></a>阻塞处理策略</h2><h3 id="单机串行（默认）"><a href="#单机串行（默认）" class="headerlink" title="单机串行（默认）"></a>单机串行（默认）</h3><p>调度进入单机执行器后，调度请求进入FIFO队列中并以串行方式运行</p><h3 id="丢弃后续调度（推荐）"><a href="#丢弃后续调度（推荐）" class="headerlink" title="丢弃后续调度（推荐）"></a>丢弃后续调度（推荐）</h3><p>调度请求进入单机执行器，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败</p><h3 id="覆盖之前调度（不推荐）"><a href="#覆盖之前调度（不推荐）" class="headerlink" title="覆盖之前调度（不推荐）"></a>覆盖之前调度（不推荐）</h3><p>调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度</p><h2 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h2><h3 id="调用核心"><a href="#调用核心" class="headerlink" title="调用核心"></a>调用核心</h3><p>要想了解路由策略在何时执行的，我们不妨从入口触发器的代码开始研究。我们找到XxlJobTrigger的trigger方法。我们在代码中看到这么一段关于路由的逻辑，我们不妨步入查看一下processTrigger做了些什么。</p><p>源码如下，由于代码比较长，笔者将代码核心部分贴出来，如下所示，它的整体步骤为:</p><ol><li>根据传入的job获取路由策略参数。</li><li>如果是分片广播则for循环调用外部传入的index获取执行器地址并调用执行器。</li><li>反之根据参数获取路由策略调用获取对应地址并调用即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processTrigger</span><span class="params">(XxlJobGroup group, XxlJobInfo jobInfo, <span class="type">int</span> finalFailRetryCount, TriggerTypeEnum triggerType, <span class="type">int</span> index, <span class="type">int</span> total)</span>&#123;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">       <span class="comment">//根据传入job获取配置的路由策略</span></span><br><span class="line">       <span class="type">ExecutorRouteStrategyEnum</span> <span class="variable">executorRouteStrategyEnum</span> <span class="operator">=</span> ExecutorRouteStrategyEnum.match(jobInfo.getExecutorRouteStrategy(), <span class="literal">null</span>);    <span class="comment">// route strategy</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3、根据路由策略找到对应执行器的地址</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       ReturnT&lt;String&gt; routeAddressResult = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (group.getRegistryList()!=<span class="literal">null</span> &amp;&amp; !group.getRegistryList().isEmpty()) &#123;</span><br><span class="line">           <span class="comment">//如果是分片广播的路由策略，则调用所有执行器执行一遍</span></span><br><span class="line">           <span class="keyword">if</span> (ExecutorRouteStrategyEnum.SHARDING_BROADCAST == executorRouteStrategyEnum) &#123;</span><br><span class="line">               <span class="keyword">if</span> (index &lt; group.getRegistryList().size()) &#123;</span><br><span class="line">                   address = group.getRegistryList().get(index);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   address = group.getRegistryList().get(<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//根据job配置信息找到对应路由策略类获取对应执行器的地址</span></span><br><span class="line">               routeAddressResult = executorRouteStrategyEnum.getRouter().route(triggerParam, group.getRegistryList());</span><br><span class="line">               <span class="keyword">if</span> (routeAddressResult.getCode() == ReturnT.SUCCESS_CODE) &#123;</span><br><span class="line">                   address = routeAddressResult.getContent();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           routeAddressResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, I18nUtil.getString(<span class="string">&quot;jobconf_trigger_address_empty&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4、trigger remote executor</span></span><br><span class="line">       ReturnT&lt;String&gt; triggerResult = <span class="literal">null</span>;</span><br><span class="line">       <span class="comment">//如果地址不为空则直接执行任务</span></span><br><span class="line">       <span class="keyword">if</span> (address != <span class="literal">null</span>) &#123;</span><br><span class="line">           triggerResult = runExecutor(triggerParam, address);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           triggerResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="literal">null</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="第一个"><a href="#第一个" class="headerlink" title="第一个"></a>第一个</h3><p>执行器地址表中的第一个</p><p>第一个：选择adressList中第一个的机器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteFirst</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(addressList.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>心跳的机制和频率</strong>：每隔30s更新一次注册表内的机器信息，删除超过90s未更新的机器，新增更新时间&gt;当前时间+90s的机器</p><blockquote><p>每5s起一个任务，该任务30s运行完毕，在第一个路由策略下如何运行？</p></blockquote><p>始终是执行器地址表中的第一个机器执行任务。</p><blockquote><p>并发任务在第一个策略和在轮询策略是怎么分配执行机器的？</p></blockquote><p>一个任务执行完成的时间超过任务调度的间隔时间， 那么就会出现并发任务的问题。</p><p>如果使用的是第一个策略， </p><p>那么，调度每次都会发往第一个机器， 当第一次任务调度还在进行中，收到第二次任务调度， 则会根据阻塞处理策略处理第二次调度， 可以单机串行， 丢弃后续调度或者覆盖当前调度。</p><p>如果使用的是轮询策略，</p><p>那么， 第一次调度和第二次调度会落在不同的机器上，任务就会并行执行。当操作相同的数据时就会遇到并发的问题。</p><p>常用的解决并发任务的方案是：单机路由策略（如：第一个、一致性哈希） + 阻塞策略（如：单机串行、丢弃后续调度或覆盖当前调度）来处理。</p><h3 id="最后一个"><a href="#最后一个" class="headerlink" title="最后一个"></a>最后一个</h3><p>执行器地址表中的最后一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteLast</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(addressList.get(addressList.size()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>每5s起一个任务，该任务30s运行完毕，在最后一个路由策略下如何运行？</p></blockquote><p>始终是执行器地址表中的最后一个机器执行任务。</p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>如果有n个执行器，轮询执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteRound</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;Integer, AtomicInteger&gt; routeCountEachJob = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">CACHE_VALID_TIME</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> jobId)</span> &#123;</span><br><span class="line">        <span class="comment">// cache clear</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &gt; CACHE_VALID_TIME) &#123;</span><br><span class="line">            routeCountEachJob.clear();</span><br><span class="line">            CACHE_VALID_TIME = System.currentTimeMillis() + <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> routeCountEachJob.get(jobId);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="literal">null</span> || count.get() &gt; <span class="number">1000000</span>) &#123;</span><br><span class="line">            <span class="comment">// 初始化时主动Random一次，缓解首次压力</span></span><br><span class="line">            count = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// count++</span></span><br><span class="line">            count.addAndGet(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        routeCountEachJob.put(jobId, count);</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> addressList.get(count(triggerParam.getJobId())%addressList.size());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>本来有两台机器，此时有一台停止了，在轮询路由策略下如何执行？</p></blockquote><p>还是在轮询，每次轮到这个节点执行失败不插入数据，周期不正常。</p><h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>如果有n个执行器，随机执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteRandom</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">localRandom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> addressList.get(localRandom.nextInt(addressList.size()));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本来有两台机器，此时有一台停止了，在随机路由策略下如何执行？</p></blockquote><p>还是在随机，不会自动剔除掉故障的节点，周期不正常。</p><h3 id="忙碌转移"><a href="#忙碌转移" class="headerlink" title="忙碌转移"></a>忙碌转移</h3><p>下发任务前向执行器节点发起rpc心跳请求查询是否忙碌，如果执行器节点返回忙碌则转移到其他执行器节点执行</p><p>具体步骤如下：</p><ol><li>遍历执行器地址。</li><li>调用执行器的idle方法查看是否忙碌。</li><li>如果忙碌则打个日志，继续遍历下一个。</li><li>找到不忙碌的直接调用执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteBusyover</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">idleBeatResultSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">//遍历执行器地址</span></span><br><span class="line">        <span class="keyword">for</span> (String address : addressList) &#123;</span><br><span class="line">            <span class="comment">// beat</span></span><br><span class="line">            ReturnT&lt;String&gt; idleBeatResult = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ExecutorBiz</span> <span class="variable">executorBiz</span> <span class="operator">=</span> XxlJobScheduler.getExecutorBiz(address);</span><br><span class="line">                <span class="comment">//调用执行器的idle方法查看是否忙碌</span></span><br><span class="line">                idleBeatResult = executorBiz.idleBeat(<span class="keyword">new</span> <span class="title class_">IdleBeatParam</span>(triggerParam.getJobId()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//如果忙碌则打个日志，继续遍历下一个</span></span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">                idleBeatResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;&quot;</span>+e );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到不忙碌的直接调用执行</span></span><br><span class="line">            idleBeatResultSB.append( (idleBeatResultSB.length()&gt;<span class="number">0</span>)?<span class="string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span>:<span class="string">&quot;&quot;</span>)</span><br><span class="line">                    .append(I18nUtil.getString(<span class="string">&quot;jobconf_idleBeat&quot;</span>) + <span class="string">&quot;：&quot;</span>)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;address：&quot;</span>).append(address)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;code：&quot;</span>).append(idleBeatResult.getCode())</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;msg：&quot;</span>).append(idleBeatResult.getMsg());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// beat success</span></span><br><span class="line">            <span class="keyword">if</span> (idleBeatResult.getCode() == ReturnT.SUCCESS_CODE) &#123;</span><br><span class="line">                idleBeatResult.setMsg(idleBeatResultSB.toString());</span><br><span class="line">                idleBeatResult.setContent(address);</span><br><span class="line">                <span class="keyword">return</span> idleBeatResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, idleBeatResultSB.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到idleBeat的逻辑就是通过loadJobThread判断执行器是否忙碌，如果忙碌则返回失败，反之返回成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">idleBeat</span><span class="params">(IdleBeatParam idleBeatParam)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isRunningOrHasQueue</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isRunningOrHasQueue</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">JobThread</span> <span class="variable">jobThread</span> <span class="operator">=</span> XxlJobExecutor.loadJobThread(idleBeatParam.getJobId());</span><br><span class="line">    <span class="keyword">if</span> (jobThread != <span class="literal">null</span> &amp;&amp; jobThread.isRunningOrHasQueue()) &#123;</span><br><span class="line">        isRunningOrHasQueue = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRunningOrHasQueue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;job thread is running or has trigger queue.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadJobThread方法逻辑也很简单，每一个执行的任务都会存到jobThreadRepository 中，以任务id为key，线程为value，如果map中存在则说明该任务还在执行，说明执行器忙碌。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;Integer, JobThread&gt; jobThreadRepository = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Integer, JobThread&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> JobThread <span class="title function_">loadJobThread</span><span class="params">(<span class="type">int</span> jobId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobThreadRepository.get(jobId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>在主节点或主服务器故障时，自动切换到备份节点或备份服务器，以保证服务的可用性和连续性。</p><p>具体步骤如下：</p><ol><li>遍历执行器地址。</li><li>调用执行器的beat方法查看是否故障。</li><li>如果故障则打个日志，继续遍历下一个。</li><li>找到不故障的直接调用执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteFailover</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">beatResultSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (String address : addressList) &#123;</span><br><span class="line">            <span class="comment">// beat</span></span><br><span class="line">            ReturnT&lt;String&gt; beatResult = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ExecutorBiz</span> <span class="variable">executorBiz</span> <span class="operator">=</span> XxlJobScheduler.getExecutorBiz(address);</span><br><span class="line">                beatResult = executorBiz.beat();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">                beatResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;&quot;</span>+e );</span><br><span class="line">            &#125;</span><br><span class="line">            beatResultSB.append( (beatResultSB.length()&gt;<span class="number">0</span>)?<span class="string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span>:<span class="string">&quot;&quot;</span>)</span><br><span class="line">                    .append(I18nUtil.getString(<span class="string">&quot;jobconf_beat&quot;</span>) + <span class="string">&quot;：&quot;</span>)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;address：&quot;</span>).append(address)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;code：&quot;</span>).append(beatResult.getCode())</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;msg：&quot;</span>).append(beatResult.getMsg());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// beat success</span></span><br><span class="line">            <span class="keyword">if</span> (beatResult.getCode() == ReturnT.SUCCESS_CODE) &#123;</span><br><span class="line"></span><br><span class="line">                beatResult.setMsg(beatResultSB.toString());</span><br><span class="line">                beatResult.setContent(address);</span><br><span class="line">                <span class="keyword">return</span> beatResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, beatResultSB.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最近最久未使用"><a href="#最近最久未使用" class="headerlink" title="最近最久未使用"></a>最近最久未使用</h3><p>选择最近最久未使用的节点来处理请求。这种算法根据节点上一次使用的时间戳，选择最长时间未使用的节点来分配请求。</p><ol><li>用jobLRUMap 来缓存每一个地址的使用情况。</li><li>如果缓存时间过期，则将jobLRUMap 清空。</li><li>根据jobId从jobLRUMap 获取对应的地址列表。</li><li>获取第一个(因为linkHashMap)取一次元素，该元素就会排到末尾，所以第一个永远是最近最少使用的。</li><li>调用linkHashMap的get方法获取最近最少使用的address。</li><li>返回地址值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteLRU</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;Integer, LinkedHashMap&lt;String, String&gt;&gt; jobLRUMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Integer, LinkedHashMap&lt;String, String&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">CACHE_VALID_TIME</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">route</span><span class="params">(<span class="type">int</span> jobId, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cache clear</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &gt; CACHE_VALID_TIME) &#123;</span><br><span class="line">            jobLRUMap.clear();</span><br><span class="line">            CACHE_VALID_TIME = System.currentTimeMillis() + <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init lru</span></span><br><span class="line">        LinkedHashMap&lt;String, String&gt; lruItem = jobLRUMap.get(jobId);</span><br><span class="line">        <span class="keyword">if</span> (lruItem == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * LinkedHashMap</span></span><br><span class="line"><span class="comment">             *      a、accessOrder：true=访问顺序排序（get/put时排序）；false=插入顺序排期；</span></span><br><span class="line"><span class="comment">             *      b、removeEldestEntry：新增元素时将会调用，返回true时会删除最老元素；可封装LinkedHashMap并重写该方法，比如定义最大容量，超出是返回true即可实现固定长度的LRU算法；</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            lruItem = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">            jobLRUMap.putIfAbsent(jobId, lruItem);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put new</span></span><br><span class="line">        <span class="keyword">for</span> (String address: addressList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lruItem.containsKey(address)) &#123;</span><br><span class="line">                lruItem.put(address, address);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove old</span></span><br><span class="line">        List&lt;String&gt; delKeys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String existKey: lruItem.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!addressList.contains(existKey)) &#123;</span><br><span class="line">                delKeys.add(existKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delKeys.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String delKey: delKeys) &#123;</span><br><span class="line">                lruItem.remove(delKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">eldestKey</span> <span class="operator">=</span> lruItem.entrySet().iterator().next().getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">eldestValue</span> <span class="operator">=</span> lruItem.get(eldestKey);</span><br><span class="line">        <span class="keyword">return</span> eldestValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> route(triggerParam.getJobId(), addressList);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最不经常使用"><a href="#最不经常使用" class="headerlink" title="最不经常使用"></a>最不经常使用</h3><p>选择最不经常使用的节点来处理请求。这种算法根据节点上一次使用的次数，选择最不经常使用的节点来分配请求。</p><ol><li>用 jobLfuMap 来缓存每一个地址的使用情况。</li><li>如果缓存时间过期，则将 jobLfuMap 清空。</li><li>根据 jobId 从 jobLfuMap 获取对应的地址列表。</li><li>获取第一个(因为linkHashMap)取一次元素，该元素就会排到末尾，所以第一个永远是最不经常使用的。</li><li>调用linkHashMap的get方法获取最不经常使用的address。</li><li>返回地址值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteLFU</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;Integer, HashMap&lt;String, Integer&gt;&gt; jobLfuMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Integer, HashMap&lt;String, Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">CACHE_VALID_TIME</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">route</span><span class="params">(<span class="type">int</span> jobId, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cache clear</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &gt; CACHE_VALID_TIME) &#123;</span><br><span class="line">            jobLfuMap.clear();</span><br><span class="line">            CACHE_VALID_TIME = System.currentTimeMillis() + <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lfu item init</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; lfuItemMap = jobLfuMap.get(jobId);     <span class="comment">// Key排序可以用TreeMap+构造入参Compare；Value排序暂时只能通过ArrayList；</span></span><br><span class="line">        <span class="keyword">if</span> (lfuItemMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            lfuItemMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">            jobLfuMap.putIfAbsent(jobId, lfuItemMap);   <span class="comment">// 避免重复覆盖</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put new</span></span><br><span class="line">        <span class="keyword">for</span> (String address: addressList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lfuItemMap.containsKey(address) || lfuItemMap.get(address) &gt;<span class="number">1000000</span> ) &#123;</span><br><span class="line">                lfuItemMap.put(address, <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(addressList.size()));  <span class="comment">// 初始化时主动Random一次，缓解首次压力</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove old</span></span><br><span class="line">        List&lt;String&gt; delKeys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String existKey: lfuItemMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!addressList.contains(existKey)) &#123;</span><br><span class="line">                delKeys.add(existKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delKeys.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String delKey: delKeys) &#123;</span><br><span class="line">                lfuItemMap.remove(delKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load least userd count address</span></span><br><span class="line">        List&lt;Map.Entry&lt;String, Integer&gt;&gt; lfuItemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;(lfuItemMap.entrySet());</span><br><span class="line">        Collections.sort(lfuItemList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getValue().compareTo(o2.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Map.Entry&lt;String, Integer&gt; addressItem = lfuItemList.get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">minAddress</span> <span class="operator">=</span> addressItem.getKey();</span><br><span class="line">        addressItem.setValue(addressItem.getValue() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> addressItem.getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> route(triggerParam.getJobId(), addressList);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><p>根据jobId和执行器地址列表来做路由。</p><ul><li>执行器地址（ip:port) hash到TreeMap</li><li>为了避免增减节点时负载不均衡，加入虚拟节点。每个物理节点虚拟为100个虚拟节点分散到TreeMap中</li><li>重写Hash算法避免原生hash算法不均衡问题</li><li>采用TreeMap的tailMap功能找到大于等于当前hash值的节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteConsistentHash</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">VIRTUAL_NODE_NUM</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get hash code on 2^32 ring (md5散列的方式计算hash值)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">hash</span><span class="params">(String key)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// md5 byte</span></span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;MD5 not supported&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.reset();</span><br><span class="line">        <span class="type">byte</span>[] keyBytes = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            keyBytes = key.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown string :&quot;</span> + key, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        md5.update(keyBytes);</span><br><span class="line">        <span class="type">byte</span>[] digest = md5.digest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hash code, Truncate to 32-bits</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> ((<span class="type">long</span>) (digest[<span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (digest[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">truncateHashCode</span> <span class="operator">=</span> hashCode &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">        <span class="keyword">return</span> truncateHashCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hashJob</span><span class="params">(<span class="type">int</span> jobId, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------A1------A2-------A3------</span></span><br><span class="line">        <span class="comment">// -----------J1------------------</span></span><br><span class="line">        TreeMap&lt;Long, String&gt; addressRing = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String address: addressList) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; VIRTUAL_NODE_NUM; i++) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">addressHash</span> <span class="operator">=</span> hash(<span class="string">&quot;SHARD-&quot;</span> + address + <span class="string">&quot;-NODE-&quot;</span> + i);</span><br><span class="line">                addressRing.put(addressHash, address);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">jobHash</span> <span class="operator">=</span> hash(String.valueOf(jobId));</span><br><span class="line">        SortedMap&lt;Long, String&gt; lastRing = addressRing.tailMap(jobHash);</span><br><span class="line">        <span class="keyword">if</span> (!lastRing.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> lastRing.get(lastRing.firstKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addressRing.firstEntry().getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> hashJob(triggerParam.getJobId(), addressList);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分片广播"><a href="#分片广播" class="headerlink" title="分片广播"></a>分片广播</h3><p>广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务。</p><p>要取出要更新的id，然后判断取模是不是本台机器处理，如果是本台机器需要处理的，再根据id查询数据，处理数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分片广播任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@XxlJob(&quot;shardingJobHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shardingJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分片参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line"></span><br><span class="line">    XxlJobHelper.log(<span class="string">&quot;分片参数：当前分片序号 = &#123;&#125;, 总分片数 = &#123;&#125;&quot;</span>, shardIndex, shardTotal);</span><br><span class="line">    <span class="comment">//获取需要处理的所有门店列表</span></span><br><span class="line">    List&lt;StoreInfo&gt; storeInfoList = storeInfoMapper.selectList(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;StoreInfo&gt;().lambda().orderByDesc(StoreInfo::getStoreCode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前分片需要处理的门店列表</span></span><br><span class="line">    List&lt;StoreInfo&gt; shardStoreInfoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; storeInfoList.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % shardTotal == shardIndex) &#123;</span><br><span class="line">            <span class="comment">//将当前分片需要处理的门店加入list</span></span><br><span class="line">            shardStoreInfoList.add(storeInfoList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理业务逻辑...</span></span><br><span class="line">    service.doBusiness(shardStoreInfoList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由策略适用场景"><a href="#路由策略适用场景" class="headerlink" title="路由策略适用场景"></a>路由策略适用场景</h2><table><thead><tr><th>路由策略</th><th>适用场景</th></tr></thead><tbody><tr><td>第一个</td><td>当只有一台机器注册</td></tr><tr><td>最后一个</td><td>当只有一台机器注册</td></tr><tr><td>轮询</td><td>有多台机器， 且希望每台机器平等的享有被调度的可能</td></tr><tr><td>随机</td><td>有多台机器， 且不关心哪台机器执行任务</td></tr><tr><td>忙碌转移</td><td>有多台机器， 希望第一次检测到空闲的机器执行任务。</td></tr><tr><td>故障转移</td><td>有多台机器，希望第一次检测到存活的机器执行任务， 且不关心该机器是否正在处理任务</td></tr><tr><td>最近最久未使用</td><td>有多台机器， 希望闲置最久的机器优先被使用</td></tr><tr><td>最不经常使用</td><td>有多台机器， 希望使用频率低的机器优先被使用</td></tr><tr><td>一致性哈希</td><td>有多台机器， 希望均匀地分布请求， 且在机器的数量变化时， 还能有很好的扩展性和容错性， 拥有相同jobId的任务调度请求， 大概率会落在相同的机器上。</td></tr><tr><td>分片广播</td><td>有多台机器，且对于执行时间长的任务，希望能分散到各个节点上执行，从而加快完成的速度</td></tr></tbody></table><h3 id="rpa分发任务到执行器的策略"><a href="#rpa分发任务到执行器的策略" class="headerlink" title="rpa分发任务到执行器的策略"></a>rpa分发任务到执行器的策略</h3><p>单机只运行一个任务策略。在RPA情景下， 一般只会有一个执行器注册执行调度中心， 为了防止用户电脑上执行的程序中断， 应该单机串行， 调度请求排队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteGlobalBusyover</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">idleBeatResultSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String address : addressList) &#123;</span><br><span class="line">            <span class="comment">// beat</span></span><br><span class="line">            ReturnT&lt;String&gt; idleBeatResult = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ExecutorBiz</span> <span class="variable">executorBiz</span> <span class="operator">=</span> XxlJobScheduler.getExecutorBiz(address);</span><br><span class="line">                <span class="comment">// 单机只运行一个任务策略 检测</span></span><br><span class="line">                idleBeatResult = executorBiz.globalIdleBeat(<span class="keyword">new</span> <span class="title class_">IdleBeatParam</span>(triggerParam.getJobId()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">                idleBeatResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;&quot;</span>+e );</span><br><span class="line">            &#125;</span><br><span class="line">            idleBeatResultSB.append( (idleBeatResultSB.length()&gt;<span class="number">0</span>)?<span class="string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span>:<span class="string">&quot;&quot;</span>)</span><br><span class="line">                    .append(I18nUtil.getString(<span class="string">&quot;jobconf_idleBeat&quot;</span>) + <span class="string">&quot;：&quot;</span>)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;address：&quot;</span>).append(address)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;code：&quot;</span>).append(idleBeatResult.getCode())</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;msg：&quot;</span>).append(idleBeatResult.getMsg());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// beat success</span></span><br><span class="line">            <span class="keyword">if</span> (idleBeatResult.getCode() == ReturnT.SUCCESS_CODE) &#123;</span><br><span class="line">                idleBeatResult.setMsg(idleBeatResultSB.toString());</span><br><span class="line">                idleBeatResult.setContent(address);</span><br><span class="line">                <span class="keyword">return</span> idleBeatResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, idleBeatResultSB.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中检测是否存在一个运行中的任务逻辑如下：</p><ol><li>获取所有的正在运行中的任务线程</li><li>再挨个遍历，如果任务线程没有在运行，则直接返回成功</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">globalIdleBeat</span><span class="params">(IdleBeatParam idleBeatParam)</span> &#123;</span><br><span class="line"></span><br><span class="line">       logger.info(<span class="string">&quot;globalIdleBeat check&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// get all job thread</span></span><br><span class="line">       ConcurrentMap&lt;Integer, JobThread&gt; jobThreadRepository = XxlJobExecutor.getJobThreadRepository();</span><br><span class="line">       <span class="keyword">if</span> (jobThreadRepository.size() == <span class="number">0</span>) &#123;</span><br><span class="line">           logger.info(<span class="string">&quot;globalIdleBeat empty&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// isRunningOrHasQueue</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">isRunningOrHasQueue</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// check is job status</span></span><br><span class="line">       <span class="keyword">for</span> (Integer jobid : jobThreadRepository.keySet()) &#123;</span><br><span class="line">           <span class="type">JobThread</span> <span class="variable">jobThread</span> <span class="operator">=</span> XxlJobExecutor.loadJobThread(jobid);</span><br><span class="line">           <span class="keyword">if</span> (jobThread != <span class="literal">null</span> &amp;&amp; jobThread.isRunningOrHasQueue()) &#123;</span><br><span class="line">               isRunningOrHasQueue = <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (isRunningOrHasQueue) &#123;</span><br><span class="line">               logger.info(<span class="string">&quot;job thread [&quot;</span> + jobThread.getName() + <span class="string">&quot;] is running or has trigger queue.&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;job thread [&quot;</span> + jobThread.getHandler() + <span class="string">&quot;] is running or has trigger queue.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           logger.info(<span class="string">&quot;job thread [&quot;</span> + jobThread.getName() + <span class="string">&quot;] is empty&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="分布式组件负载均衡策略"><a href="#分布式组件负载均衡策略" class="headerlink" title="分布式组件负载均衡策略"></a>分布式组件负载均衡策略</h2><p>Spring Cloud Gateway中负载均衡使用了路由策略。在微服务架构中，通常存在多个相同或相似的微服务实例，每个实例都提供相同的服务接口，但可能运行在不同的主机或容器上。</p><p>负载策略有： </p><ul><li>Path Route Predicate：基于请求的路径进行匹配，支持Ant风格的路径表达式，如<code>/foo/**</code>。</li><li>Query Route Predicate：基于请求的查询参数进行匹配，支持正则表达式，如<code>name=foo.*</code>。</li><li>Method Route Predicate：基于请求的方法进行匹配，如<code>GET</code>、<code>POST</code>等。</li><li>Header Route Predicate：基于请求头进行匹配，如<code>Host</code>、<code>User-Agent</code>等。</li><li>Cookie Route Predicate：基于请求的Cookie进行匹配，如<code>SESSIONID=123456</code>。</li><li>RemoteAddr Route Predicate：基于请求的IP地址进行匹配，如<code>192.168.1.100</code>。</li><li>Host Route Predicate：基于请求的Host头进行匹配，如<code>example.com</code>。</li><li>Cloud Foundry Route Service Route Predicate：用于支持Cloud Foundry的路由服务。</li><li>Weight Route Predicate：根据服务的权重进行<a href="https://cloud.tencent.com/product/clb?from_column=20065&from=20065">负载均衡</a>路由。</li></ul><p>Nginx的upstream支持如下六种方式的负载均衡算法</p><ul><li>轮询：默认方式</li><li>weight：加权轮询</li><li>ip_hash：依据发出请求的 客户端IP 的hash值来分配服务器，可以保证同IP发出的请求路由到同一服务器。<strong>与“一致性hash”路由相似</strong></li><li>url_hash：根据请求的 URL 的hash值来分配服务器。<strong>与“一致性hash”路由相似</strong></li><li>least_conn：最少连接，把请求转发给连接数较少的后端服务器。<strong>与“忙碌转移”路由相似</strong></li><li>fair：由第三方模块提供，可以根据页面大小、加载时间长短智能的进行负载均衡。<strong>与“忙碌转移”路由相似</strong><br>此外，可以用backup将某服务器标记为备用，当主服务器不可用时，将用它处理请求。<strong>与“故障转移”路由相似</strong></li></ul><h2 id="xxl-job如何实现调度器集群任务不重复执行的"><a href="#xxl-job如何实现调度器集群任务不重复执行的" class="headerlink" title="xxl-job如何实现调度器集群任务不重复执行的"></a>xxl-job如何实现调度器集群任务不重复执行的</h2><p>从定时任务处理器中可以看到，在真正调度任务之前，当前的触发器会对xxl_job_lock表上个写锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preparedStatement = conn.prepareStatement(  <span class="string">&quot;select * from xxl_job_lock where lock_name = &#x27;schedule_lock&#x27; for update&quot;</span> );</span><br><span class="line">preparedStatement.execute();</span><br></pre></td></tr></table></figure><p>xxl_job_lock仅仅是作为定时任务调度的锁，正是因为写锁的存在，保证一个触发器触发任务时，别的触发器会被阻塞。</p><p>最后将事务提交完成任务的触发，然后休眠，其他触发可以抢占后续工作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commit</span></span><br><span class="line">   <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 事务提交</span></span><br><span class="line">       conn.commit();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!scheduleThreadToStop) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         conn.setAutoCommit(connAutoCommit);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!scheduleThreadToStop) &#123;</span><br><span class="line">         logger.error(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 休眠</span></span><br><span class="line">          conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!scheduleThreadToStop) &#123;</span><br><span class="line">          logger.error(e.getMessage(), e);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;阻塞处理策略&quot;&gt;&lt;a href=&quot;#阻塞处理策略&quot; class=&quot;headerlink&quot; title=&quot;阻塞处理策略&quot;&gt;&lt;/a&gt;阻塞处理策略&lt;/h2&gt;&lt;h3 id=&quot;单机串行（默认）&quot;&gt;&lt;a href=&quot;#单机串行（默认）&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="xxl-job" scheme="https://palette-k.github.io/tags/xxl-job/"/>
    
  </entry>
  
  <entry>
    <title>xxl-job原理与实践</title>
    <link href="https://palette-k.github.io/2024/02/06/xxl-job%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>https://palette-k.github.io/2024/02/06/xxl-job%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</id>
    <published>2024-02-06T10:22:15.000Z</published>
    <updated>2024-02-18T08:57:13.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xxl-job-的概念"><a href="#xxl-job-的概念" class="headerlink" title="xxl-job 的概念"></a>xxl-job 的概念</h1><h2 id="诞生背景"><a href="#诞生背景" class="headerlink" title="诞生背景"></a>诞生背景</h2><p>我们在日常项目开发中，可能会用到分布式调度，在这期间我们可能会遇到这些问题:</p><ol><li>同一个服务中可能存在多个互斥的任务，需要统一调度和协调。</li><li>定时任务运行期间，为了确保任务能够稳定运行，我们希望能够做到高可用、监控运维、故障告警。</li><li>需要统一管理和追踪个个服务节点定时任务的情况，以及任务属性信息，比如:任务所属服务、所属责任人等信息。</li></ol><p>所以我们这里就需要用到xxl-job这个轻量级框架。</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><ul><li><strong>调度模块（调度中心）</strong>：<br>负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块；<br>支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。</li><li><strong>执行模块（执行器）</strong>：<br>负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；<br>接收“调度中心”的执行请求、终止请求和日志请求等。</li></ul><p>这里放一张官网的系统架构图：</p><p><img src="https://www.xuxueli.com/doc/static/xxl-job/images/img_Qohm.png" alt="输入图片说明"></p><p>在真正了解 xxl-job 之前，可以带着以下的问题去进行系统性的学习：</p><ul><li>执行器是如何自动注册到调度中心的？</li><li>调度中心是如何管理执行器的？</li><li>调度中心是如何触发任务的？</li><li>任务是怎么回调jobHandler的？</li><li>任务执行超时会有什么应对策略吗？</li></ul><h1 id="服务端启动流程"><a href="#服务端启动流程" class="headerlink" title="服务端启动流程"></a>服务端启动流程</h1><p><img src="https://qiniuyun.sharkchili.com/img202304260835617.png" alt="在这里插入图片描述"></p><p>要想设计一个分布式任务调度中心，我们需要下面几个东西:</p><ol><li>注册服务</li><li>RPC通信框架</li><li>调度服务</li><li>日志服务</li><li>告警服务</li></ol><h2 id="整体过程概述"><a href="#整体过程概述" class="headerlink" title="整体过程概述"></a>整体过程概述</h2><p>在 <code>xxl-job-admin</code> 的 XxlJobAdminConfig 中，可以看到它在 bean 完成初始化之后通过 InitializingBean 进行了一些特殊操作。</p><p>它继承InitializingBean所实现的afterPropertiesSet方法执行了下面的操作。代码很简单创建一个调度器之后就调用init进行初始化。我们不妨查看init做了什么操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       adminConfig = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">       xxlJobScheduler = <span class="keyword">new</span> <span class="title class_">XxlJobScheduler</span>();</span><br><span class="line">       xxlJobScheduler.init();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 步入了init我们看到了各种helper类的启动操作。从注释中我们也可以看出这些操作分别是:</p><ol><li>初始化i18n。</li><li>JobTriggerPoolHelper这里面会完成一些线程池初始化的操作。</li><li>初始化注册监控相关，在这个操作里面，会每隔30秒进行一次注册表维护。</li><li>初始化失败处理监控器，对失败的情况进行监控，这里面会涉及一些失败发送邮箱或者重试的操作。</li><li>初始化任务完成器，将一些长时间没有响应的任务进行结束处理。</li><li>初始化报表统计，会进行一些成功失败的报表统计。</li><li>初始化调度器，执行任务调度处理。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// init i18n</span></span><br><span class="line">        initI18n();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// admin trigger pool start</span></span><br><span class="line">        JobTriggerPoolHelper.toStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// admin registry monitor run</span></span><br><span class="line">        JobRegistryHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// admin fail-monitor run</span></span><br><span class="line">        JobFailMonitorHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// admin lose-monitor run ( depend on JobTriggerPoolHelper )</span></span><br><span class="line">        JobCompleteHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// admin log report start</span></span><br><span class="line">        JobLogReportHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start-schedule  ( depend on JobTriggerPoolHelper )</span></span><br><span class="line">        JobScheduleHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin success.&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="初始化触发器"><a href="#初始化触发器" class="headerlink" title="初始化触发器"></a>初始化触发器</h2><p>我们先来看看JobTriggerPoolHelper.toStart();这段代码内部的逻辑，非常简单，无非就是初始化两个线程池，一个线程池是名为快触发线程池，另一个则是慢触发线程池。</p><p>从配置参数中我们可以看到这两个线程池的区别:</p><ol><li>快线程池的最大线程数默认为200，慢线程池为100。</li><li>快线程池最多容纳1000个任务，慢线程池默认容纳2000个任务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        fastTriggerPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax(),</span><br><span class="line">                <span class="number">60L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">1000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;xxl-job, admin JobTriggerPoolHelper-fastTriggerPool-&quot;</span> + r.hashCode());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        slowTriggerPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax(),</span><br><span class="line">                <span class="number">60L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;xxl-job, admin JobTriggerPoolHelper-slowTriggerPool-&quot;</span> + r.hashCode());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题来了，什么时候使用快触发线程池，什么时候使用慢触发线程池呢？</p></blockquote><p>从添加触发器的代码中可以看到如果一分钟执行超过10次的任务就会通过 slowTriggerPool 执行，反之就通过 fastTriggerPool 执行。</p><p>这也是设计者执行的巧妙所在，将那些可以快速执行的任务放到快线程池中快速执行完成。</p><p>而将那些耗时且频繁的任务放到慢线程池中堆着慢慢消化，合理分配避免某些快任务因为慢任务而导致执行频率低下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTrigger</span><span class="params">(......)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// choose thread pool</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">triggerPool_</span> <span class="operator">=</span> fastTriggerPool;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">jobTimeoutCount</span> <span class="operator">=</span> jobTimeoutCountMap.get(jobId);</span><br><span class="line">        <span class="keyword">if</span> (jobTimeoutCount!=<span class="literal">null</span> &amp;&amp; jobTimeoutCount.get() &gt; <span class="number">10</span>) &#123;      <span class="comment">// job-timeout 10 times in 1 min</span></span><br><span class="line">            triggerPool_ = slowTriggerPool;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// trigger</span></span><br><span class="line">        triggerPool_.execute(......)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="维护注册表信息"><a href="#维护注册表信息" class="headerlink" title="维护注册表信息"></a>维护注册表信息</h2><p>接下来就是 JobRegistryHelper 的start方法。</p><p>该方法首先会声明一个线程池，从语义上可以猜测出这个线程池是负责注册或者删除执行器的线程池。而且这个线程池的拒绝策略也很特殊，会将任务再次执行一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for registry or remove</span></span><br><span class="line">registryOrRemoveThreadPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line"><span class="number">2</span>,</span><br><span class="line"><span class="number">10</span>,</span><br><span class="line"><span class="number">30L</span>,</span><br><span class="line">TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2000</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;xxl-job, admin JobRegistryMonitorHelper-registryOrRemoveThreadPool-&quot;</span> + r.hashCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">r.run();</span><br><span class="line">logger.warn(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, registry or remove too fast, match threadpool rejected handler(run now).&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后续我们又会看到这样一个守护线程，它做的事情很简单:</p><ol><li>将超过90s的注册器删除。</li><li>从xxl_job_registry查找出更新时间大于现在+90s的执行器，即可能是最新注册的执行器，以appname作为key，相关地址作为value并将其存放到appAddressMap中。</li><li>从appAddressMap取出所有appName对应的地址,更新xxl_job_group执行器地址列表,组装成 addressListStr生成一个group并将其保存到xxl_job_group表中。</li><li>休眠30s后继续1-3的操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for monitor</span></span><br><span class="line">registryMonitorThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 从xxl_job_group找到所有的注册器的信息</span></span><br><span class="line">List&lt;XxlJobGroup&gt; groupList = XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().findByAddressType(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (groupList!=<span class="literal">null</span> &amp;&amp; !groupList.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove dead address (admin/executor)   将超过90s的注册器删除</span></span><br><span class="line">List&lt;Integer&gt; ids = XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().findDead(RegistryConfig.DEAD_TIMEOUT, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="keyword">if</span> (ids!=<span class="literal">null</span> &amp;&amp; ids.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().removeDead(ids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从xxl_job_registry查找出更新时间大于现在+90s的执行器，以appname作为key，相关地址作为value并将其存放到appAddressMap中</span></span><br><span class="line">HashMap&lt;String, List&lt;String&gt;&gt; appAddressMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">List&lt;XxlJobRegistry&gt; list = XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().findAll(RegistryConfig.DEAD_TIMEOUT, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (XxlJobRegistry item: list) &#123;</span><br><span class="line"><span class="keyword">if</span> (RegistryConfig.RegistType.EXECUTOR.name().equals(item.getRegistryGroup())) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">appname</span> <span class="operator">=</span> item.getRegistryKey();</span><br><span class="line">List&lt;String&gt; registryList = appAddressMap.get(appname);</span><br><span class="line"><span class="keyword">if</span> (registryList == <span class="literal">null</span>) &#123;</span><br><span class="line">registryList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!registryList.contains(item.getRegistryValue())) &#123;</span><br><span class="line">registryList.add(item.getRegistryValue());</span><br><span class="line">&#125;</span><br><span class="line">appAddressMap.put(appname, registryList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fresh group address</span></span><br><span class="line"><span class="keyword">for</span> (XxlJobGroup group: groupList) &#123;</span><br><span class="line"><span class="comment">//从appAddressMap取出所有appName对应的地址,更新xxl_job_group执行器地址列表,组装成 addressListStr</span></span><br><span class="line">List&lt;String&gt; registryList = appAddressMap.get(group.getAppname());</span><br><span class="line"><span class="type">String</span> <span class="variable">addressListStr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (registryList!=<span class="literal">null</span> &amp;&amp; !registryList.isEmpty()) &#123;</span><br><span class="line">Collections.sort(registryList);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">addressListSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (String item:registryList) &#123;</span><br><span class="line">addressListSB.append(item).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">addressListStr = addressListSB.toString();</span><br><span class="line">addressListStr = addressListStr.substring(<span class="number">0</span>, addressListStr.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基于addressListStr生成group</span></span><br><span class="line">group.setAddressList(addressListStr);</span><br><span class="line">group.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">//更新group更新时间</span></span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().update(group);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//休眠30s</span></span><br><span class="line">TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread stop&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="失败管理监视器"><a href="#失败管理监视器" class="headerlink" title="失败管理监视器"></a>失败管理监视器</h2><p>我们再来看看JobFailMonitorHelper的start代码。大体步骤为:</p><ol><li>从xxl_job_log找到执行失败的任务。</li><li>lock log 将xxl_job_log表中这些任务alarm_status设置为-1，意为上锁，如果没锁成功下次循环继续上锁。</li><li>从xxl_job_log获取这些job的id。</li><li>根据xxl_job_log的id从xxl_job_info获取到这个任务的信息。</li><li>查看xxl_job_info失败的任务重试次数是否大于0，大于0则继续重试执行。</li><li>对于失败的任务，判断info是否为空，如果不为空，则进行告警，然后基于乐观锁更新xxl_job_log告警信息。</li><li>休眠10s，继续1-6的操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">monitorThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// monitor</span></span><br><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//从xxl_job_log找到执行失败的任务</span></span><br><span class="line">List&lt;Long&gt; failLogIds = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findFailJobLogIds(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">if</span> (failLogIds!=<span class="literal">null</span> &amp;&amp; !failLogIds.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> failLogId: failLogIds) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lock log 将xxl_job_log表中这些任务alarm_status设置为-1，意为上锁，如果没锁成功下次循环继续</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lockRet</span> <span class="operator">=</span> XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (lockRet &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从xxl_job_log获取日志信息</span></span><br><span class="line"><span class="type">XxlJobLog</span> <span class="variable">log</span> <span class="operator">=</span> XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().load(failLogId);</span><br><span class="line"><span class="comment">//根据xxl_job_log的id从xxl_job_info获取到这个任务的信息</span></span><br><span class="line"><span class="type">XxlJobInfo</span> <span class="variable">info</span> <span class="operator">=</span> XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().loadById(log.getJobId());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、fail retry monitor 查看失败的任务重试次数是否大于0，大于0则继续重试</span></span><br><span class="line"><span class="keyword">if</span> (log.getExecutorFailRetryCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">JobTriggerPoolHelper.trigger(log.getJobId(), TriggerTypeEnum.RETRY, (log.getExecutorFailRetryCount()-<span class="number">1</span>), log.getExecutorShardingParam(), log.getExecutorParam(), <span class="literal">null</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">retryMsg</span> <span class="operator">=</span> <span class="string">&quot;&lt;br&gt;&lt;br&gt;&lt;span style=\&quot;color:#F39C12;\&quot; &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>+ I18nUtil.getString(<span class="string">&quot;jobconf_trigger_type_retry&quot;</span>) +<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; &lt;/span&gt;&lt;br&gt;&quot;</span>;</span><br><span class="line">log.setTriggerMsg(log.getTriggerMsg() + retryMsg);</span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateTriggerInfo(log);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、fail alarm monitor</span></span><br><span class="line"><span class="type">int</span> <span class="variable">newAlarmStatus</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 告警状态：0-默认、-1=锁定状态、1-无需告警、2-告警成功、3-告警失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果info不为空，则进行告警</span></span><br><span class="line"><span class="keyword">if</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">alarmResult</span> <span class="operator">=</span> XxlJobAdminConfig.getAdminConfig().getJobAlarmer().alarm(info, log);</span><br><span class="line">newAlarmStatus = alarmResult?<span class="number">2</span>:<span class="number">3</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">newAlarmStatus = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基于乐观锁更新xxl_job_log告警信息</span></span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, -<span class="number">1</span>, newAlarmStatus);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job fail monitor thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job fail monitor thread stop&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="任务结束处理器"><a href="#任务结束处理器" class="headerlink" title="任务结束处理器"></a>任务结束处理器</h2><p>我们继续前进查看 JobCompleteHelper 的源码。第一步也还是创建一个回调线程池，参数如下，可以看到拒绝策略任然是再次执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for callback</span></span><br><span class="line">callbackThreadPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line"><span class="number">2</span>,</span><br><span class="line"><span class="number">20</span>,</span><br><span class="line"><span class="number">30L</span>,</span><br><span class="line">TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">3000</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;xxl-job, admin JobLosedMonitorHelper-callbackThreadPool-&quot;</span> + r.hashCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">r.run();</span><br><span class="line">logger.warn(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, callback too fast, match threadpool rejected handler(run now).&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再往后查看代码，我们会发现一个守护线程monitorThread，查看它的核心工作代码如下，具体步骤为:</p><ol><li>找到运行中状态超过10min的任务id。</li><li>拿着这个任务id组装出一个log对象</li><li>基于这个表对象将任务结果通过updateHandleInfoAndFinish设置为结束。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// monitor</span></span><br><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 任务结果丢失处理：调度记录停留在 &quot;运行中&quot; 状态超过10min，且对应执行器心跳注册失败不在线，则将本地调度主动标记失败；</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">losedTime</span> <span class="operator">=</span> DateUtil.addMinutes(<span class="keyword">new</span> <span class="title class_">Date</span>(), -<span class="number">10</span>);</span><br><span class="line"><span class="comment">//找到丢失的任务id</span></span><br><span class="line">List&lt;Long&gt; losedJobIds  = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findLostJobIds(losedTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (losedJobIds!=<span class="literal">null</span> &amp;&amp; losedJobIds.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Long logId: losedJobIds) &#123;</span><br><span class="line"><span class="comment">//基于logId组装XxlJobLog</span></span><br><span class="line"><span class="type">XxlJobLog</span> <span class="variable">jobLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobLog</span>();</span><br><span class="line">jobLog.setId(logId);</span><br><span class="line"></span><br><span class="line">jobLog.setHandleTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">jobLog.setHandleCode(ReturnT.FAIL_CODE);</span><br><span class="line">jobLog.setHandleMsg( I18nUtil.getString(<span class="string">&quot;joblog_lost_fail&quot;</span>) );</span><br><span class="line"><span class="comment">//基于jobLog将任务结果结束</span></span><br><span class="line">XxlJobCompleter.updateHandleInfoAndFinish(jobLog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job fail monitor thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">60</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>再来看看updateHandleInfoAndFinish的代码，逻辑也很简单，根据log对象的code值组装对应的msg到xxlJobLog中，然后更新到xxl_job_log表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">updateHandleInfoAndFinish</span><span class="params">(XxlJobLog xxlJobLog)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据xxlJobLog任务的code得到对应的msg并将其设置到xxlJobLog中</span></span><br><span class="line">        finishJob(xxlJobLog);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// text最大64kb 避免长度过长</span></span><br><span class="line">        <span class="keyword">if</span> (xxlJobLog.getHandleMsg().length() &gt; <span class="number">15000</span>) &#123;</span><br><span class="line">            xxlJobLog.setHandleMsg( xxlJobLog.getHandleMsg().substring(<span class="number">0</span>, <span class="number">15000</span>) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新xxl_job_log中这个任务的信息</span></span><br><span class="line">        <span class="keyword">return</span> XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateHandleInfo(xxlJobLog);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="报表处理"><a href="#报表处理" class="headerlink" title="报表处理"></a>报表处理</h2><p>还记得我们登录xxl-job-admin时，哪个报表界面吗？这个页面的数据就是通过JobLogReportHelper进行处理的。对此，我们不妨打开源码一探究竟。</p><p>核心逻辑为:</p><ol><li>获取今天、昨天、前天的任务总数、正在运行数、成功数，得出统计信息更新到表中。</li><li>查看日志保留天数，如果到期则将过期日志删除。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 1、log-report refresh: refresh log report in 3 days</span></span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                          <span class="comment">// 获取Calendar都西昂</span></span><br><span class="line">                          <span class="type">Calendar</span> <span class="variable">itemDay</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">                          <span class="comment">//查看今天-i天时的数据，按照循环3次我们可以得出回查看今天、昨天、前天的数据</span></span><br><span class="line">                          itemDay.add(Calendar.DAY_OF_MONTH, -i);</span><br><span class="line">                          itemDay.set(Calendar.HOUR_OF_DAY, <span class="number">0</span>);</span><br><span class="line">                          itemDay.set(Calendar.MINUTE, <span class="number">0</span>);</span><br><span class="line">                          itemDay.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">                          itemDay.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                          <span class="type">Date</span> <span class="variable">todayFrom</span> <span class="operator">=</span> itemDay.getTime();</span><br><span class="line"></span><br><span class="line">                          itemDay.set(Calendar.HOUR_OF_DAY, <span class="number">23</span>);</span><br><span class="line">                          itemDay.set(Calendar.MINUTE, <span class="number">59</span>);</span><br><span class="line">                          itemDay.set(Calendar.SECOND, <span class="number">59</span>);</span><br><span class="line">                          itemDay.set(Calendar.MILLISECOND, <span class="number">999</span>);</span><br><span class="line"></span><br><span class="line">                          <span class="type">Date</span> <span class="variable">todayTo</span> <span class="operator">=</span> itemDay.getTime();</span><br><span class="line"></span><br><span class="line">                          <span class="comment">// 初始化一个xxlJobLogReport对象</span></span><br><span class="line">                          <span class="type">XxlJobLogReport</span> <span class="variable">xxlJobLogReport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobLogReport</span>();</span><br><span class="line">                          xxlJobLogReport.setTriggerDay(todayFrom);</span><br><span class="line">                          xxlJobLogReport.setRunningCount(<span class="number">0</span>);</span><br><span class="line">                          xxlJobLogReport.setSucCount(<span class="number">0</span>);</span><br><span class="line">                          xxlJobLogReport.setFailCount(<span class="number">0</span>);</span><br><span class="line">                          <span class="comment">//查出当天触发的任务数、正在运行数、成功数</span></span><br><span class="line">                          Map&lt;String, Object&gt; triggerCountMap = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findLogReport(todayFrom, todayTo);</span><br><span class="line">                          <span class="keyword">if</span> (triggerCountMap!=<span class="literal">null</span> &amp;&amp; triggerCountMap.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="type">int</span> <span class="variable">triggerDayCount</span> <span class="operator">=</span> triggerCountMap.containsKey(<span class="string">&quot;triggerDayCount&quot;</span>)?Integer.valueOf(String.valueOf(triggerCountMap.get(<span class="string">&quot;triggerDayCount&quot;</span>))):<span class="number">0</span>;</span><br><span class="line">                              <span class="type">int</span> <span class="variable">triggerDayCountRunning</span> <span class="operator">=</span> triggerCountMap.containsKey(<span class="string">&quot;triggerDayCountRunning&quot;</span>)?Integer.valueOf(String.valueOf(triggerCountMap.get(<span class="string">&quot;triggerDayCountRunning&quot;</span>))):<span class="number">0</span>;</span><br><span class="line">                              <span class="type">int</span> <span class="variable">triggerDayCountSuc</span> <span class="operator">=</span> triggerCountMap.containsKey(<span class="string">&quot;triggerDayCountSuc&quot;</span>)?Integer.valueOf(String.valueOf(triggerCountMap.get(<span class="string">&quot;triggerDayCountSuc&quot;</span>))):<span class="number">0</span>;</span><br><span class="line">                              <span class="type">int</span> <span class="variable">triggerDayCountFail</span> <span class="operator">=</span> triggerDayCount - triggerDayCountRunning - triggerDayCountSuc;</span><br><span class="line"></span><br><span class="line">                              xxlJobLogReport.setRunningCount(triggerDayCountRunning);</span><br><span class="line">                              xxlJobLogReport.setSucCount(triggerDayCountSuc);</span><br><span class="line">                              xxlJobLogReport.setFailCount(triggerDayCountFail);</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          <span class="comment">// 将上述结果更新到xxl_job_log_report表中</span></span><br><span class="line">                          <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> XxlJobAdminConfig.getAdminConfig().getXxlJobLogReportDao().update(xxlJobLogReport);</span><br><span class="line">                          <span class="keyword">if</span> (ret &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                              XxlJobAdminConfig.getAdminConfig().getXxlJobLogReportDao().save(xxlJobLogReport);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                          logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job log report thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 2、log-clean: switch open &amp; once each day</span></span><br><span class="line">                  <span class="comment">//设置了保留日志天数且日志保留了24小时，则进入if逻辑内部</span></span><br><span class="line">                  <span class="keyword">if</span> (XxlJobAdminConfig.getAdminConfig().getLogretentiondays()&gt;<span class="number">0</span></span><br><span class="line">                          &amp;&amp; System.currentTimeMillis() - lastCleanLogTime &gt; <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>) &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 通过日志保留天数算出清除log时间</span></span><br><span class="line">                      <span class="type">Calendar</span> <span class="variable">expiredDay</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">                      expiredDay.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span> * XxlJobAdminConfig.getAdminConfig().getLogretentiondays());</span><br><span class="line">                      expiredDay.set(Calendar.HOUR_OF_DAY, <span class="number">0</span>);</span><br><span class="line">                      expiredDay.set(Calendar.MINUTE, <span class="number">0</span>);</span><br><span class="line">                      expiredDay.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">                      expiredDay.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br><span class="line">                      <span class="type">Date</span> <span class="variable">clearBeforeTime</span> <span class="operator">=</span> expiredDay.getTime();</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// clean expired log</span></span><br><span class="line">                      List&lt;Long&gt; logIds = <span class="literal">null</span>;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          logIds = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findClearLogIds(<span class="number">0</span>, <span class="number">0</span>, clearBeforeTime, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">                          <span class="keyword">if</span> (logIds!=<span class="literal">null</span> &amp;&amp; logIds.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="comment">//删除过期日期数据</span></span><br><span class="line">                              XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().clearLog(logIds);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> (logIds!=<span class="literal">null</span> &amp;&amp; logIds.size()&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// update clean time</span></span><br><span class="line">                      lastCleanLogTime = System.currentTimeMillis();</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                          logger.error(e.getMessage(), e);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure><h2 id="任务调度处理器-重点"><a href="#任务调度处理器-重点" class="headerlink" title="任务调度处理器(重点)"></a>任务调度处理器(重点)</h2><p>接下来就是xxl-job工作调度的核心源码 JobScheduleHelper，我们还是分两段来查看这其中的逻辑。先来看看第一段逻辑，这段逻辑是由 scheduleThread 这个守护线程处理的，它的逻辑主要是负责安排任务的执行时间的:</p><ol><li>查出未来5s要执行的任务。</li><li>如果发现这个任务执行时间距离现在已经过期5s，则根据策略要么立即触发要么安排下次处理时间。</li><li>如果发现这个任务在过期时间小于5s要么现在立刻执行，要么安排下次一次执行时间，并将这个时间。</li><li>剩下的都是未过期即将被执行的任务则全部存到一个ringdata的线程安全map中，这个map以秒为key，所有这个时间点执行的任务构成的list为value。</li><li>将job的时间安排结果更新到xxl_job_info表中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// schedule thread</span></span><br><span class="line">        scheduleThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">5000</span> - System.currentTimeMillis()%<span class="number">1000</span> );</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!scheduleThreadToStop) &#123;</span><br><span class="line">                        logger.error(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success.&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//查出可以读取的任务数，这里为6000，也就是说这个线程一次可以处理6000个任务信息</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">preReadCount</span> <span class="operator">=</span> (XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax() + XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax()) * <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!scheduleThreadToStop) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Scan Job</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="type">Boolean</span> <span class="variable">connAutoCommit</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">preReadSuc</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        conn = XxlJobAdminConfig.getAdminConfig().getDataSource().getConnection();</span><br><span class="line">                        connAutoCommit = conn.getAutoCommit();</span><br><span class="line">                        conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">//上写锁，然后操作xxl_job_info表</span></span><br><span class="line">                        preparedStatement = conn.prepareStatement(  <span class="string">&quot;select * from xxl_job_lock where lock_name = &#x27;schedule_lock&#x27; for update&quot;</span> );</span><br><span class="line">                        preparedStatement.execute();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// tx start</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 1、查出未来5s要执行的任务</span></span><br><span class="line">                        <span class="type">long</span> <span class="variable">nowTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                        List&lt;XxlJobInfo&gt; scheduleList = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleJobQuery(nowTime + PRE_READ_MS, preReadCount);</span><br><span class="line">                        <span class="keyword">if</span> (scheduleList!=<span class="literal">null</span> &amp;&amp; scheduleList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 2、push time-ring</span></span><br><span class="line">                            <span class="keyword">for</span> (XxlJobInfo jobInfo: scheduleList) &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 如果现在时间大于任务下次处理时间+5s，即当前任务到期了还没执行则进入if逻辑</span></span><br><span class="line">                                <span class="keyword">if</span> (nowTime &gt; jobInfo.getTriggerNextTime() + PRE_READ_MS) &#123;</span><br><span class="line">                                    <span class="comment">// 2.1、trigger-expire &gt; 5s：pass &amp;&amp; make next-trigger-time</span></span><br><span class="line">                                    logger.warn(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule misfire, jobId = &quot;</span> + jobInfo.getId());</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 如果任务的处理策略是FIRE_ONCE_NOW则立刻执行</span></span><br><span class="line">                                    <span class="type">MisfireStrategyEnum</span> <span class="variable">misfireStrategyEnum</span> <span class="operator">=</span> MisfireStrategyEnum.match(jobInfo.getMisfireStrategy(), MisfireStrategyEnum.DO_NOTHING);</span><br><span class="line">                                    <span class="keyword">if</span> (MisfireStrategyEnum.FIRE_ONCE_NOW == misfireStrategyEnum) &#123;</span><br><span class="line">                                        <span class="comment">// FIRE_ONCE_NOW 》 trigger</span></span><br><span class="line">                                        JobTriggerPoolHelper.trigger(jobInfo.getId(), TriggerTypeEnum.MISFIRE, -<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                                        logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule push trigger : jobId = &quot;</span> + jobInfo.getId() );</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 如果任务不是要求FIRE_ONCE_NOW则更新一下下次处理的时间</span></span><br><span class="line">                                    refreshNextValidTime(jobInfo, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nowTime &gt; jobInfo.getTriggerNextTime()) &#123;<span class="comment">//过期时间小于5s</span></span><br><span class="line">                                    <span class="comment">// 2.2、trigger-expire &lt; 5s：direct-trigger &amp;&amp; make next-trigger-time</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 1、则提交到线程池中等待执行</span></span><br><span class="line">                                    JobTriggerPoolHelper.trigger(jobInfo.getId(), TriggerTypeEnum.CRON, -<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                                    logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule push trigger : jobId = &quot;</span> + jobInfo.getId() );</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 2、设置下一次处理时间</span></span><br><span class="line">                                    refreshNextValidTime(jobInfo, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//如果下次处理时间还在5s内再次更新一下时间</span></span><br><span class="line">                                    <span class="keyword">if</span> (jobInfo.getTriggerStatus()==<span class="number">1</span> &amp;&amp; nowTime + PRE_READ_MS &gt; jobInfo.getTriggerNextTime()) &#123;</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">// 1、make ring second</span></span><br><span class="line">                                        <span class="type">int</span> <span class="variable">ringSecond</span> <span class="operator">=</span> (<span class="type">int</span>)((jobInfo.getTriggerNextTime()/<span class="number">1000</span>)%<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">// 2、push time ring将任务存到ringData这个ConcurrentHashMap中</span></span><br><span class="line">                                        pushTimeRing(ringSecond, jobInfo.getId());</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">// 3、设置下次执行时间</span></span><br><span class="line">                                        refreshNextValidTime(jobInfo, <span class="keyword">new</span> <span class="title class_">Date</span>(jobInfo.getTriggerNextTime()));</span><br><span class="line"></span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">// 2.3、trigger-pre-read：time-ring trigger &amp;&amp; make next-trigger-time</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 1、make ring second</span></span><br><span class="line">                                    <span class="type">int</span> <span class="variable">ringSecond</span> <span class="operator">=</span> (<span class="type">int</span>)((jobInfo.getTriggerNextTime()/<span class="number">1000</span>)%<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 2、push time ring</span></span><br><span class="line">                                    pushTimeRing(ringSecond, jobInfo.getId());</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 3、fresh next</span></span><br><span class="line">                                    refreshNextValidTime(jobInfo, <span class="keyword">new</span> <span class="title class_">Date</span>(jobInfo.getTriggerNextTime()));</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 3、update trigger info</span></span><br><span class="line">                            <span class="keyword">for</span> (XxlJobInfo jobInfo: scheduleList) &#123;</span><br><span class="line">                                XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleUpdate(jobInfo);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            preReadSuc = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// tx stop</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!scheduleThreadToStop) &#123;</span><br><span class="line">                            logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#scheduleThread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">........</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>接下来就是任务调度的逻辑了，这里的处理也很简单，从上文创建的rindData取出当前时间前2s的任务，然后提交到线程池中执行，避免没必要的延迟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ringThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!ringThreadToStop) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// align second</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span> - System.currentTimeMillis() % <span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!ringThreadToStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 提前2s获取即将执行的任务存到ringItemData中</span></span><br><span class="line">                        List&lt;Integer&gt; ringItemData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">nowSecond</span> <span class="operator">=</span> Calendar.getInstance().get(Calendar.SECOND);   <span class="comment">// 避免处理耗时太长，跨过刻度，向前校验一个刻度；</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                            List&lt;Integer&gt; tmpData = ringData.remove( (nowSecond+<span class="number">60</span>-i)%<span class="number">60</span> );</span><br><span class="line">                            <span class="keyword">if</span> (tmpData != <span class="literal">null</span>) &#123;</span><br><span class="line">                                ringItemData.addAll(tmpData);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// ring trigger</span></span><br><span class="line">                        logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, time-ring beat : &quot;</span> + nowSecond + <span class="string">&quot; = &quot;</span> + Arrays.asList(ringItemData) );</span><br><span class="line">                        <span class="keyword">if</span> (ringItemData.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// ringItemData中的任务全部提交到线程池中执行</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> jobId: ringItemData) &#123;</span><br><span class="line">                                <span class="comment">// do trigger</span></span><br><span class="line">                                JobTriggerPoolHelper.trigger(jobId, TriggerTypeEnum.CRON, -<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// clear</span></span><br><span class="line">                            ringItemData.clear();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!ringThreadToStop) &#123;</span><br><span class="line">                            logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#ringThread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#ringThread stop&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h1 id="客户端启动流程"><a href="#客户端启动流程" class="headerlink" title="客户端启动流程"></a>客户端启动流程</h1><h2 id="基于配置类了解作业执行器"><a href="#基于配置类了解作业执行器" class="headerlink" title="基于配置类了解作业执行器"></a>基于配置类了解作业执行器</h2><p>现在来探寻一下 xxl-job 客户端，源码项目在：xxl-job-executor-sample-springboot</p><p>要想了解spring boot项目，我们都可以从项目中的配置类中看到核心类或者操作，于是我们找到了XxlJobConfig。</p><p>XxlJobConfig有个方法xxlJobExecutor，这就是创建执行器的方法，可以看到这里面所作的操作非常简单，你拿着配置文件中配置文件中的adminAddresses、appname、address等各种信息创建一个执行器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述appname、address等信息都是来自于配置文件中。</p><h2 id="基于XxlJobSpringExecutor了解客户端初始化流程"><a href="#基于XxlJobSpringExecutor了解客户端初始化流程" class="headerlink" title="基于XxlJobSpringExecutor了解客户端初始化流程"></a>基于XxlJobSpringExecutor了解客户端初始化流程</h2><p>从类图中我们不难看出它继承了和xxl-job相关的XxlJobExecutor以及一个和spring相关的SmartInitializingSingleton接口。</p><p><img src="https://qiniuyun.sharkchili.com/img202304271422230.png" alt="在这里插入图片描述"></p><h3 id="SmartInitializingSingleton的概念"><a href="#SmartInitializingSingleton的概念" class="headerlink" title="SmartInitializingSingleton的概念"></a>SmartInitializingSingleton的概念</h3><p>该接口也是SpringBoot的一个扩展点，它会在spring将所有的单例bean初始化之后，执行afterSingletonsInstantiated这个方法。所以查看我们的XxlJobSpringExecutor这个方法实现。</p><p>可以看到这个类主要做了以下三件事:</p><ol><li>初始化JobHandler的方法。</li><li>刷新GlueFactory这个工厂。</li><li>调用XxlJobExecutor的start方法。</li></ol><h2 id="基于afterSingletonsInstantiated了解执行器启动流程"><a href="#基于afterSingletonsInstantiated了解执行器启动流程" class="headerlink" title="基于afterSingletonsInstantiated了解执行器启动流程"></a>基于afterSingletonsInstantiated了解执行器启动流程</h2><h3 id="初始化所有-JobHandler-方法"><a href="#初始化所有-JobHandler-方法" class="headerlink" title="初始化所有 JobHandler 方法"></a>初始化所有 JobHandler 方法</h3><p>接下来我们开始了解每一个方法的具体逻辑，我们首先步入initJobHandlerMethodRepository(applicationContext);方法查看一下详情。</p><p>代码如下，具体含义笔者以及详细注释，整体来说分为3步:</p><ol><li>获取spring容器中所有bean。</li><li>过滤出懒加载的bean。</li><li>看看这个bean的方法是否包含XxlJob这个注解。</li><li>将带有XxlJob注解的方法注册到xxl-job-admin上。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initJobHandlerMethodRepository</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取容器中所有的bean</span></span><br><span class="line">        String[] beanDefinitionNames = applicationContext.getBeanNamesForType(Object.class, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拿到所有懒加载的bean</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Lazy</span> <span class="variable">onBean</span> <span class="operator">=</span> applicationContext.findAnnotationOnBean(beanDefinitionName, Lazy.class);</span><br><span class="line">            <span class="keyword">if</span> (onBean!=<span class="literal">null</span>)&#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;xxl-job annotation scan, skip @Lazy Bean:&#123;&#125;&quot;</span>, beanDefinitionName);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                bean = applicationContext.getBean(beanDefinitionName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查看这个懒加载的bean是否有XxlJob注解，如果有则继续往后走</span></span><br><span class="line">            Map&lt;Method, XxlJob&gt; annotatedMethods = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                annotatedMethods = MethodIntrospector.selectMethods(bean.getClass(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">MethodIntrospector</span>.MetadataLookup&lt;XxlJob&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> XxlJob <span class="title function_">inspect</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> AnnotatedElementUtils.findMergedAnnotation(method, XxlJob.class);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;xxl-job method-jobhandler resolve error for bean[&quot;</span> + beanDefinitionName + <span class="string">&quot;].&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (annotatedMethods==<span class="literal">null</span> || annotatedMethods.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成并将该处理器的方法注册到xxl-job-admin上</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Method, XxlJob&gt; methodXxlJobEntry : annotatedMethods.entrySet()) &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">executeMethod</span> <span class="operator">=</span> methodXxlJobEntry.getKey();</span><br><span class="line">                <span class="type">XxlJob</span> <span class="variable">xxlJob</span> <span class="operator">=</span> methodXxlJobEntry.getValue();</span><br><span class="line">                <span class="comment">// 注册xxl-job-admin上</span></span><br><span class="line">                registJobHandler(xxlJob, bean, executeMethod);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="刷新GlueFactory"><a href="#刷新GlueFactory" class="headerlink" title="刷新GlueFactory"></a>刷新GlueFactory</h3><p>我们继续查看refreshInstance方法，没有什么特殊逻辑，无非是将glueFactory 指向一个全新的工厂而已。最终代码会new SpringGlueFactory();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">refreshInstance</span><span class="params">(<span class="type">int</span> type)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">glueFactory = <span class="keyword">new</span> <span class="title class_">GlueFactory</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">glueFactory = <span class="keyword">new</span> <span class="title class_">SpringGlueFactory</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="了解XxlJobExecutor的start方法-重点"><a href="#了解XxlJobExecutor的start方法-重点" class="headerlink" title="了解XxlJobExecutor的start方法(重点)"></a>了解XxlJobExecutor的start方法(重点)</h3><p>终于我们来到的最核心的不妨，在XxlJobSpringExecutor的afterSingletonsInstantiated中调用了一个super.start();，这个super就是我们的XxlJobExecutor，具体逻辑如下。</p><p>可以看到它整体分为以下几个步骤:</p><ol><li>初始化日志文件存放路径。</li><li>初始化xxl-job-admin地址列表。</li><li>初始化过期日志文件清理线程。</li><li>初始化回调结果通知xxl-job-admin线程。</li><li>初始化 executor-server监听调度器的请求器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化日志路径</span></span><br><span class="line">        XxlJobFileAppender.initLogPath(logPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化admin地址列表</span></span><br><span class="line">        initAdminBizList(adminAddresses, accessToken);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化日志文件清理线程</span></span><br><span class="line">        JobLogFileCleanThread.getInstance().start(logRetentionDays);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化回调线程</span></span><br><span class="line">        TriggerCallbackThread.getInstance().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 executor-server监听调度器的请求器</span></span><br><span class="line">        initEmbedServer(address, ip, port, appname, accessToken);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="XxlJobExecutor的start方法流程详解"><a href="#XxlJobExecutor的start方法流程详解" class="headerlink" title="XxlJobExecutor的start方法流程详解"></a>XxlJobExecutor的start方法流程详解</h2><h3 id="初始化日志"><a href="#初始化日志" class="headerlink" title="初始化日志"></a>初始化日志</h3><p>首先是initLogPath方法，逻辑其实很简单就是通过配置文件获取路径然后进行拼接，最后设置到glueSrcPath 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">logBasePath</span> <span class="operator">=</span> <span class="string">&quot;/data/applogs/xxl-job/jobhandler&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">glueSrcPath</span> <span class="operator">=</span> logBasePath.concat(<span class="string">&quot;/gluesource&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initLogPath</span><span class="params">(String logPath)</span>&#123;</span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="keyword">if</span> (logPath!=<span class="literal">null</span> &amp;&amp; logPath.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">logBasePath = logPath;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mk base dir</span></span><br><span class="line"><span class="type">File</span> <span class="variable">logPathDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(logBasePath);</span><br><span class="line"><span class="keyword">if</span> (!logPathDir.exists()) &#123;</span><br><span class="line">logPathDir.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">logBasePath = logPathDir.getPath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// mk glue dir</span></span><br><span class="line"><span class="type">File</span> <span class="variable">glueBaseDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(logPathDir, <span class="string">&quot;gluesource&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!glueBaseDir.exists()) &#123;</span><br><span class="line">glueBaseDir.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">glueSrcPath = glueBaseDir.getPath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化-admin-地址"><a href="#初始化-admin-地址" class="headerlink" title="初始化 admin 地址"></a>初始化 admin 地址</h3><p>然后是initAdminBizList方法,逻辑也很简单，将我们的配置文件中配置的adminAddresses通过逗号进行切割，然后存放到adminBizList中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;AdminBiz&gt; adminBizList;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initAdminBizList</span><span class="params">(String adminAddresses, String accessToken)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="keyword">if</span> (adminAddresses!=<span class="literal">null</span> &amp;&amp; adminAddresses.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//adminAddresses以逗号切割遍历存到adminBizList中</span></span><br><span class="line">           <span class="keyword">for</span> (String address: adminAddresses.trim().split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (address!=<span class="literal">null</span> &amp;&amp; address.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="type">AdminBiz</span> <span class="variable">adminBiz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdminBizClient</span>(address.trim(), accessToken);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (adminBizList == <span class="literal">null</span>) &#123;</span><br><span class="line">                       adminBizList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;AdminBiz&gt;();</span><br><span class="line">                   &#125;</span><br><span class="line">                   adminBizList.add(adminBiz);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="清除过期日志"><a href="#清除过期日志" class="headerlink" title="清除过期日志"></a>清除过期日志</h3><p>该方法时JobLogFileCleanThread的start方法，逻辑比较长，我们分为两段来说</p><p>首先判断日志保留天数，这个logRetentionDays 的值是从配置文件中来的，如果发现小于3天则直接返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果日志保留天数小于3天直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (logRetentionDays &lt; <span class="number">3</span> ) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>然后这个方法创建了一个localThread线程，其run方法核心逻辑如下：</p><ol><li>得到所有文件位置。</li><li>算出今天的时间。</li><li>计算出这个文件的时间。</li><li>如果创建时间至今超过logRetentionDays (这里配置为30天)，则将通过递归的方式删除这些日志文件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 得到所有文件路径</span></span><br><span class="line">                        File[] childDirs = <span class="keyword">new</span> <span class="title class_">File</span>(XxlJobFileAppender.getLogPath()).listFiles();</span><br><span class="line">                        <span class="keyword">if</span> (childDirs!=<span class="literal">null</span> &amp;&amp; childDirs.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 算出今天的时间</span></span><br><span class="line">                            <span class="type">Calendar</span> <span class="variable">todayCal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">                            todayCal.set(Calendar.HOUR_OF_DAY,<span class="number">0</span>);</span><br><span class="line">                            todayCal.set(Calendar.MINUTE,<span class="number">0</span>);</span><br><span class="line">                            todayCal.set(Calendar.SECOND,<span class="number">0</span>);</span><br><span class="line">                            todayCal.set(Calendar.MILLISECOND,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="type">Date</span> <span class="variable">todayDate</span> <span class="operator">=</span> todayCal.getTime();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (File childFile: childDirs) &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// valid</span></span><br><span class="line">                                <span class="keyword">if</span> (!childFile.isDirectory()) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (childFile.getName().indexOf(<span class="string">&quot;-&quot;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 得到文件创建时间</span></span><br><span class="line">                                <span class="type">Date</span> <span class="variable">logFileCreateDate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">                                    logFileCreateDate = simpleDateFormat.parse(childFile.getName());</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                                    logger.error(e.getMessage(), e);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (logFileCreateDate == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//如果这个文件创建时间至今超过30天则直接递归删除文件及其子文件</span></span><br><span class="line">                                <span class="keyword">if</span> ((todayDate.getTime()-logFileCreateDate.getTime()) &gt;= logRetentionDays * (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>) ) &#123;</span><br><span class="line">                                    FileUtil.deleteRecursively(childFile);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.DAYS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><h3 id="初始化回调线程回调结果给admin"><a href="#初始化回调线程回调结果给admin" class="headerlink" title="初始化回调线程回调结果给admin"></a>初始化回调线程回调结果给admin</h3><p>继续查看start方法中TriggerCallbackThread的start，我们查看其run方法，它的主要作用是将当前任务的执行结果告诉给xxl-job-admin，步骤也很简单:</p><ol><li>从队列中取出一个任务的执行结果HandleCallbackParam。</li><li>将结果存到callbackParamList中。</li><li>调用doCallback将结果发送给xxl-job-admin。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!toStop)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//从callBackQueue获取到对应jobId的执行结果</span></span><br><span class="line">                        <span class="type">HandleCallbackParam</span> <span class="variable">callback</span> <span class="operator">=</span> getInstance().callBackQueue.take();</span><br><span class="line">                        <span class="keyword">if</span> (callback != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            </span><br><span class="line">                            List&lt;HandleCallbackParam&gt; callbackParamList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HandleCallbackParam&gt;();</span><br><span class="line">                            <span class="type">int</span> <span class="variable">drainToNum</span> <span class="operator">=</span> getInstance().callBackQueue.drainTo(callbackParamList);</span><br><span class="line">                            <span class="comment">//将回调结果存到callbackParamList</span></span><br><span class="line">                            callbackParamList.add(callback);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 将结果回调给xxl-job-admin</span></span><br><span class="line">                            <span class="keyword">if</span> (callbackParamList!=<span class="literal">null</span> &amp;&amp; callbackParamList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                                doCallback(callbackParamList);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>查看doCallback的实现细节，它的工作过程也很简单，遍历出对应的xxl-job实例，发送结果某一个发送失败，则遍历下一个实例继续发送，直到成功为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doCallback</span><span class="params">(List&lt;HandleCallbackParam&gt; callbackParamList)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">callbackRet</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 遍历xxl-job-admin服务所对应的对象adminBiz</span></span><br><span class="line">        <span class="keyword">for</span> (AdminBiz adminBiz: XxlJobExecutor.getAdminBizList()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//调用adminBiz的回调接口将结果发送给xxl-job-admin服务</span></span><br><span class="line">                ReturnT&lt;String&gt; callbackResult = adminBiz.callback(callbackParamList);</span><br><span class="line">                <span class="comment">//如果成功记录一个日志并退出循环，如果失败，则继续遍历其他实例发送回调结果</span></span><br><span class="line">                <span class="keyword">if</span> (callbackResult!=<span class="literal">null</span> &amp;&amp; ReturnT.SUCCESS_CODE == callbackResult.getCode()) &#123;</span><br><span class="line">                    callbackLog(callbackParamList, <span class="string">&quot;&lt;br&gt;----------- xxl-job job callback finish.&quot;</span>);</span><br><span class="line">                    callbackRet = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果回调失败，则打个日志</span></span><br><span class="line">                    callbackLog(callbackParamList, <span class="string">&quot;&lt;br&gt;----------- xxl-job job callback fail, callbackResult:&quot;</span> + callbackResult);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                callbackLog(callbackParamList, <span class="string">&quot;&lt;br&gt;----------- xxl-job job callback error, errorMsg:&quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!callbackRet) &#123;</span><br><span class="line">            appendFailCallbackFile(callbackParamList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="注册内嵌服务等待服务端调用-重点"><a href="#注册内嵌服务等待服务端调用-重点" class="headerlink" title="注册内嵌服务等待服务端调用(重点)"></a>注册内嵌服务等待服务端调用(重点)</h3><p>到了最关键的一步initEmbedServer(address, ip, port, appname, accessToken);，这一步就是可以确保我们的执行器可以收到调度器的关键所在。 它的工作流程就是组装端口等参数，通过netty的方式将服务开启并等待调度器的调用。现在不妨我们自顶向下查看一下它的实现细节。</p><p>从调用我们可以看到它的步骤也很清晰:</p><ol><li>获取端口号以及ip地址。于端口号和ip地址组装服务地址。</li><li>获取token。</li><li>基于上述所有参数调用embedServer的start启动内嵌服务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initEmbedServer</span><span class="params">(String address, String ip, <span class="type">int</span> port, String appname, String accessToken)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取端口号和ip地址</span></span><br><span class="line">        port = port&gt;<span class="number">0</span>?port: NetUtil.findAvailablePort(<span class="number">9999</span>);</span><br><span class="line">        ip = (ip!=<span class="literal">null</span>&amp;&amp;ip.trim().length()&gt;<span class="number">0</span>)?ip: IpUtil.getIp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于端口号和ip地址生成当前服务地址</span></span><br><span class="line">        <span class="keyword">if</span> (address==<span class="literal">null</span> || address.trim().length()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ip_port_address</span> <span class="operator">=</span> IpUtil.getIpPort(ip, port);   <span class="comment">// registry-address：default use address to registry , otherwise use ip:port if address is null</span></span><br><span class="line">            address = <span class="string">&quot;http://&#123;ip_port&#125;/&quot;</span>.replace(<span class="string">&quot;&#123;ip_port&#125;&quot;</span>, ip_port_address);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取token</span></span><br><span class="line">        <span class="keyword">if</span> (accessToken==<span class="literal">null</span> || accessToken.trim().length()==<span class="number">0</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job accessToken is empty. To ensure system security, please set the accessToken.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于上述服务初始化内嵌服务，并将其启动</span></span><br><span class="line">        embedServer = <span class="keyword">new</span> <span class="title class_">EmbedServer</span>();</span><br><span class="line">        embedServer.start(address, port, appname, accessToken);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>了解了整体流程之后，我们再来看看细节。即embedServer的start的具体实现。</p><p>我们步入start方法会看到一个名为thread的线程，代码比较长，我们分段来解读。首先它会创建两个NIO group。然后再创建一个业务线程池，初始为0，最大线程数为200，队列中可以容纳2000个任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">            <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">            <span class="type">ThreadPoolExecutor</span> <span class="variable">bizThreadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                    <span class="number">0</span>,</span><br><span class="line">                    <span class="number">200</span>,</span><br><span class="line">                    <span class="number">60L</span>,</span><br><span class="line">                    TimeUnit.SECONDS,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2000</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;xxl-job, EmbedServer bizThreadPool-&quot;</span> + r.hashCode());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;xxl-job, EmbedServer bizThreadPool is EXHAUSTED!&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure><p>基于上述的参数启动ServerBootstrap，并将配置文件中appName和当前应用地址信息作为参数，将服务注册到xxl-job-admin上。然后就是调用 future.channel().closeFuture().sync()等待调度器调用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ServerBootstrap</span></span><br><span class="line">                    <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">                    bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                            .channel(NioServerSocketChannel.class)</span><br><span class="line">                            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    channel.pipeline()</span><br><span class="line">                                            .addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">30</span> * <span class="number">3</span>, TimeUnit.SECONDS))  <span class="comment">// beat 3N, close if idle</span></span><br><span class="line">                                            .addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>())</span><br><span class="line">                                            .addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>))  <span class="comment">// merge request &amp; reponse to FULL</span></span><br><span class="line">                                            .addLast(<span class="keyword">new</span> <span class="title class_">EmbedHttpServerHandler</span>(executorBiz, accessToken, bizThreadPool));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">                            .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 绑定端口号</span></span><br><span class="line">                    <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(port).sync();</span><br><span class="line"></span><br><span class="line">                    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job remoting server start success, nettype = &#123;&#125;, port = &#123;&#125;&quot;</span>, EmbedServer.class, port);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 注册到xxl-job上</span></span><br><span class="line">                    startRegistry(appname, address);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 等待调用</span></span><br><span class="line">                    future.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure><p>上文提到一个注册服务到xxl-job-admin的操作，我们查看startRegistry源码，我们查看其内部源码也是基于一个线程的带有while循环的run方法来实现的，核心逻辑如下，很简单，获取xxl-job-admin实例，调用其注册方法将当前服务注册上去，如果成功就结束循环，如果失败就遍历其他实例继续尝试注册，这一点和上文的回调处理器工作流程差不多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RegistryParam</span> <span class="variable">registryParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryParam</span>(RegistryConfig.RegistType.EXECUTOR.name(), appname, address);</span><br><span class="line">                        <span class="comment">//遍历xxl-job-admin对象，注册当前服务，只要成功就结束循环</span></span><br><span class="line">                        <span class="keyword">for</span> (AdminBiz adminBiz: XxlJobExecutor.getAdminBizList()) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                ReturnT&lt;String&gt; registryResult = adminBiz.registry(registryParam);</span><br><span class="line">                                <span class="keyword">if</span> (registryResult!=<span class="literal">null</span> &amp;&amp; ReturnT.SUCCESS_CODE == registryResult.getCode()) &#123;</span><br><span class="line">                                    registryResult = ReturnT.SUCCESS;</span><br><span class="line">                                    logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job registry success, registryParam:&#123;&#125;, registryResult:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;registryParam, registryResult&#125;);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job registry fail, registryParam:&#123;&#125;, registryResult:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;registryParam, registryResult&#125;);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job registry error, registryParam:&#123;&#125;&quot;</span>, registryParam, e);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure><p>上述操作完成之后，线程会休眠30s，然后继续向xxl-job-admin注册当前服务信息，起到一个保持心跳的作用。自此我们的客户端启动流程就结束了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                           <span class="comment">//休眠30s之后继续注册，起到一个保持心跳的效果</span></span><br><span class="line">                           TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                           logger.warn(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, executor registry thread interrupted, error msg:&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure><h3 id="EmbedHttpServerHandler详解"><a href="#EmbedHttpServerHandler详解" class="headerlink" title="EmbedHttpServerHandler详解"></a>EmbedHttpServerHandler详解</h3><p>还记得我们上文注册内嵌服务时候的逻辑吗？这一步中它们组装了一个处理器，这个就是处理调度器请求的核心所在。</p><p><img src="https://qiniuyun.sharkchili.com/img202304271422498.png" alt="在这里插入图片描述"></p><p>我们不妨找到这个类，对其channelRead0方法打个断点。</p><p><img src="https://qiniuyun.sharkchili.com/img202304271422608.png" alt="在这里插入图片描述"></p><p>从断点参数中我们可以看到这个方法收到调取器的参数之后，会将其提交到业务线程中，调用process方法调用当前服务的方法完成请求。</p><p>自此，一次完整的job调度就完成了。</p><h1 id="编写任务自动注册组件"><a href="#编写任务自动注册组件" class="headerlink" title="编写任务自动注册组件"></a>编写任务自动注册组件</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>使用 xxl-job 时会存在一个问题，编写好任务后，虽然@XxlJob注解会将方法注册到xxl-job-admin，但是任务需要我们手动添加。此时，我们希望有这样一个工具，可以让我们只需一个注解即可将执行器和任务直接注册到xxl-job-admin上，这样我们只需在编码阶段写好任务将项目启动，就可以将任务注册到xxl-job-admin中。</p><p><img src="https://qiniuyun.sharkchili.com/img202304211256304.png" alt="在这里插入图片描述"></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>我们可以借由spring-boot自动装配机制，并定义一个注解，扫描容器中所有执行器和带有这个注解的任务，然后调用xxl-job的api将这些任务注册到xxl-job-admin中。</p><h2 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h2><p>在正式编写组件前，先引入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- xxl-job-core --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;xxl-job.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hutool.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先我们从xxl-job-admin中将这两个类拷过来。</p><p><img src="https://qiniuyun.sharkchili.com/img202304211256957.png" alt="在这里插入图片描述"></p><p>我们在web界面操作xxl-job-admin时发现所有操作都需要基于一个cookie，而这个cookie是需要登录才能得到的。所以我们要定义一个接口，后续将登录和获取cookie保存到内存的操作补充上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JobLoginService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录xxl-job-admin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取登录后的cookie</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getCookie</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理然后编写一个接口，定义所有关于执行器的bean的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JobGroupService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询执行器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;XxlJobGroup&gt; <span class="title function_">getJobGroup</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动注册执行器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">autoRegisterGroup</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精确查询执行器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">preciselyCheck</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文提到我们也需要将任务注册到xxl-job上，所以在这里我们也把这个接口定义上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JobInfoService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询xxl-job-admin上是否有这个任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobGroupId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executorHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;XxlJobInfo&gt; <span class="title function_">getJobInfo</span><span class="params">(Integer jobGroupId, String executorHandler)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加任务到xxl-job-admin上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xxlJobInfo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Integer <span class="title function_">addJobInfo</span><span class="params">(XxlJobInfo xxlJobInfo)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此所有我们需要的行为都有了，我们就需要开始将逻辑补充上了。首先是登录和获取cookie的方法。代码含义都详细注释了，读者可以自行查阅，这里简单说明一下登录进行的操作就是:</p><ol><li>调用xxl-job登录接口</li><li>成功后获取cookie</li><li>将cookie缓存到map中</li></ol><p>而获取cookie的方式也很简单，从map中取出来返回出去就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobLoginServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">JobLoginService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置文件获取的xxl-job地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置文件获取的登录用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从xxl-job获取的登录密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存cookie的密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; loginCookie = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用登录接口将XXL_JOB_LOGIN_IDENTITY缓存下来后续使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//调用登录接口</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> adminAddresses + <span class="string">&quot;/login&quot;</span>;</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .form(<span class="string">&quot;userName&quot;</span>, username)</span><br><span class="line">                .form(<span class="string">&quot;password&quot;</span>, password)</span><br><span class="line">                .execute();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取登录后的cookie</span></span><br><span class="line">        List&lt;HttpCookie&gt; cookies = response.getCookies();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//尝试获得XXL_JOB_LOGIN_IDENTITY</span></span><br><span class="line">        Optional&lt;HttpCookie&gt; cookieOpt = cookies.stream()</span><br><span class="line">                .filter(cookie -&gt; cookie.getName().equals(<span class="string">&quot;XXL_JOB_LOGIN_IDENTITY&quot;</span>))</span><br><span class="line">                .findFirst();</span><br><span class="line">        <span class="keyword">if</span> (!cookieOpt.isPresent()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;get xxl-job cookie error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果存在这个cookie则将其缓存起来</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cookieOpt.get().getValue();</span><br><span class="line">        loginCookie.put(<span class="string">&quot;XXL_JOB_LOGIN_IDENTITY&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试从内存中获取cookie，如果没有则尝试3次登录即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCookie</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cookieStr</span> <span class="operator">=</span> loginCookie.get(<span class="string">&quot;XXL_JOB_LOGIN_IDENTITY&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (cookieStr != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;XXL_JOB_LOGIN_IDENTITY=&quot;</span> + cookieStr;</span><br><span class="line">            &#125;</span><br><span class="line">            login();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;get xxl-job cookie error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是执行器注册的逻辑了，整体来说有两个方法，分别是精确查询执行器和注册执行器的方法，含义都详尽注释在代码上，读者可自行参阅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobGroupServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">JobGroupService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.title&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行器地址类型：0=自动注册、1=手动录入</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.addressType:0&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer addressType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行器地址列表，多地址逗号分隔(手动录入)</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.addressList:&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String addressList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobLoginService jobLoginService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精确查询执行器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preciselyCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//调用xxl-job模糊查询job的api</span></span><br><span class="line">        List&lt;XxlJobGroup&gt; jobGroup = getJobGroup();</span><br><span class="line">        <span class="comment">//精确匹配执行器名称</span></span><br><span class="line">        Optional&lt;XxlJobGroup&gt; has = jobGroup.stream()</span><br><span class="line">                .filter(xxlJobGroup -&gt; xxlJobGroup.getAppname().equals(appName)</span><br><span class="line">                        &amp;&amp; xxlJobGroup.getTitle().equals(title))</span><br><span class="line">                .findAny();</span><br><span class="line">        <span class="comment">//返回该执行器是否存在</span></span><br><span class="line">        <span class="keyword">return</span> has.isPresent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询执行器列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;XxlJobGroup&gt; <span class="title function_">getJobGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> adminAddresses + <span class="string">&quot;/jobgroup/pageList&quot;</span>;</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .form(<span class="string">&quot;appname&quot;</span>, appName)</span><br><span class="line">                .form(<span class="string">&quot;title&quot;</span>, title)</span><br><span class="line">                .cookie(jobLoginService.getCookie())</span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> response.body();</span><br><span class="line">        <span class="type">JSONArray</span> <span class="variable">array</span> <span class="operator">=</span> JSONUtil.parse(body).getByPath(<span class="string">&quot;data&quot;</span>, JSONArray.class);</span><br><span class="line">        List&lt;XxlJobGroup&gt; list = array.stream()</span><br><span class="line">                .map(o -&gt; JSONUtil.toBean((JSONObject) o, XxlJobGroup.class))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用xxl-job保存执行器的api，将执行器保存到xxl-job上</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">autoRegisterGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//组装请求地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> adminAddresses + <span class="string">&quot;/jobgroup/save&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//组装表单参数</span></span><br><span class="line">        <span class="type">HttpRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .form(<span class="string">&quot;appname&quot;</span>, appName)</span><br><span class="line">                .form(<span class="string">&quot;title&quot;</span>, title);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组装地址类型和注册地址</span></span><br><span class="line">        httpRequest.form(<span class="string">&quot;addressType&quot;</span>, addressType);</span><br><span class="line">        <span class="keyword">if</span> (addressType.equals(<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Strings.isBlank(addressList)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;手动录入模式下,执行器地址列表不能为空&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            httpRequest.form(<span class="string">&quot;addressList&quot;</span>, addressList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行请求，带上我们之前缓存的cookie</span></span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpRequest.cookie(jobLoginService.getCookie())</span><br><span class="line">                .execute();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">code</span> <span class="operator">=</span> JSONUtil.parse(response.body()).getByPath(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回200就说明注册成功</span></span><br><span class="line">        <span class="keyword">return</span> code.equals(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是任务注册的接口实现了，核心方法也是模糊查询任务列表和注册任务两个方法，读者参阅注释即可理解，这里不多赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobInfoServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">JobInfoService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//xxl-job地址</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobLoginService jobLoginService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模糊查询任务列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobGroupId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executorHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;XxlJobInfo&gt; <span class="title function_">getJobInfo</span><span class="params">(Integer jobGroupId, String executorHandler)</span> &#123;</span><br><span class="line">        <span class="comment">//组装查询url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> adminAddresses + <span class="string">&quot;/jobinfo/pageList&quot;</span>;</span><br><span class="line">        <span class="comment">//调用查询接口</span></span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .form(<span class="string">&quot;jobGroup&quot;</span>, jobGroupId)</span><br><span class="line">                .form(<span class="string">&quot;executorHandler&quot;</span>, executorHandler)</span><br><span class="line">                .form(<span class="string">&quot;triggerStatus&quot;</span>, -<span class="number">1</span>)</span><br><span class="line">                .cookie(jobLoginService.getCookie())</span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> response.body();</span><br><span class="line">        <span class="type">JSONArray</span> <span class="variable">array</span> <span class="operator">=</span> JSONUtil.parse(body).getByPath(<span class="string">&quot;data&quot;</span>, JSONArray.class);</span><br><span class="line">        List&lt;XxlJobInfo&gt; list = array.stream()</span><br><span class="line">                .map(o -&gt; JSONUtil.toBean((JSONObject) o, XxlJobInfo.class))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回任务列表</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个任务到任务列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xxlJobInfo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">addJobInfo</span><span class="params">(XxlJobInfo xxlJobInfo)</span> &#123;</span><br><span class="line">        <span class="comment">//组装查询url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> adminAddresses + <span class="string">&quot;/jobinfo/add&quot;</span>;</span><br><span class="line">        <span class="comment">//执行添加逻辑</span></span><br><span class="line">        Map&lt;String, Object&gt; paramMap = BeanUtil.beanToMap(xxlJobInfo);</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .form(paramMap)</span><br><span class="line">                .cookie(jobLoginService.getCookie())</span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理并返回结果</span></span><br><span class="line">        <span class="type">JSON</span> <span class="variable">json</span> <span class="operator">=</span> JSONUtil.parse(response.body());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">code</span> <span class="operator">=</span> json.getByPath(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (code.equals(<span class="number">200</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Convert.toInt(json.getByPath(<span class="string">&quot;content&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;add jobInfo error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此所有核心工作方法都完成了。我们就可以基于spring-boot的自动装配自动调用这些方法完成执行器和任务的注册。</p><p>首先我们定义一个注解，用于要注册到xxl-job的任务的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于实现任务自动注册</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> XxlRegister &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务执行的cron表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">cron</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务描述</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">jobDesc</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default jobDesc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务作者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">author</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default Author&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 默认为 ROUND 轮询方式</span></span><br><span class="line"><span class="comment">     * 可选： FIRST 第一个</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    String <span class="title function_">executorRouteStrategy</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;ROUND&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果是1则自动注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">triggerStatus</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们要编写一个XxlJobAutoRegister扫描容器中带有XxlJob、XxlRegister的方法，并通过xxl-job-admin的api将其注册上去。</p><p>代码逻辑很简单，通过ApplicationContextAware获取容器中的bean，然后基于ApplicationListener监听容器加载情况，在容器准备好提供服务时，做下面这几件事:</p><ol><li>通过ApplicationContextAware找到所有的bean</li><li>遍历bean，找到带有XxlJob的方法。</li><li>查看带有XxlJob的方法是否有XxlRegister，如果有则将其注册到xxl-job-admin</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobAutoRegister</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationReadyEvent&gt;,</span><br><span class="line">        ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobGroupService jobGroupService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobInfoService jobInfoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationReadyEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">//注册执行器</span></span><br><span class="line">        addJobGroup();</span><br><span class="line">        <span class="comment">//注册任务</span></span><br><span class="line">        addJobInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动注册执行器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addJobGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果存在执行器，则直接返回，说明已经注册过了</span></span><br><span class="line">        <span class="keyword">if</span> (jobGroupService.preciselyCheck())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//否则手动注册一下执行器</span></span><br><span class="line">        <span class="keyword">if</span> (jobGroupService.autoRegisterGroup())</span><br><span class="line">            log.info(<span class="string">&quot;auto register xxl-job group success!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将带有XxlRegister的注解的方法提交到xxl-job-admin中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addJobInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;XxlJobGroup&gt; jobGroups = jobGroupService.getJobGroup();</span><br><span class="line">        <span class="type">XxlJobGroup</span> <span class="variable">xxlJobGroup</span> <span class="operator">=</span> jobGroups.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//拿到所有的bean名称</span></span><br><span class="line">        String[] beanDefinitionNames = applicationContext.getBeanNamesForType(Object.class, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(beanDefinitionName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到这个bean中带有XxlJob的方法</span></span><br><span class="line">            Map&lt;Method, XxlJob&gt; methodWithXxlJob = MethodIntrospector.selectMethods(bean.getClass(),</span><br><span class="line">                    (MethodIntrospector.MetadataLookup&lt;XxlJob&gt;) method -&gt; AnnotatedElementUtils.findMergedAnnotation(method, XxlJob.class));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Method, XxlJob&gt; methodXxlJobEntry : methodWithXxlJob.entrySet()) &#123;</span><br><span class="line">                <span class="comment">//带有XxlJob的方法名</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">executeMethod</span> <span class="operator">=</span> methodXxlJobEntry.getKey();</span><br><span class="line">                <span class="comment">//XxlJob注解配置的值</span></span><br><span class="line">                <span class="type">XxlJob</span> <span class="variable">xxlJob</span> <span class="operator">=</span> methodXxlJobEntry.getValue();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果executeMethod带有XxlRegister注解</span></span><br><span class="line">                <span class="keyword">if</span> (executeMethod.isAnnotationPresent(XxlRegister.class)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    List&lt;XxlJobInfo&gt; jobInfo = jobInfoService.getJobInfo(xxlJobGroup.getId(), xxlJob.value());</span><br><span class="line">                    <span class="keyword">if</span> (!jobInfo.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">//因为是模糊查询，需要再判断一次</span></span><br><span class="line">                        Optional&lt;XxlJobInfo&gt; first = jobInfo.stream()</span><br><span class="line">                                .filter(xxlJobInfo -&gt; xxlJobInfo.getExecutorHandler().equals(xxlJob.value()))</span><br><span class="line">                                .findFirst();</span><br><span class="line">                        <span class="comment">//如果任务已经存在则不管了</span></span><br><span class="line">                        <span class="keyword">if</span> (first.isPresent())</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//创建任务并注册</span></span><br><span class="line">                    <span class="type">XxlRegister</span> <span class="variable">xxlRegister</span> <span class="operator">=</span> executeMethod.getAnnotation(XxlRegister.class);</span><br><span class="line">                    <span class="type">XxlJobInfo</span> <span class="variable">xxlJobInfo</span> <span class="operator">=</span> createXxlJobInfo(xxlJobGroup, xxlJob, xxlRegister);</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">jobInfoId</span> <span class="operator">=</span> jobInfoService.addJobInfo(xxlJobInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于XxlRegister封装成一个xxlJobInfo对象提交到xxl-job-admin中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xxlJobGroup</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xxlJob</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xxlRegister</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> XxlJobInfo <span class="title function_">createXxlJobInfo</span><span class="params">(XxlJobGroup xxlJobGroup, XxlJob xxlJob, XxlRegister xxlRegister)</span> &#123;</span><br><span class="line">        <span class="type">XxlJobInfo</span> <span class="variable">xxlJobInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobInfo</span>();</span><br><span class="line">        xxlJobInfo.setJobGroup(xxlJobGroup.getId());</span><br><span class="line">        xxlJobInfo.setJobDesc(xxlRegister.jobDesc());</span><br><span class="line">        xxlJobInfo.setAuthor(xxlRegister.author());</span><br><span class="line">        xxlJobInfo.setScheduleType(<span class="string">&quot;CRON&quot;</span>);</span><br><span class="line">        xxlJobInfo.setScheduleConf(xxlRegister.cron());</span><br><span class="line">        xxlJobInfo.setGlueType(<span class="string">&quot;BEAN&quot;</span>);</span><br><span class="line">        xxlJobInfo.setExecutorHandler(xxlJob.value());</span><br><span class="line">        xxlJobInfo.setExecutorRouteStrategy(xxlRegister.executorRouteStrategy());</span><br><span class="line">        xxlJobInfo.setMisfireStrategy(<span class="string">&quot;DO_NOTHING&quot;</span>);</span><br><span class="line">        xxlJobInfo.setExecutorBlockStrategy(<span class="string">&quot;SERIAL_EXECUTION&quot;</span>);</span><br><span class="line">        xxlJobInfo.setExecutorTimeout(<span class="number">0</span>);</span><br><span class="line">        xxlJobInfo.setExecutorFailRetryCount(<span class="number">0</span>);</span><br><span class="line">        xxlJobInfo.setGlueRemark(<span class="string">&quot;GLUE代码初始化&quot;</span>);</span><br><span class="line">        xxlJobInfo.setTriggerStatus(xxlRegister.triggerStatus());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xxlJobInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>自此我们的组件开发完成了，为了让上面的XxlJobAutoRegister，我们需要编写一个配置类XxlJobPlusConfig，他会扫描XxlJobAutoRegister的包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.xxl.job.plus.executor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobPlusConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写一个spring.factories，将XxlJobPlusConfig路径写入，确保其他引入该组件时会自动装配XxlJobAutoRegister将指定的xxl-job注册上去。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span></span><br><span class="line">  <span class="string">com.xxl.job.plus.executor.config.XxlJobPlusConfig</span></span><br></pre></td></tr></table></figure><h2 id="引入组件并进行测试"><a href="#引入组件并进行测试" class="headerlink" title="引入组件并进行测试"></a>引入组件并进行测试</h2><p>首先将上述组件打包，然后在需要使用这个组件的应用中引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.cn.hydra&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;xxljob-autoregister-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这里直接使用xxl源码自带的spring-boot项目。</p><p><img src="https://qiniuyun.sharkchili.com/img202304211256822.png" alt="在这里插入图片描述"></p><p>编写一个自定义的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(TestService.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XxlJob(value = &quot;testJob&quot;)</span></span><br><span class="line">    <span class="meta">@XxlRegister(cron = &quot;0 0 0 * * ? *&quot;,</span></span><br><span class="line"><span class="meta">            author = &quot;shark-chili&quot;,</span></span><br><span class="line"><span class="meta">            jobDesc = &quot;测试job&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJob</span><span class="params">()</span>&#123;</span><br><span class="line">       logger.info(<span class="string">&quot;testJob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@XxlJob(value = &quot;hello&quot;)</span></span><br><span class="line">    <span class="meta">@XxlRegister(cron = &quot;0 0 0 * * ? *&quot;,</span></span><br><span class="line"><span class="meta">            triggerStatus = 1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;hello this is shark-chili&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后新增如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增配置项，必须项</span></span><br><span class="line"><span class="comment"># admin用户名</span></span><br><span class="line"><span class="string">xxl.job.admin.username=admin</span></span><br><span class="line"><span class="comment"># admin 密码</span></span><br><span class="line"><span class="string">xxl.job.admin.password=123456</span></span><br><span class="line"><span class="comment"># 执行器名称</span></span><br><span class="line"><span class="string">xxl.job.executor.title=shark-chili</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增配置项，可选项</span></span><br><span class="line"><span class="comment"># 执行器地址类型：0=自动注册、1=手动录入，默认为0</span></span><br><span class="line"><span class="string">xxl.job.executor.addressType=0</span></span><br><span class="line"><span class="comment"># 在上面为1的情况下，手动录入执行器地址列表，多地址逗号分隔</span></span><br><span class="line"><span class="string">xxl.job.executor.addressList=http://127.0.0.1:9999</span></span><br></pre></td></tr></table></figure><p>最后将xxl-job-admin和xxl-job启动，打开xxl-job的管理页面，可以看到我们的任务都注册进来了。</p><p><img src="https://qiniuyun.sharkchili.com/img202304211256178.png" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xxl-job-的概念&quot;&gt;&lt;a href=&quot;#xxl-job-的概念&quot; class=&quot;headerlink&quot; title=&quot;xxl-job 的概念&quot;&gt;&lt;/a&gt;xxl-job 的概念&lt;/h1&gt;&lt;h2 id=&quot;诞生背景&quot;&gt;&lt;a href=&quot;#诞生背景&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="xxl-job" scheme="https://palette-k.github.io/tags/xxl-job/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security的使用</title>
    <link href="https://palette-k.github.io/2024/01/25/SpringSecurity%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://palette-k.github.io/2024/01/25/SpringSecurity%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2024-01-25T09:23:54.000Z</published>
    <updated>2024-02-18T05:57:12.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>基本上，在所有的开发的系统中，都必须做认证(authentication)和授权(authorization)，以保证系统的安全性。</p><ul><li>认证是确认声明者的本身身份，其作为授权的上游衔接而存在</li><li>鉴权是对声明者所声明的真实性进行确认的过程，其作为授权的下游衔接而存在</li></ul><p>Spring Security 是一个功能强大且高度可定制的身份验证和访问控制框架。它是用于保护基于 Spring 的应用程序。</p><h1 id="认证链路"><a href="#认证链路" class="headerlink" title="认证链路"></a>认证链路</h1><p>1 用户名和密码被过滤器获取到，封装成<code>Authentication</code>,通常情况下是<code>UsernamePasswordAuthenticationToken</code>这个实现类。</p><p>2 <code>AuthenticationManager</code> 身份管理器负责验证这个<code>Authentication</code></p><p>3 认证成功后，<code>AuthenticationManager</code>身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）<code>Authentication</code>实例。</p><p>4 <code>SecurityContextHolder</code>安全上下文容器将第3步填充了信息的<code>Authentication</code>，通过SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。</p><p><img src="https://i0.hdslb.com/bfs/article/88a3aba0385efc8a25fbb26638fabc16171301454.png" alt="image-20240208155803862"></p><p><img src="http://kirito.iocoder.cn/2011121410543010.jpg" alt="http://kirito.iocoder.cn/2011121410543010.jpg"></p><h2 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h2><p>AuthenticationManager（接口）是认证相关的核心接口，也是发起认证的出发点。AuthenticationManager一般不直接认证，AuthenticationManager接口的常用实现类<code>ProviderManager</code> 内部会维护一个<code>List&lt;AuthenticationProvider&gt;</code>列表，存放多种认证方式，实际上这是委托者模式的应用（Delegate）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderManager</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationManager</span>, MessageSourceAware,</span><br><span class="line">InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护一个AuthenticationProvider列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AuthenticationProvider&gt; providers = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line">          <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">       Class&lt;? <span class="keyword">extends</span> <span class="title class_">Authentication</span>&gt; toTest = authentication.getClass();</span><br><span class="line">       <span class="type">AuthenticationException</span> <span class="variable">lastException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Authentication</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 依次认证</span></span><br><span class="line">       <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">             result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                copyDetails(authentication, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">             lastException = e;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果有Authentication信息，则直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">&amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">               <span class="comment">//移除密码</span></span><br><span class="line">((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">&#125;</span><br><span class="line">             <span class="comment">//发布登录成功事件</span></span><br><span class="line">eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">       <span class="comment">//执行到此，说明没有认证成功，包装异常信息</span></span><br><span class="line">       <span class="keyword">if</span> (lastException == <span class="literal">null</span>) &#123;</span><br><span class="line">          lastException = <span class="keyword">new</span> <span class="title class_">ProviderNotFoundException</span>(messages.getMessage(</span><br><span class="line">                <span class="string">&quot;ProviderManager.providerNotFound&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; toTest.getName() &#125;,</span><br><span class="line">                <span class="string">&quot;No AuthenticationProvider found for &#123;0&#125;&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       prepareException(lastException, authentication);</span><br><span class="line">       <span class="keyword">throw</span> lastException;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ProviderManager</code> 中的List，会依照次序去认证，认证成功则立即返回，若认证失败则返回null，下一个AuthenticationProvider会继续尝试认证，如果所有认证器都无法认证成功，则<code>ProviderManager</code> 会抛出一个ProviderNotFoundException异常。</p><p>DaoAuthenticationProvider：它获取用户提交的用户名和密码，比对其正确性，如果正确，返回一个数据库中的用户信息（假设用户信息被保存在数据库中）。</p><h1 id="核心配置解读"><a href="#核心配置解读" class="headerlink" title="核心配置解读"></a>核心配置解读</h1><h2 id="WebSecurityConfigurerAdapter"><a href="#WebSecurityConfigurerAdapter" class="headerlink" title="WebSecurityConfigurerAdapter"></a>WebSecurityConfigurerAdapter</h2><p>拿 ruoyi 的 SecurityConfig 举例，它继承了 WebSecurityConfigurerAdapter。</p><p>适配器模式在spring中被广泛的使用，在配置中使用Adapter的好处便是，我们可以选择性的配置想要修改的那一部分配置，而不用覆盖其他不相关的配置。WebSecurityConfigurerAdapter中我们可以选择自己想要修改的内容，来进行重写，而其提供了三个configure重载方法。</p><ul><li>configure(HttpSecurity)</li><li>configure(WebSecurity)</li><li>configure(AuthenticationManagerBuilder)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring security配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ruoyi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义用户认证逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证失败处理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationEntryPointImpl unauthorizedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退出处理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogoutSuccessHandlerImpl logoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * token认证过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationTokenFilter authenticationTokenFilter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跨域过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CorsFilter corsFilter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许匿名访问的地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PermitAllUrlProperties permitAllUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解决 无法直接注入 AuthenticationManager</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * anyRequest          |   匹配所有请求路径</span></span><br><span class="line"><span class="comment">     * access              |   SpringEl表达式结果为true时可以访问</span></span><br><span class="line"><span class="comment">     * anonymous           |   匿名可以访问</span></span><br><span class="line"><span class="comment">     * denyAll             |   用户不能访问</span></span><br><span class="line"><span class="comment">     * fullyAuthenticated  |   用户完全认证可以访问（非remember-me下自动登录）</span></span><br><span class="line"><span class="comment">     * hasAnyAuthority     |   如果有参数，参数表示权限，则其中任何一个权限可以访问</span></span><br><span class="line"><span class="comment">     * hasAnyRole          |   如果有参数，参数表示角色，则其中任何一个角色可以访问</span></span><br><span class="line"><span class="comment">     * hasAuthority        |   如果有参数，参数表示权限，则其权限可以访问</span></span><br><span class="line"><span class="comment">     * hasIpAddress        |   如果有参数，参数表示IP地址，如果用户IP和参数匹配，则可以访问</span></span><br><span class="line"><span class="comment">     * hasRole             |   如果有参数，参数表示角色，则其角色可以访问</span></span><br><span class="line"><span class="comment">     * permitAll           |   用户可以任意访问</span></span><br><span class="line"><span class="comment">     * rememberMe          |   允许通过remember-me登录的用户访问</span></span><br><span class="line"><span class="comment">     * authenticated       |   用户登录后可访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity httpSecurity)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注解标记允许匿名访问的url</span></span><br><span class="line">        ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.<span class="type">ExpressionInterceptUrlRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> httpSecurity.authorizeRequests();</span><br><span class="line">        permitAllUrl.getUrls().forEach(url -&gt; registry.antMatchers(url).permitAll());</span><br><span class="line"></span><br><span class="line">        httpSecurity</span><br><span class="line">                <span class="comment">// CSRF禁用，因为不使用session</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">// 禁用HTTP响应标头</span></span><br><span class="line">                .headers().cacheControl().disable().and()</span><br><span class="line">                <span class="comment">// 认证失败处理类</span></span><br><span class="line">                .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and()</span><br><span class="line">                <span class="comment">// 基于token，所以不需要session</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                <span class="comment">// 过滤请求</span></span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 对于登录login 注册register 验证码captchaImage 允许匿名访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/captchaImage&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 静态资源，可匿名访问</span></span><br><span class="line">                .antMatchers(HttpMethod.GET, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;/*.html&quot;</span>, <span class="string">&quot;/**/*.html&quot;</span>, <span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>, <span class="string">&quot;/profile/**&quot;</span>).permitAll()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/swagger-ui.html&quot;</span>, <span class="string">&quot;/swagger-resources/**&quot;</span>, <span class="string">&quot;/webjars/**&quot;</span>, <span class="string">&quot;/*/api-docs&quot;</span>, <span class="string">&quot;/druid/**&quot;</span>).permitAll()</span><br><span class="line">.antMatchers(<span class="string">&quot;/test/*&quot;</span>,<span class="string">&quot;/policy/*&quot;</span>,<span class="string">&quot;/type/*&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .headers().frameOptions().disable();</span><br><span class="line">        <span class="comment">// 添加Logout filter</span></span><br><span class="line">        httpSecurity.logout().logoutUrl(<span class="string">&quot;/logout&quot;</span>).logoutSuccessHandler(logoutSuccessHandler);</span><br><span class="line">        <span class="comment">// 添加JWT filter</span></span><br><span class="line">        httpSecurity.addFilterBefore(authenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        <span class="comment">// 添加CORS filter</span></span><br><span class="line">        httpSecurity.addFilterBefore(corsFilter, JwtAuthenticationTokenFilter.class);</span><br><span class="line">        httpSecurity.addFilterBefore(corsFilter, LogoutFilter.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 强散列哈希加密实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">bCryptPasswordEncoder</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份认证接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HttpSecurity常用配置"><a href="#HttpSecurity常用配置" class="headerlink" title="HttpSecurity常用配置"></a>HttpSecurity常用配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomWebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/resources/**&quot;</span>, <span class="string">&quot;/signup&quot;</span>, <span class="string">&quot;/about&quot;</span>).permitAll()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/db/**&quot;</span>).access(<span class="string">&quot;hasRole(&#x27;ADMIN&#x27;) and hasRole(&#x27;DBA&#x27;)&quot;</span>)</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">                .usernameParameter(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .failureForwardUrl(<span class="string">&quot;/login?error&quot;</span>)</span><br><span class="line">                .loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">            .logout()</span><br><span class="line">                .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">                .logoutSuccessUrl(<span class="string">&quot;/index&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">            .httpBasic()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是一个使用Java Configuration配置HttpSecurity的典型配置，其中http作为根开始配置，每一个and()对应了一个模块的配置（等同于xml配置中的结束标签），并且and()返回了HttpSecurity本身，于是可以连续进行配置。他们配置的含义也非常容易通过变量本身来推测，</p><ul><li>authorizeRequests()配置路径拦截，表明路径访问所对应的权限，角色，认证信息。</li><li>formLogin()对应表单认证相关的配置</li><li>logout()对应了注销相关的配置</li><li>httpBasic()可以配置basic登录</li><li>etc</li></ul><h3 id="WebSecurity常用配置"><a href="#WebSecurity常用配置" class="headerlink" title="WebSecurity常用配置"></a>WebSecurity常用配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        web</span><br><span class="line">            .ignoring()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/resources/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AuthenticationManagerBuilder"><a href="#AuthenticationManagerBuilder" class="headerlink" title="AuthenticationManagerBuilder"></a>AuthenticationManagerBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth</span><br><span class="line">            .inMemoryAuthentication()</span><br><span class="line">            .withUser(<span class="string">&quot;admin&quot;</span>).password(<span class="string">&quot;admin&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在WebSecurityConfigurerAdapter中进行认证相关的配置，可以使用configure(AuthenticationManagerBuilder auth)暴露一个AuthenticationManager的建造器：AuthenticationManagerBuilder 。如上所示，我们便完成了内存中用户的配置。</p><p>除了以上的示例代码，还有另外一种配置方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureGlobal</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth</span><br><span class="line">            .inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="string">&quot;admin&quot;</span>).password(<span class="string">&quot;admin&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的应用只有唯一一个WebSecurityConfigurerAdapter，那么他们之间的差距可以被忽略，从方法名可以看出两者的区别：</p><ul><li>使用@Autowired注入的AuthenticationManagerBuilder是全局的身份认证器，作用域可以跨越多个WebSecurityConfigurerAdapter，以及影响到基于Method的安全控制；</li><li>而 <code>protected configure()</code>的方式则类似于一个匿名内部类，它的作用域局限于一个WebSecurityConfigurerAdapter内部。</li></ul><h1 id="授权链路"><a href="#授权链路" class="headerlink" title="授权链路"></a>授权链路</h1><p><img src="https://i0.hdslb.com/bfs/article/4a5465473ec1db95c8fd8cc85ecf18a2171301454.png" alt="image-20240208154120807"></p><h2 id="UsernamePasswordAuthenticationFilter"><a href="#UsernamePasswordAuthenticationFilter" class="headerlink" title="UsernamePasswordAuthenticationFilter"></a>UsernamePasswordAuthenticationFilter</h2><p>整个调用流程是，先调用其父类 AbstractAuthenticationProcessingFilter.doFilter() 方法，然后再执行 UsernamePasswordAuthenticationFilter.attemptAuthentication() 方法进行验证；</p><p>AbstractAuthenticationProcessingFilter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line"><span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line">#<span class="number">1.</span>判断当前的filter是否可以处理当前请求，不可以的话则交给下一个filter处理</span><br><span class="line"><span class="keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Request is to process authentication&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Authentication authResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">#<span class="number">2.</span>抽象方法由子类UsernamePasswordAuthenticationFilter实现</span><br><span class="line">authResult = attemptAuthentication(request, response);</span><br><span class="line"><span class="keyword">if</span> (authResult == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// return immediately as subclass has indicated that it hasn&#x27;t completed</span></span><br><span class="line"><span class="comment">// authentication</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">2.</span>认证成功后，处理一些与session相关的方法 </span><br><span class="line">sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">logger.error(</span><br><span class="line"><span class="string">&quot;An internal error occurred while trying to authenticate the user.&quot;</span>,</span><br><span class="line">failed);</span><br><span class="line">#<span class="number">3.</span>认证失败后的的一些操作</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AuthenticationException failed) &#123;</span><br><span class="line"><span class="comment">// Authentication failed</span></span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Authentication success</span></span><br><span class="line"><span class="keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">3.</span> 认证成功后的相关回调方法 主要将当前的认证放到SecurityContextHolder中</span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个程序的执行流程如下:</p><ol><li>判断filter是否可以处理当前的请求，如果不可以则放行交给下一个filter</li><li>调用抽象方法<code>attemptAuthentication</code>进行验证，该方法由子类<code>UsernamePasswordAuthenticationFilter</code>实现</li><li>认证成功以后，回调一些与 session 相关的方法；</li><li>认证成功以后，认证成功后的相关回调方法；认证成功以后，认证成功后的相关回调方法；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">successfulAuthentication</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Authentication success. Updating SecurityContextHolder to contain: &quot;</span></span><br><span class="line">+ authResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line"></span><br><span class="line">rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fire event</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.eventPublisher != <span class="literal">null</span>) &#123;</span><br><span class="line">eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">InteractiveAuthenticationSuccessEvent</span>(</span><br><span class="line">authResult, <span class="built_in">this</span>.getClass()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将当前认证成功的 Authentication 放置到 SecurityContextHolder 中；</li><li>调用其它可扩展的 handlers 继续处理该认证成功以后的回调事件；（实现<code>AuthenticationSuccessHandler</code>接口即可）</li></ol><p>UsernamePasswordAuthenticationFilter: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">#<span class="number">1.</span>判断请求的方法必须为POST请求</span><br><span class="line"><span class="keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationServiceException</span>(</span><br><span class="line"><span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">2.</span>从request中获取username和password</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> obtainUsername(request);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> obtainPassword(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (username == <span class="literal">null</span>) &#123;</span><br><span class="line">username = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (password == <span class="literal">null</span>) &#123;</span><br><span class="line">password = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">username = username.trim();</span><br><span class="line">#<span class="number">3.</span>构建UsernamePasswordAuthenticationToken（两个参数的构造方法setAuthenticated(<span class="literal">false</span>)）</span><br><span class="line"><span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(</span><br><span class="line">username, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow subclasses to set the &quot;details&quot; property</span></span><br><span class="line">setDetails(request, authRequest);</span><br><span class="line">#<span class="number">4.</span> 调用 AuthenticationManager 进行验证（子类ProviderManager遍历所有的AuthenticationProvider认证）</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>认证请求的方法必须为<code>POST</code></li><li>从request中获取 username 和 password</li><li>封装<code>Authenticaiton</code>的实现类<code>UsernamePasswordAuthenticationToken</code>，（<code>UsernamePasswordAuthenticationToken</code>调用两个参数的构造方法setAuthenticated(false)）</li><li>调用 <code>AuthenticationManager</code> 的 <code>authenticate</code> 方法进行验证；可参考<a href="https://longfeizheng.github.io/2018/01/02/Spring-Security%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80-Spring-Security%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/#providermanager-1">ProviderManager</a>部分</li></ol><h2 id="AnonymousAuthenticationFilter"><a href="#AnonymousAuthenticationFilter" class="headerlink" title="AnonymousAuthenticationFilter"></a>AnonymousAuthenticationFilter</h2><p>从上图中过滤器的执行顺序图中可以看出<code>AnonymousAuthenticationFilter</code>过滤器是在<code>UsernamePasswordAuthenticationFilter</code>等过滤器之后，如果它前面的过滤器都没有认证成功，<code>Spring Security</code>则为当前的<code>SecurityContextHolder</code>中添加一个<code>Authenticaiton</code> 的匿名实现类<code>AnonymousAuthenticationToken</code>;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">#<span class="number">1.</span>如果前面的过滤器都没认证通过，则SecurityContextHolder中Authentication为空</span><br><span class="line"><span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">#<span class="number">2.</span>为当前的SecurityContextHolder中添加一个匿名的AnonymousAuthenticationToken</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(</span><br><span class="line">createAuthentication((HttpServletRequest) req));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Populated SecurityContextHolder with anonymous token: &#x27;&quot;</span></span><br><span class="line">+ SecurityContextHolder.getContext().getAuthentication() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;SecurityContextHolder not populated with anonymous token, as it already contained: &#x27;&quot;</span></span><br><span class="line">+ SecurityContextHolder.getContext().getAuthentication() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chain.doFilter(req, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span>创建匿名的AnonymousAuthenticationToken</span><br><span class="line"><span class="keyword">protected</span> Authentication <span class="title function_">createAuthentication</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line"><span class="type">AnonymousAuthenticationToken</span> <span class="variable">auth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnonymousAuthenticationToken</span>(key,</span><br><span class="line">principal, authorities);</span><br><span class="line">auth.setDetails(authenticationDetailsSource.buildDetails(request));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> auth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a filter with a principal named &quot;anonymousUser&quot; and the single authority</span></span><br><span class="line"><span class="comment"> * &quot;ROLE_ANONYMOUS&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key to identify tokens created by this filter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> #.创建一个用户名为anonymousUser 授权为ROLE_ANONYMOUS</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnonymousAuthenticationFilter</span><span class="params">(String key)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(key, <span class="string">&quot;anonymousUser&quot;</span>, AuthorityUtils.createAuthorityList(<span class="string">&quot;ROLE_ANONYMOUS&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>判断<code>SecurityContextHolder中Authentication</code>为否为空；</li><li>如果空则为当前的<code>SecurityContextHolder</code>中添加一个匿名的<code>AnonymousAuthenticationToken</code>（用户名为 anonymousUser 的<code>AnonymousAuthenticationToken</code>）</li></ol><h2 id="ExceptionTranslationFilter"><a href="#ExceptionTranslationFilter" class="headerlink" title="ExceptionTranslationFilter"></a>ExceptionTranslationFilter</h2><p>异常处理过滤器,该过滤器用来处理在系统认证授权过程中抛出的异常（也就是下一个过滤器<code>FilterSecurityInterceptor</code>）,主要是 处理 <code>AuthenticationException</code> 和 <code>AccessDeniedException</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line"><span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&quot;Chain processed normally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="comment">// Try to extract a SpringSecurityException from the stacktrace</span></span><br><span class="line">#.判断是不是AuthenticationException</span><br><span class="line">Throwable[] causeChain = throwableAnalyzer.determineCauseChain(ex);</span><br><span class="line"><span class="type">RuntimeException</span> <span class="variable">ase</span> <span class="operator">=</span> (AuthenticationException) throwableAnalyzer</span><br><span class="line">.getFirstThrowableOfType(AuthenticationException.class, causeChain);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ase == <span class="literal">null</span>) &#123;</span><br><span class="line">#. 判断是不是<span class="type">AccessDeniedException</span></span><br><span class="line"><span class="variable">ase</span> <span class="operator">=</span> (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType(</span><br><span class="line">AccessDeniedException.class, causeChain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ase != <span class="literal">null</span>) &#123;</span><br><span class="line">handleSpringSecurityException(request, response, chain, ase);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Rethrow ServletExceptions and RuntimeExceptions as-is</span></span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> ServletException) &#123;</span><br><span class="line"><span class="keyword">throw</span> (ServletException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line"><span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrap other Exceptions. This shouldn&#x27;t actually happen</span></span><br><span class="line"><span class="comment">// as we&#x27;ve already covered all the possibilities for doFilter</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FilterSecurityInterceptor"><a href="#FilterSecurityInterceptor" class="headerlink" title="FilterSecurityInterceptor"></a>FilterSecurityInterceptor</h2><p>此过滤器为认证授权过滤器链中最后一个过滤器，该过滤器之后就是请求真正的<code>/persons</code> 服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="type">FilterInvocation</span> <span class="variable">fi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterInvocation</span>(request, response, chain);</span><br><span class="line">invoke(fi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(FilterInvocation fi)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="keyword">if</span> ((fi.getRequest() != <span class="literal">null</span>)</span><br><span class="line">&amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) != <span class="literal">null</span>)</span><br><span class="line">&amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line"><span class="comment">// filter already applied to this request and user wants us to observe</span></span><br><span class="line"><span class="comment">// once-per-request handling, so don&#x27;t re-do security checking</span></span><br><span class="line">fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// first time this request being called, so perform security checking</span></span><br><span class="line"><span class="keyword">if</span> (fi.getRequest() != <span class="literal">null</span>) &#123;</span><br><span class="line">fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">1.</span> before invocation重要</span><br><span class="line"><span class="type">InterceptorStatusToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">super</span>.beforeInvocation(fi);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">#<span class="number">2.</span> 可以理解开始请求真正的 /persons 服务</span><br><span class="line">fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.finallyInvocation(token);</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">3.</span> after Invocation</span><br><span class="line"><span class="built_in">super</span>.afterInvocation(token, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>before invocation重要</li><li>请求真正的 &#x2F;persons 服务</li><li>after Invocation</li></ol><p>三个部分中，最重要的是 #1，该过程中会调用 <code>AccessDecisionManager</code> 来验证当前已认证成功的用户是否有权限访问该资源；</p><h3 id="before-invocation-AccessDecisionManager"><a href="#before-invocation-AccessDecisionManager" class="headerlink" title="before invocation: AccessDecisionManager"></a>before invocation: AccessDecisionManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> InterceptorStatusToken <span class="title function_">beforeInvocation</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Collection&lt;ConfigAttribute&gt; attributes = <span class="built_in">this</span>.obtainSecurityMetadataSource()</span><br><span class="line">.getAttributes(object);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="type">Authentication</span> <span class="variable">authenticated</span> <span class="operator">=</span> authenticateIfRequired();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attempt authorization</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">#<span class="number">1.</span>重点</span><br><span class="line"><span class="built_in">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">publishEvent(<span class="keyword">new</span> <span class="title class_">AuthorizationFailureEvent</span>(object, attributes, authenticated,accessDeniedException));</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>authenticated</code>就是当前认证的<code>Authentication</code>，<code>object</code>为当前请求的 <code>url:/persons</code>, getAttributes方法就是使用当前的访问资源路径去<code>匹配</code>我们自己定义的匹配规则。</p><blockquote><p>AccessDecisionManager 是如何授权的？</p></blockquote><p><code>Spring Security</code>默认使用<code>AffirmativeBased</code>实现<code>AccessDecisionManager</code> 的 <code>decide</code> 方法来实现授权</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decide</span><span class="params">(Authentication authentication, Object object,</span></span><br><span class="line"><span class="params">Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">deny</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">#<span class="number">1.</span>调用AccessDecisionVoter 进行vote(投票)</span><br><span class="line"><span class="keyword">for</span> (AccessDecisionVoter voter : getDecisionVoters()) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> voter.vote(authentication, object, configAttributes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Voter: &quot;</span> + voter + <span class="string">&quot;, returned: &quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (result) &#123;</span><br><span class="line">#<span class="number">1.1</span>只要有voter投票为ACCESS_GRANTED，则通过 直接返回</span><br><span class="line"><span class="keyword">case</span> AccessDecisionVoter.ACCESS_GRANTED:<span class="comment">//1</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">@#<span class="number">1.2</span>只要有voter投票为ACCESS_DENIED，则记录一下</span><br><span class="line"><span class="keyword">case</span> AccessDecisionVoter.ACCESS_DENIED:<span class="comment">//-1</span></span><br><span class="line">deny++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (deny &gt; <span class="number">0</span>) &#123;</span><br><span class="line">#<span class="number">2.</span>如果有一个及以上AccessDecisionVoter(姑且称之为投票者吧)都投ACCESS_DENIED，则直接就不通过了</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(messages.getMessage(</span><br><span class="line"><span class="string">&quot;AbstractAccessDecisionManager.accessDenied&quot;</span>, <span class="string">&quot;Access is denied&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// To get this far, every AccessDecisionVoter abstained</span></span><br><span class="line">checkAllowIfAllAbstainDecisions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用AccessDecisionVoter 进行vote(投票)</li><li>只要有投通过（ACCESS_GRANTED）票，则直接判为通过。</li><li>如果没有投通过则 <code>deny++</code> ,最后判断<code>if（deny&gt;0</code> 抛出<code>AccessDeniedException</code>（未授权）</li></ol><h1 id="SpringSecurityFilterChain过滤器加载流程"><a href="#SpringSecurityFilterChain过滤器加载流程" class="headerlink" title="SpringSecurityFilterChain过滤器加载流程"></a>SpringSecurityFilterChain过滤器加载流程</h1><h2 id="DelegatingFilterProxy"><a href="#DelegatingFilterProxy" class="headerlink" title="DelegatingFilterProxy"></a>DelegatingFilterProxy</h2><p>它的包结构：org.springframework.web.filter，它本身是 Spring Web 包中的类，并不是 SpringSecurity 中的类。因为 Spring 考虑到了多种使用场景，自然希望将侵入性降到最低，所以使用了这个委托代理类来代理真正的 SpringSecurityFilterChain。</p><p>DelegatingFilterProxy 实现了 javax.servlet.Filter 接口，使得它可以作为一个 java web 的标准过滤器，其职责也很简单，只负责调用真正的 SpringSecurityFilterChain。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegatingFilterProxy</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> WebApplicationContext webApplicationContext;</span><br><span class="line">   <span class="comment">// springSecurityFilterChain</span></span><br><span class="line">   <span class="keyword">private</span> String targetBeanName;</span><br><span class="line">   <span class="comment">// &lt;1&gt; 关键点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> Filter delegate;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">delegateMonitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">DelegatingFilterProxy</span><span class="params">(String targetBeanName, WebApplicationContext wac)</span> &#123;</span><br><span class="line">      Assert.hasText(targetBeanName, <span class="string">&quot;Target Filter bean name must not be null or empty&quot;</span>);</span><br><span class="line">      <span class="built_in">this</span>.setTargetBeanName(targetBeanName);</span><br><span class="line">      <span class="built_in">this</span>.webApplicationContext = wac;</span><br><span class="line">      <span class="keyword">if</span> (wac != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="built_in">this</span>.setEnvironment(wac.getEnvironment());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.delegateMonitor) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">this</span>.delegate == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.targetBeanName == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="built_in">this</span>.targetBeanName = getFilterName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Fetch Spring root application context and initialize the delegate early,</span></span><br><span class="line">            <span class="comment">// if possible. If the root application context will be started after this</span></span><br><span class="line">            <span class="comment">// filter proxy, we&#x27;ll have to resort to lazy initialization.</span></span><br><span class="line">            <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> findWebApplicationContext();</span><br><span class="line">            <span class="keyword">if</span> (wac != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="built_in">this</span>.delegate = initDelegate(wac);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><br><span class="line">         <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 过滤器代理支持懒加载</span></span><br><span class="line">      <span class="type">Filter</span> <span class="variable">delegateToUse</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">      <span class="keyword">if</span> (delegateToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="built_in">this</span>.delegateMonitor) &#123;</span><br><span class="line">            delegateToUse = <span class="built_in">this</span>.delegate;</span><br><span class="line">            <span class="keyword">if</span> (delegateToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> findWebApplicationContext();</span><br><span class="line">               delegateToUse = initDelegate(wac);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.delegate = delegateToUse;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 让代理过滤器执行实际的过滤行为</span></span><br><span class="line">      invokeDelegate(delegateToUse, request, response, filterChain);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化过滤器代理</span></span><br><span class="line">   <span class="comment">// &lt;2&gt;</span></span><br><span class="line">   <span class="keyword">protected</span> Filter <span class="title function_">initDelegate</span><span class="params">(WebApplicationContext wac)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">      <span class="type">Filter</span> <span class="variable">delegate</span> <span class="operator">=</span> wac.getBean(getTargetBeanName(), Filter.class);</span><br><span class="line">      <span class="keyword">if</span> (isTargetFilterLifecycle()) &#123;</span><br><span class="line">         delegate.init(getFilterConfig());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> delegate;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用代理过滤器</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeDelegate</span><span class="params">(</span></span><br><span class="line"><span class="params">         Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><br><span class="line">         <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">      delegate.doFilter(request, response, filterChain);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;1&gt; 可以发现整个 DelegatingFilterProxy 的逻辑就是为了调用 <code>private volatile Filter delegate;</code></p><p>&lt;2&gt; 可以看到，DelegatingFilterProxy 尝试去容器中获取名为 targetBeanName 的类，而 targetBeanName 的默认值便是 Filter 的名称，也就是 springSecurityFilterChain</p><p>DelegatingFilterProxy 只是名称和 targetBeanName 叫 springSecurityFilterChain，真正容器中的 Bean(name&#x3D;”springSecurityFilterChain”) 其实另有其人——通过 debug，我们发现了真正的 springSecurityFilterChain — FilterChainProxy。</p><blockquote><p>SpringSecurityFilterChain 是什么时候被放进去的？</p></blockquote><p>这就得说到老朋友 WebSecurity 了，还记得一般我们都会选择使用 @EnableWebSecurity 和 WebSecurityConfigurerAdapter 来进行 web 安全配置吗，来到 WebSecurity 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WebSecurity</span> <span class="keyword">extends</span></span><br><span class="line">      <span class="title class_">AbstractConfiguredSecurityBuilder</span>&lt;Filter, WebSecurity&gt; <span class="keyword">implements</span></span><br><span class="line">      <span class="title class_">SecurityBuilder</span>&lt;Filter&gt;, ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Filter <span class="title function_">performBuild</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">chainSize</span> <span class="operator">=</span> ignoredRequests.size() + securityFilterChainBuilders.size();</span><br><span class="line">List&lt;SecurityFilterChain&gt; securityFilterChains = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SecurityFilterChain&gt;(</span><br><span class="line">chainSize);</span><br><span class="line"><span class="keyword">for</span> (RequestMatcher ignoredRequest : ignoredRequests) &#123;</span><br><span class="line">securityFilterChains.add(<span class="keyword">new</span> <span class="title class_">DefaultSecurityFilterChain</span>(ignoredRequest));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (SecurityBuilder&lt;? <span class="keyword">extends</span> <span class="title class_">SecurityFilterChain</span>&gt; securityFilterChainBuilder : securityFilterChainBuilders) &#123;</span><br><span class="line">securityFilterChains.add(securityFilterChainBuilder.build());</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// &lt;1&gt; FilterChainProxy 由 WebSecurity 构建</span></span><br><span class="line"><span class="type">FilterChainProxy</span> <span class="variable">filterChainProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterChainProxy</span>(securityFilterChains);</span><br><span class="line"><span class="keyword">if</span> (httpFirewall != <span class="literal">null</span>) &#123;</span><br><span class="line">filterChainProxy.setFirewall(httpFirewall);</span><br><span class="line">&#125;</span><br><span class="line">filterChainProxy.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line"><span class="type">Filter</span> <span class="variable">result</span> <span class="operator">=</span> filterChainProxy;</span><br><span class="line">postBuildAction.run();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;1&gt; 最终定位到 WebSecurity 的 performBuild 方法，我们之前配置了一堆参数的 WebSecurity 最终帮助我们构建了 FilterChainProxy。</p><p>并且，最终在 <code>org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration</code>中被注册为默认名称为 SpringSecurityFilterChain。</p><h2 id="FilterChainProxy"><a href="#FilterChainProxy" class="headerlink" title="FilterChainProxy"></a>FilterChainProxy</h2><p>它才是真正的 springSecurityFilterChain，我们来看看它的源码（有删减，不影响理解）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterChainProxy</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line">   <span class="comment">// &lt;1&gt; 包含了多个SecurityFilterChain</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;SecurityFilterChain&gt; filterChains;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">FilterChainProxy</span><span class="params">(SecurityFilterChain chain)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>(Arrays.asList(chain));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">FilterChainProxy</span><span class="params">(List&lt;SecurityFilterChain&gt; filterChains)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.filterChains = filterChains;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">      filterChainValidator.validate(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">         FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">         doFilterInternal(request, response, chain);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">         FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">FirewalledRequest</span> <span class="variable">fwRequest</span> <span class="operator">=</span> firewall</span><br><span class="line">            .getFirewalledRequest((HttpServletRequest) request);</span><br><span class="line">      <span class="type">HttpServletResponse</span> <span class="variable">fwResponse</span> <span class="operator">=</span> firewall</span><br><span class="line">            .getFirewalledResponse((HttpServletResponse) response);</span><br><span class="line">  <span class="comment">// &lt;1&gt;</span></span><br><span class="line">      List&lt;Filter&gt; filters = getFilters(fwRequest);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (filters == <span class="literal">null</span> || filters.size() == <span class="number">0</span>) &#123;</span><br><span class="line">         fwRequest.reset();</span><br><span class="line">         chain.doFilter(fwRequest, fwResponse);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">VirtualFilterChain</span> <span class="variable">vfc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualFilterChain</span>(fwRequest, chain, filters);</span><br><span class="line">      vfc.doFilter(fwRequest, fwResponse);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &lt;1&gt; 可能会有多个过滤器链，返回第一个和请求URL匹配的过滤器链</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;Filter&gt; <span class="title function_">getFilters</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (SecurityFilterChain chain : filterChains) &#123;</span><br><span class="line">         <span class="keyword">if</span> (chain.matches(request)) &#123;</span><br><span class="line">            <span class="keyword">return</span> chain.getFilters();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看 FilterChainProxy 的名字就可以发现，它依旧不是真正实施过滤的类，它内部维护了一个 SecurityFilterChain，这个过滤器链才是请求真正对应的过滤器链，并且同一个 Spring 环境下，可能同时存在多个安全过滤器链，如 private List filterChains 所示，需要经过 chain.matches(request) 判断到底哪个过滤器链匹配成功，每个 request 最多只会经过一个 SecurityFilterChain。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;基本上，在所有的开发的系统中，都必须做认证(authentication)和授权(authorization)，以保证系统的</summary>
      
    
    
    
    
    <category term="Spring Security" scheme="https://palette-k.github.io/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>加签和验签</title>
    <link href="https://palette-k.github.io/2024/01/23/%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/"/>
    <id>https://palette-k.github.io/2024/01/23/%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/</id>
    <published>2024-01-23T10:25:02.000Z</published>
    <updated>2024-01-24T09:46:38.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学概念"><a href="#密码学概念" class="headerlink" title="密码学概念"></a>密码学概念</h1><h2 id="明文、密文、密钥、加密、解密"><a href="#明文、密文、密钥、加密、解密" class="headerlink" title="明文、密文、密钥、加密、解密"></a>明文、密文、密钥、加密、解密</h2><ul><li>明文：指没有经过加密的信息&#x2F;数据。</li><li>密文：明文被加密算法加密之后，会变成密文，以确保数据安全。</li><li>密钥：是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。</li><li>加密：将明文变成密文的过程。</li><li>解密：将密文还原为明文的过程。</li></ul><h2 id="对称加密、非对称加密"><a href="#对称加密、非对称加密" class="headerlink" title="对称加密、非对称加密"></a>对称加密、非对称加密</h2><ul><li>对称加密：加密和解密使用相同密钥的加密算法。</li><li>非对称加密：非对称加密算法需要两个密钥（公开密钥和私有密钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。</li></ul><h2 id="什么是公钥私钥？"><a href="#什么是公钥私钥？" class="headerlink" title="什么是公钥私钥？"></a>什么是公钥私钥？</h2><ul><li>公钥与私钥是成对存在的密钥，如果用公钥对数据进行加密，只有用对应的私钥才能解密。</li><li>其实，公钥就是公开的秘钥，私钥就是要你私自保存好的秘钥。</li><li>非对称加密算法需要有一对公私钥~</li></ul><h1 id="加签验签概念"><a href="#加签验签概念" class="headerlink" title="加签验签概念"></a>加签验签概念</h1><p><strong>「加签」</strong>：用Hash函数把原始报文生成报文摘要，然后用私钥对这个摘要进行加密，就得到这个报文对应的数字签名。通常来说呢，请求方会把<strong>「数字签名和报文原文」</strong>一并发送给接收方。</p><p><img src="https://i0.hdslb.com/bfs/article/3afa1614473420ae859db75b5844ebfb171301454.png" alt="image-20240123194037932"></p><p><strong>「验签」</strong>：接收方拿到原始报文和数字签名后，用<strong>「同一个Hash函数」</strong>从报文中生成摘要A。另外，用对方提供的公钥对数字签名进行解密，得到摘要B，对比A和B是否相同，就可以得知报文有没有被篡改过。</p><p><img src="https://i0.hdslb.com/bfs/article/d5e65c2f233576edd445aafe8ad2c148171301454.png" alt="image-20240123194253661"></p><h2 id="为什么需要加签和验签"><a href="#为什么需要加签和验签" class="headerlink" title="为什么需要加签和验签"></a>为什么需要加签和验签</h2><blockquote><p>为什么需要加签和验签呢？我们不是用<strong>「公钥加密，私钥解密」</strong>就好了嘛？</p></blockquote><p><img src="https://i0.hdslb.com/bfs/article/c01f928b38175b2862215b74d1717d1d171301454.png" alt="image-20240123194922845"></p><p>假设现在有A公司，要接入C公司的转账系统。</p><p>在一开始，C公司把自己的公钥寄给A公司，自己收藏好私钥。</p><p>A公司这边的商户，发起转账时，A公司先用C公司的公钥，对请求报文加密，加密报文到达C公司的转账系统时，C公司就用自己的私钥把报文解开。</p><p>假设在加密的报文在传输过程中，被入侵者获取了，他也郁闷，因为他没有私钥，本来想修改报文，给自己账号转一个亿的，哈哈。这个实现方式看起来是天衣无缝，稳得一匹的。</p><p>但是呢，如果一开始，C公司把公钥发给公司A的时候，就被入侵者获取到呢？</p><p>入侵者截取了C的公钥，他把自己的公钥发给了A公司，A误以为这就是C公司的公钥。A在发起转账时，用入侵者的公钥，对请求报文加密，加密报文到在传输过程，入侵者又截取了，这时候，他用自己的私钥解密，然后修改了报文（给自己转一个亿），再用C的公钥加密，发给C公司，C公司收到报文后，继续用自己的私钥解密。最后是不是A公司的转账账户损失了一个亿呢~</p><p><img src="https://i0.hdslb.com/bfs/article/c4e21e133c29eaaec66f0fb0153887c2171301454.png" alt="image-20240123195714790"></p><p>C公司是怎么区分报文是不是来自A呢，还是被入侵者修改过呢？为了表明身份和报文真实性，这就需要<strong>「加签验签」</strong>啦！</p><p>A公司把自己的公钥也发送给C公司，私钥自己保留着。在发起转账时，先用自己的私钥对请求报文加签，于是得到自己的数字签名。再把数字签名和请求报文一起发送给C公司。C公司收到报文后，拿A的公钥进行验签，如果原始报文和数字签名的摘要内容不一致，那就是报文被篡改啦~</p><p><img src="https://i0.hdslb.com/bfs/article/78eb7169a6300b247e60765ce5483e1a171301454.png" alt="image-20240123200041173"></p><p>假设A在发自己的公钥给C公司的时候，也被入侵者截取了呢？</p><p>假设入侵者截取到A的公钥后，随后也截取了到A发往C的报文。他截取到报文后，第一件想做的事肯定是修改报文内容。但是如果单单修改原始报文是不可以的，因为发过去C公司肯定验签不过啦。但是呢，数字签名似乎解不开，因为消息摘要算法（hash算法）无法逆向解开的，只起验证的作用呢….</p><p>所以呢，公钥与私钥是用来加密与解密的，<strong>「加签与验签是用来证明身份」</strong>，以免被篡改的。</p><h2 id="消息摘要算法"><a href="#消息摘要算法" class="headerlink" title="消息摘要算法"></a>消息摘要算法</h2><ul><li>相同的明文数据经过相同的消息摘要算法会得到相同的密文结果值。</li><li>数据经过消息摘要算法处理，得到的摘要结果值，是无法还原为处理前的数据的。</li><li>数据摘要算法也被称为哈希（Hash）算法或散列算法。</li><li>消息摘要算法一般用于签名验签。</li></ul><p>消息摘要算法主要分三类：MD（Message Digest，消息摘要算法）、SHA（Secure Hash Algorithm，安全散列算法）和MAC（Message Authentication Code，消息认证码算法）。</p><h3 id="MD家族算法"><a href="#MD家族算法" class="headerlink" title="MD家族算法"></a>MD家族算法</h3><p>MD（Message Digest，消息摘要算法）家族，包括MD2，MD4，MD5。</p><ul><li>MD2，MD4，MD5 计算的结果都是是一个128位（即16字节）的散列值，用于确保信息传输完整一致。</li><li>MD2的算法较慢但相对安全，MD4速度很快，但安全性下降，MD5则比MD4更安全、速度更快。</li><li>MD5被广泛应用于数据完整性校验、数据（消息）摘要、数据加密等。</li><li>MD5，可以被破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞攻击，因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。</li></ul><p><strong>MD5破解方式：</strong>把常用的密码先MD5处理，并将数据存储起来，然后跟需要查询的MD5结果匹配，这时就有可能通过匹配的MD5得到明文，所以有些简单的MD5码是反查到加密前原文的。</p><p>为了让MD5码更加安全，涌现了很多其他方法，如加盐。 盐要足够长足够乱，得到的MD5码就很难查到。</p><blockquote><p>MD5 算加密算法吗？</p></blockquote><p>MD5 算法和加密算法都可以将信息转换为另外一种内容，但是，<strong>MD5 算法对比 加密算法缺少了解密过程。</strong></p><p>使用 <strong>加密算法</strong> 加密后的消息是完整的，并且基于解密算法后，可以恢复原始数据。而 <strong>MD5 算法</strong> 得到的消息是不完整的，并且通过摘要的数据也无法得到原始数据。</p><p>所以严格意义上来讲，<strong>MD5 称为摘要&#x2F;散列算法更合适，而不是加密算法</strong>！</p><h3 id="SHA家族算法"><a href="#SHA家族算法" class="headerlink" title="SHA家族算法"></a>SHA家族算法</h3><p>SHA（Secure Hash Algorithm，安全散列算法，它是在MD算法基础上实现的，与MD算法区别在于<strong>「摘要长度」</strong>，SHA 算法的摘要<strong>「长度更长，安全性更高」</strong>。</p><h3 id="MAC算法家族"><a href="#MAC算法家族" class="headerlink" title="MAC算法家族"></a>MAC算法家族</h3><p>MAC算法 MAC（Message Authentication Code，消息认证码算法），是带密钥的Hash函数。输入密钥和消息，输出一个消息摘要。它集合了MD和SHA两大系列消息摘要算法。</p><h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>加密和解密使用<strong>「相同密钥」</strong>的加密算法就是对称加密算法。常见的对称加密算法有AES、3DES、DES、RC5、RC6等。</p><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p>数据加密标准（英语：Data Encryption Standard，缩写为 DES）是一种对称密钥加密块密码算法。DES算法的入口参数有三个：Key、Data、Mode。</p><ul><li>Key: 7个字节共56位，是DES算法的工作密钥；</li><li>Data: 8个字节64位，是要被加密或被解密的数据；</li><li>Mode: 加密或解密。</li></ul><h3 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h3><p>三重数据加密算法（英语：Triple Data Encryption Algorithm，又称3DES（Triple DES），是一种对称密钥加密块密码，相当于是对每个数据块应用三次数据加密标准（DES）算法。</p><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>AES，高级加密标准（英语：Advanced Encryption Standard），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。</p><ul><li>采用对称分组密码体制，密钥长度为 128 位、 192 位、256 位，分组长度128位</li><li>相对于DES ，AES具有更好的 安全性、效率 和 灵活性。</li></ul><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><p>非对称加密算法需要两个密钥：公钥和私钥。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有用对应的私钥才能解密。主要的非对称加密算法有：RSA、Elgamal、DSA、D-H、ECC。</p><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><ul><li>RSA加密算法是一种非对称加密算法,广泛应用于加密和<strong>数字签名</strong></li><li>RSA算法原理：两个大素数的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</li><li>RSA是被研究得最广泛的公钥算法，从提出到现在，经历了各种攻击的考验，普遍认为是目前最优秀的公钥方案之一。</li></ul><h3 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h3><ul><li>DSA(Digital Signature Algorithm,数字签名算法),也是一种非对称加密算法。</li><li>DSA和RSA区别在，DSA仅用于数字签名，不能用于数据加密解密。其安全性和RSA相当，但其性能要比RSA好。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学概念&quot;&gt;&lt;a href=&quot;#密码学概念&quot; class=&quot;headerlink&quot; title=&quot;密码学概念&quot;&gt;&lt;/a&gt;密码学概念&lt;/h1&gt;&lt;h2 id=&quot;明文、密文、密钥、加密、解密&quot;&gt;&lt;a href=&quot;#明文、密文、密钥、加密、解密&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="密码" scheme="https://palette-k.github.io/tags/%E5%AF%86%E7%A0%81/"/>
    
    <category term="算法" scheme="https://palette-k.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="验签" scheme="https://palette-k.github.io/tags/%E9%AA%8C%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>Maven入门到实战</title>
    <link href="https://palette-k.github.io/2024/01/18/Maven%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"/>
    <id>https://palette-k.github.io/2024/01/18/Maven%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</id>
    <published>2024-01-18T01:34:41.000Z</published>
    <updated>2024-01-22T10:39:57.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven-的安装与配置"><a href="#Maven-的安装与配置" class="headerlink" title="Maven 的安装与配置"></a>Maven 的安装与配置</h1><p>下载地址：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>使用 <code>win + r</code> 打开运行框，输入<code>control system</code>，回车进入设置界面后，创建一个环境变量<code>MAVEN_HOME</code>（maven的安装地址）。</p><p>创建好后，找到系统变量中的<code>path</code>，将<code>MAVEN_HOME</code>这个变量配置进去：%MAVEN_HOME%\bin</p><p>打开<code>cmd</code>命令行输入<code>mvn -v</code>，打印出版本号表示安装成功。</p><h2 id="修改-settings-xml"><a href="#修改-settings-xml" class="headerlink" title="修改 settings.xml"></a>修改 settings.xml</h2><p>修改 conf 下的 settings.xml，将 localRepository 替换成本地的 maven 仓库地址。</p><p>至此，maven 就能正常使用了！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">Licensed to the Apache Software Foundation (ASF) under one</span></span><br><span class="line"><span class="comment">or more contributor license agreements.  See the NOTICE file</span></span><br><span class="line"><span class="comment">distributed with this work for additional information</span></span><br><span class="line"><span class="comment">regarding copyright ownership.  The ASF licenses this file</span></span><br><span class="line"><span class="comment">to you under the Apache License, Version 2.0 (the</span></span><br><span class="line"><span class="comment">&quot;License&quot;); you may not use this file except in compliance</span></span><br><span class="line"><span class="comment">with the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Unless required by applicable law or agreed to in writing,</span></span><br><span class="line"><span class="comment">software distributed under the License is distributed on an</span></span><br><span class="line"><span class="comment">&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span></span><br><span class="line"><span class="comment">KIND, either express or implied.  See the License for the</span></span><br><span class="line"><span class="comment">specific language governing permissions and limitations</span></span><br><span class="line"><span class="comment">under the License.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> | This is the configuration file for Maven. It can be specified at two levels:</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |  1. User Level. This settings.xml file provides configuration for a single user,</span></span><br><span class="line"><span class="comment"> |                 and is normally provided in $&#123;user.home&#125;/.m2/settings.xml.</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 <span class="doctag">NOTE:</span> This location can be overridden with the CLI option:</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 -s /path/to/user/settings.xml</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |  2. Global Level. This settings.xml file provides configuration for all Maven</span></span><br><span class="line"><span class="comment"> |                 users on a machine (assuming they&#x27;re all using the same Maven</span></span><br><span class="line"><span class="comment"> |                 installation). It&#x27;s normally provided in</span></span><br><span class="line"><span class="comment"> |                 $&#123;maven.conf&#125;/settings.xml.</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 <span class="doctag">NOTE:</span> This location can be overridden with the CLI option:</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 -gs /path/to/global/settings.xml</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> | The sections in this sample file are intended to give you a running start at</span></span><br><span class="line"><span class="comment"> | getting the most out of your Maven installation. Where appropriate, the default</span></span><br><span class="line"><span class="comment"> | values (values used when the setting is not specified) are provided.</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">   | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\mvnrepository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- interactiveMode</span></span><br><span class="line"><span class="comment">   | This will determine whether maven prompts you when it needs input. If set to false,</span></span><br><span class="line"><span class="comment">   | maven will use a sensible default value, perhaps based on some other setting, for</span></span><br><span class="line"><span class="comment">   | the parameter in question.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: true</span></span><br><span class="line"><span class="comment">  &lt;interactiveMode&gt;true&lt;/interactiveMode&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- offline</span></span><br><span class="line"><span class="comment">   | Determines whether maven should attempt to connect to the network when executing a build.</span></span><br><span class="line"><span class="comment">   | This will have an effect on artifact downloads, artifact deployment, and others.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: false</span></span><br><span class="line"><span class="comment">  &lt;offline&gt;false&lt;/offline&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- pluginGroups</span></span><br><span class="line"><span class="comment">   | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.</span></span><br><span class="line"><span class="comment">   | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers</span></span><br><span class="line"><span class="comment">   | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- pluginGroup</span></span><br><span class="line"><span class="comment">     | Specifies a further group identifier to use for plugin lookup.</span></span><br><span class="line"><span class="comment">    &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- proxies</span></span><br><span class="line"><span class="comment">   | This is a list of proxies which can be used on this machine to connect to the network.</span></span><br><span class="line"><span class="comment">   | Unless otherwise specified (by system property or command-line switch), the first proxy</span></span><br><span class="line"><span class="comment">   | specification in this list marked as active will be used.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- proxy</span></span><br><span class="line"><span class="comment">     | Specification for one proxy, to be used in connecting to the network.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;proxy&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;optional&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;active&gt;true&lt;/active&gt;</span></span><br><span class="line"><span class="comment">      &lt;protocol&gt;http&lt;/protocol&gt;</span></span><br><span class="line"><span class="comment">      &lt;username&gt;proxyuser&lt;/username&gt;</span></span><br><span class="line"><span class="comment">      &lt;password&gt;proxypass&lt;/password&gt;</span></span><br><span class="line"><span class="comment">      &lt;host&gt;proxy.host.net&lt;/host&gt;</span></span><br><span class="line"><span class="comment">      &lt;port&gt;80&lt;/port&gt;</span></span><br><span class="line"><span class="comment">      &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;</span></span><br><span class="line"><span class="comment">    &lt;/proxy&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- servers</span></span><br><span class="line"><span class="comment">   | This is a list of authentication profiles, keyed by the server-id used within the system.</span></span><br><span class="line"><span class="comment">   | Authentication profiles can be used whenever maven must make a connection to a remote server.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- server</span></span><br><span class="line"><span class="comment">     | Specifies the authentication information to use when connecting to a particular server, identified by</span></span><br><span class="line"><span class="comment">     | a unique name within the system (referred to by the &#x27;id&#x27; attribute below).</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | <span class="doctag">NOTE:</span> You should either specify username/password OR privateKey/passphrase, since these pairings are</span></span><br><span class="line"><span class="comment">     |       used together.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;server&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;deploymentRepo&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;username&gt;repouser&lt;/username&gt;</span></span><br><span class="line"><span class="comment">      &lt;password&gt;repopwd&lt;/password&gt;</span></span><br><span class="line"><span class="comment">    &lt;/server&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Another sample, using keys to authenticate.</span></span><br><span class="line"><span class="comment">    &lt;server&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;siteServer&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt;</span></span><br><span class="line"><span class="comment">      &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt;</span></span><br><span class="line"><span class="comment">    &lt;/server&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- mirrors</span></span><br><span class="line"><span class="comment">   | This is a list of mirrors to be used in downloading artifacts from remote repositories.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | It works like this: a POM may declare a repository to use in resolving certain artifacts.</span></span><br><span class="line"><span class="comment">   | However, this repository may have problems with heavy traffic at times, so people have mirrored</span></span><br><span class="line"><span class="comment">   | it to several places.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | That repository definition will have a unique id, so we can create a mirror reference for that</span></span><br><span class="line"><span class="comment">   | repository, to be used as an alternate download site. The mirror site will be the preferred</span></span><br><span class="line"><span class="comment">   | server for that repository.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- mirror</span></span><br><span class="line"><span class="comment">&lt;mirrors&gt;</span></span><br><span class="line"><span class="comment">     | Specifies a repository mirror site to use instead of a given repository. The repository that</span></span><br><span class="line"><span class="comment">     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span></span><br><span class="line"><span class="comment">     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;mirrorId&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span></span><br><span class="line"><span class="comment">      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;</span></span><br><span class="line"><span class="comment">    &lt;/mirror&gt;</span></span><br><span class="line"><span class="comment"> &lt;/mirrors&gt;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 阿里云仓库 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">&lt;id&gt;nexus-aliyun&lt;/id&gt;</span></span><br><span class="line"><span class="comment">&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">&lt;name&gt;Nexus aliyun&lt;/name&gt;</span></span><br><span class="line"><span class="comment">&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span></span><br><span class="line"><span class="comment">&lt;/mirror&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- profiles</span></span><br><span class="line"><span class="comment">   | This is a list of profiles which can be activated in a variety of ways, and which can modify</span></span><br><span class="line"><span class="comment">   | the build process. Profiles provided in the settings.xml are intended to provide local machine-</span></span><br><span class="line"><span class="comment">   | specific paths and repository locations which allow the build to work in the local environment.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | For example, if you have an integration testing plugin - like cactus - that needs to know where</span></span><br><span class="line"><span class="comment">   | your Tomcat instance is installed, you can provide a variable here such that the variable is</span></span><br><span class="line"><span class="comment">   | dereferenced during the build process to configure the cactus plugin.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles</span></span><br><span class="line"><span class="comment">   | section of this document (settings.xml) - will be discussed later. Another way essentially</span></span><br><span class="line"><span class="comment">   | relies on the detection of a system property, either matching a particular value for the property,</span></span><br><span class="line"><span class="comment">   | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a</span></span><br><span class="line"><span class="comment">   | value of &#x27;1.4&#x27; might activate a profile when the build is executed on a JDK version of &#x27;1.4.2_07&#x27;.</span></span><br><span class="line"><span class="comment">   | Finally, the list of active profiles can be specified directly from the command line.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | <span class="doctag">NOTE:</span> For profiles defined in the settings.xml, you are restricted to specifying only artifact</span></span><br><span class="line"><span class="comment">   |       repositories, plugin repositories, and free-form properties to be used as configuration</span></span><br><span class="line"><span class="comment">   |       variables for plugins in the POM.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- profile</span></span><br><span class="line"><span class="comment">&lt;profiles&gt;</span></span><br><span class="line"><span class="comment">     | Specifies a set of introductions to the build process, to be activated using one or more of the</span></span><br><span class="line"><span class="comment">     | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt;</span></span><br><span class="line"><span class="comment">     | or the command line, profiles have to have an ID that is unique.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | An encouraged best practice for profile identification is to use a consistent naming convention</span></span><br><span class="line"><span class="comment">     | for profiles, such as &#x27;env-dev&#x27;, &#x27;env-test&#x27;, &#x27;env-production&#x27;, &#x27;user-jdcasey&#x27;, &#x27;user-brett&#x27;, etc.</span></span><br><span class="line"><span class="comment">     | This will make it more intuitive to understand what the set of introduced profiles is attempting</span></span><br><span class="line"><span class="comment">     | to accomplish, particularly when you only have a list of profile id&#x27;s for debug.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo.</span></span><br><span class="line"><span class="comment">    &lt;profile&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;jdk-1.4&lt;/id&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;activation&gt;</span></span><br><span class="line"><span class="comment">        &lt;jdk&gt;1.4&lt;/jdk&gt;</span></span><br><span class="line"><span class="comment">      &lt;/activation&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;repositories&gt;</span></span><br><span class="line"><span class="comment">        &lt;repository&gt;</span></span><br><span class="line"><span class="comment">          &lt;id&gt;jdk14&lt;/id&gt;</span></span><br><span class="line"><span class="comment">          &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt;</span></span><br><span class="line"><span class="comment">          &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt;</span></span><br><span class="line"><span class="comment">          &lt;layout&gt;default&lt;/layout&gt;</span></span><br><span class="line"><span class="comment">          &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt;</span></span><br><span class="line"><span class="comment">        &lt;/repository&gt;</span></span><br><span class="line"><span class="comment">      &lt;/repositories&gt;</span></span><br><span class="line"><span class="comment">    &lt;/profile&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     | Here is another profile, activated by the system property &#x27;target-env&#x27; with a value of &#x27;dev&#x27;,</span></span><br><span class="line"><span class="comment">     | which provides a specific path to the Tomcat instance. To use this, your plugin configuration</span></span><br><span class="line"><span class="comment">     | might hypothetically look like:</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | ...</span></span><br><span class="line"><span class="comment">     | &lt;plugin&gt;</span></span><br><span class="line"><span class="comment">     |   &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">     |   &lt;artifactId&gt;myplugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     |   &lt;configuration&gt;</span></span><br><span class="line"><span class="comment">     |     &lt;tomcatLocation&gt;$&#123;tomcatPath&#125;&lt;/tomcatLocation&gt;</span></span><br><span class="line"><span class="comment">     |   &lt;/configuration&gt;</span></span><br><span class="line"><span class="comment">     | &lt;/plugin&gt;</span></span><br><span class="line"><span class="comment">     | ...</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | <span class="doctag">NOTE:</span> If you just wanted to inject this configuration whenever someone set &#x27;target-env&#x27; to</span></span><br><span class="line"><span class="comment">     |       anything, you could just leave off the &lt;value/&gt; inside the activation-property.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;profile&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;env-dev&lt;/id&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;activation&gt;</span></span><br><span class="line"><span class="comment">        &lt;property&gt;</span></span><br><span class="line"><span class="comment">          &lt;name&gt;target-env&lt;/name&gt;</span></span><br><span class="line"><span class="comment">          &lt;value&gt;dev&lt;/value&gt;</span></span><br><span class="line"><span class="comment">        &lt;/property&gt;</span></span><br><span class="line"><span class="comment">      &lt;/activation&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;properties&gt;</span></span><br><span class="line"><span class="comment">        &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt;</span></span><br><span class="line"><span class="comment">      &lt;/properties&gt;</span></span><br><span class="line"><span class="comment">    &lt;/profile&gt;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- activeProfiles</span></span><br><span class="line"><span class="comment">   | List of profiles that are active for all builds.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">  &lt;activeProfiles&gt;</span></span><br><span class="line"><span class="comment">    &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt;</span></span><br><span class="line"><span class="comment">    &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;</span></span><br><span class="line"><span class="comment">  &lt;/activeProfiles&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Maven-配置详解"><a href="#Maven-配置详解" class="headerlink" title="Maven 配置详解"></a>Maven 配置详解</h1><p>pom.xml 的基本结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ls.mavendemo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-world<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hello-world<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先看一下各个标签的含义：</p><p><project> ：POM 的根元素，定义了一些POM相关的规范。<br><modelVersion>: POM版本号，我们用的是 Maven3 这里只能是4.0.0<br><groupId> <artifactId> <version>：项目的坐标，用于确定一个唯一的项目</p><ul><li><code>&lt;groupId&gt;</code>：指的是当前构建隶属的实际项目，一般是 公司的网址倒序 + 项目名</li><li><code>&lt;artifactId&gt;</code>：一般是指的当前项目中的其中一个模块</li><li><code>&lt;version&gt;</code>：当前项目的版本号</li></ul><p>Maven 的版本号规则实际上也是业界的通过规则，它的定义方式如下：</p><p><code>&#123;主版本号&#125;.&#123;次版本号&#125;.&#123;增量版本号&#125;-&#123;里程碑版本&#125;</code><br><strong>主版本号：</strong>一般是指的当前的项目有了重大的架构变动，版本之间几乎完全不兼容，例如：最近出的 SpringBoot3 就已经放弃了Java8，如果不升级 JDK的话，还是只能使用SpringBoot2<br><strong>次版本号：</strong>一般是指的项目的迭代版本，这种版本会修复大量的bug，带来一些小的新特性等，但是没有什么架构上的重大变化。<br><strong>增量版本号：</strong>一般是用于修复一些紧急bug，改动量很小时，可以使用增量版本号。<br><strong>里程碑版本：</strong>就是项目的当前版本处于一个什么样的阶段了，常见的里程碑版本有 SNAPSHOT，alpha，beta，release，GA 等。</p><ul><li>SNAPSHOT：开发版，此时会存在大量的代码变动</li><li>alpha和beta分别对应的是内测版与公测版，属于不稳定版本，使用的时候非常容易踩坑，所以一般只用于demo体验，在正式环境中不能使用。</li><li>release和GA都属于是稳定的正式版本，可以在正式环境中使用。</li></ul><p><name>：当前项目的名称<br><dependencies>：当前项目引入的依赖<br><dependency>：单个需要引入的具体的依赖包<br><scope>：依赖的范围，常见的有 compile 和 test，不同的范围起到包隔离的作用</p><h2 id="Maven-的依赖"><a href="#Maven-的依赖" class="headerlink" title="Maven 的依赖"></a>Maven 的依赖</h2><p>来看一下完整的依赖配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--type 指的的当前引入的构件类型，默认为 jar --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span><span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span><span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>通过<code>pom.xml</code> 分别描述 A、B 构建的依赖关系：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A 依赖 B --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ls.mavendemo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- B 依赖 C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ls.mavendemo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，A 可以使用 C 里面打包的代码。</p><p>在上面的依赖配置基础上，如果我们不想将 C 传递给 A，则可以在 B 引入 C 的时候，将其设置为可选依赖：</p><p>引入的依赖如果标记为 <code>optional</code> 则不再向上传递，此时 A 不能再直接使用 C中的代码，可以选依赖在 <code>pom.xml</code> 中表示为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- B 依赖 C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ls.mavendemo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>为什么会需要禁止依赖传递？</p></blockquote><p>举个简单的开发例子，我们在一个 WEB 项目的开发中，将 service 层与 dao 分别拆成了两个构件，service 包依赖 dao 包，但是 service 中只需要使用我们写的主代码，而不需要使用例如数据库驱动、JDBC、ORM框架等依赖，我们就可以在 dao 中使用<optional>禁止这些持久化相关的包向上传递到service。</p><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>依赖范围在 pom.xml 中使用 <scope></scope> 来表示，有5种选项：</p><ul><li>compile：默认选项，也是最常用的选项，在编译、运行、测试的classpath中有引入；依赖范围在向上传递的时候，间接依赖于直接依赖的范围一致</li><li>provided：只在编译、测试引入，运行时不引入，例如：lombok；依赖范围不会向上传递</li><li>runtime：只在运行、测试引入，编译期不引入，例如：mysql-connector-java；依赖范围可向上传递，直接依赖为<code>compile</code>时，间接依赖的范围依然是<code>runtime</code></li><li>test：只在测试中有效，例如：JUnit；依赖范围不会向上传递</li><li>system：与provided相同，但是需要手动指定依赖文件路径（system会破坏可移植性，不推荐使用）</li></ul><h3 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h3><p><strong>直接依赖：</strong>在同一个 pom.xml 下，后声明的依赖会覆盖先声明的依赖。</p><p><strong>间接依赖：</strong>在不同的 pom.xml 下，依赖路径最短的那个依赖会生效，也就是<strong>就近原则</strong>。</p><p>有时候我们需要手动的排除一部分传递性的依赖，然后再定义我们需要的依赖，举个简单的例子：</p><p>我们在 spring-boot 的项目中使用 redis，首先需要引入一个 starter，这个 starter 中又依赖了 <code>lettuce</code> 这个客户端，此时，我们不想使用这个客户端，想切换成 <code>jedis</code>，那么我们就可以使用<code>exclusions</code> 将 <code>lettuce</code> 排除掉。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注：这里的exclusion 中不需要使用版本号。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后再引入 <code>jedis</code> 的依赖就可以了。</p><h1 id="Maven-的继承与聚合"><a href="#Maven-的继承与聚合" class="headerlink" title="Maven 的继承与聚合"></a>Maven 的继承与聚合</h1><h2 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h2><p>所有的 pom.xml 文件都会默认继承 super pom，在 super pom 中定义了这么几个配置：</p><ul><li><p>构件与插件仓库的地址</p></li><li><p>源码、测试代码以及资源文件resources的默认路径</p></li><li><p>编译及打包后的文件路径</p></li></ul><p>这也是为什么我们创建一个Maven项目之后，只要在 Maven 约定好的路径中编写我们的代码，其他的几乎什么都不用配置，就可以直接进行构建，也是一种约定优于配置的思想体现。</p><p>super pom 的位置在Maven主目录的lib文件夹下面，找到一个叫maven-model-builder.jar 的文件，在这个 jar 包的\org\apache\maven\model\pom-4.0.0.xml 路径下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>never<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/test-classes<span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/scripts<span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/test/java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/test/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="手动引入自定义父POM"><a href="#手动引入自定义父POM" class="headerlink" title="手动引入自定义父POM"></a>手动引入自定义父POM</h3><p>父 <code>pom</code> 的引入语法很简单，在<code>parent</code>标签中添加构件坐标即可，类似于<code>dependency</code>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- relativePath 指的是父 pom.xml 所在的相对路径，默认值是 ../pom.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span><span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子模块会优先从上级目录中查找<code>pom.xml</code>，如果查不到则到<strong>本地仓库</strong>中查找，如果还是查不到则会从远程仓库中查找。</p><h2 id="模块的聚合"><a href="#模块的聚合" class="headerlink" title="模块的聚合"></a>模块的聚合</h2><p>demo-a 依赖 demo-b， demo-b 依赖 demo-c , 在这种情况下，我们需要先 install c ，再 install b ，最后再构建 a，执行起来非常麻烦，为了处理这个问题，Maven 引入了聚合机制，可以将这三个模块聚合在一起，一次性完成构建。</p><p>聚合的语法也非常简单，只需要在父目录的 <code>pom.xml</code> 中添加 <code>&lt;modules&gt;</code> 即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-a<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-b<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-c<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;module&gt;</code> 中填写的并不是 <code>artifactId</code>，而是需要被聚合的模块的名称。</p><h3 id="反应堆-reactor"><a href="#反应堆-reactor" class="headerlink" title="反应堆(reactor)"></a>反应堆(reactor)</h3><p>Maven 的反应堆是将多个模块的项目按照一定的顺序进行构建。</p><p>当我们执行install或package语句时，maven先构建的是配置了聚合关系的<strong>聚合模块</strong>，然后才是子模块。子模块构建的时候会按照被依赖的顺序，由底层向上层进行构建。因此，我们的模块之间不能出现循环依赖的情况，假如在<code>demo-c</code>中引入<code>demo-a</code>的依赖，此时构建就会报错。</p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>Maven配置会把子模块中使用到的<strong>依赖</strong>以及<strong>版本号</strong>等，抽取到父模块中由子模块直接继承。</p><p>父pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql-connector-java.verison</span>&gt;</span>8.0.29<span class="tag">&lt;/<span class="name">mysql-connector-java.verison</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector-java.verison&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子pom.xml可不声明依赖版本，直接继承父pom.xml的版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Maven-的生命周期"><a href="#Maven-的生命周期" class="headerlink" title="Maven 的生命周期"></a>Maven 的生命周期</h1><p>Maven 的生命周期有三个，分别是<code>clean</code>、<code>default</code>、<code>site</code>。</p><ul><li>clean：默认是清除target目录中的所有文件，避免将历史版本打到新的包中造成一些不在预期中的问题</li><li>process-resources：将资源文件src&#x2F;main&#x2F;resources下的文件复制到target&#x2F;classes目录中。</li><li>compile：将src&#x2F;main&#x2F;java下的代码编译成 class 文件，也放到target&#x2F;classes目录中。</li><li>process-test-resources：将资源文件src&#x2F;test&#x2F;resources下的文件复制到target&#x2F;test-classes目录中。</li><li>test-compile：将src&#x2F;test&#x2F;java下的代码编译成 class 文件，也放到target&#x2F;test-classes目录中。</li><li>test：运行单元测试并在target&#x2F;surefire-reports中生成测试报告。</li><li>package：将资源文件、class文件、pom文件打包成一个jar包。</li><li>install：将生成的jar包推送到本地仓库中。</li><li>deploy：将生成的jar包推送到远程仓库中。</li></ul><p>执行构建时，会按照<strong>阶段</strong>顺序从上到下的执行，但只有绑定了<strong>插件目标</strong>的<strong>阶段</strong>才会执行</p><p>可以在通过<code>&lt;plugin&gt;</code>标签引入插件，通过<code>&lt;excutions&gt;</code>来定义执行计划，通过<code>&lt;phase&gt;</code>与<code>&lt;goal&gt;</code>绑定<strong>阶段</strong>与<strong>插件模板</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--源码插件引入--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--执行计划--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--在哪个生命周期阶段执行--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--执行别名--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>build-source<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件目标--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Maven-私服"><a href="#Maven-私服" class="headerlink" title="Maven 私服"></a>Maven 私服</h1><p>Maven 的仓库只有两种类型：<strong>本地仓库</strong>、<strong>远程仓库</strong>。</p><p>对于 远程仓库 来说，有几种特殊的子类型，最特殊的就是 Maven 的 中央仓库，这个是 Maven 提供的官方仓库，我们可以在里面找到市面上的几乎任何一个开源构件。除了中央仓库之前，还有其他的公共仓库，例如：JBoss的仓库，阿里云、腾讯云的镜像仓库等。</p><p>另外一种就是我们接下来要讲到的私服了，私服是假设在局域网中的仓库服务，也可以看作是对公用远程仓库的代理。</p><h2 id="私服-Nexus"><a href="#私服-Nexus" class="headerlink" title="私服 Nexus"></a>私服 Nexus</h2><p>本地的开发电脑在引入某个依赖的时候，可以<strong>先从私服查找</strong>，如果私服没有找到再去<strong>公用仓库</strong>下载，同时，也允许我们将开发好的某些构件上传到私服中，供其他的开发者下载使用。</p><p>私服有以下优势：</p><ul><li>节省带宽，增加构件的下载速度，同时也增加了仓库的稳定性。<br>在同一个局域网中，只要有一个开发者引入了某个构件，触发了私服从公用仓库中下载构件后，私服就会将这构件缓存到私服所在的服务器中。此时，再有其他的开发者要使用这个构件，就能够直接从局域网下载了，局域网相对于公网，更快更稳定。</li><li>可以上传公共仓库中没有的构件，与同一局域网中的其他开发者共享。</li></ul><h2 id="Docker-安装私服"><a href="#Docker-安装私服" class="headerlink" title="Docker 安装私服"></a>Docker 安装私服</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>在 docker-desktop 中找到 sonatype&#x2F;nexus3 这个镜像，拉取一个版本下来。</p><p>打开 powershell，执行以下命令启动：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker volume create <span class="literal">--name</span> nexus<span class="literal">-data</span></span><br><span class="line"><span class="comment"># 将容器的8081端口映射到宿主机的8082端口</span></span><br><span class="line">docker run <span class="literal">-dp</span> <span class="number">8082</span>:<span class="number">8081</span> <span class="literal">--name</span> nexus <span class="literal">-v</span> nexus<span class="literal">-data</span>:/nexus<span class="literal">-data</span> sonatype/nexus3</span><br></pre></td></tr></table></figure><p>打开 nexus 管理台</p><p><img src="https://i0.hdslb.com/bfs/article/4dd60622c59e64e007a2075e55c20cfe171301454.png" alt="image-20240119094827382"></p><p>进入到 nexus 容器里，进入<code>sonatype-work/nexus3</code>文件夹，找到 admin.password，里面保存着初始密码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec <span class="literal">-it</span> nexus bash</span><br></pre></td></tr></table></figure><p>获取到密码之后，回到网页上，点击右上角的 sign in ，使用 admin 登录，接下来会进入一个引导流程，会做下面两个配置：</p><p>修改密码：这里直接改成admin123<br>配置是否允许匿名登录：即后面使用Maven连接私服的时候是否需要使用密码<br>安全的配置一般都是不允许使用匿名登录的，这里我们选择Disable anonymous access。</p><h3 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h3><p>登录成功之后，我们需要在私服中配置国内的公用仓库作为私服下载构件的下载源，在这之前，我们先看一下默认的仓库配置。打开<code>Server administration and configuration</code>进行配置，也就是标题栏上面那个齿轮，然后打开<code>Repositores</code>：</p><p><img src="https://i0.hdslb.com/bfs/article/c8dd78d0ecd1cfbca8df0f18771a397d171301454.png" alt="image-20240119105708923"></p><p><strong>Type:</strong></p><ul><li>proxy：代理仓库，用来代理中央仓库或其他的远程公用仓库。</li><li>hosted：用来保存我们在局域网中发布的构件，也就是私有仓库。</li><li>group：仓库分组，里面可以配置多个仓库，并指定仓库访问的优先级。</li></ul><p><strong>Name:</strong></p><ul><li>maven-release：存放非SNAPSHOT的构件。</li><li>maven-snapshots：用于存放里程碑版本为SNAPSHOT的构件。</li><li>maven-central：代理Maven中央仓库，这里会缓存从中央仓库下载的构件。</li><li>maven-public：是仓库的分组，这个仓库中配置了上面三个仓库的访问顺序。</li></ul><p>回到仓库列表页面，点击左上角的<code>Create repository</code>，然后选择&#96;maven2(proxy)</p><p><img src="https://i0.hdslb.com/bfs/article/5406b6aa45b35982e0ea5db44dc3a7b6171301454.png" alt="image-20240119111324927"></p><p>ali_repo 配置如下：</p><p><img src="https://i0.hdslb.com/bfs/article/baa1125bb3ca91494e5186f3dabbd3c6171301454.png" alt="image-20240119111757956"></p><p>然后打开<code>maven_public</code>，将<code>ali_repo</code>配置上去：</p><p><img src="https://i0.hdslb.com/bfs/article/b51abb55934afd94a004482f6740e411171301454.png" alt="image-20240119112013042"></p><p>将ali_repo放到 <code>snapshots</code> 与 <code>maven-central</code> 之间</p><p><img src="https://i0.hdslb.com/bfs/article/671f04680c99606e665a25f9884b86c5171301454.png" alt="image-20240119151424667"></p><p>如果是正式环境使用的话，还需要对新建角色<code>role</code>，并针对每一个开发者都创建一个用户<code>user</code></p><h3 id="私服的使用"><a href="#私服的使用" class="headerlink" title="私服的使用"></a>私服的使用</h3><h4 id="修改Maven配置"><a href="#修改Maven配置" class="headerlink" title="修改Maven配置"></a>修改Maven配置</h4><p>先修改<code>setting.xml</code>的两个配置，让Maven可以连接上私服</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后是镜像配置，这里的<code>url</code>配置成上面所说的<code>maven-public</code>地址：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8082/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：两个配置中的<code>id</code>需要保持一致</p><h4 id="从私服中下载构件"><a href="#从私服中下载构件" class="headerlink" title="从私服中下载构件"></a>从私服中下载构件</h4><p>尝试引入一个<code>spring-core</code>的jar包（一定本地仓库中没有的，不然不会触发从私服中拉取），去查看私服中是否进行了下载：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以在私服上成功看到下载下来的依赖</p><p><img src="https://i0.hdslb.com/bfs/article/5c06d75e2d708a28cc854c893a4dd827171301454.png" alt="image-20240119151253203"></p><h4 id="推送构件到私服"><a href="#推送构件到私服" class="headerlink" title="推送构件到私服"></a>推送构件到私服</h4><p>如果要把自定义的构件发布到仓库中，需要使用以下两个指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发布到本地仓库</span></span><br><span class="line">mvn clean install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发布到远程仓库</span></span><br><span class="line">mvn clean deploy</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要忽略<span class="built_in">test</span></span> </span><br><span class="line">mvn clean deploy -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>在 pom.xml 中配置将构件推送到哪个仓库中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8082/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8082/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>成功在私服上看到我们自定义的构件</p><p><img src="https://i0.hdslb.com/bfs/article/22a28009beb63ae94afd773eaf10e214171301454.png" alt="image-20240119153656855"></p><h4 id="打包源码"><a href="#打包源码" class="headerlink" title="打包源码"></a>打包源码</h4><p>在开发协作中，有时候还需要将源码发布到私服中以便其他开发者下载，源码中包含了注释和接口说明，更有利于协作，例如：api包、封装的工具包、基础架构包等。</p><p>但是Maven的默认生命周期中没有加入打包源码的插件，所以需要我们自行引入，在<code>plugins</code>标签中加入插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--源码插件引入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--执行计划--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--在生命周期的哪个阶段执行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新打包完成之后，查看Maven仓库会发现里面多了一个<code>xxx-sources.jar</code>的源码包。</p><p><img src="https://i0.hdslb.com/bfs/article/143c582bccfda3d50cceeff505067e95171301454.png" alt="image-20240119154543318"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Maven-的安装与配置&quot;&gt;&lt;a href=&quot;#Maven-的安装与配置&quot; class=&quot;headerlink&quot; title=&quot;Maven 的安装与配置&quot;&gt;&lt;/a&gt;Maven 的安装与配置&lt;/h1&gt;&lt;p&gt;下载地址：&lt;a href=&quot;https://maven.ap</summary>
      
    
    
    
    
    <category term="maven" scheme="https://palette-k.github.io/tags/maven/"/>
    
    <category term="docker" scheme="https://palette-k.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>SSO单点登录</title>
    <link href="https://palette-k.github.io/2024/01/03/SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>https://palette-k.github.io/2024/01/03/SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</id>
    <published>2024-01-03T03:52:17.000Z</published>
    <updated>2024-02-07T06:49:48.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是SSO"><a href="#什么是SSO" class="headerlink" title="什么是SSO"></a>什么是SSO</h1><p>SSO( Single Sign On)，即单点登录。是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分。</p><p>简单来说，在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录；用户只需注销一次，各个系统即可感知该用户已经注销。</p><h1 id="单系统登录"><a href="#单系统登录" class="headerlink" title="单系统登录"></a>单系统登录</h1><p>众所周知，HTTP是<strong>无状态</strong>的协议，这意味着<strong>服务器无法确认用户的信息</strong>。于是乎，W3C就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是<strong>Cookie</strong>。</p><p>如果说Cookie是检查用户身上的”通行证“来确认用户的身份，那么Session就是通过检查服务器上的”客户明细表“来确认用户的身份的。<strong>Session相当于在服务器中建立了一份“客户明细表”</strong>。</p><p>HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一个用户。于是乎：服务器向用户浏览器发送了一个名为JESSIONID的Cookie，它的值是Session的id值。<strong>其实Session是依据Cookie来识别是否是同一个用户</strong>。</p><blockquote><p>虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？</p></blockquote><p>单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie</p><p>既然这样，为什么不将web应用群中所有子系统的域名统一在一个顶级域名下，例如“*.baidu.com”，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。</p><p>共享cookie的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间；第三，cookie本身不安全。</p><h1 id="多系统登录的问题和解决方式"><a href="#多系统登录的问题和解决方式" class="headerlink" title="多系统登录的问题和解决方式"></a>多系统登录的问题和解决方式</h1><h2 id="Session-不共享问题"><a href="#Session-不共享问题" class="headerlink" title="Session 不共享问题"></a>Session 不共享问题</h2><p>单系统登录功能主要是用Session保存用户信息来实现的，但我们清楚的是：多系统即可能有多个Tomcat，而Session是依赖当前系统的Tomcat，所以系统A的Session和系统B的Session是<strong>不共享</strong>的。</p><p>解决系统之间Session不共享问题有一下几种方案：</p><ul><li>Tomcat集群Session全局复制（集群内每个tomcat的session完全同步）【会影响集群的性能呢，不建议】</li><li>根据请求的IP进行<strong>Hash映射</strong>到对应的机器上（这就相当于请求的IP一直会访问同一个服务器）【如果服务器宕机了，会丢失了一大部分Session的数据，不建议】</li><li>把Session数据放在Redis中（使用Redis模拟Session）【<strong>建议</strong>】</li></ul><h2 id="Cookie-跨域问题"><a href="#Cookie-跨域问题" class="headerlink" title="Cookie 跨域问题"></a>Cookie 跨域问题</h2><p>我们请求<code>&lt;https://www.google.com/&gt;</code>时，浏览器会自动把<code>google.com</code>的Cookie带过去给<code>google</code>的服务器，而不会把<code>&lt;https://www.baidu.com/&gt;</code>的Cookie带过去给<code>google</code>的服务器。</p><p>这就意味着，<strong>由于域名不同</strong>，用户向系统A登录后，系统A返回给浏览器的Cookie，用户再请求系统B的时候不会将系统A的Cookie带过去。</p><p>针对Cookie存在跨域问题，有几种解决方案：</p><ol><li>服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析出来，此后请求都把这个Token带上就行了</li><li>多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。</li><li>将Token保存在SessionStroage中（不依赖Cookie就没有跨域的问题了）</li></ol><h2 id="SSO-CAS"><a href="#SSO-CAS" class="headerlink" title="SSO-CAS"></a>SSO-CAS</h2><p>CAS （Central Authentication Service）</p><p>sso认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立<strong>全局会话（生成一份Token，写到Cookie中，保存在浏览器上）</strong>。随后，认证中心<strong>重定向回系统A</strong>，并把Token携带过去给系统A。</p><p>接着，系统A去sso认证中心验证这个Token是否正确，如果正确，则系统A和用户建立局部会话（<strong>创建Session</strong>）。到此，系统A和用户已经是登录状态了。</p><p>此时，用户想要访问系统B<code>www.java4y.com</code>受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统B<code>www.java4y.com</code>发现用户并没有登录，于是<strong>重定向到sso认证中心，并将自己的地址作为参数</strong>。</p><p>注意，因为之前用户与认证中心<code>www.sso.com</code>已经建立了全局会话（当时已经把Cookie保存到浏览器上了），所以这次系统B<strong>重定向</strong>到认证中心<code>www.sso.com</code>是可以带上Cookie的。</p><p>认证中心<strong>根据带过来的Cookie</strong>发现已经与用户建立了全局会话了，认证中心<strong>重定向回系统B</strong>，并把Token携带过去给系统B。</p><p>接着，系统B去sso认证中心验证这个Token是否正确，如果正确，则系统B和用户建立局部会话（<strong>创建Session</strong>）。到此，系统B和用户已经是登录状态了。</p><p>其实SSO认证中心就类似一个<strong>中转站</strong>。</p><p><img src="https://i0.hdslb.com/bfs/article/48fd7714fdcf677dd1f444901a96a874171301454.png" alt="image-20240207114043185"></p><h2 id="SSO-JWT"><a href="#SSO-JWT" class="headerlink" title="SSO-JWT"></a>SSO-JWT</h2><p>JWT（JSON Web Token）是一种轻量级的开放标准（RFC 7519），用于在各方之间安全地传输信息。在SSO系统中，JWT被广泛应用于认证和授权，可以实现基于令牌的单点登录（SSO）。</p><p>JWT是一种自包含的令牌，它由三部分组成：头部、载荷和签名。头部包含了JWT类型和使用的加密算法；载荷包含了JWT所包含的信息，如用户身份、角色、权限等；签名则用于验证JWT的真实性和完整性。</p><p>在SSO系统中，JWT通常用于跨域认证和授权，实现以下流程：</p><ol><li>用户在第一次登录时，SSO服务器会生成一个JWT令牌，并将该令牌发送给用户。</li><li>用户访问其他应用程序或系统时，将JWT令牌随请求一同发送给目标应用程序或系统。</li><li>目标应用程序或系统通过验证JWT令牌的签名，确认该令牌是由SSO服务器颁发的，并可以解析出JWT中的用户信息。</li><li>目标应用程序或系统可以根据JWT中的用户信息进行身份验证和授权，让用户在不同的应用程序或系统之间实现无缝切换。</li></ol><h2 id="SSO-企微认证"><a href="#SSO-企微认证" class="headerlink" title="SSO-企微认证"></a>SSO-企微认证</h2><p>PaaS企微认证SSO是根据企业微信提供了OAuth的<a href="https://developer.work.weixin.qq.com/document/path/91335">授权登录方式</a>，可以让从企业微信终端打开的网页获取成员的身份信息，从而免去登录的环节。企业应用中的URL链接（包括自定义菜单或者消息中的链接），均可通过OAuth2.0验证接口来获取成员的UserId身份信息。</p><p>企微SSO再根据UserId查询用户表数据找到企微userid对应的用户信息，根据用户信息颁发JWT-token.</p><h2 id="SSO-微信小程序认证"><a href="#SSO-微信小程序认证" class="headerlink" title="SSO-微信小程序认证"></a>SSO-微信小程序认证</h2><p>PaaS微信小程序认证是根据<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">微信小程序登录</a> 调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。<br>调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 、 用户在微信开放平台帐号下的唯一标识UnionID（若当前小程序已绑定到微信开放平台帐号） 和 会话密钥 session_key，根据OpenID和UnionID 生成登录凭证。</p><h2 id="SSO-OAuth-2-0"><a href="#SSO-OAuth-2-0" class="headerlink" title="SSO-OAuth 2.0"></a>SSO-OAuth 2.0</h2><p>系统对接SSO-OAuth2.0,通过sso单点登录获取授权码并跳转到自己的系统,用授权码code获取用户信息比对自己的系统用户数据,以确认登录成功。</p><h3 id="接入流程"><a href="#接入流程" class="headerlink" title="接入流程"></a>接入流程</h3><p><img src="https://i0.hdslb.com/bfs/article/e2a56f673631318ced90a2014b4b5ef9171301454.png" alt="image-20240122114748174"></p><ol><li>用户访问第三方服务，第三方服务通过构造OAuth2链接（参数包括当前第三方服务的身份ID，以及重定向URI），将用户引导到认证服务器的授权页</li><li>用户选择是否同意授权</li><li>若用户同意授权，则认证服务器将用户重定向到第一步指定的重定向URI，同时附上一个授权码。</li><li>第三方服务收到授权码，带上授权码来源的重定向URI，并向认证服务器申请凭证。</li><li>认证服务器检查授权码和重定向URI的有效性，通过后颁发AccessToken（调用凭证）,根据AccessToken和授权码可获得用户数据</li></ol><p>OAuth2.0协议支持多种授权模式，如授权码模式、隐式授权模式、密码凭证授权模式、客户端模式等，每种模式都有不同的应用场景和安全性。</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>授权码模式</td><td>第三方应用先申请一个授权码code，然后根据code获取令牌accessToken</td></tr><tr><td>隐式授权模式</td><td>有些web应用为纯前端应用，该模式允许直接向前端颁发令牌</td></tr><tr><td>密码凭证授权模式</td><td>如果你高度信任某个应用，RFC 6379也允许用户把用户名和密码直接告诉该应用</td></tr><tr><td>客户端凭证模式</td><td>指客户端以自己的名义，而不是以用户的名义，向“服务提供商”进行认证</td></tr></tbody></table><h3 id="OAuth2-0协议的优点"><a href="#OAuth2-0协议的优点" class="headerlink" title="OAuth2.0协议的优点"></a>OAuth2.0协议的优点</h3><ol><li>安全性：OAuth2.0协议通过授权码、访问令牌等机制，保证了用户的资源不会被未经授权的第三方应用程序访问。</li><li>可扩展性：OAuth2.0协议支持多种授权模式，可以适用于不同类型的应用程序和系统。</li><li>简单性：OAuth2.0协议是一种简单的授权协议，易于实现和使用。</li><li>可移植性：OAuth2.0协议可以在不同的平台和语言之间使用，可以提高系统的可移植性和互操作性。</li></ol><h2 id="SSO-OIDC"><a href="#SSO-OIDC" class="headerlink" title="SSO-OIDC"></a>SSO-OIDC</h2><p>英文全称为 OpenID Connect，缩写为 OIDC，是一个基于 OAuth2 协议的身份认证标准协议。它在 OAuth2 上构建了一个身份层，提供完善的身份认证功能。</p><p>OIDC的交互时序图如下：</p><p><img src="https://i0.hdslb.com/bfs/article/9823bb275a6674b61e6a5940fab05b8b171301454.png" alt="image-20240207144926930"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是SSO&quot;&gt;&lt;a href=&quot;#什么是SSO&quot; class=&quot;headerlink&quot; title=&quot;什么是SSO&quot;&gt;&lt;/a&gt;什么是SSO&lt;/h1&gt;&lt;p&gt;SSO( Single Sign On)，即单点登录。是指在多系统应用群中登录一个系统，便可在其他所有系统中</summary>
      
    
    
    
    
    <category term="SSO" scheme="https://palette-k.github.io/tags/SSO/"/>
    
    <category term="OAuth2" scheme="https://palette-k.github.io/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>SSE</title>
    <link href="https://palette-k.github.io/2024/01/02/SSE/"/>
    <id>https://palette-k.github.io/2024/01/02/SSE/</id>
    <published>2024-01-02T02:08:08.000Z</published>
    <updated>2024-01-11T12:13:34.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Server-Sent Events 服务器推送事件，简称 SSE，是一种服务端实时<strong>主动</strong>向浏览器推送消息的技术。</p><p>SSE运行在HTTP协议之上，它允许服务器以事件流（Event Stream）的形式将数据发送给客户端。客户端通过建立持久化的HTTP连接，并监听这个事件流，从而可以实时接收到服务器推送的数据。</p><h1 id="SSE用途"><a href="#SSE用途" class="headerlink" title="SSE用途"></a>SSE用途</h1><p>ChatGPT 是一个基于深度学习的大型语言模型，处理自然语言需要大量的计算资源和时间，响应速度肯定比普通的读数据库要慢的多，普通 http 接口等待时间过长，显然并不合适。对于这种单项对话场景，ChagtGPT 将先计算出的数据“推送”给用户，边计算边返回，避免用户因为等待时间过长关闭页面。而这，可以采用 SSE 技术。</p><p>SSE 可以在 Web 应用程序中实现诸如股票在线数据、日志推送、聊天室实时人数等即时数据推送功能。股票📈k线的实时变化，彩票趋势走向，以及工业数据实时监控（受限于页面的数据获取范围面）和日志推送和CI&#x2F;CD工作流进度的推送等相关单向推送需求的场景。</p><p>需要注意的是，SSE 并不是适用于所有的实时推送场景。在需要高并发、高吞吐量和低延迟的场景下，WebSockets 可能更加适合。而在需要更轻量级的推送场景下，SSE 可能更加适合。因此，在选择即时更新方案时，需要根据具体的需求和场景进行选择。</p><h1 id="SSE与-WebSocket-比较"><a href="#SSE与-WebSocket-比较" class="headerlink" title="SSE与 WebSocket 比较"></a>SSE与 WebSocket 比较</h1><table><thead><tr><th>WebSocket</th><th>SSE</th></tr></thead><tbody><tr><td>基于TCP长连接通讯</td><td>基于HTTP协议</td></tr><tr><td>全双工，可以同时发送和接收消息</td><td>单工，只能服务端单向发送信息</td></tr><tr><td>相对复杂</td><td>轻量级，使用简单</td></tr><tr><td>不在协议范围内，需手动实现</td><td>内置断线重连和消息追踪功能</td></tr><tr><td>类型广泛</td><td>文本或使用 Base64 编码和 gzip 压缩的二进制消息</td></tr><tr><td>不支持自定义事件类型</td><td>支持自定义事件类型</td></tr><tr><td>连接数无限制</td><td>连接数 HTTP&#x2F;1.1 6个，HTTP&#x2F;2 可协商（默认100）</td></tr></tbody></table><h1 id="SSE的实现原理"><a href="#SSE的实现原理" class="headerlink" title="SSE的实现原理"></a>SSE的实现原理</h1><p>以下是SSE（Server-Sent Events）的实现原理：</p><ul><li>连接建立：通常情况下，客户端（如浏览器）通过发送HTTP GET请求到服务器来请求建立一个SSE连接。</li><li>服务器响应：一旦服务器接收到请求，它将返回一个HTTP响应，该响应的状态码为200，内容类型（Content-Type）设置为”text&#x2F;event-stream”。</li><li>数据推送：服务器可以通过已经建立的连接向客户端推送数据。每次推送的数据被称作一个事件（Event）。每个事件由一个或多个以”\n\n”分隔的数据块组成。每个数据块都是一行文本，可能包含一个以”:”开头的注释行、以”data:”开头的数据行，或者以”id:”和”event:”开头的行来指定事件ID和事件类型。</li><li>客户端处理：当客户端接收到服务器推送的事件后，它会触发相应的JavaScript事件处理器来处理这些事件。</li><li>重连：如果连接断开，客户端会自动尝试重新连接。如果服务器在事件中指定了ID，那么在重新连接时，客户端会发送一个”Last-Event-ID”的HTTP头部信息到服务器，告诉服务器客户端接收到的最后一个事件的ID。根据这个信息，服务器可以决定从哪个事件开始重新发送数据。</li></ul><p>总结起来，SSE使用了基于文本和HTTP协议的简单机制，使得服务器能够实时地将数据推送到客户端，而无需客户端频繁地发起新的请求。</p><h1 id="使用SSE的注意事项"><a href="#使用SSE的注意事项" class="headerlink" title="使用SSE的注意事项"></a>使用SSE的注意事项</h1><p>以下是在使用SSE（Server-Sent Events）技术进行实时数据推送时需要注意的几个关键点：</p><ul><li>异步处理：由于SSE基于长连接的机制，因此数据推送过程可能会持续较长时间。为了防止服务器线程被阻塞，建议采用异步方式处理SSE请求。例如，可以在控制器方法中使用@Async注解或利用CompletableFuture等异步编程方式。</li><li>超时处理：SSE连接可能会因网络中断、客户端关闭等原因而超时。为了避免无效连接占据服务器资源，建议设置超时时间并处理超时情况。例如，可以利用SseEmitter对象的setTimeout()方法设定超时时间，并通过onTimeout()方法处理超时逻辑。</li><li>异常处理：在实际应用中，可能会遇到网络异常、数据推送失败等问题。这种情况下，可以使用SseEmitter对象的completeWithError()方法将异常信息发送给客户端，并在客户端通过eventSource.onerror事件进行处理。</li><li>内存管理：在使用SseEmitter时，需要特别注意内存管理问题，尤其是在大量并发连接的场景下。当客户端断开连接后，务必及时释放SseEmitter对象，以避免资源泄漏和内存溢出。</li><li>并发性能：SSE的并发连接数可能对服务器性能产生影响。如果需要处理大量并发连接，可以考虑使用线程池或其他异步处理方式，以最大化服务器资源利用。</li><li>客户端兼容性：虽然大多数现代浏览器都支持SSE，但一些旧版本的浏览器可能不支持。因此，在使用SSE时，需要确保目标客户端对其有良好的支持，或者提供备选的实时数据推送机制。</li></ul><h1 id="SpringBoot-集成-SSE"><a href="#SpringBoot-集成-SSE" class="headerlink" title="SpringBoot 集成 SSE"></a>SpringBoot 集成 SSE</h1><p>下面给出一个 SpringBoot 集成 SSE 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SseEmitter <span class="title function_">streamChatCompletions</span><span class="params">(ChatCompletionRequest completionRequest, String tenantToken)</span> &#123;</span><br><span class="line">        <span class="comment">// 发起OpenaiStream请求，并使用sse发送给客户端</span></span><br><span class="line">      List&lt;ChatCompletionChunk&gt; chunks = Lists.newArrayList();</span><br><span class="line">      Flowable&lt;ChatCompletionChunk&gt; flowable = service.streamChatCompletion(completionRequest);</span><br><span class="line">      <span class="type">SseEmitter</span> <span class="variable">sseEmitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SseEmitter</span>(<span class="number">120000L</span>);</span><br><span class="line">      <span class="type">AtomicBoolean</span> <span class="variable">isCompleted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">      <span class="comment">// CAS 处理超时情况，避免无效连接持续占据服务器资源</span></span><br><span class="line">      sseEmitter.onTimeout(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (isCompleted.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">              sseEmitter.complete();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">       <span class="comment">// 流数据处理</span></span><br><span class="line">      flowable.subscribe(chatCompletionChunk -&gt; &#123;</span><br><span class="line">          <span class="comment">// 监听数据流</span></span><br><span class="line">          <span class="keyword">if</span> (!Objects.isNull(chatCompletionChunk.getId())) &#123;</span><br><span class="line">              <span class="type">boolean</span> <span class="variable">isStop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">              <span class="keyword">if</span> (chatCompletionChunk != <span class="literal">null</span> &amp;&amp; chatCompletionChunk.getChoices() != <span class="literal">null</span>) &#123;</span><br><span class="line">                  isStop = chatCompletionChunk.getChoices().stream().anyMatch(choice -&gt; choice != <span class="literal">null</span> &amp;&amp; <span class="string">&quot;stop&quot;</span>.equals(choice.getFinishReason()));</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (isStop) &#123;</span><br><span class="line">                  <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> chunks.stream().map(item -&gt; item.getChoices().stream().map(choice -&gt; choice.getMessage().getContent()).filter(Objects::nonNull).collect(Collectors.joining())).collect(Collectors.joining());</span><br><span class="line">                  List&lt;ChatMessage&gt; messages = completionRequest.getMessages();</span><br><span class="line">              &#125;</span><br><span class="line">              chunks.add(chatCompletionChunk);</span><br><span class="line">              sseEmitter.send(chatCompletionChunk);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">100</span>);</span><br><span class="line">              sseEmitter.send(JROpenaiConstant.SSE_DONE);</span><br><span class="line">              <span class="keyword">if</span> (isCompleted.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">                  sseEmitter.complete();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,throwable -&gt; &#123;</span><br><span class="line">          <span class="comment">// 异常处理</span></span><br><span class="line">          <span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> OpenAiHttpException) &#123;</span><br><span class="line">               log.error(<span class="string">&quot;OpenAi异常&quot;</span>);</span><br><span class="line">               sseEmitter.send(Result.failed(throwable.getMessage()));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// other throwable error</span></span><br><span class="line">              log.error(throwable.getMessage(), throwable);</span><br><span class="line">              sseEmitter.send(Result.failed(throwable.getMessage()));</span><br><span class="line">          &#125;</span><br><span class="line">          Thread.sleep(<span class="number">100</span>);</span><br><span class="line">          sseEmitter.send(JROpenaiConstant.SSE_DONE);</span><br><span class="line">          <span class="keyword">if</span> (isCompleted.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">              sseEmitter.complete();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">       <span class="comment">// shutdown okhttp3.Dispatcher</span></span><br><span class="line">      service.shutdownExecutor();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> sseEmitter;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Server-Sent Events 服务器推送事件，简称 SSE，是一种服务端实时&lt;strong&gt;主动&lt;/strong&gt;向浏览器推送消息的</summary>
      
    
    
    
    
    <category term="SSE" scheme="https://palette-k.github.io/tags/SSE/"/>
    
  </entry>
  
  <entry>
    <title>logback的配置和使用</title>
    <link href="https://palette-k.github.io/2023/12/28/logback%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://palette-k.github.io/2023/12/28/logback%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</id>
    <published>2023-12-28T06:20:54.000Z</published>
    <updated>2023-12-29T05:35:26.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="logback-简介"><a href="#logback-简介" class="headerlink" title="logback 简介"></a>logback 简介</h1><blockquote><p>logback 官网：<a href="https://logback.qos.ch/">https://logback.qos.ch/</a></p></blockquote><p>logback 由三个模块组成：</p><ul><li>logback-core</li><li>logback-classic</li><li>logback-access</li></ul><p><code>logback-core</code> 是其它模块的基础设施，其它模块基于它构建，<code>logback-core</code> 提供了一些关键的通用机制。</p><p><code>logback-classic</code> 的地位和作用等同于 <code>Log4J</code>，它也被认为是 <code>Log4J</code> 的一个改进版，并且它实现了简单日志门面 <code>SLF4J</code>；</p><p><code>logback-access</code> 主要作为一个与 <code>Servlet</code> 容器交互的模块，比如说<code>tomcat</code>或者 <code>jetty</code>，提供一些与 <code>HTTP</code> 访问相关的功能。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>接下来会介绍关于 logback 配置文件的配置项。</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>整个 logback.xml 配置文件的结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;glmapper-name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;glmapper-demo&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>$&#123;glmapper-name&#125;<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span> </span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span>&gt;</span></span><br><span class="line">        //xxxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span>&gt;</span></span><br><span class="line">        //xxxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span>             </span><br><span class="line">       //xxxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br></pre></td></tr></table></figure><ul><li><p>scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</p></li><li><p>scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</p></li><li><p>debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</p></li></ul><h3 id="contextName"><a href="#contextName" class="headerlink" title="contextName"></a>contextName</h3><p>logger上下文，默认名称为 “default”。可以使用 contextName 标签设置成其他名字，用于区分不同应用程序。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">contextName</span>&gt;</span>xxl_job<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>用于定义变量标签，name 为变量的名称，value 的值是变量的值。可以用 “${name}” 来使用变量。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志记录器，日期滚动记录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;./logs/xxl-job-admin&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><p>用来设置某一个包或者具体的某一个类的日志打印级别以及指定<code>appender</code>。这里的 level 是向下兼容的，即 DEBUG 级别的也会包含 INFO 级别的日志。</p><p>name:用来指定受此<code>logger</code>约束的某一个包或者具体的某一个类。</p><p>level:用来设置打印级别（<code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>, <code>ALL</code> 和 <code>OFF</code>），还有一个值<code>INHERITED</code>或者同义词<code>NULL</code>，代表强制执行上级的级别。如果没有设置此属性，那么当前<code>logger</code>将会继承上级的级别。</p><p>addtivity:用来描述是否向上级<code>logger</code>传递打印信息。默认是<code>true</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.xxl.job.executor&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>根logger，也是一种logger，且只有一个level属性。根logger 用于控制 appender 配置的日志等级和输出权限。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 生产环境下，将此级别配置为适合的级别，以免日志文件太多或影响程序性能 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILEERROR&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILEWARN&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILEINFO&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILEALL&quot;</span> /&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 生产环境将请stdout,testfile去掉 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter其实是appender里面的子元素。它作为过滤器存在，执行一个过滤器会有返回DENY，NEUTRAL，ACCEPT三个枚举值中的一个。可以为<code>appender</code> 添加一个或多个过滤器，可以用任意条件对日志进行过滤。<code>appender</code> 有多个过滤器时，按照配置顺序执行。</p><ul><li>DENY：日志将立即被抛弃不再经过其他过滤器</li><li>NEUTRAL：有序列表里的下个过滤器过接着处理日志</li><li>ACCEPT：日志会被立即处理，不再经过剩余过滤器</li></ul><p>filter 还指定了一个 class，class有两个种类：</p><ul><li>ThresholdFilter：临界值过滤器，过滤掉低于临界值的日志。当日志级别等于或高于临界值，过滤器返回 NEUTRAL；当日志级别低于临界值时，日志会被拒绝。</li><li>LevelFilter：级别过滤器，根据日志级别进行过滤。如果日志级别等于配置级别，过滤器会根据 onMatch 和 onMismatch 接收或拒绝日志。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志记录器，日期滚动记录 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILEINFO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">     ......</span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- 此日志文件只记录info级别的 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">level</span>&gt;</span>info<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 如果命中就使用这条规则 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 如果没有命中就禁止这条日志 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="appender"><a href="#appender" class="headerlink" title="appender"></a>appender</h3><p><code>appender</code>是一个日志打印的组件，这里组件里面定义了打印过滤的条件、打印输出方式、滚动策略、编码方式、打印格式等等。但是它只是一个配置，这个配置的开关和打印级别由 logger 或者 root 的 appender-ref 指定某个具体的 appender 控制。</p><h4 id="appender-的种类"><a href="#appender-的种类" class="headerlink" title="appender 的种类"></a>appender 的种类</h4><p><code>appender</code> 有两个属性 <code>name</code>和<code>class</code>;<code>name</code>指定<code>appender</code>名称，<code>class</code>指定<code>appender</code>的全限定名。</p><ul><li>ConsoleAppender：把日志添加到控制台</li><li>FileAppender：把日志添加到文件</li><li>RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。它是FileAppender的子类</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;GLMAPPER-LOGGERONE&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="append-子标签"><a href="#append-子标签" class="headerlink" title="append 子标签"></a>append 子标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是 <code>true</code>，日志被追加到文件结尾，如果是<code>false</code>，清空现存文件，默认是<code>true</code>。</p><h4 id="file-子标签"><a href="#file-子标签" class="headerlink" title="file 子标签"></a>file 子标签</h4><p>file 标签用于指定被写入的文件名，可以是相对也可以是绝对路径，如果上级目录不存在会自动创建，没有默认值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">    $&#123;logging.path&#125;/glmapper-spring-boot/glmapper-loggerone.log</span><br><span class="line"><span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表示当前appender将会将日志写入到<code>$&#123;logging.path&#125;/glmapper-spring-boot/glmapper-loggerone.log</code>这个目录下。</p><h4 id="rollingPolicy-子标签"><a href="#rollingPolicy-子标签" class="headerlink" title="rollingPolicy 子标签"></a>rollingPolicy 子标签</h4><p>这个子标签用来描述滚动策略的。这个只有<code>appender</code>的<code>class</code>是<code>RollingFileAppender</code>时才需要配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 归档的日志文件的路径，例如今天是2013-12-21日志，当前写的日志文件路径为file节点指定，可以将此文件与file指定文件路径设置为不同路径，从而将当前日志文件或归档日志文件置不同的目录。</span></span><br><span class="line"><span class="comment">           而2013-12-21的日志文件在由fileNamePattern指定。%d&#123;yyyy-MM-dd&#125;指定日期格式，%i指定索引 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/all/log-all-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 除按日志记录之外，还配置了日志文件不能超过2M，若超过2M，日志文件会以索引0开始，</span></span><br><span class="line"><span class="comment">           命名日志文件，例如log-error-2013-12-21.0.log --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="TimeBasedRollingPolicy"><a href="#TimeBasedRollingPolicy" class="headerlink" title="TimeBasedRollingPolicy"></a>TimeBasedRollingPolicy</h4><p>最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。这个下面又包括了两个属性：</p><ul><li>FileNamePattern</li><li>maxHistory</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rollingPolicy</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志文件输出的文件名:按天回滚 daily --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">        $&#123;logging.path&#125;/glmapper-spring-boot/glmapper-loggerone.log.%d&#123;yyyy-MM-dd&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的这段配置表明<strong>每天生成一个日志文件，保存30天的日志文件</strong></p><h4 id="FixedWindowRollingPolicy"><a href="#FixedWindowRollingPolicy" class="headerlink" title="FixedWindowRollingPolicy"></a>FixedWindowRollingPolicy</h4><p>根据固定窗口算法重命名文件的滚动策略。</p><h4 id="encoder-子标签"><a href="#encoder-子标签" class="headerlink" title="encoder 子标签"></a>encoder 子标签</h4><p>对记录事件进行格式化。它干了两件事：</p><ul><li>把日志信息转换成字节数组</li><li>把字节数组写入到输出流</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125;</span><br><span class="line">    - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前<code>encoder</code>只有<code>PatternLayoutEncoder</code>一种类型。</p><h1 id="不同日志隔离级别打印"><a href="#不同日志隔离级别打印" class="headerlink" title="不同日志隔离级别打印"></a>不同日志隔离级别打印</h1><h2 id="根据包、类隔离"><a href="#根据包、类隔离" class="headerlink" title="根据包、类隔离"></a>根据包、类隔离</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--此logger约束将.service包下的日志输出到GLMAPPER-SERVICE，错误日志输出到GERROR-APPENDE；GERROR-APPENDE见上面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.glmapper.spring.boot.service&quot;</span> <span class="attr">level</span>=<span class="string">&quot;$&#123;logging.level&#125;&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;GLMAPPER-SERVICE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;GERROR-APPENDER&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--这里指定到了具体的某一个类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.glmapper.spring.boot.task.TestLogTask&quot;</span> <span class="attr">level</span>=<span class="string">&quot;$&#123;logging.level&#125;&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;SCHEDULERTASKLOCK-APPENDER&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ERROR-APPENDER&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="根据环境隔离"><a href="#根据环境隔离" class="headerlink" title="根据环境隔离"></a>根据环境隔离</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;appender-ref ref=&quot;sendErrorMsgAppender&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;sit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;appender-ref ref=&quot;sendErrorMsgAppender&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;uat&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;appender-ref ref=&quot;sendErrorMsgAppender&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;sendErrorMsgAppender&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="logback小实战"><a href="#logback小实战" class="headerlink" title="logback小实战"></a>logback小实战</h1><p>使用 logback 配置将日志定义到自定义输出源，可以拿SpringBoot 整合 logback 发送企微通知作为例子。</p><p>要实现error级别异常日志异常报警，就是要捕获所有的error级别的日志，然后解析出异常数据，调用企业微信接口发送消息即可。</p><p>Logback中的<code>Appender</code>类用来表示日志的输出的目的地。所以我们只需要自定义一个 <code>Appeder</code>，然后在Logback的配置文件中的所有的<code>Logger</code>配置中(或者是所有Error级别的 <code>Logger</code>配置)增加这个自定义的<code>Appeder</code>就可以以拦截所有的(异常)日志。</p><p>首先定义一个企微发送消息的Appender。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendErrorMsgAppender</span> <span class="keyword">extends</span> <span class="title class_">UnsynchronizedAppenderBase</span>&lt;LoggingEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pattern;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PatternLayout layout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Level</span> <span class="variable">nowLevel</span> <span class="operator">=</span> Level.ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(LoggingEvent eventObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventObject == <span class="literal">null</span> || !eventObject.getLevel().isGreaterOrEqual(nowLevel)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>, userAccount = <span class="string">&quot;&quot;</span>, bodyString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (requestAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> requestAttributes.getRequest();</span><br><span class="line"></span><br><span class="line">                url = request.getRequestURI();</span><br><span class="line">                userAccount = getUserinfo(request);</span><br><span class="line">                bodyString = ServletUtil.getBody(request);</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotBlank(bodyString)) &#123;</span><br><span class="line">                    bodyString = JSON.toJSONString(JSON.parse(bodyString));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                logger.info(<span class="string">&quot;url:&#123;&#125;&quot;</span>, url);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.isBlank(eventObject.getFormattedMessage())) &#123;</span><br><span class="line">                <span class="comment">// 没有地址的错误日志不发送直接存储到日志文件即可,避免企业微信页面展示过多的错误信息</span></span><br><span class="line">                logger.info(<span class="string">&quot;lockKey:&#123;&#125;&quot;</span>, eventObject.getLoggerName());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Environment</span> <span class="variable">bean</span> <span class="operator">=</span> SpringUtil.getBean(Environment.class);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">active</span> <span class="operator">=</span> bean.getProperty(<span class="string">&quot;spring.profiles.active&quot;</span>);</span><br><span class="line">            <span class="comment">// dev本地调试异常错误不推送企微</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;prod&quot;</span>.equals(active)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">serverName</span> <span class="operator">=</span> <span class="string">&quot;jr-ai-open-api&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">errorMessage</span> <span class="operator">=</span> layout.doLayout(eventObject);</span><br><span class="line">            <span class="type">String</span> <span class="variable">webHook</span> <span class="operator">=</span> bean.getProperty(<span class="string">&quot;qyWeChat.webHook&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(webHook)) &#123;</span><br><span class="line">                toWechat(webHook, serverName, active, url, userAccount, bodyString, errorMessage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PatternLayout</span> <span class="variable">patternLayout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PatternLayout</span>();</span><br><span class="line">        patternLayout.setContext(context);</span><br><span class="line">        patternLayout.setPattern(getPattern());</span><br><span class="line">        patternLayout.start();</span><br><span class="line">        <span class="built_in">this</span>.layout = patternLayout;</span><br><span class="line">        <span class="built_in">super</span>.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toWechat</span><span class="params">(String robotUrl, String projectName, String environment, String requestUrl, String requestAccount, String requestBody, String errorLog)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">markdownContent</span> <span class="operator">=</span> buildMarkdownContent(projectName, environment, requestUrl, requestAccount, requestBody, errorLog);</span><br><span class="line">        <span class="type">String</span> <span class="variable">markdownMsg</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;msgtype\&quot;: \&quot;markdown\&quot;, \&quot;markdown\&quot;: &#123;\&quot;content\&quot;: &quot;</span> + JSON.toJSONString(markdownContent) + <span class="string">&quot;&#125;&#125;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">CloseableHttpClient</span> <span class="variable">httpclient</span> <span class="operator">=</span> HttpClients.createDefault()) &#123;</span><br><span class="line">            <span class="type">HttpPost</span> <span class="variable">httppost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(robotUrl);</span><br><span class="line">            httppost.addHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line">            httppost.setEntity(<span class="keyword">new</span> <span class="title class_">StringEntity</span>(markdownMsg, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            httpclient.execute(httppost);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">buildMarkdownContent</span><span class="params">(String projectName, String environment, String requestUrl, String requestAccount, String requestBody, String errorLog)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;font color=\&quot;red\&quot;&gt; 【ERROR 通知】  &lt;/font&gt; \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 触发项目：&lt;/font&gt; &lt;font color=\&quot;info\&quot;&gt; &quot;</span> + projectName + <span class="string">&quot;&lt;/font&gt; \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 触发环境：&lt;/font&gt; &lt;font color=\&quot;info\&quot;&gt; &quot;</span> + environment + <span class="string">&quot;&lt;/font&gt; \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 触发时间：&lt;/font&gt; &quot;</span> + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)) + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 请求URL：&lt;/font&gt; &quot;</span> + requestUrl + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 请求账号：&lt;/font&gt; &quot;</span> + requestAccount + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 请求Body：&lt;/font&gt; \n```json\n&quot;</span> + requestBody + <span class="string">&quot;\n```\n\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;font color=&#x27;red&#x27;&gt;【Exception 详情】&lt;/font&gt; \n```json\n&quot;</span> + errorLog + <span class="string">&quot;\n```\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPattern</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pattern = pattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PatternLayout <span class="title function_">getLayout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> layout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLayout</span><span class="params">(PatternLayout layout)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.layout = layout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Level <span class="title function_">getNowLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nowLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNowLevel</span><span class="params">(Level nowLevel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nowLevel = nowLevel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 logback.xml 中定义 SendErrorMsgAppender 的输出源，并指定在生产环境下才输出日志。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;sendErrorMsgAppender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.junrunrenli.proxy.exception.SendErrorMsgAppender&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] [%X&#123;traceId&#125;] [%X&#123;loginName&#125;] %-5level %logger&#123;50&#125; [line:%L]: %ex&#123;10&#125; -%msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.filter.EvaluatorFilter&quot;</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 过滤指定类型日志 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">evaluator</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">expression</span>&gt;</span>return message.contains(&quot;Broken pipe&quot;);<span class="tag">&lt;/<span class="name">expression</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">evaluator</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">OnMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">OnMatch</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">OnMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">OnMismatch</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">OnMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">OnMatch</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">OnMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">OnMismatch</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;sendErrorMsgAppender&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样配置以后，项目中所有使用<code>log.error()</code>方法打印的日志(即error级别日志)都会通过企业微信发出消息报警。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;logback-简介&quot;&gt;&lt;a href=&quot;#logback-简介&quot; class=&quot;headerlink&quot; title=&quot;logback 简介&quot;&gt;&lt;/a&gt;logback 简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;logback 官网：&lt;a href=&quot;https</summary>
      
    
    
    
    
    <category term="logback，日志" scheme="https://palette-k.github.io/tags/logback%EF%BC%8C%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>一致性哈希</title>
    <link href="https://palette-k.github.io/2023/12/27/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    <id>https://palette-k.github.io/2023/12/27/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</id>
    <published>2023-12-27T10:47:26.000Z</published>
    <updated>2023-12-29T09:54:40.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><p>对于经常使用的数据，我们一般会使用 Redis 作为缓存机制，为了实现高可用，使用了3台Redis（没有设置集群，集群至少要6台）。</p><p>使用hash算法，存储的时候根据公式 h &#x3D; hash(key)%机器节点数，h 为 Redis 对应的编号，取数据的时候也根据相同的公式取，因此一定可以从存储的机器中拿到想要的数据。但是使用这种策略可能会存在以下问题：</p><ul><li>假设有一台 Redis 服务器宕机了，此时每个 key 就要按照 h &#x3D; hash(key)%(机器节点数-1) 重新计算</li><li>假设要新增一台 Redis 服务器，此时每个 key 就要按照 h &#x3D; hash(key)%(机器节点数+1) 重新计算</li></ul><p>也就是说，如果服务节点有变更，会导致缓存失效，大量的 key 需要重新计算，在这期间如果有请求进来，就会直接打到数据库上，导致缓存雪崩。</p><h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><p>一致性哈希是讲整个哈希空间组织成一个虚拟的圆环，假设哈希函数 H 的值空间为 [0,2^32-1]（哈希值是32位无符号整形）。</p><p>把服务器按照 IP 或者主机名作为关键字进行哈希，确定服务器在哈希环中的位置。</p><p>再使用哈希函数把数据对象映射到环上，数据从顺时针方向找，遇到的第一个服务器就是它定位到的服务器。</p><p><img src="https://i0.hdslb.com/bfs/article/a41c409530fc27e7ebb2d744f585e22a171301454.png" alt="image-20231228103401543"></p><p>结论：数据1、2存储服务器B上，数据3存储在服务器C上，数据4存储在服务器A上</p><h2 id="容错性和可扩展性"><a href="#容错性和可扩展性" class="headerlink" title="容错性和可扩展性"></a>容错性和可扩展性</h2><p>假如这时候有服务器C宕机了呢？那么只有原本在B和C之间的数据会失效，重新定位到服务器A，其他数据节点的服务器不会发生变化。</p><p><img src="https://i0.hdslb.com/bfs/article/33a772b9eb938f8d2a865da97731ee75171301454.png" alt="image-20231228103647790"></p><p>或者我们想新增一台服务器D呢？那么只有C和D之间的数据会失效，重新定位到服务器D，而其他的数据节点的存储服务器也不会发生任何变化。</p><p><img src="https://i0.hdslb.com/bfs/article/6cb533eae847346c14f72dc43343b8a0171301454.png" alt="image-20231228103831559"></p><p>可以看出，一致性哈希算法对于节点的增减只会有一部分数据需要重新定位，不会导致大量的缓存失效。</p><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>现实的业务场景中，节点不会分布得那么均匀，如果节点较少，可能会出现数据倾斜的情况。</p><p>观察下图，所有的数据全都定位到服务B上，无法实现负载均衡了。</p><p><img src="https://i0.hdslb.com/bfs/article/dc20a553ace0ca99611ae40d9774f23b171301454.png" alt="image-20231228104239560"></p><p>为了解决这种数据存储不平衡的问题，一致性哈希算法引入了虚拟节点机制，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点称为虚拟节点。</p><p><img src="https://i0.hdslb.com/bfs/article/046f08a7f3e7ec5f5a83beadf6c27054171301454.png" alt="image-20231228112641899"></p><p>增加了虚拟节点到实际节点的映射，这样就能解决服务节点少时数据不平均的问题了。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p><h1 id="手撕源码"><a href="#手撕源码" class="headerlink" title="手撕源码"></a>手撕源码</h1><p>介绍完一致性哈希算法的概念和规则，接下来我们从源码的角度分析一致性哈希算法是怎么实现的。</p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>首先确定项目中要使用的哈希算法，其中服务器和数据的映射都依赖哈希算法。</p><p>非加密算法：MurMurHash算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  MurMurHash算法，是非加密HASH算法，性能很高，</span></span><br><span class="line"><span class="comment"> *  比传统的CRC32,MD5，SHA-1（这两个算法都是加密HASH算法，复杂度本身就很高，带来的性能上的损害也不可避免）</span></span><br><span class="line"><span class="comment"> *  等HASH算法要快很多，而且据说这个算法的碰撞率很低.</span></span><br><span class="line"><span class="comment"> *  http://murmurhash.googlepages.com/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">hash</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(key.getBytes());</span><br><span class="line">    <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="number">0x1234ABCD</span>;</span><br><span class="line">    <span class="type">ByteOrder</span> <span class="variable">byteOrder</span> <span class="operator">=</span> buf.order();</span><br><span class="line">    buf.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">    <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0xc6a4a7935bd1e995L</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">h</span> <span class="operator">=</span> seed ^ (buf.remaining() * m);</span><br><span class="line">    <span class="type">long</span> k;</span><br><span class="line">    <span class="keyword">while</span> (buf.remaining() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">        k = buf.getLong();</span><br><span class="line">        k *= m;</span><br><span class="line">        k ^= k &gt;&gt;&gt; r;</span><br><span class="line">        k *= m;</span><br><span class="line">        h ^= k;</span><br><span class="line">        h *= m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buf.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">finish</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>).order(</span><br><span class="line">                ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        <span class="comment">// for big-endian version, do this first:</span></span><br><span class="line">        <span class="comment">// finish.position(8-buf.remaining());</span></span><br><span class="line">        finish.put(buf).rewind();</span><br><span class="line">        h ^= finish.getLong();</span><br><span class="line">        h *= m;</span><br><span class="line">    &#125;</span><br><span class="line">    h ^= h &gt;&gt;&gt; r;</span><br><span class="line">    h *= m;</span><br><span class="line">    h ^= h &gt;&gt;&gt; r;</span><br><span class="line">    buf.order(byteOrder);</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密算法：md5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get hash code on 2^32 ring (md5散列的方式计算hash值)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> long</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">hash2</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// md5 byte</span></span><br><span class="line">    MessageDigest md5;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;MD5 not supported&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    md5.reset();</span><br><span class="line">    <span class="type">byte</span>[] keyBytes = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        keyBytes = key.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown string :&quot;</span> + key, e);</span><br><span class="line">    &#125;</span><br><span class="line">    md5.update(keyBytes);</span><br><span class="line">    <span class="type">byte</span>[] digest = md5.digest();</span><br><span class="line">    <span class="comment">// hash code, Truncate to 32-bits</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> ((<span class="type">long</span>) (digest[<span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">            | ((<span class="type">long</span>) (digest[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">            | ((<span class="type">long</span>) (digest[<span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">            | (digest[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">truncateHashCode</span> <span class="operator">=</span> hashCode &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">    <span class="keyword">return</span> truncateHashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节点映射"><a href="#节点映射" class="headerlink" title="节点映射"></a>节点映射</h2><p>以有序 Map 的形式在内存中缓存每个节点的 Hash 值对应的物理节点信息，所以引入了 TreeMap 进行存储。</p><p>为了增加一致性哈希算法中的虚拟节点，在初始化节点映射的过程中，将计算出 实际节点*虚拟节点 的hash值，以 Hash 值为 key，以物理节点标识为 value，以有序 Map 的形式在内存中缓存，作为后续计算数据对象对应的物理节点时的查询数据。代码如下，virtualHash2RealNode 中缓存着所有虚拟节点 Hash 值对应的物理节点信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚拟节点数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NODE_NUM</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 映射到哈希环上的 虚拟节点+真实节点 (使用 红黑树 排序)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> TreeMap&lt;Long, String&gt; virtualHash2RealNode = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化节点（引入虚拟节点）</span></span><br><span class="line"><span class="comment"> * init consistency hash ring, put virtual node on the 2^64 ring</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initVirtual2RealRing</span><span class="params">(List&lt;String&gt; shards)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.shardNodes = shards;</span><br><span class="line">    <span class="keyword">for</span> (String node : shardNodes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NODE_NUM; i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> hash(<span class="string">&quot;SHARD-&quot;</span> + node + <span class="string">&quot;-NODE-&quot;</span> + i);</span><br><span class="line">            virtualHash2RealNode.put(hashCode, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据定位节点"><a href="#数据定位节点" class="headerlink" title="数据定位节点"></a>数据定位节点</h2><p>已知 virtualHash2RealNode 中存放着物理节点的信息，使用 tailMap() 方法寻找到比该数据大的范围内的所有物理节点，返回第一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找数据所对应节点</span></span><br><span class="line"><span class="comment"> * 从顺时针遇到的第一个节点</span></span><br><span class="line"><span class="comment"> * get real node by key&#x27;s hash on the 2^64</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getShardInfo</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    SortedMap&lt;Long, String&gt; tailMap = virtualHash2RealNode.tailMap(hashCode);</span><br><span class="line">    <span class="keyword">if</span> (tailMap.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> virtualHash2RealNode.get(virtualHash2RealNode.firstKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> virtualHash2RealNode.get(tailMap.firstKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><p>一般在项目中，会把一致性哈希算法包装成工具类使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistencyHashUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; shardNodes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储节点数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NODE_NUM</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 映射到哈希环上的 虚拟节点+真实节点 (使用 红黑树 排序)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;Long, String&gt; virtualHash2RealNode = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, String&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化节点（引入虚拟节点）</span></span><br><span class="line"><span class="comment">     * init consistency hash ring, put virtual node on the 2^64 ring</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initVirtual2RealRing</span><span class="params">(List&lt;String&gt; shards)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.shardNodes = shards;</span><br><span class="line">        <span class="keyword">for</span> (String node : shardNodes) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NODE_NUM; i++)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> hash(<span class="string">&quot;SHARD-&quot;</span> + node + <span class="string">&quot;-NODE-&quot;</span> + i);</span><br><span class="line">                virtualHash2RealNode.put(hashCode, node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 寻找数据所对应节点</span></span><br><span class="line"><span class="comment">     * 从顺时针遇到的第一个节点</span></span><br><span class="line"><span class="comment">     * get real node by key&#x27;s hash on the 2^64</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShardInfo</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        SortedMap&lt;Long, String&gt; tailMap = virtualHash2RealNode.tailMap(hashCode);</span><br><span class="line">        <span class="keyword">if</span> (tailMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> virtualHash2RealNode.get(virtualHash2RealNode.firstKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualHash2RealNode.get(tailMap.firstKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印节点</span></span><br><span class="line"><span class="comment">     * prinf ring virtual node info</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMap</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(virtualHash2RealNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  MurMurHash算法，是非加密HASH算法，性能很高，</span></span><br><span class="line"><span class="comment">     *  比传统的CRC32,MD5，SHA-1（这两个算法都是加密HASH算法，复杂度本身就很高，带来的性能上的损害也不可避免）</span></span><br><span class="line"><span class="comment">     *  等HASH算法要快很多，而且据说这个算法的碰撞率很低.</span></span><br><span class="line"><span class="comment">     *  http://murmurhash.googlepages.com/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">hash</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(key.getBytes());</span><br><span class="line">        <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="number">0x1234ABCD</span>;</span><br><span class="line">        <span class="type">ByteOrder</span> <span class="variable">byteOrder</span> <span class="operator">=</span> buf.order();</span><br><span class="line">        buf.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0xc6a4a7935bd1e995L</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">h</span> <span class="operator">=</span> seed ^ (buf.remaining() * m);</span><br><span class="line">        <span class="type">long</span> k;</span><br><span class="line">        <span class="keyword">while</span> (buf.remaining() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            k = buf.getLong();</span><br><span class="line">            k *= m;</span><br><span class="line">            k ^= k &gt;&gt;&gt; r;</span><br><span class="line">            k *= m;</span><br><span class="line">            h ^= k;</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buf.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">finish</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>).order(</span><br><span class="line">                    ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">            <span class="comment">// for big-endian version, do this first:</span></span><br><span class="line">            <span class="comment">// finish.position(8-buf.remaining());</span></span><br><span class="line">            finish.put(buf).rewind();</span><br><span class="line">            h ^= finish.getLong();</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line">        h *= m;</span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line">        buf.order(byteOrder);</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get hash code on 2^32 ring (md5散列的方式计算hash值)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">hash2</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// md5 byte</span></span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;MD5 not supported&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.reset();</span><br><span class="line">        <span class="type">byte</span>[] keyBytes = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            keyBytes = key.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown string :&quot;</span> + key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.update(keyBytes);</span><br><span class="line">        <span class="type">byte</span>[] digest = md5.digest();</span><br><span class="line">        <span class="comment">// hash code, Truncate to 32-bits</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> ((<span class="type">long</span>) (digest[<span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (digest[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">truncateHashCode</span> <span class="operator">=</span> hashCode &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">        <span class="keyword">return</span> truncateHashCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; shards = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        shards.add(<span class="string">&quot;consumer-uuid-2&quot;</span>);</span><br><span class="line">        shards.add(<span class="string">&quot;consumer-uuid-1&quot;</span>);</span><br><span class="line">        <span class="type">ConsistencyHashUtil</span> <span class="variable">sh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsistencyHashUtil</span>();</span><br><span class="line">        sh.initVirtual2RealRing(shards);</span><br><span class="line">        sh.printMap();</span><br><span class="line">        <span class="type">int</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;consumer&quot;</span> + i;</span><br><span class="line">            System.out.println(hash(key) + <span class="string">&quot;:&quot;</span> + sh.getShardInfo(key));</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;consumer-uuid-1&quot;</span>.equals(sh.getShardInfo(key))) &#123;</span><br><span class="line">                consumer1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;consumer-uuid-2&quot;</span>.equals(sh.getShardInfo(key))) &#123;</span><br><span class="line">                consumer2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;consumer1:&quot;</span> + consumer1);</span><br><span class="line">        System.out.println(<span class="string">&quot;consumer2:&quot;</span> + consumer2);</span><br><span class="line">        <span class="comment">/*long start = System.currentTimeMillis();</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 1000 * 1000 * 1000; i++) &#123;</span></span><br><span class="line"><span class="comment">            if (i % (100 * 1000 * 1000) == 0) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(i + &quot;:&quot; + hash(&quot;key1&quot; + i));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        long end = System.currentTimeMillis();</span></span><br><span class="line"><span class="comment">        System.out.println(end - start);*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hutool 工具包也有封装好一致性哈希算法的工具类，只需要传入复制的节点个数和节点对象就能初始化节点映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一致性Hash算法</span></span><br><span class="line"><span class="comment"> * 算法详解：http://blog.csdn.net/sparkliang/article/details/5279393</span></span><br><span class="line"><span class="comment"> * 算法实现：https://weblogs.java.net/blog/2007/11/27/consistent-hashing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoleilu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;节点类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistentHash</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Hash计算对象，用于自定义hash算法 */</span></span><br><span class="line">Hash32&lt;Object&gt; hashFunc;</span><br><span class="line"><span class="comment">/** 复制的节点个数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> numberOfReplicas;</span><br><span class="line"><span class="comment">/** 一致性Hash环 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Integer, T&gt; circle = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造，使用Java默认的Hash算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numberOfReplicas 复制的节点个数，增加每个节点的复制节点有利于负载均衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodes 节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConsistentHash</span><span class="params">(<span class="type">int</span> numberOfReplicas, Collection&lt;T&gt; nodes)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.numberOfReplicas = numberOfReplicas;</span><br><span class="line"><span class="built_in">this</span>.hashFunc = key -&gt; &#123;</span><br><span class="line"><span class="comment">//默认使用FNV1hash算法</span></span><br><span class="line"><span class="keyword">return</span> HashUtil.fnvHash(key.toString());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//初始化节点</span></span><br><span class="line"><span class="keyword">for</span> (T node : nodes) &#123;</span><br><span class="line">add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hashFunc hash算法对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numberOfReplicas 复制的节点个数，增加每个节点的复制节点有利于负载均衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodes 节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConsistentHash</span><span class="params">(Hash32&lt;Object&gt; hashFunc, <span class="type">int</span> numberOfReplicas, Collection&lt;T&gt; nodes)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.numberOfReplicas = numberOfReplicas;</span><br><span class="line"><span class="built_in">this</span>.hashFunc = hashFunc;</span><br><span class="line"><span class="comment">//初始化节点</span></span><br><span class="line"><span class="keyword">for</span> (T node : nodes) &#123;</span><br><span class="line">add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加节点&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 每增加一个节点，就会在闭环上增加给定复制节点数&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 例如复制节点数是2，则每调用此方法一次，增加两个虚拟节点，这两个节点指向同一Node</span></span><br><span class="line"><span class="comment"> * 由于hash算法会调用node的toString方法，故按照toString去重</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T node)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfReplicas; i++) &#123;</span><br><span class="line">circle.put(hashFunc.hash32(node.toString() + i), node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除节点的同时移除相应的虚拟节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(T node)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfReplicas; i++) &#123;</span><br><span class="line">circle.remove(hashFunc.hash32(node.toString() + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得一个最近的顺时针节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 为给定键取Hash，取得顺时针方向上最近的一个虚拟节点对应的实际节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (circle.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hashFunc.hash32(key);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span> == circle.containsKey(hash)) &#123;</span><br><span class="line">SortedMap&lt;Integer, T&gt; tailMap = circle.tailMap(hash);<span class="comment">//返回此映射的部分视图，其键大于等于 hash</span></span><br><span class="line">hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正好命中</span></span><br><span class="line"><span class="keyword">return</span> circle.get(hash);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入复制的节点个数和实际物理节点信息，实现一致性哈希。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ConsistentHash&lt;Node&gt; <span class="title function_">makeProxyPool</span><span class="params">(List&lt;OpenaiProxy&gt; openaiProxies)</span> &#123;</span><br><span class="line">        List&lt;Node&gt; realNodes = openaiProxies.stream().map(item -&gt; <span class="keyword">new</span> <span class="title class_">Node</span>(item.getHost(), item.getToken())).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConsistentHash</span>&lt;&gt;(<span class="number">500</span>, realNodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式缓存&quot;&gt;&lt;a href=&quot;#分布式缓存&quot; class=&quot;headerlink&quot; title=&quot;分布式缓存&quot;&gt;&lt;/a&gt;分布式缓存&lt;/h1&gt;&lt;p&gt;对于经常使用的数据，我们一般会使用 Redis 作为缓存机制，为了实现高可用，使用了3台Redis（没有设置集群，集</summary>
      
    
    
    
    
    <category term="算法，一致性哈希" scheme="https://palette-k.github.io/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Spring AOP</title>
    <link href="https://palette-k.github.io/2023/12/21/AOP/"/>
    <id>https://palette-k.github.io/2023/12/21/AOP/</id>
    <published>2023-12-21T11:28:26.000Z</published>
    <updated>2023-12-27T10:35:25.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对AOP的理解"><a href="#对AOP的理解" class="headerlink" title="对AOP的理解"></a>对AOP的理解</h1><p><code>AOP(Aspect-Oriented Programming:面向切面编程)</code>，它实际做的就是将业务和一些非业务进行拆解，降低彼此业务模块与非业务模块的耦合度，便于后续的扩展维护。例如<code>权限校验</code>、<code>日志管理</code>、<code>事务处理</code>等都可以使用<code>AOP</code>实现。而<code>Spring</code>就是基于动态代理实现<code>AOP</code>的。如果被代理的类有实现接口的话，就会基于<code>JDK Proxy</code>完成代理的创建。反之就是通过<code>Cglib</code>完成代理创建。</p><p><img src="https://qiniuyun.sharkchili.com/img202304071136659.png"></p><blockquote><p>Spring AOP和AspectJ AOP的区别知道吗？</p></blockquote><p><strong>答:</strong> 其实<code>Spring AOP</code>属于运行时增强，基于<code>代理(Proxying)</code>实现的。而<code>AspectJ AOP</code>属于编译时增强，基于<code>字节码操作(Bytecode Manipulation)</code>实现的。相比之下后者比前者更成熟、更强大一些。如果在切面不多的情况下，两者差异是不大的，如果切面非常多的话，后者性能会比强者好很多。</p><p><code>AOP</code>中有很多核心术语，分别是:</p><ol><li><p><code>目标(Target)</code>: 这就被代理的对象，例如我们希望对<code>UserService</code>每个方法进行<code>增强(在不动它的代码情况下增加一些非业务的动作)</code>，那么这个<code>UserService</code>就是目标。</p></li><li><p><code>代理(Proxy)</code>: 就是给你被代理后的对象的厂商，例如我们上面说过希望对<code>UserService</code>每个方法进行增强，那么给用户返回增强后的对象的类就是<code>代理类</code>。</p></li><li><p><code>连接点(JoinPoint)</code>:目标对象，每一个可能可以被增强的方法都可以称为连接点，尽管它最后可能不会被增强。</p></li><li><p><code>切入点(Pointcut)</code>: 连接点中确确实实被做增强操作的方法就叫切入点。</p></li><li><p><code>通知(Advice)</code>: 不要被表面的语义误导，通知并不是告知某人的意思，通知的意思是拦截对象后，做的增强操作。</p></li><li><p><code>切面(Aspect)</code>: 切入点<code>(Pointcut)</code>+通知<code>(Advice)</code></p></li><li><p><code>织入(Weaving)</code>：把通知的动作融入到对象中，生成代理对象的过程就叫做织入</p></li></ol><blockquote><p>AspectJ 通知类型有哪些？</p></blockquote><p><strong>答:</strong> 有很多，分别是：</p><ol><li><code>Before（前置通知）</code>: 目标对象方法调用前触发增强。</li><li><code>After （后置通知）</code>:目标对象方法调用后进行增强。</li><li><code>AfterReturning（返回通知）</code>:目标对象方法执行结束，返回值时进行增强。</li><li><code>AfterThrowing（异常通知）</code>:目标对象方法执行报错并抛出时做的增强。</li><li><code>Around(环绕通知）</code>:这个比较常用了，目标对象方法调用前后我们可以做各种增强操作,甚至不调用对象的方法都能做到。</li></ol><h1 id="动态代理实现"><a href="#动态代理实现" class="headerlink" title="动态代理实现"></a>动态代理实现</h1><h2 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h2><p>使用 Spring 实现 JDK 动态代理，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDKProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          *  1 创建原始对象</span></span><br><span class="line"><span class="comment">          *  JDK1.8 以前，内部类访问外部类的对象， 原始对象需声明成 final</span></span><br><span class="line"><span class="comment">          *  final UserService userService = new UserServiceImpl();</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    </span><br><span class="line">          <span class="comment">// 2 JDK 创建动态代理</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>()&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作用：书写额外功能，运行原始方法，执行前、后 抛出异常</span></span><br><span class="line"><span class="comment">     * 参数：Proxy 代理对象</span></span><br><span class="line"><span class="comment">            Method 额外功能，增加给原始方法</span></span><br><span class="line"><span class="comment">            Object[] 原始方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;------proxy log ------&quot;</span>);</span><br><span class="line">       <span class="comment">// 原始方法运行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(userService,args);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1. 需要ClassLoader创建代理类的Class对象，可以借一个，借用的类加载器没有限制 TestJDKProxy UserServiceImpl</span></span><br><span class="line"><span class="comment">    * 2. 代理对象和原始对象实现相同的接口，取原始对象实现的接口</span></span><br><span class="line"><span class="comment">    * 3. 重写 InvocationHandler 的 invoke 方法，实现额外功能</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userServiceProxy</span> <span class="operator">=</span> (UserService)Proxy.newProxyInstance(TestJDKProxy.class.getClassLoader(),userService.getClass().getInterfaces(),handler);</span><br><span class="line">    </span><br><span class="line">    userService.login(<span class="string">&quot;suns&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    userServiceProxy.register(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cglib-动态代理"><a href="#Cglib-动态代理" class="headerlink" title="Cglib 动态代理"></a>Cglib 动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCglib</span>  &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">           *  1 创建原始对象</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">         <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">         </span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2 通过Cglib方式创建动态代理</span></span><br><span class="line"><span class="comment">         * Enhancer 通过继承父类创建代理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">         </span><br><span class="line">         enhancer.setClassLoader(TestCglib.class.getClassLoader());</span><br><span class="line">         enhancer.setSuperClass(userService.getClass());</span><br><span class="line">         </span><br><span class="line">     </span><br><span class="line">         <span class="type">MethodInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>()&#123;</span><br><span class="line">     </span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等同于 InvocationHandler --- invoke</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;------cglib log ------&quot;</span>);</span><br><span class="line">       <span class="comment">// 原始方法运行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(userService,args);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">         enhancer.setCallback(interceptor);</span><br><span class="line">         <span class="type">UserService</span> <span class="variable">userServiceProxy</span> <span class="operator">=</span> (UserService)enhancer.create();</span><br><span class="line">         </span><br><span class="line">         userServiceProxy.login(<span class="string">&quot;suns&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">         userServiceProxy.register(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于 @EnableAspectJAutoProxy 注解，在AopAutoConfiguration这个类里可以看到相关定义。</p><p>Cglib代理：@EnableAspectJAutoProxy(proxyTargetClass &#x3D; true) </p><p>JDK代理：@EnableAspectJAutoProxy(proxyTargetClass &#x3D; false) </p><p><strong>Spring AOP 代理默认实现 JDK，SpringBoot AOP 代理默认实现 Cglib。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(Advice.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AspectJAutoProxyingConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JdkDynamicAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CglibAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AOP源码"><a href="#AOP源码" class="headerlink" title="AOP源码"></a>AOP源码</h1><p>注解切面类名为:<code>AnnotationAwareAspectJAutoProxyCreator</code></p><p><img src="https://qiniuyun.sharkchili.com/img202304071136639.png"></p><p>从类图中我们可以看到它继承了<code>BeanPostProcessor</code>以及<code>BeanFactoryAware</code>这就意味着这个类在<code>bean</code>工厂加载期间以及<code>bean</code>初始化前后会对<code>bean</code>做一些手脚。 而且我们看到这个类继承了<code>AbstractAutoProxyCreator</code>，这就意味它的抽象类一定为当前类做了某些方法的模板，即<strong>模板方法模式</strong>。 笔者贴出了<code>bean</code>初始化前置处理器的<code>postProcessBeforeInstantiation</code>的核心逻辑，可以看到<code>AbstractAutoProxyCreator</code>里面会判断当前传入的<code>bean</code>是否是<code>AOP</code>类，如果是则将其生成通知器类然后放入缓存<code>advisedBeans</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="comment">//判断是否是AOP类，或者是否需要跳过?</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line"><span class="comment">//放到增强其的缓存中</span></span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否是<code>AOP</code>类的逻辑方法如下所示，<code>isInfrastructureClass</code>就是判断这个类是否属于通知或者切点或者通知器<code>Advisor</code>类，如果是就返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> &#123;</span><br><span class="line"><span class="comment">//判断这个类是否是切点、增强器或者需要被代理的类</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">retVal</span> <span class="operator">=</span> Advice.class.isAssignableFrom(beanClass) ||</span><br><span class="line">Pointcut.class.isAssignableFrom(beanClass) ||</span><br><span class="line">Advisor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">AopInfrastructureBean.class.isAssignableFrom(beanClass);</span><br><span class="line"><span class="keyword">if</span> (retVal &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Did not attempt to auto-proxy infrastructure class [&quot;</span> + beanClass.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否跳过的逻辑也很简单，如下所示，找到所有的通知器，判断当前这个<code>bean</code>是否这里面某个通知器名字一样，如果一样就返回<code>true</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"><span class="comment">// 这步就会找到并生成通知器类，然后和当前bean比对，如果这个bean属于通知器类则返回true</span></span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line"><span class="keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line"><span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;</span><br><span class="line">((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;</span><br><span class="line"><span class="comment">//如果和当前bean名字一样则返回true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不妨看看<code>findCandidateAdvisors</code>的逻辑，可以看到它又会调用一个<code>findCandidateAdvisors</code>查找通知器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findCandidateAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 查找通知器然后返回</span></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="built_in">super</span>.findCandidateAdvisors();</span><br><span class="line"><span class="comment">//然后创建生成通知器</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.aspectJAdvisorsBuilder != <span class="literal">null</span>) &#123;</span><br><span class="line">advisors.addAll(<span class="built_in">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑来了<code>buildAspectJAdvisors</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title function_">buildAspectJAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">List&lt;String&gt; aspectNames = <span class="built_in">this</span>.aspectBeanNames;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">aspectNames = <span class="built_in">this</span>.aspectBeanNames;</span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//将这个bean封装成factory </span></span><br><span class="line"><span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">BeanFactoryAspectInstanceFactory</span>(<span class="built_in">this</span>.beanFactory, beanName);</span><br><span class="line">Class&lt;?&gt; beanType = <span class="built_in">this</span>.beanFactory.getType(beanName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果当前这个bean类型是切面类则调用getAdvisors然后返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">List&lt;Advisor&gt; classAdvisors = <span class="built_in">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="comment">//存放到缓存中，后续调用时会用到</span></span><br><span class="line"><span class="built_in">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们不断步进就会看到，通过上述的<code>factory</code>各种参数信息找到这个<code>bean</code>的切点，切点表达式，方法名，切面名称构成一个增强器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Advisor <span class="title function_">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span><br><span class="line"><span class="params"><span class="type">int</span> declarationOrderInAspect, String aspectName)</span> &#123;</span><br><span class="line"></span><br><span class="line">validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"></span><br><span class="line"><span class="type">AspectJExpressionPointcut</span> <span class="variable">expressionPointcut</span> <span class="operator">=</span> getPointcut(</span><br><span class="line">candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"><span class="keyword">if</span> (expressionPointcut == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个增强器</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InstantiationModelAwarePointcutAdvisorImpl</span>(expressionPointcut, candidateAdviceMethod,</span><br><span class="line"><span class="built_in">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装成增强器后，如何将其他类变成代理类？-重点"><a href="#封装成增强器后，如何将其他类变成代理类？-重点" class="headerlink" title="封装成增强器后，如何将其他类变成代理类？(重点)"></a>封装成增强器后，如何将其他类变成代理类？(重点)</h2><p><strong>答:</strong> 这就到<code>bean</code>初始化后置操作了，如下代码所示，从缓存中获取这个<code>bean</code>，如果这个<code>bean</code>不在<code>earlyProxyReferences</code>中，则调用<code>wrapIfNecessary</code>，这个方法会在必要情况下根据策略决定用<code>cglib</code>或者jdk代理完成某些需要被代理的类的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="comment">// 如果这个bean不在代理缓存中，则进行增强</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="那你知道他们在bean生命周期的那个阶段实现的呢？"><a href="#那你知道他们在bean生命周期的那个阶段实现的呢？" class="headerlink" title="那你知道他们在bean生命周期的那个阶段实现的呢？"></a>那你知道他们在bean生命周期的那个阶段实现的呢？</h2><p><strong>答:</strong> 上面的类图已经写的非常清楚了，在<code>bean初始化前后</code>也就我们常说的<code>BPP阶段</code>完成<code>AOP</code>类的缓存以及通知器创建。在<code>bean</code>初始化后，根据需要结合通知器完成代理类的改造。</p><h2 id="代理的创建过程是什么呢？"><a href="#代理的创建过程是什么呢？" class="headerlink" title="代理的创建过程是什么呢？"></a>代理的创建过程是什么呢？</h2><p><strong>答:</strong> AOP提供了一个默认工厂根据类是否有继承接口或者是否就是目标类决定创建的策略。然后根据不同的策略决定代理类的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line"><span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下便是<code>jdk</code>代理的创建策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">.........</span><br><span class="line"><span class="comment">//获取被代理的类的接口</span></span><br><span class="line">Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised, <span class="literal">true</span>);</span><br><span class="line">findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成代理对象并返回</span></span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下便是<code>cglib</code>的创建策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">.......</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">.......</span><br><span class="line">将当前类信息通过enhancer 生成代理对象</span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> createEnhancer();</span><br><span class="line"><span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">enhancer.setClassLoader(classLoader);</span><br><span class="line"><span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised));</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> <span class="title class_">ClassLoaderAwareGeneratorStrategy</span>(classLoader));</span><br><span class="line"></span><br><span class="line">Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">Class&lt;?&gt;[] types = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[callbacks.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">types[x] = callbacks[x].getClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回最终生成的代理对象</span></span><br><span class="line"><span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">&#125;</span><br><span class="line">........</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="手写事务-AOP实现"><a href="#手写事务-AOP实现" class="headerlink" title="手写事务-AOP实现"></a>手写事务-AOP实现</h1><p>基于以上对 AOP 的理解，我们可以自己实现AOP，就以事务的实现为例。</p><p>首先列出建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `user_test`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_test` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `balance` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">9</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `user_test` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `user_test` <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="自定义事务注解"><a href="#自定义事务注解" class="headerlink" title="自定义事务注解"></a>自定义事务注解</h2><p>对于声明式的事务，我们可以自定义注解实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTransaction &#123;</span><br><span class="line">    Propagation <span class="title function_">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务的传播属性可以在枚举类中定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Propagation</span> &#123;</span><br><span class="line"></span><br><span class="line">    REQUIRED(<span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    REQUIRES_NEW(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    Propagation(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据库连接资源管理"><a href="#数据库连接资源管理" class="headerlink" title="数据库连接资源管理"></a>数据库连接资源管理</h2><p>数据库的连接是由 ThreadLocal 控制的，ThreadLocal 存储的类型是一个 Map<br>Map 中的 key 是 DataSource，value 是 Connection（为了应对多数据源的情况，所以是一个 Map）<br>用了 ThreadLocal 保证了同一个线程获取一个 Connection 对象，从而保证一次事务的所有操作需要在同一个数据库连接上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ConnectionHolder&gt; CONNECTION_THREAD_LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Connection curConnection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  上一个方法的</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">private</span> ConnectionHolder lastConnectionHolder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unbindResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">lastConnectionHolder</span> <span class="operator">=</span> CONNECTION_THREAD_LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (lastConnectionHolder == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置当前连接为上一个方法的连接</span></span><br><span class="line">        <span class="comment">// 第一个ConnectionHolder的lastConnectionHolder属性为null，间接释放资源</span></span><br><span class="line">        CONNECTION_THREAD_LOCAL.set(lastConnectionHolder.getLastConnectionHolder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  获取资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConnectionHolder <span class="title function_">getResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CONNECTION_THREAD_LOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  绑定(set)资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bindResource</span><span class="params">(ConnectionHolder connectionHolder)</span> &#123;</span><br><span class="line">        CONNECTION_THREAD_LOCAL.set(connectionHolder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getCurConnectionStatic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">connectionHolder</span> <span class="operator">=</span> ConnectionHolder.getResource();</span><br><span class="line">        <span class="keyword">return</span> connectionHolder != <span class="literal">null</span> ? connectionHolder.getCurConnection() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getCurConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> curConnection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurConnection</span><span class="params">(Connection curConnection)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.curConnection = curConnection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConnectionHolder <span class="title function_">getLastConnectionHolder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastConnectionHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastConnectionHolder</span><span class="params">(ConnectionHolder lastConnectionHolder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lastConnectionHolder = lastConnectionHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p>自定义事务管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TransactionManager</span><span class="params">(ObjectProvider&lt;DataSource&gt; dataSourceProvider)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSourceProvider.getIfAvailable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TransactionInfo <span class="title function_">createTransactionIfNecessary</span><span class="params">(MyTransaction miniTransactional)</span> &#123;</span><br><span class="line">        <span class="type">TransactionInfo</span> <span class="variable">transactionInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionInfo</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">needNew</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (miniTransactional != <span class="literal">null</span> &amp;&amp; miniTransactional.propagation() == Propagation.REQUIRES_NEW) &#123;</span><br><span class="line">            needNew = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取连接（可能会调用setAutoCommit）</span></span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">curConnectionHolder</span> <span class="operator">=</span> transactionInfo.createConnectionIfNecessary(<span class="built_in">this</span>.dataSource, needNew);</span><br><span class="line">        transactionInfo.setConnection(curConnectionHolder.getCurConnection());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定ThreadLocal</span></span><br><span class="line">        ConnectionHolder.bindResource(curConnectionHolder);</span><br><span class="line">        <span class="keyword">return</span> transactionInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rollBack</span><span class="params">(TransactionInfo transactionInfo)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (transactionInfo.isNewTransaction()) &#123;</span><br><span class="line">                <span class="comment">// 执行回滚事务</span></span><br><span class="line">                transactionInfo.getConnection().rollback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理资源</span></span><br><span class="line">            TransactionManager.cleanupAfterCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionInfo transactionInfo)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (transactionInfo.isNewTransaction()) &#123;</span><br><span class="line">                <span class="comment">// 执行提交事务</span></span><br><span class="line">                transactionInfo.getConnection().commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理资源</span></span><br><span class="line">            TransactionManager.cleanupAfterCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cleanupAfterCompletion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 先将当前连接还回连接池</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">curConnection</span> <span class="operator">=</span> ConnectionHolder.getCurConnectionStatic();</span><br><span class="line">        <span class="keyword">if</span>(curConnection!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curConnection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再重置当前连接为上一个方法的连接</span></span><br><span class="line">        ConnectionHolder.unbindResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 transactionInfo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前connection是否为事务创建者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">newTransaction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConnectionHolder <span class="title function_">createConnectionIfNecessary</span><span class="params">(DataSource dataSource, <span class="type">boolean</span> needNew)</span> &#123;</span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">curConnectionHolder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">lastConnectionHolder</span> <span class="operator">=</span> ConnectionHolder.getResource();</span><br><span class="line">        <span class="keyword">if</span> (lastConnectionHolder == <span class="literal">null</span> || needNew) &#123;</span><br><span class="line">            curConnectionHolder = newOneConnectionHolder(dataSource, lastConnectionHolder);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!needNew) &#123;</span><br><span class="line">            curConnectionHolder = lastConnectionHolder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curConnectionHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConnectionHolder <span class="title function_">newOneConnectionHolder</span><span class="params">(DataSource dataSource, ConnectionHolder lastConnectionHolder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.newTransaction = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">connectionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionHolder</span>();</span><br><span class="line">        connectionHolder.setLastConnectionHolder(lastConnectionHolder);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">newConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newConnection = dataSource.getConnection();</span><br><span class="line">            <span class="comment">// fixme 关闭自动提交，间接开启事务</span></span><br><span class="line">            newConnection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        connectionHolder.setCurConnection(newConnection);</span><br><span class="line">        <span class="keyword">return</span> connectionHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConnection</span><span class="params">(Connection connection)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connection = connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNewTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newTransaction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNewTransaction</span><span class="params">(<span class="type">boolean</span> newTransaction)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.newTransaction = newTransaction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AOP实现事务逻辑"><a href="#AOP实现事务逻辑" class="headerlink" title="AOP实现事务逻辑"></a>AOP实现事务逻辑</h2><p>使用@Aspect实现AOP，定义切入点和真正实现AOP的切面方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">TransactionAspect</span><span class="params">(TransactionManager transactionManager)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.transactionManager = transactionManager;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Pointcut(value = &quot;@within(com.jrrl.transaction.aop.MyTransaction)&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">point</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around(&quot;point()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">MyTransaction</span> <span class="variable">myTransaction</span> <span class="operator">=</span> ((MethodSignature) joinPoint.getSignature()).getMethod().getAnnotation(MyTransaction.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化 transactionInfo</span></span><br><span class="line">        <span class="type">TransactionInfo</span> <span class="variable">transactionInfo</span> <span class="operator">=</span> transactionManager.createTransactionIfNecessary(myTransaction);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用目标方法</span></span><br><span class="line">            res = joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 回滚事务</span></span><br><span class="line">            transactionManager.rollBack(transactionInfo);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        transactionManager.commit(transactionInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务的传播属性"><a href="#事务的传播属性" class="headerlink" title="事务的传播属性"></a>事务的传播属性</h2><table><thead><tr><th>传播属性</th><th>概念</th><th>建议</th></tr></thead><tbody><tr><td><strong><code>PROPAGATION_REQUIRED</code></strong></td><td>（默认传播属性）如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</td><td>增删改操作@Transactional(rollbackFor &#x3D; Exception.class)</td></tr><tr><td><strong><code>PROPAGATION_SUPPORTS</code></strong></td><td>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</td><td>查询操作@Transactional(propagation&#x3D;Propagation.SUPPORTS, readOnly &#x3D; true)</td></tr><tr><td><strong><code>PROPAGATION_REQUIRES_NEW</code></strong></td><td>创建一个新的事务，如果当前存在事务，则把当前事务挂起。</td><td></td></tr><tr><td><strong><code>PROPAGATION_NESTED</code></strong></td><td>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</td><td></td></tr><tr><td><strong><code>PROPAGATION_MANDATORY</code></strong></td><td>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</td><td></td></tr></tbody></table><blockquote><p>需要注意的是，在同一个类中非事务方法调用事务方法，事务失效问题</p></blockquote><p><strong>原因：</strong></p><p>spring 在扫描bean的时候会扫描方法上是否包含@Transactional注解，如果包含，spring会为这个bean动态地生成一个子类（即代理类，proxy），代理类是继承原来那个bean的。此时，当这个有注解的方法被调用的时候，实际上是由代理类来调用的，代理类在调用之前就会启动transaction。</p><p>然而，如果这个有注解的方法是被同一个类中的其他方法调用的，那么该方法的调用并没有通过代理类，而是直接通过原来的那个bean，所以就不会启动transaction，我们看到的现象就是@Transactional注解无效。</p><p>解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">noneTransactionMethod</span><span class="params">()</span>&#123; <span class="comment">//非事务方法</span></span><br><span class="line">    <span class="type">xxxServiceImpl</span> <span class="variable">bean</span> <span class="operator">=</span> SpringUtils.getBean(xxxServiceImpl.class);</span><br><span class="line">    bean.transactionMethod();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionMethod</span><span class="params">()</span>&#123; <span class="comment">// 事务方法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对AOP的理解&quot;&gt;&lt;a href=&quot;#对AOP的理解&quot; class=&quot;headerlink&quot; title=&quot;对AOP的理解&quot;&gt;&lt;/a&gt;对AOP的理解&lt;/h1&gt;&lt;p&gt;&lt;code&gt;AOP(Aspect-Oriented Programming:面向切面编程)&lt;/cod</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://palette-k.github.io/tags/Spring/"/>
    
    <category term="AOP" scheme="https://palette-k.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis源码</title>
    <link href="https://palette-k.github.io/2023/12/20/MyBatis%E6%BA%90%E7%A0%81/"/>
    <id>https://palette-k.github.io/2023/12/20/MyBatis%E6%BA%90%E7%A0%81/</id>
    <published>2023-12-20T10:24:15.000Z</published>
    <updated>2024-01-25T08:46:49.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis-执行流程"><a href="#MyBatis-执行流程" class="headerlink" title="MyBatis 执行流程"></a>MyBatis 执行流程</h1><p>首先回顾一下jdbc的执行流程。</p><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MyBatis/jdbc.png"></p><p>MyBatis的执行流程也包含jdbc的执行流程，但是会做一些前置处理。</p><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MyBatis/MyBatis.png"></p><h2 id="方法代理-MapperMethod"><a href="#方法代理-MapperMethod" class="headerlink" title="方法代理(MapperMethod)"></a>方法代理(MapperMethod)</h2><p>使用动态代理调用，可以看到非常熟悉的 invoke 方法，这个invoke方法就是动态代理的逻辑，method.invoke()方法就是实现代理类对原始方法的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6424540398559729838L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="built_in">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="built_in">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="会话-SqlSession"><a href="#会话-SqlSession" class="headerlink" title="会话(SqlSession)"></a>会话(SqlSession)</h2><p>SqlSession 是myBatis的门面(采用门面模式设计)，核心作用是为用户提供API。API包括增、删、改、查以及提交、关闭等。其自身是没有能力处理这些请求的，所以内部会包含一个唯一的执行器 Executor，所有请求都会交给执行器来处理。</p><p>SqlSession 是SqlSessionFactory会话工厂创建出来的一个会话的对象，这个SqlSession对象用于执行具体的SQL语句并返回给用户请求的结果。</p><h2 id="执行器-Executor"><a href="#执行器-Executor" class="headerlink" title="执行器(Executor)"></a>执行器(Executor)</h2><p>Executor是一个大管家，核心功能包括：缓存维护、获取动态SQL、获取连接、以及最终的JDBC调用等。在图中所有蓝色节点全部都是在Executor中完成。</p><p>这么多事情无法全部亲力亲为，就需要把任务分派下去。所以Executor内部还会包含若干个组件：</p><ul><li>缓存维护：cache</li><li>获取连接：Transaction</li><li>获取动态sql：SqlSource</li><li>调用jdbc：StatementHandler</li></ul><p>上述组件中前三个和Executor是1对1关系，只有StatementHandler是1对多。每执行一次SQL 就会构造一个新的StatementHandler。StatementHandler的作用就是专门和JDBC打交道，执行SQL的。</p><h3 id="SQL处理器-StatementHandler"><a href="#SQL处理器-StatementHandler" class="headerlink" title="SQL处理器(StatementHandler)"></a>SQL处理器(StatementHandler)</h3><p>在JDBC中执行一次sql的步骤包括。预编译SQL、设置参数然后执行。StatementHandler就是用来处理这三步。</p><p>用于获取预处理器，共有三种类型。通过statementType&#x3D;<code>&quot;STATEMENT|PREPARED|CALLABLE&quot;</code> 可分别进行指定。</p><ul><li>PreparedStatementHandler：带预处理的执行器</li><li>CallableStatementHandler：存储过程执行器</li><li>SimpleStatementHandler：基于Sql执行器</li></ul><p>同样它也需要两个助手分别是：</p><ul><li>设置参数：ParameterHandler</li><li>读取结果：ResultSetHandler，可在SqlSession中查询时自行定义ResultSetHandler</li></ul><p>另外的执行是由它自己完成。</p><h1 id="主键生成"><a href="#主键生成" class="headerlink" title="主键生成"></a>主键生成</h1><p>在平时开发的时候经常会有这样的需求，插入数据返回主键，或者插入数据之前需要获取主键，这样的需求在 mybatis 中也是支持的。只需要在 xml 里配置 useGenerateKey &#x3D; true 就好了。</p><p>其中主要的逻辑部分就在 KeyGenerator 中，其接口方法如下：</p><p>processBefore 是在生成 StatementHandler 的时候执行，processAfter 则是在完成插入返回结果之前执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">KeyGenerator</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">processBefore</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">processAfter</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所见 KeyGenerator 非常的简单，主要是通过两个拦截方法实现的：</p><ul><li>Jdbc3KeyGenerator：主要基于 java.sql.Statement.getGeneratedKeys 的主键返回接口实现的，所以他不需要 processBefore 方法，只需要在获取到结果后使用 processAfter 拦截，然后用反射将主键设置到参数中即可；</li><li>SelectKeyGenerator：主要是通过 XML 配置或者注解设置 <strong>selectKey</strong> ，然后单独发出查询语句，在返回拦截方法中使用反射设置主键，其中两个拦截方法只能使用其一，在 <strong>selectKey.order</strong> 属性中设置 <code>AFTER|BEFORE</code> 来确定；</li></ul><h1 id="MyBatis-缓存"><a href="#MyBatis-缓存" class="headerlink" title="MyBatis 缓存"></a>MyBatis 缓存</h1><p>myBatis中存在两个缓存，一级缓存和二级缓存。</p><ul><li>一级缓存：也叫做会话级缓存，生命周期仅存在于当前会话，不可以直接关关闭。但可以通过flushCache和localCacheScope对其做相应控制。</li><li>二级缓存：也叫应用级性缓存，缓存对象存在于整个应用周期，而且可以跨线程使用。</li></ul><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><h3 id="一级缓存的命中场景"><a href="#一级缓存的命中场景" class="headerlink" title="一级缓存的命中场景"></a>一级缓存的命中场景</h3><p>关于一级缓存的命中可大致分为两个场景，满足特定命中参数，第二不触发清空方法。</p><h4 id="缓存命中参数："><a href="#缓存命中参数：" class="headerlink" title="缓存命中参数："></a>缓存命中参数：</h4><ol><li>SQL与参数相同：</li><li>同一个会话：</li><li>相同的MapperStatement ID：</li><li>RowBounds行范围相同：</li></ol><h4 id="触发清空缓存"><a href="#触发清空缓存" class="headerlink" title="触发清空缓存"></a>触发清空缓存</h4><ol><li>手动调用clearCache</li><li>执行提交回滚</li><li>执行update</li><li>配置flushCache&#x3D;true</li><li>缓存作用域为Statement</li></ol><h3 id="一级缓存源码解析"><a href="#一级缓存源码解析" class="headerlink" title="一级缓存源码解析"></a>一级缓存源码解析</h3><p>一级缓存逻辑就存在于 BaseExecutor (基础执行器)里面。当会话接收到查询请求之后，会交给执行器的Query方法，在这里会通过 Sql、参数、分页条件等参数创建一个缓存key，在基于这个key去 PerpetualCache中查找对应的缓存值，如果有命中直接返回。没有就会查询数据库，然后在填充缓存。最终缓存的实现非常简单，就是一个HashMap。</p><h4 id="一级缓存的清空"><a href="#一级缓存的清空" class="headerlink" title="一级缓存的清空"></a>一级缓存的清空</h4><p>缓存的清空对应BaseExecutor中的 clearLocalCache.方法。只要找到调用该方法地方，就知道哪些场景中会清空缓存了。</p><ul><li>update: 执行任意增删改</li><li>select：查询又分为两种情况清空，一前置清空，即配置了flushCache&#x3D;true。二后置清空，配置了缓存作用域为statement 查询结束合会清空缓存。</li><li>commit：提交前清空</li><li>Rolback：回滚前清空</li></ul><blockquote><p>注意：clearLocalCache 不是清空某条具体数据，而清当前会话下所有一级缓存数据。</p></blockquote><h3 id="MyBatis集成Spring后一级缓存失效的问题？"><a href="#MyBatis集成Spring后一级缓存失效的问题？" class="headerlink" title="MyBatis集成Spring后一级缓存失效的问题？"></a>MyBatis集成Spring后一级缓存失效的问题？</h3><p>很多人发现，集成一级缓存后会话失效了，以为是spring Bug ，真正原因是Spring 对SqlSession进行了封装，通过SqlSessionTemplae ，使得每次调用Sql，都会重新构建一个SqlSession，具体参见SqlSessionInterceptor。而根据前面所学，一级缓存必须是同一会话才能命中,所以在这些场景当中不能命中。</p><p>怎么解决呢？给Spring 添加事物 即可。添加事物之后，SqlSessionInterceptor(会话拦截器)就会去判断两次请求是否在同一事物当中，如果是就会共用同一个SqlSession会话来解决。</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>二级缓存也称作是应用级缓存，与一级缓存不同的，是它的作用范围是整个应用，而且可以跨线程使用。所以二级缓存有更高的命中率，适合缓存一些修改较少的数据。在流程上是先访问二级缓存，再访问一级缓存。</p><p>MyBatis抽象出Cache接口，其只定义了缓存中最基本的功能方法：</p><ul><li>设置缓存</li><li>获取缓存</li><li>清除缓存</li><li>获取缓存数量</li></ul><p>然后上述中每一个功能都会对应一个组件类，并基于装饰者加责任链的模式，将各个组件进行串联。在执行缓存的基本功能时，其它的缓存逻辑会沿着这个责任链依次往下传递。</p><p>这样设计有以下优点：</p><ol><li>职责单一：各个节点只负责自己的逻辑，不需要关心其它节点。</li><li>扩展性强：可根据需要扩展节点、删除节点，还可以调换顺序保证灵活性。</li><li>松耦合：各节点之间不没强制依赖其它节点。而是通过顶层的Cache接口进行间接依赖。</li></ol><h3 id="缓存空间声明"><a href="#缓存空间声明" class="headerlink" title="缓存空间声明"></a>缓存空间声明</h3><p>二级默认缓存默认是不开启的，需要为其声明缓存空间才可以使用，通过@CacheNamespace 或 为指定的MappedStatement声明。声明之后该缓存为该Mapper所独有，其它Mapper不能访问。如需要多个Mapper共享一个缓存空间可通过@CacheNamespaceRef 或进行引用同一个缓存空间。</p><h3 id="二级缓存的命中条件"><a href="#二级缓存的命中条件" class="headerlink" title="二级缓存的命中条件"></a>二级缓存的命中条件</h3><p>二级缓存的命中场景与一级缓存类似，不同在于二级可以跨会放使用，还有就是二级缓存的更新，为了保证数据一至性，二级缓存必须是会话提交之才会真正填充，包括对缓存的清空，也必须是会话正常提交之后才生效。</p><h3 id="二级缓存结构"><a href="#二级缓存结构" class="headerlink" title="二级缓存结构"></a>二级缓存结构</h3><p>为了实现会话提交之后才变更二级缓存，MyBatis为每个会话设立了若干个暂存区，当前会话对指定缓存空间的变更，都存放在对应的暂存区，当会话提交之后才会提交到每个暂存区对应的缓存空间。为了统一管理这些暂存区，每个会话都一个唯一的事物缓存管理器。所以这里暂存区也可叫做事物缓存。</p><h3 id="二级缓存的执行流程"><a href="#二级缓存的执行流程" class="headerlink" title="二级缓存的执行流程"></a>二级缓存的执行流程</h3><p>原本会话是通过Executor实现SQL调用，这里基于装饰器模式使用CachingExecutor对SQL调用逻辑进行拦截。以嵌入二级缓存相关逻辑。</p><h4 id="查询操作query"><a href="#查询操作query" class="headerlink" title="查询操作query"></a>查询操作query</h4><p>当会话调用query() 时，会基于查询语句、参数等数据组成缓存Key，然后尝试从二级缓存中读取数据。读到就直接返回，没有就调用被装饰的Executor去查询数据库，然后在填充至对应的暂存区。</p><blockquote><p>请注意，这里的查询是实时从缓存空间读取的，而变更，只会记录在暂存区</p></blockquote><h4 id="更新操作update"><a href="#更新操作update" class="headerlink" title="更新操作update"></a>更新操作update</h4><p>当执行update操作时，同样会基于查询的语句和参数组成缓存KEY，然后在执行update之前清空缓存。这里清空只针对暂存区，同时记录清空的标记，以便当会话提交之时，依据该标记去清空二级缓存空间。</p><blockquote><p>如果在查询操作中配置了flushCache&#x3D;true ，也会执行相同的操作。</p></blockquote><h4 id="提交操作commit"><a href="#提交操作commit" class="headerlink" title="提交操作commit"></a>提交操作commit</h4><p>当会话执行commit操作后，会将该会话下所有暂存区的变更，更新到对应二级缓存空间去。</p><h1 id="Hibernate和MyBatis的区别"><a href="#Hibernate和MyBatis的区别" class="headerlink" title="Hibernate和MyBatis的区别"></a>Hibernate和MyBatis的区别</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。</p><p>其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。Hibernate和MyBatis都支持 JDBC 和 JTA 事务处理。</p><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h3 id="hibernate是全自动，而mybatis是半自动"><a href="#hibernate是全自动，而mybatis是半自动" class="headerlink" title="hibernate是全自动，而mybatis是半自动"></a>hibernate是全自动，而mybatis是半自动</h3><p>hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p><h3 id="hibernate数据库移植性远大于mybatis"><a href="#hibernate数据库移植性远大于mybatis" class="headerlink" title="hibernate数据库移植性远大于mybatis"></a>hibernate数据库移植性远大于mybatis</h3><p>hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（Oracle、MySQL等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于程序员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。</p><h3 id="hibernate拥有完整的日志系统"><a href="#hibernate拥有完整的日志系统" class="headerlink" title="hibernate拥有完整的日志系统"></a>hibernate拥有完整的日志系统</h3><p>hibernate日志系统非常健全，涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等；而mybatis则除了基本记录功能外，功能薄弱很多。</p><h3 id="mybatis相比hibernate需要关心很多细节"><a href="#mybatis相比hibernate需要关心很多细节" class="headerlink" title="mybatis相比hibernate需要关心很多细节"></a>mybatis相比hibernate需要关心很多细节</h3><p>hibernate配置要比mybatis复杂的多，学习成本也比mybatis高。但也正因为mybatis使用简单，才导致它要比hibernate关心很多技术细节。mybatis由于不用考虑很多细节，开发模式上与传统jdbc区别很小，因此很容易上手并开发项目，但忽略细节会导致项目前期bug较多，因而开发出相对稳定的软件很慢，而开发出软件却很快。hibernate则正好与之相反。但是如果使用hibernate很熟练的话，实际上开发效率丝毫不差于甚至超越mybatis。</p><h3 id="sql直接优化上，mybatis要比hibernate方便很多"><a href="#sql直接优化上，mybatis要比hibernate方便很多" class="headerlink" title="sql直接优化上，mybatis要比hibernate方便很多"></a>sql直接优化上，mybatis要比hibernate方便很多</h3><p>由于mybatis的sql都是写在xml里，因此优化sql比hibernate方便很多。而hibernate的sql很多都是自动生成的，无法直接维护sql；虽有hql，但功能还是不及sql强大，见到报表等变态需求时，hql也歇菜，也就是说hql是有局限的；hibernate虽然也支持原生sql，但开发模式上却与orm不同，需要转换思维，因此使用上不是非常方便。总之写sql的灵活度上hibernate不及mybatis。</p><h3 id="缓存机制上，hibernate要比mybatis更好一些"><a href="#缓存机制上，hibernate要比mybatis更好一些" class="headerlink" title="缓存机制上，hibernate要比mybatis更好一些"></a>缓存机制上，hibernate要比mybatis更好一些</h3><p>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p><p>而Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MyBatis-执行流程&quot;&gt;&lt;a href=&quot;#MyBatis-执行流程&quot; class=&quot;headerlink&quot; title=&quot;MyBatis 执行流程&quot;&gt;&lt;/a&gt;MyBatis 执行流程&lt;/h1&gt;&lt;p&gt;首先回顾一下jdbc的执行流程。&lt;/p&gt;
&lt;p&gt;&lt;img s</summary>
      
    
    
    
    
    <category term="原理" scheme="https://palette-k.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
    <category term="MyBatis" scheme="https://palette-k.github.io/tags/MyBatis/"/>
    
    <category term="源码" scheme="https://palette-k.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jdbc的演变</title>
    <link href="https://palette-k.github.io/2023/12/20/jdbc%E7%9A%84%E6%BC%94%E5%8F%98/"/>
    <id>https://palette-k.github.io/2023/12/20/jdbc%E7%9A%84%E6%BC%94%E5%8F%98/</id>
    <published>2023-12-20T02:05:22.000Z</published>
    <updated>2023-12-20T11:04:57.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jdbc流程"><a href="#jdbc流程" class="headerlink" title="jdbc流程"></a>jdbc流程</h1><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MyBatis/jdbc.png"></p><h1 id="jdbc操作"><a href="#jdbc操作" class="headerlink" title="jdbc操作"></a>jdbc操作</h1><h2 id="jdbc连接"><a href="#jdbc连接" class="headerlink" title="jdbc连接"></a>jdbc连接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//1.加载配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span></span><br><span class="line">ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pros.load(is);</span><br><span class="line"><span class="comment">//2.读取配置信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"><span class="comment">//3.加载驱动</span></span><br><span class="line">Class.forName(driverClass);</span><br><span class="line"><span class="comment">//4.获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password);</span><br><span class="line">System.out.println(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><h2 id="使用PreparedStatement实现增删改操作"><a href="#使用PreparedStatement实现增删改操作" class="headerlink" title="使用PreparedStatement实现增删改操作"></a>使用PreparedStatement实现增删改操作</h2><p>可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p><h3 id="PreparedStatement-vs-Statement"><a href="#PreparedStatement-vs-Statement" class="headerlink" title="PreparedStatement vs Statement"></a>PreparedStatement vs Statement</h3><ul><li><p>代码的可读性和可维护性。 </p></li><li><p>PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的 编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) </p></li><li><p>PreparedStatement 可以防止 SQL 注入</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String sql,Object ... args)</span>&#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1.获取数据库的连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">//2.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">//3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.执行sql语句</span></span><br><span class="line">ps.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//5.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用PreparedStatement实现查询操作"><a href="#使用PreparedStatement实现查询操作" class="headerlink" title="使用PreparedStatement实现查询操作"></a>使用PreparedStatement实现查询操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getInstance</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取数据库连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">// 2.预编译sql语句，得到PreparedStatement对象</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4.执行executeQuery(),得到结果集：ResultSet</span></span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="comment">// 5.得到结果集的元数据：ResultSetMetaData</span></span><br><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"><span class="comment">// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnCount; i++) &#123;<span class="comment">// 遍历每一个列</span></span><br><span class="line"><span class="comment">// 获取列值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">columnVal</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 获取列的别名:列的别名，使用类的属性名充当</span></span><br><span class="line"><span class="type">String</span> <span class="variable">columnLabel</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 6.2使用反射，给对象的相应属性赋值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnLabel);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 7.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jdbc事务处理"><a href="#jdbc事务处理" class="headerlink" title="jdbc事务处理"></a>jdbc事务处理</h2><ul><li><p>调用 Connection 对象的 setAutoCommit(false); </p></li><li><p>以取消自动提交事务在所有的 SQL 语句都成功执行后，调用 commit(); </p></li><li><p>方法提交事务在出现异常时，调用 rollback(); 方法回滚事务</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJDBCTransaction</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取数据库连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">// 2.开启事务</span></span><br><span class="line">conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 3.进行数据库操作</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance - 100 where user = ?&quot;</span>;</span><br><span class="line">update(conn, sql1, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line"><span class="comment">// 模拟网络异常</span></span><br><span class="line"><span class="comment">//System.out.println(10 / 0);</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance + 100 where user = ?&quot;</span>;</span><br><span class="line">update(conn, sql2, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"><span class="comment">// 4.若没有异常，则提交事务</span></span><br><span class="line">conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">// 5.若有异常，则回滚事务</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//6.恢复每次DML操作的自动提交功能</span></span><br><span class="line">conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7.关闭连接</span></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到的 update 方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Connection conn ,String sql, Object... args)</span> &#123;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 2.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.执行sql语句</span></span><br><span class="line">ps.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 4.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(<span class="literal">null</span>, ps);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Druid数据库连接池"><a href="#Druid数据库连接池" class="headerlink" title="Druid数据库连接池"></a>Druid数据库连接池</h1><p>如果使用传统的jdbc连接方式，可能会出现以下问题：</p><ul><li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求 一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用</strong>。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严 重的甚至会造成服务器的崩溃。 </li><li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统 中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？） </li><li><strong>这种开发不能控制被创建的连接对象数，</strong>系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内 存泄漏，服务器崩溃。</li></ul><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 </p><p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 </p><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了 日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDruid</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">    System.out.println(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【druid.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">20</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">filters</span>=<span class="string">wall</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jdbc流程&quot;&gt;&lt;a href=&quot;#jdbc流程&quot; class=&quot;headerlink&quot; title=&quot;jdbc流程&quot;&gt;&lt;/a&gt;jdbc流程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ashleyblog.oss-cn-shenzhen.aliyuncs.</summary>
      
    
    
    
    
    <category term="jdbc" scheme="https://palette-k.github.io/tags/jdbc/"/>
    
    <category term="Druid" scheme="https://palette-k.github.io/tags/Druid/"/>
    
  </entry>
  
  <entry>
    <title>自定义starter</title>
    <link href="https://palette-k.github.io/2023/12/19/%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
    <id>https://palette-k.github.io/2023/12/19/%E8%87%AA%E5%AE%9A%E4%B9%89starter/</id>
    <published>2023-12-19T02:07:52.000Z</published>
    <updated>2023-12-19T07:57:03.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="starter介绍"><a href="#starter介绍" class="headerlink" title="starter介绍"></a>starter介绍</h1><p><strong>Spring Boot Starter是什么？</strong></p><p>Spring Boot Starter可以被理解为一种依赖的集合，也可以看作是一个空的项目，它由<a href="http://pom.xml/">pom.xml</a>文件配置了一堆jar包的组合。</p><p><strong>Spring Boot Starter解决了什么问题？</strong></p><p>Spring Boot Starter解决了手动配置大量依赖项和参数的问题。在Spring Boot之前，如果要开发一个Web应用程序，需要手动添加很多依赖项，如Servlet、JSP、JSTL等，并且还需要配置很多参数，如数据源、事务管理器等。而通过使用Spring Boot Starter，开发者只需要添加一个Starter依赖，就可以轻松地集成各种不同的功能模块，而无需关心底层的配置和集成细节。</p><p><strong>Spring Boot Starter的价值是什么？</strong></p><p>Spring Boot Starter的价值在于它能够提高开发效率和代码质量，同时减少开发成本和复杂度。通过使用Starter，开发者可以专注于业务逻辑的实现，而不需要关心底层的配置和集成细节。另外，Starter还支持更快的迭代和部署，因为它们通常包含了一些可重用的依赖库和自动配置类。</p><h1 id="SpringBoot-starter封装方法"><a href="#SpringBoot-starter封装方法" class="headerlink" title="SpringBoot starter封装方法"></a>SpringBoot starter封装方法</h1><h2 id="第1步：定义一个XXXProperties的类文件"><a href="#第1步：定义一个XXXProperties的类文件" class="headerlink" title="第1步：定义一个XXXProperties的类文件"></a>第1步：定义一个XXXProperties的类文件</h2><p>用于抽象化原有的配置属性与增加新的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(GrowingioProperties.GROWINGIO_PREFIX)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrowingioProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GROWINGIO_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;growingio&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目采集端地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String apiHost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String projectId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息发送间隔时间,单位ms（默认 100）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">sendMsgInterval</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息发送线程数量,默认为3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">sendMsgThread</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息队列大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">msgStoreQueueSize</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据压缩 false:不压缩, true:压缩 不压缩可节省cpu，压缩可省带宽</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">compress</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志输出级别（debug | error）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">loggerLevel</span> <span class="operator">=</span> <span class="string">&quot;debug&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义日志输出实现类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">loggerImplemention</span> <span class="operator">=</span> <span class="string">&quot;com.my.growingio.log.GrowingioLogger&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行模式，test：仅输出消息体，不发送消息，production：发送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">runMode</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * http 连接超时时间，默认2000ms</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">connectionTimeout</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * http 连接读取时间，默认2000ms</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">readTimeout</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否启用:自定义属性:标识是否启用，默认为不启用，非growing io 官方属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">enable</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第2步：定义XXXAutoConfiguration的类文件"><a href="#第2步：定义XXXAutoConfiguration的类文件" class="headerlink" title="第2步：定义XXXAutoConfiguration的类文件"></a>第2步：定义XXXAutoConfiguration的类文件</h2><p>将核心的业务处理类，初始化核心业务处理类并注入到IOC中，通常写在XXXAutoConfiguration的类文件文件中。</p><p>GrowingioAutoConfiguration这个类主要是方便做bean的注册，@ComponentScan这个注解会扫描并加载属性basePackages指定的包路径下所有bean，就不用在spring.factories文件逐个写了，只用写这个类就行了。@SpringBootApplication启动类注解也使用了@ComponentScan。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(GrowingioProperties.class)</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.my.growingio&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrowingioAutoConfiguration</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(GrowingioAutoConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> GrowingioProperties growingioProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GrowingioService <span class="title function_">growingioService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GrowingioServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//校验并开始检查是否配置必填的属性</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(growingioProperties.getApiHost()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;growing properties api.host must be defined&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(growingioProperties.getProjectId()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;growing properties project.id must be defined&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 页面初始化执行函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.checkProperties();</span><br><span class="line">        <span class="comment">//初始化配置</span></span><br><span class="line">        <span class="built_in">this</span>.initGrowingioApiProperties();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initGrowingioApiProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(GrowingioConstant.API_HOST_KEY, growingioProperties.getApiHost());</span><br><span class="line">        properties.setProperty(GrowingioConstant.PROJECT_ID_KEY, growingioProperties.getProjectId());</span><br><span class="line">        properties.setProperty(GrowingioConstant.SEND_MSG_INTERVAL_KEY, growingioProperties.getSendMsgInterval().toString());</span><br><span class="line">        properties.setProperty(GrowingioConstant.SEND_MSG_THREAD_KEY, growingioProperties.getSendMsgThread().toString());</span><br><span class="line">        properties.setProperty(GrowingioConstant.MSG_STORE_QUEUE_SIZE_KEY, growingioProperties.getMsgStoreQueueSize().toString());</span><br><span class="line">        properties.setProperty(GrowingioConstant.COMPRESS_KEY, growingioProperties.getCompress().toString());</span><br><span class="line">        properties.setProperty(GrowingioConstant.LOGGER_LEVEL_KEY, growingioProperties.getLoggerLevel());</span><br><span class="line">        properties.setProperty(GrowingioConstant.LOGGER_IMPL_KEY, growingioProperties.getLoggerImplemention());</span><br><span class="line">        properties.setProperty(GrowingioConstant.RUN_MODE_KEY, growingioProperties.getRunMode());</span><br><span class="line">        properties.setProperty(GrowingioConstant.CONNECTION_TIMEOUT_KEY, growingioProperties.getConnectionTimeout().toString());</span><br><span class="line">        properties.setProperty(GrowingioConstant.READ_TIMEOUT_KEY, growingioProperties.getReadTimeout().toString());</span><br><span class="line">        <span class="comment">//通过SDK中的这个API可以避免使用properties文件</span></span><br><span class="line">        ConfigUtils.init(properties);</span><br><span class="line">        logger.info(<span class="string">&quot;init load growingio starter api properties success,url:&#123;&#125;,runmode:&#123;&#125;,enable:&#123;&#125;&quot;</span>,</span><br><span class="line">                growingioProperties.getApiHost(),growingioProperties.getRunMode(),growingioProperties.getEnable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第3步：声明一个spring-factories的文件"><a href="#第3步：声明一个spring-factories的文件" class="headerlink" title="第3步：声明一个spring.factories的文件"></a>第3步：声明一个spring.factories的文件</h2><p>为了防止使用者与Starter中包名路径不一致，声明一个spring.factories的文件，来提供一种扫描类到IOC中的途径。</p><p>resources包下手动创建一个META-INF文件夹，并且在包下创建一个spring.factories文件，文件内容写，注意空格(使用Idea会有提示)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.my.growingio.config.GrowingioAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>在Spring Boot 2.7后，这个文件过时了，后续版本会取消，那么新版本的约定是怎么样的规则呢，这里以wxjava的spring-boot-starter组件为例，仓库地址如下：</p><p><a href="https://github.com/Wechat-Group/WxJava/tree/develop/spring-boot-starters/wx-java-miniapp-spring-boot-starter">https://github.com/Wechat-Group/WxJava/tree/develop/spring-boot-starters/wx-java-miniapp-spring-boot-starter</a></p><p>在该工程示例中，在resources文件下定义了如下文件：</p><p>META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports</p><p>在该文件中直接定义了实现类，接口声明在体现在了文件名字上。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">com.binarywang.spring.starter.wxjava.miniapp.config.WxMaAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>简化配置: 新的方法可能旨在简化配置过程，使得自动配置和服务的管理更加直观和易于理解。</p><p>性能优化: 改变 SPI 文件的规则可能是为了提高应用启动和运行时的性能。</p><p>增加灵活性: 新的机制可能提供了更大的灵活性，允许更精细的控制和定制。</p><h1 id="SpringBoot-starter-新玩法"><a href="#SpringBoot-starter-新玩法" class="headerlink" title="SpringBoot starter 新玩法"></a>SpringBoot starter 新玩法</h1><h2 id="定义一个XXXXEnable模式-Import模式的注解"><a href="#定义一个XXXXEnable模式-Import模式的注解" class="headerlink" title="定义一个XXXXEnable模式+@Import模式的注解"></a>定义一个XXXXEnable模式+@Import模式的注解</h2><p>用于控制Starter是否生效与动态注册对象Bean到IOC容器中。这里以rocketmq的spring-boot-starter为例，</p><p>首先我们在自定义好一个autoconfiguration类后，如果不想让客户端自动装配上，可以提供一个Enable命名为开头的类，来通过这种方式启用装配，代码样例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Import(RocketMQAutoConfiguration.class)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableRocketMQ &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义好这样的一个注解，使用时在启动类上面进行声明即可。然后再Auto装配类中，我们还可以结合ConditionalOnProperty注解来表达，某个属性等于某个值的时候，才触发某些装配，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DefaultMQProducer.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DefaultMQProducer.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.rocketmq&quot;, value = &#123;&quot;nameServer&quot;, &quot;producer.group&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> DefaultMQProducer <span class="title function_">mqProducer</span><span class="params">(RocketMQProperties rocketMQProperties)</span> &#123;</span><br><span class="line"><span class="comment">//省略部分代码</span></span><br><span class="line"><span class="keyword">return</span> producer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h2><p>使用多种注解，来区分当前starter组件中的先后顺序、环境区分、兼容性等等。</p><p><strong>@Profile注解：用于区分环境来加载不同的自动装配类</strong></p><p><strong>@EnableConfigurationProperties注解：用于装配导入一个属性配置文件，通常结合@ConfigurationProperties来使用</strong></p><p><strong>@ConditionalOnClass注解：用于标识当前类路径中存在某个类的时候，才触发自动装配类</strong></p><p><strong>@ConditionalOnMissingClass注解：用于标识当前类路径中不存在某个类的时候，才触发</strong></p><p><strong>@ConditionalOnMissingBean注解：用于标识当前IOC容器中不存在某个Bean的时候，才触发</strong></p><p><strong>@AutoConfigureAfter、@AutoConfigureBefore注解：用于控制先后顺序的注解</strong></p><h2 id="基于-AOP-注解实现对某些接口或配置的自动拦截、代码增强"><a href="#基于-AOP-注解实现对某些接口或配置的自动拦截、代码增强" class="headerlink" title="基于 AOP 注解实现对某些接口或配置的自动拦截、代码增强"></a>基于 AOP 注解实现对某些接口或配置的自动拦截、代码增强</h2><p>自定义一个AOP类和一个注解，用于动态标识哪些方法进行业务埋点操作，避免一定程度上的代码侵入。</p><p>这里以一个Redis的ratelimiter-spring-boot-starter的限流的Starter组件为例，仓库地址如下：</p><p><a href="https://github.com/taptap/ratelimiter-spring-boot-starter">https://github.com/taptap/ratelimiter-spring-boot-starter</a></p><p>首先，可以定义一个自定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(value = &#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RateLimit &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===================== 公共参数 ============================</span></span><br><span class="line"></span><br><span class="line">    Mode <span class="title function_">mode</span><span class="params">()</span> <span class="keyword">default</span> Mode.TIME_WINDOW;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间窗口模式表示每个时间窗口内的请求数量</span></span><br><span class="line"><span class="comment">     * 令牌桶模式表示每秒的令牌生产数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> rate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，为这个注解定义一个AOP拦截类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitAspectHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(RateLimitAspectHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RateLimiterService rateLimiterService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RuleProvider ruleProvider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RateLimitAspectHandler</span><span class="params">(RateLimiterService lockInfoProvider, RuleProvider ruleProvider)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rateLimiterService = lockInfoProvider;</span><br><span class="line">        <span class="built_in">this</span>.ruleProvider = ruleProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;@annotation(rateLimit)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint, RateLimit rateLimit)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Rule</span> <span class="variable">rule</span> <span class="operator">=</span> ruleProvider.getRateLimiterRule(joinPoint, rateLimit);</span><br><span class="line"></span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> rateLimiterService.isAllowed(rule);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allowed</span> <span class="operator">=</span> result.isAllow();</span><br><span class="line">        <span class="keyword">if</span> (!allowed) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Trigger current limiting,key:&#123;&#125;&quot;</span>, rule.getKey());</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(rule.getFallbackFunction())) &#123;</span><br><span class="line">                <span class="keyword">return</span> ruleProvider.executeFunction(rule.getFallbackFunction(), joinPoint);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">extra</span> <span class="operator">=</span> result.getExtra();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RateLimitException</span>(<span class="string">&quot;Too Many Requests&quot;</span>, extra, rule.getMode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段的核心配置其实是@Around(value &#x3D; “@annotation(rateLimit)”)这个代码，通过这个环绕通知的切面拦截，可以实现一种AOP的Starter的自动增强处理。</p><p>然后在AutoConfiguration类中，去导入这个AOP类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = RateLimiterProperties.PREFIX, name = &quot;enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(RedisAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RateLimiterProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123;RateLimitAspectHandler.class, RateLimitExceptionHandler.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RateLimiterProperties limiterProperties;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">REDISSON_BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;rateLimiterRedissonBeanName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RateLimiterAutoConfiguration</span><span class="params">(RateLimiterProperties limiterProperties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limiterProperties = limiterProperties;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringBoot-自动装配"><a href="#SpringBoot-自动装配" class="headerlink" title="SpringBoot 自动装配"></a>SpringBoot 自动装配</h1><p>@SpringBootApplication的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">       @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ComponentScan的作用是扫描被 @Component @Service @Controller注解的bean，注解会默认扫描该类所在包下的所有类</p><p>@SpringBootConfiguration 的源码如下：</p><p>它的核心就是 @Configuration，允许在上下文中注册额外的bean或导入其他配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableAutoConfiguration是启用SpringBoot的自动配置机制的关键</p><p>可以看到，@EnableAutoConfiguration注解通过 Spring 提供的 @Import 注解导入了 AutoConfigurationImportSelector 类</p><p>AutoConfigurationImportSelector 类中的 getCandidateConfigurations 方法会将所有自动配置类信息以 List 的形式返回。这些配置信息会被 Spring 容器作 bean 来管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Environment property that can be used to override when auto-configuration is</span></span><br><span class="line"><span class="comment"> * enabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment"> * applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">getBeanClassLoader());</span><br><span class="line">Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">+ <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了自动配置信息以后，自动配置还差 @Conditional 注解。</p><p>拿 Spring Security 的自动配置举个例子：SecurityAutoConfiguration 中导入了 WebSecurityEnablerConfiguration类，WebSecurityEnablerConfiguration源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = BeanIds.SPRING_SECURITY_FILTER_CHAIN)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(EnableWebSecurity.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebSecurityEnablerConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebSecurityEnablerConfiguration 类中使用了 @ConditionalOnClass 指定了容器中必须还有 EnableWebSecurity 类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;starter介绍&quot;&gt;&lt;a href=&quot;#starter介绍&quot; class=&quot;headerlink&quot; title=&quot;starter介绍&quot;&gt;&lt;/a&gt;starter介绍&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Spring Boot Starter是什么？&lt;/strong&gt;&lt;/</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://palette-k.github.io/tags/SpringBoot/"/>
    
    <category term="starter" scheme="https://palette-k.github.io/tags/starter/"/>
    
  </entry>
  
  <entry>
    <title>MySQL语句执行原理</title>
    <link href="https://palette-k.github.io/2023/12/07/MySQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>https://palette-k.github.io/2023/12/07/MySQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</id>
    <published>2023-12-07T06:30:04.000Z</published>
    <updated>2023-12-07T08:24:59.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*) 的实现方式"></a>count(*) 的实现方式</h1><p>在不同的MySQL引擎中，count(*)有不同的实现方式。</p><ul><li>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</li><li>而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><p>这篇文章里讨论的是没有过滤条件的count(*)，如果加了where 条件的话，MyISAM表也是不能返回得这么快的。</p><blockquote><p><strong>为什么InnoDB不跟MyISAM一样，也把数字存起来呢？</strong></p></blockquote><p>由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</p><h2 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h2><p>一般会想到使用 Redis 缓存总数，但是即使 Redis 正常工作，这个值还是逻辑上不精确的。</p><p>因为使用 Redis 存储会存在数据不一致的情况，无论是先往数据表里插入一行，然后 Redis 计数 + 1; 还是先 Redis 计数 + 1,再往数据表里插入一行。</p><p><strong>Redis 和 MySQL 是不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。</strong></p><h2 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h2><table><thead><tr><th>时刻</th><th>会话A</th><th>会话B</th></tr></thead><tbody><tr><td>T1</td><td></td><td></td></tr><tr><td>T2</td><td>begin;<br />表C中计数加1</td><td></td></tr><tr><td>T3</td><td></td><td>begin;<br />读表C计数值；<br />查询最近100条记录；<br />commit;</td></tr><tr><td>T4</td><td>插入一行数据R;<br />commit;</td><td></td></tr></tbody></table><p>虽然会话B的读操作仍然是在T3执行的，但是因为这时候更新事务还没有提交，所以计数值加1这个操作对会话B还不可见。</p><p>因此，会话B看到的结果里， 查计数值和“最近100条记录”看到的结果，逻辑上就是一致的。</p><h2 id="不同的-count-用法"><a href="#不同的-count-用法" class="headerlink" title="不同的 count 用法"></a>不同的 count 用法</h2><p>count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</p><p>count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。</p><p><strong>对于count(主键id)来说</strong>，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</p><p><strong>对于count(1)来说</strong>，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p><p>单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。</p><p><strong>对于count(字段)来说</strong>：</p><ol><li>如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</li><li>如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</li></ol><p>也就是前面的第一条原则，server层要什么字段，InnoDB就返回什么字段。</p><p><strong>但是count(*)是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不是null，按行累加。</p><blockquote><p>由于事务可以保证中间结果不被别的事务读到，因此修改计数值和插入新记录的顺序是不影响逻辑结果的。但是，从并发系统性能的角度考虑，你觉得在这个事务序列里，应该先插入操作记录，还是应该先更新计数表呢？</p></blockquote><p>并发系统性能的角度考虑，应该先插入操作记录，再更新计数表。<br>因为更新计数表涉及到行锁的竞争，先插入再更新能最大程度地减少事务之间的锁等待，提升并发度。</p><blockquote><p>如果把update计数表放到事务的第一个语句，多个业务表同时插入数据的话，等待时间会更长吗？</p></blockquote><p>答案是不会。即使我们用一个计数表记录多个业务表的行数，也肯定会给表名字段加唯一索引。在更新计数表的时候，一定会传入where table_name&#x3D;$table_name，使用主键索引，更新加行锁只会锁在一行上。而在不同业务表插入数据，是更新不同的行，不会有行锁。</p><h1 id="查询一行数据怎么那么慢"><a href="#查询一行数据怎么那么慢" class="headerlink" title="查询一行数据怎么那么慢"></a>查询一行数据怎么那么慢</h1><p>构造一个表，插入10万行数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">100000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><h2 id="第一类：查询长时间不返回"><a href="#第一类：查询长时间不返回" class="headerlink" title="第一类：查询长时间不返回"></a>第一类：查询长时间不返回</h2><p>在表t执行下面的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>大概率是表t被锁住了，执行一下show processlist命令，看看当前语句处于什么状态。</p><h3 id="等MDL锁"><a href="#等MDL锁" class="headerlink" title="等MDL锁"></a>等MDL锁</h3><p>如图2所示，就是使用show processlist命令查看Waiting for table metadata lock的示意图。</p><p><img src="https://static001.geekbang.org/resource/image/50/28/5008d7e9e22be88a9c80916df4f4b328.png" alt="img"></p><p>session A 通过lock table命令持有表t的MDL写锁，而session B的查询需要获取MDL读锁。所以，session B进入等待状态。</p><p>通过查询sys.schema_table_lock_waits这张表，我们就可以直接找出造成阻塞的process id，把这个连接用kill 命令断开即可。</p><p><img src="https://static001.geekbang.org/resource/image/74/01/74fb24ba3826e3831eeeff1670990c01.png" alt="img"></p><h3 id="等flush"><a href="#等flush" class="headerlink" title="等flush"></a>等flush</h3><p>在表t上，执行下面的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.processlist <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查出来这个线程的状态是Waiting for table flush，这个状态表示的是，现在有一个线程正要对表t做flush操作。<br><img src="https://static001.geekbang.org/resource/image/2d/24/2d8250398bc7f8f7dce8b6b1923c3724.png" alt="img"></p><p>如果指定表t的话，代表的是只关闭表t；如果没有指定具体的表名，则表示关闭MySQL里所有打开的表。但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。</p><p>所以，出现Waiting for table flush状态的可能情况是：有一个flush tables命令被别的语句堵住了，然后它又堵住了我们的select语句。</p><p>同样使用show processlist命令，找到并kill掉阻塞的线程。</p><h3 id="等行锁"><a href="#等行锁" class="headerlink" title="等行锁"></a>等行锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode; </span><br></pre></td></tr></table></figure><p>由于访问id&#x3D;1这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的select语句就会被堵住。</p><p>如果你用的是MySQL 5.7版本，可以通过sys.innodb_lock_waits 表查到谁在占用这个写锁。</p><p>查询方法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t sys.innodb_lock_waits <span class="keyword">where</span> locked_table<span class="operator">=</span>`<span class="string">&#x27;test&#x27;</span>.<span class="string">&#x27;t&#x27;</span>`\G</span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/d8/18/d8603aeb4eaad3326699c13c46379118.png" alt="img"></p><p>可以看到，这个信息很全，4号线程是造成堵塞的罪魁祸首。而干掉这个罪魁祸首的方式，就是KILL QUERY 4或KILL 4。</p><p>不过，这里不应该显示“KILL QUERY 4”。这个命令表示停止4号线程当前正在执行的语句，而这个方法其实是没有用的。因为占有行锁的是update语句，这个语句已经是之前执行完成了的，现在执行KILL QUERY，无法让这个事务去掉id&#x3D;1上的行锁。</p><p>实际上，KILL 4才有效，也就是说直接断开这个连接。这里隐含的一个逻辑就是，连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了id&#x3D;1上的行锁。</p><h2 id="第二类：查询慢"><a href="#第二类：查询慢" class="headerlink" title="第二类：查询慢"></a>第二类：查询慢</h2><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>start transaction with consistent snapshot;</td><td>update t set c&#x3D;c+1 where id&#x3D;1;<br />执行100万次</td></tr><tr><td></td><td></td></tr><tr><td>select * from t where id &#x3D; 1;</td><td></td></tr><tr><td>select * from t where id&#x3D;1 lock in share mode;</td><td></td></tr></tbody></table><p>session A先用start transaction with consistent snapshot命令启动了一个事务，之后session B才开始执行update 语句。</p><p>session B更新完100万次，生成了100万个回滚日志(undo log)。</p><p>带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select * from t where id&#x3D;1这个语句，是一致性读，因此需要从1000001开始，依次执行undo log，执行了100万次以后，才将1这个结果返回。</p><h1 id="Order-by的排序原理"><a href="#Order-by的排序原理" class="headerlink" title="Order by的排序原理"></a>Order by的排序原理</h1><p>现给出一个使用 order by 的查询语句，通过这个语句了解其执行流程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>  ;</span><br></pre></td></tr></table></figure><h2 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h2><p>为避免全表扫描，我们需要在city字段加上索引。</p><p>在city字段上创建索引之后，我们用explain命令来看看这个语句的执行情况。</p><p>Extra这个字段中的“Using filesort”表示的就是需要排序，MySQL会给每个线程分配一块内存用于排序，称为<strong>sort_buffer</strong>。</p><p>假设满足city&#x3D;’杭州’条件的行，是从ID_X到ID_Y的这些记录。</p><p>通常情况下，这个语句执行流程如下所示 ：</p><ol><li>初始化sort_buffer，确定放入name、city、age这三个字段；</li><li>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是ID_X；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是ID_Y；</li><li>对sort_buffer中的数据按照字段name做快速排序；</li><li>按照排序结果取前1000行返回给客户端。</li></ol><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MySQL/17012396485694.png"></p><p>可以看到，排序操作是再 sort_buffer 内完成的，也有可能会使用到外部排序，取决于排序所需的内存和参数 sort_buffer_size。</p><p><strong>sort_buffer_size</strong>：是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p><p>你可以用下面介绍的方法，来确定一个排序语句是否使用了临时文件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* @a保存Innodb_rows_read的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@a</span> <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`\G</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @b保存Innodb_rows_read的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@b</span> <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算Innodb_rows_read差值 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@b</span><span class="operator">-</span><span class="variable">@a</span>;</span><br></pre></td></tr></table></figure><p>这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，你可以从 number_of_tmp_files中看到是否使用了临时文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;filesort_summary&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span><span class="number">4000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;examined_rows&quot;</span><span class="punctuation">:</span><span class="number">4000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;number_of_tmp_files&quot;</span><span class="punctuation">:</span><span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort_buffer_size&quot;</span><span class="punctuation">:</span><span class="number">32664</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort_mode&quot;</span><span class="punctuation">:</span><span class="string">&quot;&lt;sort_key,packed_additional_fields&gt;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>number_of_tmp_files表示的是，排序过程中使用的临时文件数。当number_of_tmp_files的值大于0，表示内存放不下了，就需要使用外部排序，外部排序一般使用归并排序算法。可以这么简单理解，<strong>MySQL将需要排序的数据分成n份，每一份单独排序后存在这些临时文件中。然后把这n个有序文件再合并成一个有序的大文件。</strong></p><p>如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，表示排序可以直接在内存中完成。</p><p>表中有4000条满足city&#x3D;’杭州’的记录，所以你可以看到 examined_rows&#x3D;4000，表示参与排序的行数是4000行。</p><p>sort_mode 里面的packed_additional_fields的意思是，排序过程对字符串做了“紧凑”处理。即使name字段的定义是varchar(16)，在排序过程中还是要按照实际长度来分配空间的。</p><p>同时，最后一个查询语句select @b-@a 的返回结果是4000，表示整个执行过程只扫描了4000行。</p><p>这里需要注意的是，为了避免对结论造成干扰，我把internal_tmp_disk_storage_engine设置成MyISAM。否则，select @b-@a的结果会显示为4001。</p><p>这是因为查询OPTIMIZER_TRACE这个表时，需要用到临时表，而internal_tmp_disk_storage_engine的默认值是InnoDB。如果使用的是InnoDB引擎的话，把数据从临时表取出来的时候，会让Innodb_rows_read的值加1。</p><h2 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h2><p>如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p><p>针对于排序的单行长度太大的问题，可以通过修改 max_length_for_sort_dat 的值来解决。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> max_length_for_sort_data <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>max_length_for_sort_data 是如果单行的长度超过这个值，MySQL 就认为单行太大，需要换一个算法。</p><p>假设 city、name、age 这三个字段的定义总长度是36，新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id。</p><p>因此会比全字段排序多一个步骤，遍历排序结果，按照 id 值回到原表中取出 city,name,age 三个字段返回给客户端。</p><p>examined_rows的值还是4000，表示用于排序的数据是4000行。但是select @b-@a这个语句的值变成5000了。</p><p>因为这时候除了排序过程外，在排序完成后，还要根据id去原表取值。由于语句是limit 1000，因此会多读1000行。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;filesort_summary&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span><span class="number">4000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;examined_rows&quot;</span><span class="punctuation">:</span><span class="number">4000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;number_of_tmp_files&quot;</span><span class="punctuation">:</span><span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort_buffer_size&quot;</span><span class="punctuation">:</span><span class="number">32728</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort_mode&quot;</span><span class="punctuation">:</span><span class="string">&quot;&lt;sort_key,rowid&gt;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>从OPTIMIZER_TRACE的结果中，还能看到另外两个信息也变了。</p><ul><li>sort_mode变成了&lt;sort_key, rowid&gt;，表示参与排序的只有name和id这两个字段。</li><li>number_of_tmp_files变成10了，是因为这时候参与排序的行数虽然仍然是4000行，但是每一行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了。</li></ul><p><strong>更佳实践：</strong></p><ul><li>建一个(city,name)的联合索引，就可以避免使用order by 排序时生成临时表并在临时表上排序了。原因是索引保证了从city这个索引取出来的行，天然按照name递增排序。</li><li>建一个(city,name,age)的覆盖索引，不但能避免多余的排序操作，还能避免回到主键索引上取数据的操作</li></ul><h1 id="随机数据的显示"><a href="#随机数据的显示" class="headerlink" title="随机数据的显示"></a>随机数据的显示</h1><blockquote><p>有个英语学习App首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。</p><p>现在，如果让你来设计这个SQL语句，你会怎么写呢？</p></blockquote><p>为了便于理解，我对这个例子进行了简化：去掉每个级别的用户都有一个对应的单词表这个逻辑，直接就是从一个单词表中随机选出三个单词。</p><p>建表语句和初始化数据如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `words` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `word` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">  while i<span class="operator">&lt;</span><span class="number">10000</span> do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> words(word) <span class="keyword">values</span>(concat(<span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i div <span class="number">1000</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">1000</span> div <span class="number">100</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">100</span> div <span class="number">10</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">10</span>))));</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><h2 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>我们先用explain命令来看看这个语句的执行情况。</p><p><img src="https://static001.geekbang.org/resource/image/59/50/59a4fb0165b7ce1184e41f2d061ce350.png" alt="img"></p><p>图1 使用explain命令查看语句的执行情况</p><p>Extra字段显示Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行排序操作。</p><p>因此这个Extra的意思就是，需要临时表，并且需要在临时表上排序。</p><p><strong>对于InnoDB表来说</strong>，执行全字段排序会减少磁盘访问，因此会被优先选择。</p><p><strong>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘</strong>。优化器会优先考虑的，就是用于排序的行越少越好了，所以，MySQL这时就会选择rowid排序。</p><p>这条语句的执行流程是这样的：</p><ol><li>创建一个临时表。这个临时表使用的是memory引擎，表里有两个字段，第一个字段是double类型，为了后面描述方便，记为字段R，第二个字段是varchar(64)类型，记为字段W。并且，这个表没有建索引。</li><li>从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中，到此，扫描行数是10000。</li><li>现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排序。</li><li>初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。</li><li>从内存临时表中一行一行地取出R值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加10000，变成了20000。</li><li>在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li><li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。</li></ol><p>接下来，我们通过慢查询日志（slow log）来验证一下我们分析得到的扫描行数是否正确。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Query_time: <span class="number">0.900376</span>  Lock_time: <span class="number">0.000347</span> Rows_sent: <span class="number">3</span> Rows_examined: <span class="number">20003</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">timestamp</span><span class="operator">=</span><span class="number">1541402277</span>;</span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行，也就验证了我们分析得出的结论。</p><p>如果你创建的表没有主键，或者把一个表的主键删掉了，那么InnoDB会自己生成一个长度为6字节的rowid来作为主键。</p><p>这也就是排序模式里面，rowid名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行的信息。</p><ul><li>对于有主键的InnoDB表来说，这个rowid就是主键ID；</li><li>对于没有主键的InnoDB表来说，这个rowid就是由系统生成的；</li><li>MEMORY引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个rowid其实就是数组的下标。</li></ul><p>到这里，我来稍微小结一下：<strong>order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。</strong></p><h2 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h2><p>tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。</p><p>磁盘临时表使用的引擎默认是InnoDB，是由参数internal_tmp_disk_storage_engine控制的。</p><p>为了复现这个过程，把tmp_table_size设置成1024，把sort_buffer_size设置成 32768, 把 max_length_for_sort_data 设置成16。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> tmp_table_size<span class="operator">=</span><span class="number">1024</span>;</span><br><span class="line"><span class="keyword">set</span> sort_buffer_size<span class="operator">=</span><span class="number">32768</span>;</span><br><span class="line"><span class="keyword">set</span> max_length_for_sort_data<span class="operator">=</span><span class="number">16</span>;</span><br><span class="line"><span class="comment">/* 打开 optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`\G</span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/78/ab/78d2db9a4fdba81feadccf6e878b4aab.png" alt="img"></p><p>R字段存放的随机值就8个字节，rowid是6个字节，数据总行数是10000，这样算出来就有140000字节，超过了sort_buffer_size 定义的 32768字节了。但是，number_of_tmp_files的值居然是0。</p><p>此时采用是MySQL 5.6版本引入的一个新的排序算法，即：优先队列排序算法。filesort_priority_queue_optimization这个部分的chosen&#x3D;true，就表示使用了优先队列排序算法</p><blockquote><p>为什么不使用归并排序算法呢？</p></blockquote><p>原因是我们的 sql 语句只需要取R值最小的3个rowid，使用归并排序需要将10000行数据排好，浪费很多计算量。</p><p>而优先队列算法，就可以精确地只得到三个最小值，执行流程如下：</p><ol><li>对于这10000个准备排序的(R,rowid)，先取前三行，构造成一个堆；</li></ol><p>（对数据结构印象模糊的同学，可以先设想成这是一个由三个元素组成的数组）</p><ol start="2"><li><p>取下一个行(R’,rowid’)，跟当前堆里面最大的R比较，如果R’小于R，把这个(R,rowid)从堆中去掉，换成(R’,rowid’)；</p></li><li><p>重复第2步，直到第10000个(R’,rowid’)完成比较。</p></li></ol><p>整个排序过程中，为了最快地拿到当前堆的最大值，总是保持最大值在堆顶，因此这是一个最大堆。</p><h2 id="随机排序算法"><a href="#随机排序算法" class="headerlink" title="随机排序算法"></a>随机排序算法</h2><p>要随机取3个word值，你可以这么做：</p><ol><li>取得整个表的行数，记为C；</li><li>根据相同的随机方法得到Y1、Y2、Y3；</li><li>再执行三个limit Y, 1语句得到三行数据。</li></ol><p>下面这段代码，就是上面流程的执行语句的序列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@C</span> <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y1</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y2</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y3</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y1</span>，<span class="number">1</span>； <span class="operator">/</span><span class="operator">/</span>在应用代码里面取Y1、Y2、Y3值，拼出<span class="keyword">SQL</span>后执行</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y2</span>，<span class="number">1</span>；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y3</span>，<span class="number">1</span>；</span><br></pre></td></tr></table></figure><blockquote><p>为什么这个算法比order by rand()的代价小很多？</p></blockquote><p>因为进行limit获取数据的时候是根据主键排序获取的，主键天然索引排序。获取到第9999条的数据也远比order by rand()方法的组成临时表R字段排序再获取rowid代价小的多。</p><blockquote><p>上面的随机算法3的总扫描行数是 C+(Y1+1)+(Y2+1)+(Y3+1)，实际上它还是可以继续优化，来进一步减少扫描行数的。</p><p>我的问题是，如果你是这个需求的开发人员，你会怎么做，来减少扫描行数呢？说说你的方案，并说明你的方案需要的扫描行数。</p></blockquote><p>取Y1、Y2和Y3里面最大的一个数，记为M，最小的一个数记为N，然后执行下面这条SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit N, M<span class="operator">-</span>N<span class="operator">+</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>再加上取整个表总行数的C行，这个方案的扫描行数总共只需要C+M+1行。</p><p>当然也可以先取回id值，在应用中确定了三个id值以后，再执行三次where id&#x3D;X的语句也是可以的。</p><h1 id="Kill-线程"><a href="#Kill-线程" class="headerlink" title="Kill 线程"></a>Kill 线程</h1><p><strong>实现上，当用户执行kill query thread_id_B时，MySQL里处理kill命令的线程做了两件事：</strong></p><ol><li>把session B的运行状态改成THD::KILL_QUERY(将变量killed赋值为THD::KILL_QUERY)；</li><li>给session B的执行线程发一个信号。让session B退出等待，来处理这个THD::KILL_QUERY状态。</li></ol><p>语句的执行终止过程：</p><ol><li>一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态是THD::KILL_QUERY，才开始进入语句终止逻辑；</li><li>如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处；</li><li>语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。</li></ol><p><strong>为什么在执行kill query命令时，这条语句不像第一个例子的update语句一样退出呢？</strong></p><p><strong>第一类线程没有执行到判断线程状态的逻辑。</strong>跟这种情况相同的，还有由于IO压力过大，读写IO的函数一直无法返回，导致不能及时判断线程的状态。</p><p><strong>另一类情况是，终止逻辑耗时较长。</strong>这时候，从show processlist结果上看也是Command&#x3D;Killed，需要等到终止逻辑完成，语句才算真正完成。这类情况，比较常见的场景有以下几种：</p><ol><li>超大事务执行期间被kill。这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。</li><li>大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待IO资源，导致耗时较长。</li><li>DDL命令执行到最后阶段，如果被kill，需要删除中间过程的临时文件，也可能受IO资源影响耗时较久。</li></ol><blockquote><p>如果直接在客户端通过Ctrl+C命令，是不是就可以直接终止线程呢？</p></blockquote><p>答案是，不可以。</p><p>这里有一个误解，其实在客户端的操作只能操作到客户端的线程，客户端和服务端只能通过网络交互，是不可能直接操作服务端线程的。</p><p>而由于MySQL是停等协议，所以这个线程执行的语句还没有返回的时候，再往这个连接里面继续发命令也是没有用的。实际上，执行Ctrl+C的时候，是MySQL客户端另外启动一个连接，然后发送一个kill query 命令。</p><blockquote><p>如果库里面的表特别多，连接就会很慢。这是什么原因？</p></blockquote><p>每个客户端在和服务端建立连接的时候，需要做的事情就是TCP握手、用户校验、获取权限。但这几个操作，显然跟库里面表的个数无关。</p><p>当使用默认参数连接的时候，MySQL客户端会提供一个本地库名和表名补全的功能。为了实现这个功能，客户端在连接成功后，需要多做一些操作：</p><ol><li>执行show databases；</li><li>切到db1库，执行show tables；</li><li>把这两个命令的结果用于构建一个本地的哈希表。</li></ol><p>在这些操作中，最花时间的就是第三步在本地构建哈希表的操作。所以，当一个库中的表个数非常多的时候，这一步就会花比较长的时间。</p><p>如果在连接命令中加上-A，就可以关掉这个自动补全的功能，然后客户端就可以快速返回了。</p><p>这里自动补全的效果就是，你在输入库名或者表名的时候，输入前缀，可以使用Tab键自动补全表名或者显示提示。</p><p>实际使用中，如果你自动补全功能用得并不多，我建议你每次使用的时候都默认加-A。</p><blockquote><p>如果你碰到一个被killed的事务一直处于回滚状态，你认为是应该直接把MySQL进程强行重启，还是应该让它自己执行完成呢？为什么呢？</p></blockquote><p>因为重启之后该做的回滚动作还是不能少的，所以从恢复速度的角度来说，应该让它自己结束。</p><p>当然，如果这个语句可能会占用别的锁，或者由于占用IO资源过多，从而影响到了别的语句执行的话，就需要先做主备切换，切到新主库提供服务。</p><p>切换之后别的线程都断开了连接，自动停止执行。接下来还是等它自己执行完成。</p><h1 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h1><h2 id="对-server-层影响"><a href="#对-server-层影响" class="headerlink" title="对 server 层影响"></a>对 server 层影响</h2><p>假设，我们现在要对一个200G的InnoDB表db1. t，执行一个全表扫描。要把扫描结果保存在客户端，会使用类似这样的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h$host <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="operator">-</span>p$pwd <span class="operator">-</span>e &quot;select * from db1.t&quot; <span class="operator">&gt;</span> $target_file</span><br></pre></td></tr></table></figure><p>InnoDB的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表t的主键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到结果集里面，然后返回给客户端。</p><p>取数据和发数据的流程是这样的：</p><ol><li>获取一行，写到net_buffer中。这块内存的大小是由参数net_buffer_length定义的，默认是16k。</li><li>重复获取行，直到net_buffer写满，调用网络接口发出去。</li><li>如果发送成功，就清空net_buffer，然后继续取下一行，并写入net_buffer。</li><li>如果发送函数返回EAGAIN或WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。</li></ol><p><strong>MySQL是“边读边发的”</strong>,如果客户端接收得慢，会导致MySQL服务端由于结果发不出去，这个事务的执行时间变长。</p><p>如果客户端使用–quick参数，会使用mysql_use_result方法。这个方法是读一行处理一行。你可以想象一下，假设有一个业务的逻辑比较复杂，每读一行数据以后要处理的逻辑如果很慢，就会导致客户端要过很久才会去取下一行数据，就很有可能看到State的值一直处于<strong>“Sending to client”</strong>。</p><p><strong>对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，我都建议你使用mysql_store_result这个接口，直接把查询结果保存到本地内存。</strong></p><p>如果你在自己负责维护的MySQL里看到很多个线程都处于“Sending to client”这个状态，就意味着你要让业务开发同学优化查询结果，并评估这么多的返回结果是否合理。</p><p>而如果要快速减少处于这个状态的线程的话，将net_buffer_length参数设置为一个更大的值是一个可选方案。</p><p>仅当一个线程处于“等待客户端接收结果”的状态，才会显示”Sending to client”；而如果显示成“Sending data”，它的意思只是“正在执行”。</p><h2 id="对-InnoDB-的影响"><a href="#对-InnoDB-的影响" class="headerlink" title="对 InnoDB 的影响"></a>对 InnoDB 的影响</h2><p>Buffer Pool对查询的加速效果，依赖于一个重要的指标，即：<strong>内存命中率</strong> Buffer pool hit rate。InnoDB Buffer Pool的大小是由参数 innodb_buffer_pool_size确定的，一般建议设置成可用物理内存的60%~80%。</p><p>在大约十年前，单机的数据量是上百个G，而物理内存是几个G；现在虽然很多服务器都能有128G甚至更高的内存，但是单机的数据量却达到了T级别。</p><p>所以，innodb_buffer_pool_size小于磁盘的数据量是很常见的。如果一个 Buffer Pool满了，而又要从磁盘读入一个数据页，那肯定是要淘汰一个旧数据页的。</p><p>InnoDB内存管理用的是最近最少使用 (Least Recently Used, LRU)算法，这个算法的核心就是淘汰最久未使用的数据。但是实际上，InnoDB不是直接使用 LRU 算法的，因为如果完全按照这个算法，当业务上需要扫描一个200G的历史数据表（平时没有业务访问），就会使得当前 Buffer Pool 里的数据全部淘汰掉，Buffer Pool 的内存命中率下降，磁盘压力增加，SQL语句响应变慢。</p><p>实际上，InnoDB对LRU算法做了改进。在InnoDB实现上，按照5:3的比例把整个LRU链表分成了young区域和old区域。</p><ol><li><p>图中状态1，要访问数据页P3，由于P3在young区域，因此和优化前的LRU算法一样，将其移到链表头部，变成状态2。</p></li><li><p>之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页Pm，但是新插入的数据页Px，是放在LRU_old处。</p></li><li><p>处于old区域的数据页，每次被访问的时候都要做下面这个判断：</p><ul><li>若这个数据页在LRU链表中存在的时间超过了1秒，就把它移动到链表头部；</li><li>如果这个数据页在LRU链表中存在的时间短于1秒，位置保持不变。1秒这个时间，是由参数innodb_old_blocks_time控制的。其默认值是1000，单位毫秒。</li></ul><p><img src="https://static001.geekbang.org/resource/image/25/9e/25e18920dd204cf99eec2d62755fe99e.png" alt="img"></p></li><li><p>扫描过程中，需要新插入的数据页，都被放到old区域;</p></li><li><p>一个数据页里面有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过1秒，因此还是会被保留在old区域；</p></li><li><p>再继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移到链表头部（也就是young区域），很快就会被淘汰出去</p></li></ol><h1 id="Join-执行原理"><a href="#Join-执行原理" class="headerlink" title="Join 执行原理"></a>Join 执行原理</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t2` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> idata;</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">like</span> t2;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>可以看到，这两个表都有一个主键索引id和一个索引a，字段b上无索引。存储过程idata()往表t2里插入了1000行数据，在表t1里插入的是100行数据。</p><h2 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h2><p>我们来看一下这个语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a<span class="operator">=</span>t2.a);</span><br></pre></td></tr></table></figure><p>可以看到，在这条语句里，被驱动表t2的字段a上有索引，join过程用上了这个索引，因此这个语句的执行流程是这样的：先遍历表t1，然后根据从表t1中取出的每行数据中的a值，去表t2中查找满足条件的记录。</p><p>在这个流程里：</p><ol><li>对驱动表t1做了全表扫描，这个过程需要扫描100行；</li><li>而对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描100行；</li><li>所以，整个执行流程，总扫描行数是200。</li></ol><p>在这个join语句执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索。</p><p>假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每次搜索一棵树近似复杂度是以2为底的M的对数，记为log2M，所以在被驱动表上查一行的时间复杂度是 2*log2M。</p><p>假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次。</p><p>因此整个执行过程，近似复杂度是 N + N<em>2</em>log2M。显然，N对扫描行数的影响更大，因此应该让小表来做驱动表。</p><h2 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h2><p>这时候，被驱动表上没有可用的索引，算法的流程是这样的：</p><ol><li>把表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是select *，因此是把整个表t1放入了内存；</li><li>扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。</li></ol><p>可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100。由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做的判断次数是：100*1000&#x3D;10万次。</p><p>假设小表的行数是N，大表的行数是M，那么在这个算法里：</p><ol><li>两个表都做一次全表扫描，所以总的扫描行数是M+N；</li><li>内存中的判断次数是M*N。</li></ol><blockquote><p> 如果表t1是一张大表，join_buffer的 join_buffer_size 不够怎么办？</p></blockquote><p>分段放。</p><ol><li>扫描表t1，顺序读取数据行放入join_buffer中，放完第88行join_buffer满了，继续第2步；</li><li>扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回；</li><li>清空join_buffer；</li><li>继续扫描表t1，顺序读取最后的12行数据放入join_buffer中，继续执行第2步。</li></ol><p>假设，驱动表的数据行数是N，需要分K段才能完成算法流程，被驱动表的数据行数是M。</p><p>注意，这里的K不是常数，N越大K就会越大，因此把K表示为λ*N，显然λ的取值范围是(0,1)。</p><p>所以，在这个算法的执行过程中：</p><ol><li>扫描行数是 N+λ<em>N</em>M；</li><li>内存判断 N*M次。</li></ol><p>考虑到扫描行数，在M和N大小确定的情况下，N小一些，整个算式的结果会更小。那么，N固定的时候，什么参数会影响K的大小呢？（也就是λ的大小）答案是join_buffer_size。join_buffer_size越大，一次可以放入的行越多，分成的段数也就越少，对被驱动表的全表扫描次数就越少。</p><blockquote><p>能不能使用join语句？</p></blockquote><ol><li>如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</li><li>如果使用Block Nested-Loop Join算法，扫描行数就会过多。尤其是在大表上的join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。</li></ol><blockquote><p>如果要使用join，应该选择大表做驱动表还是选择小表做驱动表？</p></blockquote><ol><li>如果是Index Nested-Loop Join算法，应该选择小表做驱动表；</li><li>如果是Block Nested-Loop Join算法：<ul><li>在join_buffer_size足够大的时候，是一样的；</li><li>在join_buffer_size不够大的时候（这种情况更常见），应该选择小表做驱动表。</li></ul></li></ol><p><strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</strong></p><h2 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested Loop Join"></a>Simple Nested Loop Join</h2><p>Simple Nested Loop Join算法的执行逻辑是：顺序取出驱动表中的每一行数据，到被驱动表去做全表扫描匹配，匹配成功则作为结果集的一部分返回。</p><blockquote><p>为什么Simple Nested Loop Join算法和BNL算法性能差距那么大？</p></blockquote><ol><li>在对被驱动表做全表扫描的时候，如果数据没有在Buffer Pool中，就需要等待这部分数据从磁盘读入；<br>从磁盘读入数据到内存中，会影响正常业务的Buffer Pool命中率，而且这个算法天然会对被驱动表的数据做多次访问，更容易将这些数据页放到Buffer Pool的头部</li><li>即使被驱动表数据都在内存中，每次查找“下一个记录的操作”，都是类似指针操作。而join_buffer中是数组，遍历的成本更低。</li></ol><h1 id="Join-优化方法"><a href="#Join-优化方法" class="headerlink" title="Join 优化方法"></a>Join 优化方法</h1><h2 id="Multi-Range-Read-优化"><a href="#Multi-Range-Read-优化" class="headerlink" title="Multi-Range Read 优化"></a>Multi-Range Read 优化</h2><p><strong>因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</strong></p><p>这，就是MRR优化的设计思路。此时，语句的执行流程变成了这样：</p><ol><li>根据索引a，定位到满足条件的记录，将id值放入read_rnd_buffer中;</li><li>将read_rnd_buffer中的id进行递增排序；</li><li>排序后的id数组，依次到主键id索引中查记录，并作为结果返回。</li></ol><p>read_rnd_buffer的大小是由read_rnd_buffer_size参数控制的。如果步骤1中，read_rnd_buffer放满了，就会先执行完步骤2和3，然后清空read_rnd_buffer。之后继续找索引a的下个记录，并继续循环。</p><p>如果你想要稳定地使用MRR优化的话，需要设置<code>set optimizer_switch=&quot;mrr_cost_based=off&quot;</code>。</p><h2 id="Batched-Key-Access"><a href="#Batched-Key-Access" class="headerlink" title="Batched Key Access"></a>Batched Key Access</h2><p>从驱动表t1，一次性多拿些行写入到 join_buffer，再到被驱动表t2去做join。</p><p>如果要使用BKA优化算法的话，你需要在执行SQL语句之前，先设置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;</span>;</span><br></pre></td></tr></table></figure><p>其中，前两个参数的作用是要启用MRR。这么做的原因是，BKA算法的优化要依赖于MRR。</p><h2 id="BNL算法性能问题"><a href="#BNL算法性能问题" class="headerlink" title="BNL算法性能问题"></a>BNL算法性能问题</h2><blockquote><p>如果被驱动表是一个大表，并且是一个冷数据表，除了查询过程中可能会导致IO压力大以外，你觉得对这个MySQL服务还有什么更严重的影响吗？</p></blockquote><p>如果一个使用BNL算法的join语句，多次扫描一个冷表，而且这个语句执行时间超过1秒，就会在再次扫描冷表的时候，把冷表的数据页移到LRU链表头部。</p><p>这种情况对应的，是冷表的数据量小于整个Buffer Pool的3&#x2F;8，能够完全放入old区域的情况。</p><p>如果这个冷表很大，就会出现另外一种情况：业务正常访问的数据页，没有机会进入young区域。</p><p>BNL算法对系统的影响主要包括三个方面：</p><ol><li>可能会多次扫描被驱动表，占用磁盘IO资源；</li><li>判断join条件需要执行M*N次对比（M、N分别是两张表的行数），如果是大表就会占用非常多的CPU资源；</li><li>可能会导致Buffer Pool的热数据被淘汰，影响内存命中率。</li></ol><h2 id="BNL算法转BKA"><a href="#BNL算法转BKA" class="headerlink" title="BNL算法转BKA"></a>BNL算法转BKA</h2><p>一些情况下，我们可以直接在被驱动表上建索引，这时就可以直接转成BKA算法了。</p><p>但是，有时候你确实会碰到一些不适合在被驱动表上建索引的情况。比如下面这个语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span> (t1.b<span class="operator">=</span>t2.b) <span class="keyword">where</span> t2.b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> t2.b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br></pre></td></tr></table></figure><p>表t2中插入了100万行数据，但是经过where条件过滤后，需要参与join的只有2000行数据。如果这条语句同时是一个低频的SQL语句，那么再为这个语句在表t2的字段b上创建一个索引就很浪费了。</p><p>如果使用BNL算法来join的话，这个语句的执行流程是这样的：</p><ol><li>把表t1的所有字段取出来，存入join_buffer中。这个表只有1000行，join_buffer_size默认值是256k，可以完全存入。</li><li>扫描表t2，取出每一行数据跟join_buffer中的数据进行对比，<ul><li>如果不满足t1.b&#x3D;t2.b，则跳过；</li><li>如果满足t1.b&#x3D;t2.b, 再判断其他条件，也就是是否满足t2.b处于[1,2000]的条件，如果是，就作为结果集的一部分返回，否则跳过。</li></ul></li></ol><p>对于表t2的每一行，判断join是否满足的时候，都需要遍历join_buffer中的所有行。因此判断等值条件的次数是1000*100万&#x3D;10亿次，这个判断的工作量很大。</p><p>这时候，我们可以考虑使用临时表。使用临时表的大致思路是：</p><ol><li>把表t2中满足条件的数据放在临时表tmp_t中；</li><li>为了让join使用BKA算法，给临时表tmp_t的字段b加上索引；</li><li>让表t1和tmp_t做join操作。</li></ol><p>此时，对应的SQL语句的写法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(b))engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b<span class="operator">=</span>temp_t.b);</span><br></pre></td></tr></table></figure><p>接下来，我们一起看一下这个过程的消耗：</p><ol><li>执行insert语句构造temp_t表并插入数据的过程中，对表t2做了全表扫描，这里扫描行数是100万。</li><li>之后的join语句，扫描表t1，这里的扫描行数是1000；join比较过程中，做了1000次带索引的查询。相比于优化前的join语句需要做10亿次条件判断来说，这个优化效果还是很明显的。</li></ol><p>其实这里使用内存临时表的效果更好，原因有三个：</p><ol><li>相比于InnoDB表，使用内存表不需要写磁盘，往表temp_t的写数据的速度更快；</li><li>索引b使用hash索引，查找的速度比B-Tree索引快；</li><li>临时表数据只有2000行，占用的内存有限。</li></ol><p>将临时表t1改成内存临时表，并且在字段b上创建一个hash索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index (b))engine<span class="operator">=</span>memory;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b<span class="operator">=</span>temp_t.b);</span><br></pre></td></tr></table></figure><h2 id="扩展-hash-join"><a href="#扩展-hash-join" class="headerlink" title="扩展-hash join"></a>扩展-hash join</h2><p>如果join_buffer里面维护的不是一个无序数组，而是一个哈希表的话，那么就不是10亿次判断，而是100万次hash查找。这样的话，整条语句的执行速度就快多了。</p><p>这个优化思路，我们可以自己实现在业务端。实现流程大致如下：</p><ol><li><code>select * from t1;</code>取得表t1的全部1000行数据，在业务端存入一个hash结构，比如C++里的set、PHP的dict这样的数据结构。</li><li><code>select * from t2 where b&gt;=1 and b&lt;=2000;</code> 获取表t2中满足条件的2000行数据。</li><li>把这2000行数据，一行一行地取到业务端，到hash结构的数据表中寻找匹配的数据。满足匹配的条件的这行数据，就作为结果集的一行。</li></ol><p>现在有一个三个表join的需求，假设这三个表的表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t1;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t3 <span class="keyword">like</span> t2;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ... <span class="operator">/</span><span class="operator">/</span>初始化三张表的数据</span><br></pre></td></tr></table></figure><p>语句的需求实现如下的join逻辑：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span>(t1.a<span class="operator">=</span>t2.a) <span class="keyword">join</span> t3 <span class="keyword">on</span> (t2.b<span class="operator">=</span>t3.b) <span class="keyword">where</span> t1.c<span class="operator">&gt;=</span>X <span class="keyword">and</span> t2.c<span class="operator">&gt;=</span>Y <span class="keyword">and</span> t3.c<span class="operator">&gt;=</span>Z;</span><br></pre></td></tr></table></figure><blockquote><p>现在为了得到最快的执行速度，如果让你来设计表t1、t2、t3上的索引，来支持这个join语句，你会加哪些索引呢？</p></blockquote><blockquote><p>同时，如果我希望你用straight_join来重写这个语句，配合你创建的索引，你就需要安排连接顺序，你主要考虑的因素是什么呢？</p></blockquote><p>答：第一原则是要尽量使用BKA算法。需要注意的是，使用BKA算法的时候，并不是“先计算两个表join的结果，再跟第三个表join”，而是直接嵌套查询的。</p><p>具体实现是：在t1.c&gt;&#x3D;X、t2.c&gt;&#x3D;Y、t3.c&gt;&#x3D;Z这三个条件里，选择一个经过过滤以后，数据最少的那个表，作为第一个驱动表。此时，可能会出现如下两种情况。</p><p>第一种情况，如果选出来是表t1或者t3，那剩下的部分就固定了。</p><ol><li>如果驱动表是t1，则连接顺序是t1-&gt;t2-&gt;t3，要在被驱动表字段创建上索引，也就是t2.a 和 t3.b上创建索引；</li><li>如果驱动表是t3，则连接顺序是t3-&gt;t2-&gt;t1，需要在t2.b 和 t1.a上创建索引。</li></ol><p>同时，我们还需要在第一个驱动表的字段c上创建索引。</p><p>第二种情况是，如果选出来的第一个驱动表是表t2的话，则需要评估另外两个条件的过滤效果。</p><p>总之，整体的思路就是，尽量让每一次参与join的驱动表的数据集，越小越好，因为这样我们的驱动表就会越小。</p><h1 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h1><p><strong>临时表和内存表的区别：</strong></p><ul><li>内存表，指的是使用Memory引擎的表，建表语法是create table … engine&#x3D;memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。</li><li>而临时表，可以使用各种引擎类型 。如果是使用InnoDB引擎或者MyISAM引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用Memory引擎。</li></ul><h2 id="为什么临时表可以重名"><a href="#为什么临时表可以重名" class="headerlink" title="为什么临时表可以重名"></a>为什么临时表可以重名</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key)engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></table></figure><p>MySQL要给这个InnoDB表创建一个frm文件保存表结构定义，<strong>这个frm文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程id}_{线程id}_序列号”</strong>。你可以使用select @@tmpdir命令，来显示实例的临时文件目录。</p><p>而关于表中数据的存放方式，在不同的MySQL版本中有着不同的处理方式：</p><ul><li>在5.6以及之前的版本里，MySQL会在临时文件目录下创建一个相同前缀、以.ibd为后缀的文件，用来存放数据文件；</li><li>而从 5.7版本开始，MySQL引入了一个临时文件表空间，专门用来存放临时文件的数据。因此，我们就不需要再创建ibd文件了。</li></ul><p>MySQL维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个table_def_key。一个普通表的table_def_key的值是由“库名+表名”得到的，而临时表的 table_def_key 是由 “server_id+thread_id+库名+表名”。</p><p>每个线程都维护了自己的临时表链表。这样每次session内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在session结束的时候，对链表里的每个临时表，执行 “DROP TEMPORARY TABLE +表名”操作。</p><h2 id="临时表和主备复制"><a href="#临时表和主备复制" class="headerlink" title="临时表和主备复制"></a>临时表和主备复制</h2><p>在主库上执行下面这个语句序列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_normal(id <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>)engine<span class="operator">=</span>innodb;<span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t <span class="keyword">like</span> t_normal;<span class="comment">/*Q2*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">/*Q3*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_normal <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp_t;<span class="comment">/*Q4*/</span></span><br></pre></td></tr></table></figure><p>如果关于临时表的操作都不记录，那么在备库就只有create table t_normal表和insert into t_normal select * from temp_t这两个语句的binlog日志，备库在执行到insert into t_normal的时候，就会报错“表temp_t不存在”。</p><p>如果把binlog设置为row格式，在记录insert into t_normal的binlog时，记录的是这个操作的数据，即：write_row event里面记录的逻辑是“插入一行数据（1,1)”。也就是说，只在binlog_format&#x3D;statment&#x2F;mixed 的时候，binlog中才会记录临时表的操作。</p><p>这种情况下，创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，这时候我们就需要在主库上再写一个DROP TEMPORARY TABLE传给备库执行。</p><p>MySQL在记录binlog的时候，会把主库执行这个语句的线程id写到binlog中。这样，在备库的应用线程就能够知道执行每个语句的主库线程id，并利用这个线程id来构造临时表的table_def_key：</p><ol><li>session A的临时表t1，在备库的table_def_key就是：库名+t1+“M的serverid”+“session A的thread_id”;</li><li>session B的临时表t1，在备库的table_def_key就是 ：库名+t1+“M的serverid”+“session B的thread_id”。</li></ol><p>由于table_def_key不同，所以这两个表在备库的应用线程里面是不会冲突的。</p><blockquote><p>我们可以使用alter table语法修改临时表的表名，而不能使用rename语法。你知道这是什么原因吗？</p></blockquote><p>在实现上，执行rename table语句的时候，要求按照“库名&#x2F;表名.frm”的规则去磁盘找文件，但是临时表在磁盘上的frm文件是放在tmpdir目录下的，并且文件名的规则是“#sql{进程id}_{线程id}_序列号.frm”，因此会报“找不到文件名”的错误。</p><blockquote><p>假设你刚刚接手的一个数据库上，真的发现了一个内存表。备库重启之后肯定是会导致备库的内存表数据被清空，进而导致主备同步停止。这时，最好的做法是将它修改成InnoDB引擎表。</p><p>假设当时的业务场景暂时不允许你修改引擎，你可以加上什么自动化逻辑，来避免主备同步停止呢？</p></blockquote><p>那么就把备库的内存表引擎先都改成InnoDB。对于每个内存表，执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> sql_log_bin<span class="operator">=</span>off;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tbl_name engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></table></figure><p>这样就能避免备库重启的时候，数据丢失的问题。</p><p>由于主库重启后，会往binlog里面写“delete from tbl_name”，这个命令传到备库，备库的同名的表数据也会被清空。</p><p>因此，就不会出现主备同步停止的问题。</p><p>如果由于主库异常重启，触发了HA，这时候我们之前修改过引擎的备库变成了主库。而原来的主库变成了新备库，在新备库上把所有的内存表（这时候表里没数据）都改成InnoDB表。</p><p>所以，如果我们不能直接修改主库上的表引擎，可以配置一个自动巡检的工具，在备库上发现内存表就把引擎改了。</p><h1 id="Union执行流程"><a href="#Union执行流程" class="headerlink" title="Union执行流程"></a>Union执行流程</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">reate <span class="keyword">table</span> t1(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(a));</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><p>然后，我们执行下面这条语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> <span class="number">1000</span> <span class="keyword">as</span> f) <span class="keyword">union</span> (<span class="keyword">select</span> id <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> limit <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>这条语句用到了union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。</p><p>这个语句的执行流程是这样的：</p><ol><li>创建一个内存临时表，这个临时表只有一个整型字段f，并且f是主键字段。</li><li>执行第一个子查询，得到1000这个值，并存入临时表中。</li><li>执行第二个子查询：<ul><li>拿到第一行id&#x3D;1000，试图插入临时表中。但由于1000这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；</li><li>取到第二行id&#x3D;999，插入临时表成功。</li></ul></li><li>从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是1000和999。</li></ol><p>这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键id的唯一性约束，实现了union的语义。</p><h1 id="Group-by-执行流程"><a href="#Group-by-执行流程" class="headerlink" title="Group by 执行流程"></a>Group by 执行流程</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id<span class="operator">%</span><span class="number">10</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure><p>这个语句的逻辑是把表t1里的数据，按照 id%10 进行分组统计，并按照m的结果排序后输出。</p><p>这个语句的执行流程是这样的：</p><ol><li>创建内存临时表，表里有两个字段m和c，主键是m；</li><li>扫描表t1的索引a，依次取出叶子节点上的id值，计算id%10的结果，记为x；<ul><li>如果临时表中没有主键为x的行，就插入一个记录(x,1);</li><li>如果表中有主键为x的行，就将x这一行的c值加1；</li></ul></li><li>遍历完成后，再根据字段m做排序，得到结果集返回给客户端。</li></ol><p>如果你的需求并不需要对结果进行排序，那你可以在SQL语句末尾增加order by null，也就是改成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id<span class="operator">%</span><span class="number">10</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>这个例子里由于临时表只有10行，内存可以放得下，因此全程只使用了内存临时表。但是，内存临时表的大小是有限制的，参数tmp_table_size就是控制这个内存大小的，默认是16M。</p><p>如果我执行下面这个语句序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set tmp_table_size=1024;</span><br><span class="line">select id%100 as m, count(*) as c from t1 group by m order by null limit 10;</span><br></pre></td></tr></table></figure><p>把内存临时表的大小限制为最大1024字节，并把语句改成id % 100，这样返回结果里有100行数据。但是，这时的内存临时表大小不够存下这100行数据，也就是说，执行过程中会发现内存临时表大小到达了上限（1024字节）。</p><p>那么，这时候就会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是InnoDB。</p><h1 id="Group-by-优化方法"><a href="#Group-by-优化方法" class="headerlink" title="Group by 优化方法"></a>Group by 优化方法</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>不论是使用内存临时表还是磁盘临时表，group by逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。</p><p>group by的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的id%100的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。</p><p>InnoDB的索引，就可以满足这个输入有序的条件。</p><p>在MySQL 5.7版本支持了generated column机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列z，然后在z列上创建一个索引（如果是MySQL 5.6及之前的版本，你也可以创建普通列和索引，来解决这个问题）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">column</span> z <span class="type">int</span> generated always <span class="keyword">as</span>(id <span class="operator">%</span> <span class="number">100</span>), <span class="keyword">add</span> index(z);</span><br></pre></td></tr></table></figure><h2 id="直接排序"><a href="#直接排序" class="headerlink" title="直接排序"></a>直接排序</h2><p>在group by语句中加入SQL_BIG_RESULT这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。</p><p>因此，下面这个语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;</span><br></pre></td></tr></table></figure><p>的执行流程就是这样的：</p><ol><li>初始化sort_buffer，确定放入一个整型字段，记为m；</li><li>扫描表t1的索引a，依次取出里面的id值, 将 id%100的值存入sort_buffer中；</li><li>扫描完成后，对sort_buffer的字段m做排序（如果sort_buffer内存不够用，就会利用磁盘临时文件辅助排序）；</li><li>排序完成后，就得到了一个有序数组。</li></ol><p>根据有序数组，得到数组里面的不同值，以及每个值的出现次数。</p><blockquote><p>MySQL什么时候会使用内部临时表？</p></blockquote><ol><li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；</li><li>join_buffer是无序数组，sort_buffer是有序数组，临时表是二维表结构；</li><li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union需要用到唯一索引约束， group by还需要用到另外一个字段来存累积计数。</li></ol><blockquote><p>group by 优化方法总结：</p></blockquote><ol><li>如果对group by语句的结果没有排序要求，要在语句后面加 order by null；</li><li>尽量让group by过程用上表的索引，确认方法是explain结果里没有Using temporary 和 Using filesort；</li><li>如果group by需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大tmp_table_size参数，来避免用到磁盘临时表；</li><li>如果数据量实在太大，使用SQL_BIG_RESULT这个提示，来告诉优化器直接使用排序算法得到group by的结果。</li></ol><h1 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h1><h2 id="自增主键存储位置"><a href="#自增主键存储位置" class="headerlink" title="自增主键存储位置"></a>自增主键存储位置</h2><p>实际上，<strong>表的结构定义存放在后缀名为.frm的文件中，但是并不会保存自增值。</strong></p><p>不同的引擎对于自增值的保存策略不同。</p><ul><li>MyISAM引擎的自增值保存在数据文件中。</li><li>InnoDB引擎的自增值，其实是保存在了内存里，并且到了MySQL 8.0版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为MySQL重启前的值”，具体情况是：<ul><li>在MySQL 5.7及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值max(id)，然后将max(id)+1作为这个表当前的自增值。﻿<br>也就是说，MySQL重启可能会修改一个表的AUTO_INCREMENT的值。</li><li>在MySQL 8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值。</li></ul></li></ul><h2 id="自增值修改机制"><a href="#自增值修改机制" class="headerlink" title="自增值修改机制"></a>自增值修改机制</h2><p>在插入一行数据的时候，自增值的行为如下：</p><ol><li>如果插入数据时id字段指定为0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT值填到自增字段；</li><li>如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值。</li></ol><p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是X，当前的自增值是Y。</p><ol><li>如果X&lt;Y，那么这个表的自增值不变；</li><li>如果X≥Y，就需要把当前自增值修改为新的自增值 + 1。</li></ol><p>auto_increment_offset 和 auto_increment_increment是两个系统参数，分别用来表示自增的初始值和步长，默认值都是1。</p><blockquote><p>备注：在一些场景下，使用的就不全是默认值。比如，双M的主备结构里要求双写的时候，我们就可能会设置成auto_increment_increment&#x3D;2，让一个库的自增id都是奇数，另一个库的自增id都是偶数，避免两个库生成的主键发生冲突。</p></blockquote><h2 id="自增值修改时机"><a href="#自增值修改时机" class="headerlink" title="自增值修改时机"></a>自增值修改时机</h2><h3 id="唯一键冲突"><a href="#唯一键冲突" class="headerlink" title="唯一键冲突"></a>唯一键冲突</h3><p>表t里面已经有了(1,1,1)这条记录，这时我再执行一条插入数据命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>, <span class="number">1</span>); </span><br></pre></td></tr></table></figure><ol><li>执行器调用InnoDB引擎接口写入一行，传入的这一行的值是(0,1,1);</li><li>InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2；</li><li>将传入的行的值改成(2,1,1);</li><li>将表的自增值改成3；</li><li>继续执行插入数据操作，由于已经存在c&#x3D;1的记录，所以报Duplicate key error，语句返回。</li></ol><p>在这之后，再插入新的数据行时，拿到的自增id就是3。</p><h3 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚"></a>事务回滚</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>插入的行是(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>事务回滚后，自增值为什么不能回退？</p></blockquote><p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请。</p><ol><li>每次申请id之前，先判断表里面是否已经存在这个id。如果存在，就跳过这个id。但是，这个方法的成本很高。因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断id是否存在。</li><li>把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li></ol><p>这两个方法都会导致性能问题。InnoDB放弃了这个设计，语句执行失败也不回退自增id。</p><h3 id="自增锁的优化"><a href="#自增锁的优化" class="headerlink" title="自增锁的优化"></a>自增锁的优化</h3><p>MySQL 5.0版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。</p><p>MySQL 5.1.22版本引入了一个新策略，新增参数innodb_autoinc_lock_mode，默认值是1。</p><ol><li>这个参数的值被设置为0时，表示采用之前MySQL 5.0版本的策略，即语句执行结束后才释放锁；</li><li>这个参数的值被设置为1时：<ul><li>普通insert语句，自增锁在申请之后就马上释放；</li><li>类似insert … select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li></ul></li><li>这个参数的值被设置为2时，所有的申请自增主键的动作都是申请后就释放锁。</li></ol><blockquote><p>为什么参数innodb_autoinc_lock_mode要设置为2?</p></blockquote><p>如果有两个事务在批量新增，而批量插入过程中没有加自增锁，在binlog_format&#x3D;statement的情况下，binlog里面对表t的更新日志只有两种情况：要么先记session A的，要么先记session B的。但不论是哪一种，这个binlog拿去从库执行，或者用来恢复临时实例，备库和临时实例里面，session B这个语句执行出来，生成的结果里面，id都是连续的。这时，这个库就发生了数据不一致。</p><p>因此，<strong>在生产上，尤其是有insert … select这种批量插入数据的场景时，从并发插入数据性能的角度考虑，我建议你这样设置：innodb_autoinc_lock_mode&#x3D;2 ，并且 binlog_format&#x3D;row</strong>.这样做，既能提升并发性，又不会出现数据一致性问题。</p><p>对于批量插入数据的语句，MySQL有一个批量申请自增id的策略：</p><ol><li><p>语句执行过程中，第一次申请自增id，会分配1个；</p></li><li><p>1个用完以后，这个语句第二次申请自增id，会分配2个；</p></li><li><p>2个用完以后，还是这个语句，第三次申请自增id，会分配4个；</p></li><li><p>依此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">5</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>insert…select，实际上往表t2中插入了4行数据。但是，这四行数据是分三次申请的自增id，第一次申请到了id&#x3D;1，第二次被分配了id&#x3D;2和id&#x3D;3， 第三次被分配到id&#x3D;4到id&#x3D;7。</p><p>由于这条语句实际只用上了4个id，所以id&#x3D;5到id&#x3D;7就被浪费掉了。之后，再执行insert into t2 values(null, 5,5)，实际上插入的数据就是（8,5,5)。</p></li></ol><h1 id="Insert-加锁"><a href="#Insert-加锁" class="headerlink" title="Insert 加锁"></a>Insert 加锁</h1><p>表t和t2的表结构、初始化数据语句如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t</span><br></pre></td></tr></table></figure><p>为什么在可重复读隔离级别下，binlog_format&#x3D;statement时执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure><p>这个语句时，需要对表t的所有行和间隙加锁呢？</p><table><thead><tr><th>session A</th><th>session B</th></tr></thead><tbody><tr><td>insert into t values(-1,-1,-1);</td><td>insert into t2(c,d) select c,d from t;</td></tr></tbody></table><p>如果session B先执行，由于这个语句对表t主键索引加了(-∞,1]这个next-key lock，会在语句执行完成后，才允许session A的insert语句执行。</p><p>但如果没有锁的话，就可能出现session B的insert语句先执行，但是后写入binlog的情况。于是，在binlog_format&#x3D;statement的情况下，binlog里面就记录了这样的语句序列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure><p>这个语句到了备库执行，就会把id&#x3D;-1这一行也写到表t2中，出现主备不一致。</p><h2 id="insert-循环写入"><a href="#insert-循环写入" class="headerlink" title="insert 循环写入"></a>insert 循环写入</h2><p>执行insert … select 的时候，对目标表也不是锁全表，而是只锁住需要访问的资源。</p><p>如果现在有这么一个需求：要往表t2中插入一行数据，这一行的c值是表t中c值的最大值加1。</p><p>此时，我们可以这么写这条SQL语句 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d)  (<span class="keyword">select</span> c<span class="operator">+</span><span class="number">1</span>, d <span class="keyword">from</span> t force index(c) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> limit <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这个语句的加锁范围，就是表t索引c上的(4,supremum]这个next-key lock和主键索引上id&#x3D;4这一行。</p><h2 id="insert-唯一键冲突"><a href="#insert-唯一键冲突" class="headerlink" title="insert 唯一键冲突"></a>insert 唯一键冲突</h2><table><thead><tr><th>session A</th><th>session B</th></tr></thead><tbody><tr><td>insert into t values(10,10,10);</td><td></td></tr><tr><td>begin;<br />insert into t values(11,10,10);<br />(Duplicate entry ‘10’ for key ‘c’)</td><td></td></tr><tr><td></td><td>insert into t values(12,9,9);<br />(blocked)</td></tr></tbody></table><p>session A执行的insert语句，发生主键冲突的时候，并不只是简单地报错返回，还在冲突的索引上加了锁。这时候，session A持有索引c上的(5,10]共享next-key lock（读锁）。从作用上来看，这样做可以避免这一行被别的事务删掉。</p><h1 id="拷贝数据"><a href="#拷贝数据" class="headerlink" title="拷贝数据"></a>拷贝数据</h1><h2 id="mysqldump方法"><a href="#mysqldump方法" class="headerlink" title="mysqldump方法"></a>mysqldump方法</h2><p>使用mysqldump命令将数据导出成一组INSERT语句。你可以使用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user --add-locks --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&gt;900&quot; --result-file=/client_tmp/t.sql</span><br></pre></td></tr></table></figure><ol><li>–single-transaction的作用是，在导出数据的时候不需要对表db1.t加表锁，而是使用START TRANSACTION WITH CONSISTENT SNAPSHOT的方法；</li><li>–add-locks设置为0，表示在输出的文件结果里，不增加” LOCK TABLES <code>t</code> WRITE;” ；</li><li>–no-create-info的意思是，不需要导出表结构；</li><li>–set-gtid-purged&#x3D;off表示的是，不输出跟GTID相关的信息；</li><li>–result-file指定了输出文件的路径，其中client表示生成的文件是在客户端机器上的。</li></ol><p>如果你希望生成的文件中一条INSERT语句只插入一行数据的话，可以在执行mysqldump命令时，加上参数–skip-extended-insert。</p><p>然后，将这些INSERT语句放到db2库里去执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h127.0.0.1 -P13000  -uroot db2 -e &quot;source /client_tmp/t.sql&quot;</span><br></pre></td></tr></table></figure><p>需要说明的是，source并不是一条SQL语句，而是一个客户端命令。mysql客户端执行这个命令的流程是这样的：</p><ol><li>打开文件，默认以分号为结尾读取一条条的SQL语句；</li><li>将SQL语句发送到服务端执行。</li></ol><h2 id="导出CSV文件"><a href="#导出CSV文件" class="headerlink" title="导出CSV文件"></a>导出CSV文件</h2><p>MySQL提供了下面的语法，用来将查询结果导出到服务端本地目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from db1.t where a&gt;900 into outfile &#x27;/server_tmp/t.csv&#x27;;</span><br></pre></td></tr></table></figure><p>我们在使用这条语句时，需要注意如下几点。</p><ol><li>这条语句会将结果保存在服务端。如果你执行命令的客户端和MySQL服务端不在同一个机器上，客户端机器的临时目录下是不会生成t.csv文件的。</li><li>into outfile指定了文件的生成位置（&#x2F;server_tmp&#x2F;），这个位置必须受参数secure_file_priv的限制。参数secure_file_priv的可选值和作用分别是：<ul><li>如果设置为empty，表示不限制文件生成的位置，这是不安全的设置；</li><li>如果设置为一个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录；</li><li>如果设置为NULL，就表示禁止在这个MySQL实例上执行select … into outfile 操作。</li></ul></li><li>这条命令不会帮你覆盖文件，因此你需要确保&#x2F;server_tmp&#x2F;t.csv这个文件不存在，否则执行语句时就会因为有同名文件的存在而报错。</li><li>这条命令生成的文本文件中，原则上一个数据行对应文本文件的一行。但是，如果字段中包含换行符，在生成的文本中也会有换行符。不过类似换行符、制表符这类符号，前面都会跟上“\”这个转义符，这样就可以跟字段之间、数据行之间的分隔符区分开。</li></ol><p><strong>select …into outfile方法不会生成表结构文件</strong>, 所以我们导数据时还需要单独的命令得到表结构定义。mysqldump提供了一个–tab参数，可以同时导出表结构定义文件和csv数据文件。这条命令的使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user ---single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&gt;900&quot; --tab=$secure_file_priv</span><br></pre></td></tr></table></figure><p>这条命令会在$secure_file_priv定义的目录下，创建一个t.sql文件保存建表语句，同时创建一个t.txt文件保存CSV数据。</p><p>得到.csv导出文件后，你就可以用下面的load data命令将数据导入到目标表db2.t中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data infile &#x27;/server_tmp/t.csv&#x27; into table db2.t;</span><br></pre></td></tr></table></figure><p>这条语句的执行流程如下所示。</p><ol><li>主库执行完成后，将&#x2F;server_tmp&#x2F;t.csv文件的内容直接写到binlog文件中。</li><li>往binlog文件中写入语句load data local infile ‘&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0’ INTO TABLE <code>db2</code>.<code>t</code>。</li><li>把这个binlog日志传到备库。</li><li>备库的apply线程在执行这个事务日志时：<br>a. 先将binlog中t.csv文件的内容读出来，写入到本地临时目录&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0 中；<br>b. 再执行load data语句，往备库的db2.t表中插入跟主库相同的数据</li></ol><p><strong>load data命令有两种用法</strong>：</p><ol><li>不加“local”，是读取服务端的文件，这个文件必须在secure_file_priv指定的目录或子目录下；</li><li>加上“local”，读取的是客户端的文件，只要mysql客户端有访问这个文件的权限即可。这时候，MySQL客户端会先把本地文件传给服务端，然后执行上述的load data流程。</li></ol><blockquote><p>binlog_format&#x3D;statement的时候，binlog记录的load data命令是带local的。既然这条命令是发送到备库去执行的，那么备库执行的时候也是本地执行，为什么需要这个local呢？如果写到binlog中的命令不带local，又会出现什么问题呢？</p></blockquote><p>这样做的一个原因是，为了确保备库应用binlog正常。因为备库可能配置了secure_file_priv&#x3D;null，所以如果不用local的话，可能会导入失败，造成主备同步延迟。</p><p>另一种应用场景是使用mysqlbinlog工具解析binlog文件，并应用到目标库的情况。你可以使用下面这条命令 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog $binlog_file | mysql -h$host -P$port -u$user -p$pwd</span><br></pre></td></tr></table></figure><p>把日志直接解析出来发给目标库执行。增加local，就能让这个方法支持非本地的$host。</p><h2 id="物理拷贝方法"><a href="#物理拷贝方法" class="headerlink" title="物理拷贝方法"></a>物理拷贝方法</h2><p>在MySQL 5.6版本引入了<strong>可传输表空间</strong>(transportable tablespace)的方法，可以通过导出+导入表空间的方式，实现物理拷贝表的功能。</p><p>假设我们现在的目标是在db1库下，复制一个跟表t相同的表r，具体的执行步骤如下：</p><ol><li>执行 create table r like t，创建一个相同表结构的空表；</li><li>执行alter table r discard tablespace，这时候r.ibd文件会被删除；</li><li>执行flush table t for export，这时候db1目录下会生成一个t.cfg文件；</li><li>在db1目录下执行cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令；</li><li>执行unlock tables，这时候t.cfg文件会被删除；</li><li>执行alter table r import tablespace，将这个r.ibd文件作为表r的新的表空间，由于这个文件的数据内容和t.ibd是相同的，所以表r中就有了和表t相同的数据。</li></ol><p>关于拷贝表的这个流程，有以下几个注意点：</p><ol><li>在第3步执行完flsuh table命令之后，db1.t整个表处于只读状态，直到执行unlock tables命令后才释放读锁；</li><li>在执行import tablespace的时候，为了让文件里的表空间id和数据字典中的一致，会修改t.ibd的表空间id。而这个表空间id存在于每一个数据页中。因此，如果是一个很大的文件（比如TB级别），每个数据页都需要修改，所以你会看到这个import语句的执行是需要一些时间的。当然，如果是相比于逻辑导入的方法，import语句的耗时是非常短的。</li></ol><h1 id="MySQL权限"><a href="#MySQL权限" class="headerlink" title="MySQL权限"></a>MySQL权限</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;ua&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;pa&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这条语句的逻辑是创建一个用户’ua’@’%’，密码是pa。注意，在MySQL里面，用户名(user)+地址(host)才表示一个用户，因此 ua@ip1 和 ua@ip2代表的是两个不同的用户。</p><p>这条命令做了两个动作：</p><ol><li>磁盘上，往mysql.user表里插入一行，由于没有指定权限，所以这行数据上所有表示权限的字段的值都是N；</li><li>内存里，往数组acl_users里插入一个acl_user对象，这个对象的access字段值为0。</li></ol><h2 id="全局权限"><a href="#全局权限" class="headerlink" title="全局权限"></a>全局权限</h2><p>如果我要给用户ua赋一个最高权限的话，语句是这么写的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;ua&#x27;@&#x27;%&#x27; with grant option;</span><br></pre></td></tr></table></figure><p>这个grant命令做了两个动作：</p><ol><li>磁盘上，将mysql.user表里，用户’ua’@’%’这一行的所有表示权限的字段的值都修改为‘Y’；</li><li>内存里，从数组acl_users中找到这个用户对应的对象，将access值（权限位）修改为二进制的“全1”。</li></ol><p>grant 命令对于全局权限，同时更新了磁盘和内存。命令完成后即时生效，接下来新创建的连接会使用新的权限。对于一个已经存在的连接，它的全局权限不受 grant 命令影响。</p><p>如果要回收上面的grant语句赋予的权限，你可以使用下面这条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke all privileges on *.* from &#x27;ua&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><h2 id="db权限"><a href="#db权限" class="headerlink" title="db权限"></a>db权限</h2><p>如果要让用户ua拥有库db1的所有权限，可以执行下面这条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on db1.* to &#x27;ua&#x27;@&#x27;%&#x27; with grant option;</span><br></pre></td></tr></table></figure><p>基于库的权限记录保存在mysql.db表中，在内存里则保存在数组acl_dbs中。这条grant命令做了如下两个动作：</p><ol><li>磁盘上，往mysql.db表中插入了一行记录，所有权限位字段设置为“Y”；</li><li>内存里，增加一个对象到数组acl_dbs中，这个对象的权限位为“全1”。</li></ol><p>每次需要判断一个用户对一个数据库读写权限的时候，都需要遍历一次acl_dbs数组，根据user、host和db找到匹配的对象，然后根据对象的权限位来判断。</p><p>也就是说，grant修改db权限的时候，是同时对磁盘和内存生效的。</p><p>super是全局权限，这个权限信息在线程对象中，而revoke操作影响不到这个线程对象。</p><h2 id="表权限和列权限"><a href="#表权限和列权限" class="headerlink" title="表权限和列权限"></a>表权限和列权限</h2><p>表权限定义存放在表mysql.tables_priv中，列权限定义存放在表mysql.columns_priv中。这两类权限，组合起来存放在内存的hash结构column_priv_hash中。</p><p>这两类权限的赋权命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table db1.t1(id int, a int);</span><br><span class="line"></span><br><span class="line">grant all privileges on db1.t1 to &#x27;ua&#x27;@&#x27;%&#x27; with grant option;</span><br><span class="line">GRANT SELECT(id), INSERT (id,a) ON mydb.mytbl TO &#x27;ua&#x27;@&#x27;%&#x27; with grant option;</span><br></pre></td></tr></table></figure><p>flush privileges命令会清空acl_users数组，然后从mysql.user表中读取数据重新加载，重新构造一个acl_users数组。也就是说，以数据表中的数据为准，会将全局权限内存数组重新加载一遍。</p><p><strong>正常情况下，grant命令之后，没有必要跟着执行flush privileges命令。</strong></p><p><strong>flush privileges使用场景：</strong>当数据表中的权限数据跟内存中的权限数据不一致的时候，flush privileges语句可以用来重建内存数据，达到一致状态。而这种不一致往往是由于直接用DML语句操作系统权限表导致的，所以我们尽量不要使用这类语句。</p><h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><p>先创建一个表t：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `ftime` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  KEY (`ftime`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(ftime))</span><br><span class="line">(<span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2017</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2018 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2018</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2019 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2019</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"><span class="keyword">PARTITION</span> p_others <span class="keyword">VALUES</span> LESS THAN MAXVALUE ENGINE <span class="operator">=</span> InnoDB);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="string">&#x27;2017-4-1&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;2018-4-1&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>我在表t中初始化插入了两行记录，按照定义的分区规则，这两行记录分别落在p_2018和p_2019这两个分区上。</p><p>可以看到，这个表包含了一个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件。也就是说：</p><ul><li>对于引擎层来说，这是4个表；</li><li>对于Server层来说，这是1个表。</li></ul><h2 id="分区表的引擎层行为"><a href="#分区表的引擎层行为" class="headerlink" title="分区表的引擎层行为"></a>分区表的引擎层行为</h2><p>初始化表t的时候，只插入了两行数据， ftime的值分别是，‘2017-4-1’ 和’2018-4-1’ 。</p><table><thead><tr><th></th><th>session A</th><th>session B</th></tr></thead><tbody><tr><td>T1</td><td>begin;<br />select * from t where ftime&#x3D;’2017-5-1’ for update;</td><td></td></tr><tr><td>T2</td><td></td><td>insert into t values(‘2018-2-1’,1);<br />(Query OK)<br />insert into t values(‘2017-12-1’,1);<br />(blocked)</td></tr></tbody></table><p>session A的select语句对索引ftime上这两个记录之间的间隙加了锁，(‘2017-4-1’,’2018-4-1’)，sesion B的两条插入语句应该都要进入锁等待状态。</p><p>但实际上，session B的第一个insert语句是可以执行成功的。这是因为，对于引擎来说，p_2018和p_2019是两个不同的表，也就是说2017-4-1的下一个记录并不是2018-4-1，而是p_2018分区的supremum。</p><p>所以T1时刻，在表t的ftime索引上，间隙和加锁的状态是 p_2018 表上的 (2017-4-1,supremum)，session B要写入一行ftime是2018-2-1的时候是可以成功的，而要写入2017-12-1这个记录，就要等session A的间隙锁。</p><h2 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h2><p>使用MyISAM引擎时，每当第一次访问一个分区表的时候，MySQL需要把所有的分区都访问一遍。<strong>一个典型的报错情况</strong>是这样的：如果一个分区表的分区很多，比如超过了1000个，而MySQL启动的时候，open_files_limit参数使用的是默认值1024，那么就会在访问这个表的时候，由于需要打开所有的文件，导致打开表文件的个数超过了上限而报错。</p><p>MyISAM分区表使用的分区策略，我们称为<strong>通用分区策略</strong>（generic partitioning），每次访问分区都由server层控制。通用分区策略，是MySQL一开始支持分区表的时候就存在的代码，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题。</p><p>从MySQL 5.7.9开始，InnoDB引擎引入了<strong>本地分区策略</strong>（native partitioning）。这个策略是在InnoDB内部自己管理打开分区的行为。</p><p>从MySQL 8.0版本开始，就不允许创建MyISAM分区表了，只允许创建已经实现了本地分区策略的引擎。目前来看，只有InnoDB和NDB这两个引擎支持了本地分区策略。</p><h2 id="分区表的server层行为"><a href="#分区表的server层行为" class="headerlink" title="分区表的server层行为"></a>分区表的server层行为</h2><ol><li>MySQL在第一次打开分区表的时候，需要访问所有的分区；</li><li>在server层，认为这是同一张表，因此所有分区共用同一个MDL锁；</li><li>在引擎层，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，只访问必要的分区。</li></ol><h2 id="分区表的应用场景"><a href="#分区表的应用场景" class="headerlink" title="分区表的应用场景"></a>分区表的应用场景</h2><p>如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求。这时候，按照时间分区的分区表，就可以直接通过alter table t drop partition …这个语法删掉分区，从而删掉过期的历史数据。</p><p>这个alter table t drop partition …操作是直接删除分区文件，效果跟drop普通表类似。与使用delete语句删除数据相比，优势是速度快、对系统影响小。</p><blockquote><p>假设现在要创建一个自增字段id。MySQL要求分区表中的主键必须包含分区字段。如果要在表t的基础上做修改，你会怎么定义这个表的主键呢？为什么这么定义呢？</p></blockquote><p>由于MySQL要求主键包含所有的分区字段，所以肯定是要创建联合主键的。</p><p>两种方案：一种是(ftime, id)，另一种是(id, ftime)。</p><p>如果从利用率上来看，应该使用(ftime, id)这种模式。因为用ftime做分区key，说明大多数语句都是包含ftime的，使用这种模式，可以利用前缀索引的规则，减少一个索引。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;count-的实现方式&quot;&gt;&lt;a href=&quot;#count-的实现方式&quot; class=&quot;headerlink&quot; title=&quot;count(*) 的实现方式&quot;&gt;&lt;/a&gt;count(*) 的实现方式&lt;/h1&gt;&lt;p&gt;在不同的MySQL引擎中，count(*)有不同的实现方</summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://palette-k.github.io/tags/MySQL/"/>
    
    <category term="原理" scheme="https://palette-k.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MySQL高可用</title>
    <link href="https://palette-k.github.io/2023/11/30/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>https://palette-k.github.io/2023/11/30/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/</id>
    <published>2023-11-30T06:32:33.000Z</published>
    <updated>2023-12-07T01:35:01.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL主备一致"><a href="#MySQL主备一致" class="headerlink" title="MySQL主备一致"></a>MySQL主备一致</h1><h2 id="MySQL-主从复制"><a href="#MySQL-主从复制" class="headerlink" title="MySQL 主从复制"></a>MySQL 主从复制</h2><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MySQL/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.png"></p><p> 主库将数据库中数据的变化写入到 binlog</p><ul><li>在从库上通过change master命令，设置主库的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。</li><li>在从库上执行start slave命令，这时候从库会启动两个线程，就是图中的io_thread和sql_thread。其中io_thread负责与主库建立连接。</li><li>主库校验完用户名、密码后，创建一个 binlog dump 线程，开始按照从库传过来的位置来发送 binlog ，从库中的 I&#x2F;O 线程负责接收</li><li>从库的 I&#x2F;O 线程将接收的 binlog 写入到 relay log 中。</li><li>从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。</li></ul><h2 id="基于位点的主备切换"><a href="#基于位点的主备切换" class="headerlink" title="基于位点的主备切换"></a>基于位点的主备切换</h2><p>把节点B设置成节点A’的从库的时候，需要执行一条change master命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST=$host_name  #IP</span><br><span class="line">MASTER_PORT=$port       #端口</span><br><span class="line">MASTER_USER=$user_name  #用户名</span><br><span class="line">MASTER_PASSWORD=$password  #密码</span><br><span class="line">MASTER_LOG_FILE=$master_log_name  #主库对应的文件名</span><br><span class="line">MASTER_LOG_POS=$master_log_pos  #日志偏移量，从master_log_pos这个位置的日志继续同步</span><br></pre></td></tr></table></figure><p>从库B要切换的时候，就需要先经过“找同步位点”这个逻辑。</p><p>考虑到切换过程中不能丢数据，所以我们找位点的时候，总是要找一个“稍微往前”的，然后再通过判断跳过那些在从库B上已经执行过的事务。</p><p>一种取同步位点的方法是这样的：</p><ol><li>等待新主库A’把中转日志（relay log）全部同步完成；</li><li>在A’上执行show master status命令，得到当前A’上最新的File 和 Position；</li><li>取原主库A故障的时刻T；</li><li>用mysqlbinlog工具解析A’的File，得到T时刻的位点。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog File --stop-datetime=T --start-datetime=T</span><br></pre></td></tr></table></figure><p>假设在T这个时刻，主库A已经执行完成了一个insert 语句插入了一行数据R，并且已经将binlog传给了A’和B，然后在传完的瞬间主库A的主机就掉电了。</p><p>那么，这时候系统的状态是这样的：</p><ol><li>在从库B上，由于同步了binlog， R这一行已经存在；</li><li>在新主库A’上， R这一行也已经存在，日志是写在123这个位置之后的；</li><li>我们在从库B上执行change master命令，指向A’的File文件的123位置，就会把插入R这一行数据的binlog又同步到从库B去执行。</li></ol><p>这时候，从库B的同步线程就会报告 Duplicate entry ‘id_of_R’ for key ‘PRIMARY’ 错误，提示出现了主键冲突，然后停止同步。</p><p>切换任务时，要主动跳过错误，有两种方法：</p><p><strong>一种做法是</strong>，主动跳过一个事务。跳过命令的写法是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global sql_slave_skip_counter=1;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库B刚开始接到新主库A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。</p><p><strong>另外一种方式是，</strong>通过设置slave_skip_errors参数，直接设置跳过指定的错误。</p><p>在执行主备切换时，有这么两类错误，是经常会遇到的：</p><ul><li>1062错误是插入数据时唯一键冲突；</li><li>1032错误是删除数据时找不到行。</li></ul><p>因此，我们可以把slave_skip_errors 设置为 “1032,1062”，这样中间碰到这两个错误时就直接跳过。</p><p>记住等到主备间的同步关系建立完成，并稳定执行一段时间之后，我们还需要把这个参数设置为空，以免之后真的出现了主从数据不一致，也跳过了。</p><h2 id="GTID"><a href="#GTID" class="headerlink" title="GTID"></a>GTID</h2><p>GTID的全称是Global Transaction Identifier，也就是全局事务ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GTID=server_uuid:gno</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>server_uuid是一个实例第一次启动时自动生成的，是一个全局唯一的值；</li><li>gno是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1。</li></ul><p>GTID模式启动方式：启动时加上参数 gtid_mode&#x3D;on和enforce_gtid_consistency&#x3D;on</p><h3 id="关于GTID的理解"><a href="#关于GTID的理解" class="headerlink" title="关于GTID的理解"></a>关于GTID的理解</h3><p>假设，现在这个实例X是另外一个实例Y的从库，并且此时在实例Y上执行了下面这条插入语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>并且，这条语句在实例Y上的GTID是 “aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”。</p><p>那么，实例X作为Y的从库，就要同步这个事务过来执行，显然会出现主键冲突，导致实例X的同步线程停止。这时，我们应该怎么处理呢？</p><p>处理方法就是，你可以执行下面的这个语句序列：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set gtid_next=&#x27;aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10&#x27;;</span><br><span class="line">begin;</span><br><span class="line">commit;</span><br><span class="line">set gtid_next=automatic;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>其中，前三条语句的作用，是通过提交一个空事务，把这个GTID加到实例X的GTID集合中。</p><p>再执行start slave命令让同步线程执行起来的时候，虽然实例X上还是会继续执行实例Y传过来的事务，但是由于“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”已经存在于实例X的GTID集合中了，所以实例X就会直接跳过这个事务，也就不会再出现主键冲突的错误。</p><h3 id="GTID的使用"><a href="#GTID的使用" class="headerlink" title="GTID的使用"></a>GTID的使用</h3><p>在GTID模式下，备库B要设置为新主库A’的从库的语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$password </span><br><span class="line">master_auto_position=1 </span><br></pre></td></tr></table></figure><p>其中，master_auto_position&#x3D;1就表示这个主备关系使用的是GTID协议。可以看到，前面让我们头疼不已的MASTER_LOG_FILE和MASTER_LOG_POS参数，已经不需要指定了。</p><p>我们在实例B上执行start slave命令，取binlog的逻辑是这样的：</p><ol><li>实例B指定主库A’，基于主备协议建立连接。</li><li>实例B把set_b发给主库A’。</li><li>实例A’算出set_a与set_b的差集，也就是所有存在于set_a，但是不存在于set_b的GITD的集合，判断A’本地是否包含了这个差集需要的所有binlog事务。<br>a. 如果不包含，表示A’已经把实例B需要的binlog给删掉了，直接返回错误；<br>b. 如果确认全部包含，A’从自己的binlog文件里面，找出第一个不在set_b的事务，发给B；</li><li>之后就从这个事务开始，往后读文件，按顺序取binlog发给B去执行。</li></ol><p>其实，这个逻辑里面包含了一个设计思想：在基于GTID的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。因此，如果实例B需要的日志已经不存在，A’就拒绝把日志发给B。</p><blockquote><p>你在GTID模式下设置主从关系的时候，从库执行start slave命令后，主库发现需要的binlog已经被删除掉了，导致主备创建不成功。这种情况下，你觉得可以怎么处理呢？</p></blockquote><ol><li>如果业务允许主从不一致的情况，那么可以在主库上先执行show global variables like ‘gtid_purged’，得到主库已经删除的GTID集合，假设是gtid_purged1；然后先在从库上执行reset master，再执行set global gtid_purged &#x3D;‘gtid_purged1’；最后执行start slave，就会从主库现存的binlog开始同步。binlog缺失的那一部分，数据在从库上就可能会有丢失，造成主从不一致。</li><li>如果需要主从数据一致的话，最好还是通过重新搭建从库来做。</li><li>如果有其他的从库保留有全量的binlog的话，可以把新的从库先接到这个保留了全量binlog的从库，追上日志以后，如果有需要，再接回主库。</li><li>如果binlog有备份的情况，可以先在从库上应用缺失的binlog，然后再执行start slave。</li></ol><h2 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h2><p><strong>双M结构下（主备切换过程中），怎么解决循环复制问题？</strong></p><p>首先说一下什么是循环复制问题，举个例子说明一下。</p><p>业务逻辑在节点A上更新了一条语句，然后再把生成的binlog 发给节点B，节点B执行完这条更新语句后也会生成binlog。（参数log_slave_updates设置为on，表示备库执行relay log后生成binlog）</p><p>那么，如果节点A同时是节点B的备库，相当于又把节点B新生成的binlog拿过来执行了一次，然后节点A和B间，会不断地循环执行这个更新语句，也就是循环复制了。</p><p>MySQL在binlog中记录了这个命令第一次执行时所在实例的server id。所以它是根据 server id  来解决两个节点间的循环复制问题的：</p><ol><li>规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系；</li><li>一个备库接到binlog并在重放的过程中，生成与原binlog的server id相同的新的binlog；</li><li>每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li></ol><p>按照这个逻辑，如果我们设置了双M结构，日志的执行流就会变成这样：</p><ol><li>从节点A更新的事务，binlog里面记的都是A的server id；</li><li>传到节点B执行一次以后，节点B生成的binlog 的server id也是A的server id；</li><li>再传回给节点A，A判断到这个server id与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了。</li></ol><blockquote><p>什么情况下双M结构会出现循环复制？</p></blockquote><ul><li>在一个主库更新事务后，用命令set global server_id&#x3D;x修改了server_id。等日志再传回来的时候，发现server_id跟自己的server_id不同，就只能执行了。</li><li>trx1是在节点 B执行的，因此binlog上的server_id就是B，binlog传给节点 A，然后A和A’搭建了双M结构，就会出现循环复制。</li></ul><p>如果出现了循环复制，可以在A或者A’上，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave；</span><br><span class="line">CHANGE MASTER TO IGNORE_SERVER_IDS=(server_id_of_B);</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>这样这个节点收到日志后就不会再执行。过一段时间后，再执行下面的命令把这个值改回来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave；</span><br><span class="line">CHANGE MASTER TO IGNORE_SERVER_IDS=();</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><h2 id="binlog的三种格式对比"><a href="#binlog的三种格式对比" class="headerlink" title="binlog的三种格式对比"></a>binlog的三种格式对比</h2><h3 id="statement格式"><a href="#statement格式" class="headerlink" title="statement格式"></a>statement格式</h3><p>statement格式是记录语句到 binlog，因此可能会出现这样一种情况：在主库执行SQL语句的时候，用的是索引a；而在备库执行这条SQL语句的时候，却使用了索引b。假如这是条带有 LIMIT 的 DELETE 语句，从库和主库走不同的索引会导致数据不一致。</p><h3 id="row格式"><a href="#row格式" class="headerlink" title="row格式"></a>row格式</h3><p>使用 mysqlbinlog 工具查看binlog的内容，这个事务的binlog是从8900这个位置开始的，所以可以用start-position参数来指定从这个位置的日志开始解析。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog  <span class="operator">-</span>vv data<span class="operator">/</span>master<span class="number">.000001</span> <span class="comment">--start-position=8900;</span></span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/c3/c2/c342cf480d23b05d30a294b114cebfc2.png" alt="img"></p><p>从这个图中，我们可以看到以下几个信息：</p><ul><li>server id 1，表示这个事务是在server_id&#x3D;1的这个库上执行的。</li><li>每个event都有CRC32的值，这是因为我把参数binlog_checksum设置成了CRC32。</li><li>Table_map event示了接下来要打开的表，map到数字226。现在我们这条SQL语句只操作了一张表，如果要操作多张表呢？每个表都有一个对应的Table_map event、都会map到一个单独的数字，用于区分对不同表的操作。</li><li>我们在mysqlbinlog的命令中，使用了-vv参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1&#x3D;4、 @2&#x3D;4这些值）。</li><li>binlog_row_image的默认配置是FULL，因此Delete_event里面，包含了删掉的行的所有字段的值。如果把binlog_row_image设置为MINIMAL，则只会记录必要的信息，在这个例子里，就是只会记录id&#x3D;4这个信息。</li><li>最后的Xid event，用于表示事务被正确地提交了。</li></ul><p>你可以看到，当binlog_format使用row格式的时候，binlog里面记录了真实删除行的主键id，这样binlog传到备库去的时候，就肯定会删除id&#x3D;4的行，不会有主备删除不同行的问题。</p><ul><li>执行delete语句，row格式的binlog也会把被删掉的行的整行信息保存起来。</li><li>执行insert语句，row格式下，insert语句的binlog里会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行。</li><li>执行update语句，binlog里面会记录修改前整行的数据和修改后的整行数据。</li></ul><h3 id="mixed格式"><a href="#mixed格式" class="headerlink" title="mixed格式"></a>mixed格式</h3><p><strong>为什么会有mixed这种binlog格式的存在场景？</strong>推论过程是这样的：</p><ul><li>因为有些statement格式的binlog可能会导致主备不一致，所以要使用row格式。</li><li>但row格式的缺点是，很占空间。比如你用一个delete语句删掉10万行数据，用statement的话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但如果用row格式的binlog，就要把这10万条记录都写到binlog中。这样做，不仅会占用更大的空间，同时写binlog也要耗费IO资源，影响执行速度。</li><li>所以，MySQL就取了个折中方案，也就是有了mixed格式的binlog。mixed格式的意思是，MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。</li></ul><p>也就是说，mixed格式可以利用statment格式的优点，同时又避免了数据不一致的风险。</p><h2 id="binglog恢复数据"><a href="#binglog恢复数据" class="headerlink" title="binglog恢复数据"></a>binglog恢复数据</h2><p>用binlog来恢复数据的标准做法是，用 mysqlbinlog工具解析出来，然后把解析结果整个发给MySQL执行。类似下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog master.000001  --start-position=2738 --stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;</span><br></pre></td></tr></table></figure><p>这个命令的意思是，将 master.000001 文件里面从第2738字节到第2973字节中间这段内容解析出来，放到MySQL去执行。</p><h2 id="主备延迟问题"><a href="#主备延迟问题" class="headerlink" title="主备延迟问题"></a>主备延迟问题</h2><p>与数据同步有关的时间点主要包括以下三个：</p><ol><li>主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</li><li>之后传给备库B，我们把备库B接收完这个binlog的时刻记为T2;</li><li>备库B执行完成这个事务，我们把这个时刻记为T3。</li></ol><p>所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。</p><p>在备库上执行show slave status命令，它的返回结果里面会显示seconds_behind_master，用于表示当前备库延迟了多少秒。</p><blockquote><p>如果主备库机器的系统时间设置不一致，会不会导致主备延迟的值不准？</p></blockquote><p>不会的。因为，备库连接到主库的时候，会通过执行SELECT UNIX_TIMESTAMP()函数来获得当前主库的系统时间。如果这时候发现主库的系统时间与自己不一致，备库在执行seconds_behind_master计算的时候会自动扣掉这个差值。</p><p>主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产binlog的速度要慢。</p><h3 id="主备延迟来源"><a href="#主备延迟来源" class="headerlink" title="主备延迟来源"></a>主备延迟来源</h3><p><strong>有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。</strong></p><p>有些人把20个主库放在4台机器上，而把备库集中在一台机器上。更新请求对IOPS的压力，在主库和备库上是无差别的。所以，做这种部署时，一般都会将备库设置为“非双1”的模式。</p><p>但是更新过程中也会触发大量的读操作。所以，当备库主机上的多个备库都在争抢资源的时候，就可能会导致主备延迟了。</p><p><strong>备库压力大</strong></p><p>由于主库直接影响业务，大家使用起来会比较克制，反而忽视了备库的压力控制。结果就是，备库上的查询耗费了大量的CPU资源，影响了同步速度，造成主备延迟。</p><p>这种情况，我们一般可以这么处理：</p><ol><li>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。</li><li>通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力。</li></ol><p><strong>大事务</strong></p><p>有时候主库开启一个大事务，那必须等待主库大事务执行完成才写入 binlog，再传给备库。</p><p>比如，一些归档类的数据，平时没有注意删除历史数据，等到空间快满了，业务开发人员要一次性地删掉大量历史数据。同时，又因为要避免在高峰期操作会影响业务（至少有这个意识还是很不错的），所以会在晚上执行这些大量数据的删除操作。但还是建议控制每个事务删除的数据量，分多次删除。</p><h2 id="主备切换策略"><a href="#主备切换策略" class="headerlink" title="主备切换策略"></a>主备切换策略</h2><h3 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h3><p>双M结构下，主备切换的详细过程是这样的：</p><ol><li>判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则持续重试这一步；</li><li>把主库A改成只读状态，即把readonly设置为true；</li><li>判断备库B的seconds_behind_master的值，直到这个值变成0为止；</li><li>把备库B改成可读写状态，也就是把readonly 设置为false；</li><li>把业务请求切到备库B。</li></ol><p>这个切换流程，一般是由专门的HA系统来完成的，我们暂时称之为可靠性优先流程。</p><p>这个切换流程中是有不可用时间的。因为在步骤2之后，主库A和备库B都处于readonly状态，也就是说这时系统处于不可写状态，直到步骤5完成后才能恢复。</p><h3 id="可用性优先策略"><a href="#可用性优先策略" class="headerlink" title="可用性优先策略"></a>可用性优先策略</h3><p>如果不等主备数据同步，直接把连接切到备库B，并且让备库B可以读写，那么系统几乎就没有不可用时间了。</p><p>我们把这个切换流程，暂时称作可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。</p><p>使用可用性优先策略，且<strong>binlog_format&#x3D;mixed</strong></p><ol><li>主库A执行完insert语句，插入了一行数据（4,4），之后开始进行主备切换。</li><li>由于主备之间有5秒的延迟，所以备库B还没来得及应用“插入c&#x3D;4”这个中转日志，就开始接收客户端“插入 c&#x3D;5”的命令。</li><li>备库B插入了一行数据（4,5），并且把这个binlog发给主库A。</li><li>备库B执行“插入c&#x3D;4”这个中转日志，插入了一行数据（5,4）。而直接在备库B执行的“插入c&#x3D;5”这个语句，传到主库A，就插入了一行新数据（5,5）。</li></ol><p>使用可用性优先策略，且<strong>binlog_format&#x3D;row</strong></p><p>因为row格式在记录binlog的时候，会记录新插入的行的所有字段值，所以最后只会有一行不一致。而且，两边的主备同步的应用线程会报错duplicate key error并停止。也就是说，这种情况下，备库B的(5,4)和主库A的(5,5)这两行数据，都不会被对方执行。</p><blockquote><p>有没有哪种情况数据的可用性优先级更高呢？</p></blockquote><p>有过这样的一个场景：</p><ul><li>有一个库的作用是记录操作日志。这时候，如果数据不一致可以通过binlog来修补，而这个短暂的不一致也不会引发业务问题。</li><li>同时，业务系统依赖于这个日志写入逻辑，如果这个库不可写，会导致线上的业务操作无法执行。</li></ul><p>另一种使用可靠性优先策略的改进措施就是，让业务逻辑不要依赖于这类日志的写入。也就是说，日志写入这个逻辑模块应该可以降级，比如写到本地文件，或者写到另外一个临时库里面。</p><h2 id="MySQL并行复制策略"><a href="#MySQL并行复制策略" class="headerlink" title="MySQL并行复制策略"></a>MySQL并行复制策略</h2><p>备库从主库同步数据时，会由一个IO线程接收 relay log，然后有一个 sql_thread 执行 relay log。而MySQL的并行复制，就是将一个 sql_thread 拆分成多个线程，使用一个 coordinator 负责读取中转日志和分发事务，分发到各个 worker 中更新日志。</p><p>worker 线程数由 slave_parallel_workers 决定。建议设置在 8~16之间（32核物理机）。</p><p>coordinator在分发的时候，需要满足以下这两个基本要求：</p><ol><li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。</li><li>同一个事务不能被拆开，必须放到同一个worker中。</li></ol><h3 id="按表分发策略（MySQL-5-5）"><a href="#按表分发策略（MySQL-5-5）" class="headerlink" title="按表分发策略（MySQL 5.5）"></a>按表分发策略（MySQL 5.5）</h3><p>每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事务所涉及的表。hash表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表。</p><p>在有事务分配给worker时，事务里面涉及的表会被加到对应的hash表中。worker执行完成后，这个表会被从hash表中去掉。</p><p>如果一个事务T修改表t1和t2，但是已知 worker1中涉及到修改表 t1 的操作，worker2 中涉及到修改表 t2 的操作，因此事务 T 和 worker1、worker2 均存在冲突。coordinator线程就进入等待，等到只存在一个冲突的worker后，就可以让事务T加入worker了。</p><h3 id="按行分发策略-MySQL-5-5"><a href="#按行分发策略-MySQL-5-5" class="headerlink" title="按行分发策略(MySQL 5.5)"></a>按行分发策略(MySQL 5.5)</h3><p>如果两个事务没有更新相同的行，它们在备库上可以并行执行。</p><p>为每个worker，分配一个hash表。只是要实现按行分发，这时候的key，就必须是“库名+表名+索引a的名字+a的值”。</p><p>在实现这个策略的时候会设置一个阈值，单个事务如果超过设置的行数阈值（比如，如果单个事务更新的行数超过10万行），就暂时退化为单线程模式。</p><p>按行分发策略和按表分发策略其实都有一些约束条件：</p><ol><li>要能够从binlog里面解析出表名、主键值和唯一索引的值。也就是说，主库的binlog格式必须是row；</li><li>表必须有主键；</li><li>不能有外键。表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准确。</li></ol><h3 id="按库分发策略-MySQL-5-6"><a href="#按库分发策略-MySQL-5-6" class="headerlink" title="按库分发策略(MySQL 5.6)"></a>按库分发策略(MySQL 5.6)</h3><p>用于决定分发策略的hash表里，key就是数据库名。</p><p>这个策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使用这个策略的效果会很好。</p><p>相比于按表和按行分发，这个策略有两个优势：</p><ol><li>构造hash值的时候很快，只需要库名；而且一个实例上DB数也不会很多，不会出现需要构造100万个项这种情况。</li><li>不要求binlog的格式。因为statement格式的binlog也可以很容易拿到库名。</li></ol><p>但是，如果你的主库上的表都放在同一个DB里面，这个策略就没有效果了；或者如果不同DB的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。</p><h3 id="MySQL-5-7的并行复制策略"><a href="#MySQL-5-7的并行复制策略" class="headerlink" title="MySQL 5.7的并行复制策略"></a>MySQL 5.7的并行复制策略</h3><h4 id="由参数slave-parallel-type来控制并行复制策略："><a href="#由参数slave-parallel-type来控制并行复制策略：" class="headerlink" title="由参数slave-parallel-type来控制并行复制策略："></a>由参数slave-parallel-type来控制并行复制策略：</h4><ol><li>配置为DATABASE，表示使用MySQL 5.6版本的按库并行策略；</li><li>配置为 LOGICAL_CLOCK，表示的就是类似MariaDB的策略。</li></ol><p>MySQL 5.7并行复制策略的思想是：</p><ol><li>同时处于prepare状态的事务，在备库执行时是可以并行的；</li><li>处于prepare状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的。</li></ol><p>有两个参数：</p><ol><li>binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync;</li><li>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。</li></ol><p>这两个参数是用于故意拉长binlog从write到fsync的时间，以此减少binlog的写盘次数。在MySQL 5.7的并行复制策略里，它们可以用来制造更多的“同时处于prepare阶段的事务”。这样就增加了备库复制的并行度。</p><p>也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些。在MySQL 5.7处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。</p><h4 id="基于WRITESET的并行复制策略"><a href="#基于WRITESET的并行复制策略" class="headerlink" title="基于WRITESET的并行复制策略"></a>基于WRITESET的并行复制策略</h4><p>相应地，新增了一个参数binlog-transaction-dependency-tracking，用来控制是否启用这个新策略。这个参数的可选值有以下三种。</p><ol><li>COMMIT_ORDER，表示的就是前面介绍的，根据同时进入prepare和commit来判断是否可以并行的策略。</li><li>WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的hash值，组成集合writeset。如果两个事务没有操作相同的行，也就是说它们的writeset没有交集，就可以并行。</li><li>WRITESET_SESSION，是在WRITESET的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li></ol><p>当然为了唯一标识，这个hash值是通过“库名+表名+索引名+值”计算出来的。如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert语句对应的writeset就要多增加一个hash值。</p><p>你可能看出来了，这跟我们前面介绍的基于MySQL 5.5版本的按行分发的策略是差不多的。不过，MySQL官方的这个实现还是有很大的优势：</p><ol><li>writeset是在主库生成后直接写入到binlog里面的，这样在备库执行的时候，不需要解析binlog内容（event里的行数据），节省了很多计算量；</li><li>不需要把整个事务的binlog都扫一遍才能决定分发到哪个worker，更省内存；</li><li>由于备库的分发策略不依赖于binlog内容，所以binlog是statement格式也是可以的</li></ol><h2 id="MariaDB的并行复制策略"><a href="#MariaDB的并行复制策略" class="headerlink" title="MariaDB的并行复制策略"></a>MariaDB的并行复制策略</h2><p>MariaDB的并行复制策略利用的是redo log组提交(group commit)优化：</p><ol><li>能够在同一组里提交的事务，一定不会修改同一行；</li><li>主库上可以并行执行的事务，备库上也一定是可以并行执行的。</li></ol><p>在实现上，MariaDB是这么做的：</p><ol><li>在一组里面一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1；</li><li>commit_id直接写到binlog里面；</li><li>传到备库应用的时候，相同commit_id的事务分发到多个worker执行；</li><li>这一组全部执行完成后，coordinator再去取下一批。</li></ol><p>但是，这个策略有一个问题，它并没有实现“真正的模拟主库并发度”这个目标。在主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，这样系统的吞吐量就不够。</p><blockquote><p>假设一个MySQL 5.7.22版本的主库，单线程插入了很多数据，过了3个小时后，我们要给这个主库搭建一个相同版本的备库。</p><p>这时候，你为了更快地让备库追上主库，要开并行复制。在binlog-transaction-dependency-tracking参数的COMMIT_ORDER、WRITESET和WRITE_SESSION这三个取值中，你会选择哪一个呢？</p><p>你选择的原因是什么？如果设置另外两个参数，你认为会出现什么现象呢？</p></blockquote><p>应该将这个参数设置为WRITESET。</p><p>由于主库是单线程压力模式，所以每个事务的commit_id都不同，那么设置为COMMIT_ORDER模式的话，从库也只能单线程执行。</p><p>同样地，由于WRITESET_SESSION模式要求在备库应用日志的时候，同一个线程的日志必须与主库上执行的先后顺序相同，也会导致主库单线程压力模式下退化成单线程复制。</p><p>所以，应该将binlog-transaction-dependency-tracking 设置为WRITESET。</p><h2 id="处理过期读方案"><a href="#处理过期读方案" class="headerlink" title="处理过期读方案"></a>处理过期读方案</h2><p>尽管知道了主备延迟的原因和对应的优化策略，主从延迟仍不是能100%避免的。从库仍有可能读到系统的过期状态，那么接下来我们可以讨论如何处理过期读问题。</p><h3 id="强制走主库"><a href="#强制走主库" class="headerlink" title="强制走主库"></a>强制走主库</h3><p>通常情况下，可以把请求分为两类：</p><ol><li>对于必须要拿到最新结果的请求，强制将其发到主库上。</li><li>对于可以读到旧数据的请求，才将其发到从库上。</li></ol><h3 id="Sleep-方案"><a href="#Sleep-方案" class="headerlink" title="Sleep 方案"></a>Sleep 方案</h3><p>主库更新后，读从库之前先sleep一下。具体的方案就是，类似于执行一条select sleep(1)命令。</p><p>这个方案的假设是，大多数情况下主备延迟在1秒之内，做一个sleep可以有很大概率拿到最新的数据。</p><h3 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h3><p>执行 show slave status。</p><ol><li><p>观察 seconds_behind_master 字段。每次从库执行查询请求前，先判断seconds_behind_master是否已经等于0。如果还不等于0 ，那就必须等到这个参数变为0才能执行查询请求。</p></li><li><p>对比位点确保主备无延迟：</p><ul><li>Master_Log_File和Read_Master_Log_Pos，表示的是读到的主库的最新位点；</li><li>Relay_Master_Log_File和Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li></ul><p>如果Master_Log_File和Relay_Master_Log_File、Read_Master_Log_Pos和Exec_Master_Log_Pos这两组值完全相同，就表示接收到的日志已经同步完成。</p></li><li><p>对比GTID集合确保主备无延迟：</p><ul><li>Auto_Position&#x3D;1 ，表示这对主备关系使用了GTID协议。</li><li>Retrieved_Gtid_Set，是备库收到的所有日志的GTID集合；</li><li>Executed_Gtid_Set，是备库所有已经执行完成的GTID集合。</li></ul><p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。</p></li></ol><h3 id="配合-semi-sync"><a href="#配合-semi-sync" class="headerlink" title="配合 semi-sync"></a>配合 semi-sync</h3><p>semi-sync做了这样的设计：</p><ol><li>事务提交的时候，主库把binlog发给从库；</li><li>从库收到binlog以后，发回给主库一个ack，表示收到了；</li><li>主库收到这个ack以后，才能给客户端返回“事务完成”的确认。</li></ol><p>也就是说，如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。</p><p>但是，semi-sync+位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：</p><ol><li>如果查询是落在这个响应了ack的从库上，是能够确保读到最新数据；</li><li>但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。</li></ol><p>其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者GTID集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。</p><h3 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure><p>这条命令的逻辑如下：</p><ol><li>它是在从库执行的；</li><li>参数file和pos指的是主库上的文件名和位置；</li><li>timeout可选，设置为正整数N表示这个函数最多等待N秒。</li></ol><p>这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。</p><p>这里我们假设，这条select查询最多在从库上等待1秒。那么，如果1秒内master_pos_wait返回一个大于等于0的整数，就确保了从库上执行的这个查询结果一定包含了trx1的数据。</p><p>若返回一个小于0的整数，则到主库执行查询语句，是这类方案常用的退化机制。因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查。</p><h3 id="GTID-方案"><a href="#GTID-方案" class="headerlink" title="GTID 方案"></a>GTID 方案</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> wait_for_executed_gtid_set(gtid_set, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这条命令的逻辑是：</p><ol><li>等待，直到这个库执行的事务中包含传入的gtid_set，返回0；</li><li>超时返回1。</li></ol><p>而MySQL 5.7.6版本开始，允许在执行完更新类事务后，把这个事务的GTID返回给客户端，这样等GTID的方案就可以减少一次查询。</p><p>这时，等GTID的执行流程就变成了：</p><ol><li>trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1；</li><li>选定一个从库执行查询语句；</li><li>在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</li><li>如果返回值是0，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。</li></ol><p>跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。</p><blockquote><p>怎么能够让MySQL在执行事务后，返回包中带上GTID呢？</p></blockquote><p>将参数session_track_gtids设置为OWN_GTID，然后通过API接口mysql_session_track_get_first从返回包解析出GTID的值即可。</p><blockquote><p>实际业务场景中，怎么结合以上几种处理过期读方案？</p></blockquote><p>先在客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读；然后，对于不能接受过期读的语句，再使用等GTID或等位点的方案。</p><p>但话说回来，过期读在本质上是由一写多读导致的。在实际应用中，可能会有别的不需要等待就可以水平扩展的数据库方案，但这往往是用牺牲写性能换来的，也就是需要在读性能和写性能中取权衡。</p><blockquote><p>假设你的系统采用了我们文中介绍的最后一个方案，也就是等GTID的方案，现在你要对主库的一张大表做DDL，可能会出现什么情况呢？为了避免这种情况，你会怎么做呢？</p></blockquote><p>假设，这条语句在主库上要执行10分钟，提交后传到备库就要10分钟（典型的大事务）。那么，在主库DDL之后再提交的事务的GTID，去备库查的时候，就会等10分钟才出现。</p><p>这样，这个读写分离机制在这10分钟之内都会超时，然后走主库。</p><p>这种预期内的操作，应该在业务低峰期的时候，确保主库能够支持所有业务查询，然后把读请求都切到主库，再在主库上做DDL。等备库延迟追上以后，再把读请求切回备库。</p><h2 id="判断主库情况"><a href="#判断主库情况" class="headerlink" title="判断主库情况"></a>判断主库情况</h2><p>主备切换有两种场景，一种是主动切换，一种是被动切换。而其中被动切换，往往是因为主库出问题了，由HA系统发起的。</p><h3 id="select-1-判断"><a href="#select-1-判断" class="headerlink" title="select 1 判断"></a>select 1 判断</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_thread_concurrency<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>innodb_thread_concurrency：控制InnoDB的并发线程上限。一旦并发线程数达到这个值，InnoDB在接收到新请求的时候，就会进入等待状态，直到有线程退出。</p><p>同时在执行的语句超过了设置的innodb_thread_concurrency的值，这时候系统其实已经不行了，但是通过select 1来检测系统，会认为系统还是正常的。</p><h3 id="查表判断"><a href="#查表判断" class="headerlink" title="查表判断"></a>查表判断</h3><p>在系统库（mysql库）里创建一个表，比如命名为health_check，里面只放一行数据，然后定期执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.health_check; </span><br></pre></td></tr></table></figure><p>更新事务要写binlog，而一旦binlog所在磁盘的空间占用率达到100%，那么所有的更新语句和事务提交的commit语句就都会被堵住。但是，系统这时候还是可以正常读数据的。</p><h3 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h3><p>既然要更新，就要放个有意义的字段，常见做法是放一个timestamp字段，用来表示最后一次执行检测的时间。这条更新语句类似于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> mysql.health_check <span class="keyword">set</span> t_modified<span class="operator">=</span>now();</span><br></pre></td></tr></table></figure><p>为了让主备之间的更新不产生冲突，我们可以在mysql.health_check表上存入多行数据，并用A、B的server_id做主键。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `health_check` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `t_modified` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检测命令 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql.health_check(id, t_modified) <span class="keyword">values</span> (@<span class="variable">@server_id</span>, now()) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> t_modified<span class="operator">=</span>now();</span><br></pre></td></tr></table></figure><p>IO利用率100%表示系统的IO是在工作的，每个请求都有机会获得IO资源，执行自己的任务。而我们的检测使用的update命令，需要的资源很少，所以可能在拿到IO资源的时候就可以提交成功，并且在超时时间N秒未到达之前就返回给了检测系统。</p><p>检测系统一看，update命令没有超时，于是就得到了“系统正常”的结论。</p><p>之所以会出现这个现象，根本原因是我们上面说的所有方法，都是基于外部检测的。</p><h3 id="内部统计"><a href="#内部统计" class="headerlink" title="内部统计"></a>内部统计</h3><p>MySQL 5.6版本以后提供的performance_schema库，就在file_summary_by_event_name表里统计了每次IO请求的时间。</p><p>如果打开所有的performance_schema项，性能大概会下降10%左右。所以，我建议你只打开自己需要的项进行统计。你可以通过下面的方法打开或者关闭某个具体项的统计。</p><p>如果要打开redo log的时间监控，你可以执行这个语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> setup_instruments <span class="keyword">set</span> ENABLED<span class="operator">=</span><span class="string">&#x27;YES&#x27;</span>, Timed<span class="operator">=</span><span class="string">&#x27;YES&#x27;</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%wait/io/file/innodb/innodb_log_file%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>现在你已经开启了redo log和binlog这两个统计信息，就可以通过MAX_TIMER的值来判断数据库是否出问题了。比如，你可以设定阈值，单次IO请求时间超过200毫秒属于异常，然后使用类似下面这条语句作为检测逻辑。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> event_name,MAX_TIMER_WAIT  <span class="keyword">FROM</span> performance_schema.file_summary_by_event_name <span class="keyword">where</span> event_name <span class="keyword">in</span> (<span class="string">&#x27;wait/io/file/innodb/innodb_log_file&#x27;</span>,<span class="string">&#x27;wait/io/file/sql/binlog&#x27;</span>) <span class="keyword">and</span> MAX_TIMER_WAIT<span class="operator">&gt;</span><span class="number">200</span><span class="operator">*</span><span class="number">1000000000</span>;</span><br></pre></td></tr></table></figure><p>发现异常后，取到你需要的信息，再通过下面这条语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">truncate</span> <span class="keyword">table</span> performance_schema.file_summary_by_event_name;</span><br></pre></td></tr></table></figure><p>把之前的统计信息清空。这样如果后面的监控中，再次出现这个异常，就可以加入监控累积值了。</p><h2 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h2><h3 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h3><p>MySQL建立连接的过程，成本是很高的。除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的数据读写权限。</p><p>短连接模型是存在风险的。max_connections参数是用来控制一个MySQL实例同时存在的连接数的上限，超过这个值，系统就会拒绝接下来的请求，报错提示：“Too many connection”</p><blockquote><p>如果调高max_connections的值呢？</p></blockquote><p>存在一定风险。因为设计max_connections这个参数的目的是想保护MySQL，如果我们把它改得太大，让更多的连接都可以进来，那么系统的负载可能会进一步加大，大量的资源耗费在权限验证等逻辑上，结果可能是适得其反，已经连接的线程拿不到CPU资源去执行业务的SQL请求。</p><h4 id="处理掉占着连接不工作的线程"><a href="#处理掉占着连接不工作的线程" class="headerlink" title="处理掉占着连接不工作的线程"></a>处理掉占着连接不工作的线程</h4><p>首先 show processlist 查看正在 sleep 的线程。</p><p><img src="https://static001.geekbang.org/resource/image/ae/25/ae6a9ceecf8517e47f9ebfc565f0f925.png" alt="img"></p><p>图中id&#x3D;4和id&#x3D;5的两个会话都是Sleep 状态。而要看事务具体状态的话，你可以查information_schema库的innodb_trx表。</p><p><img src="https://static001.geekbang.org/resource/image/ca/e8/ca4b455c8eacbf32b98d1fe9ed9876e8.png" alt="img"></p><p>trx_mysql_thread_id&#x3D;4，表示id&#x3D;4的线程还处在事务中。</p><p>可以优先断开事务外空闲太久的连接，再考虑断开事务内空闲太久的连接。</p><p>断开连接使用的是kill connection + id的命令， 一个客户端处于sleep状态时，它的连接被服务端主动断开后，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。</p><h4 id="减少连接过程的消耗"><a href="#减少连接过程的消耗" class="headerlink" title="减少连接过程的消耗"></a>减少连接过程的消耗</h4><p>有的业务代码会在短时间内先大量申请数据库连接做备用，如果现在数据库确认是被连接行为打挂了，那么一种可能的做法，是让数据库跳过权限验证阶段。</p><p>因此可以重启数据库，并使用–skip-grant-tables参数启动。</p><p>MySQL 8.0版本里，如果你启用–skip-grant-tables参数，MySQL会默认把 –skip-networking参数打开，表示这时候数据库只能被本地的客户端连接。</p><h3 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h3><h4 id="索引没有设计好"><a href="#索引没有设计好" class="headerlink" title="索引没有设计好"></a>索引没有设计好</h4><p>MySQL 5.6版本以后，创建索引都支持Online DDL了，对于那种高峰期数据库已经被这个语句打挂了的情况，最高效的做法就是直接执行alter table 语句。</p><p>比较理想的是能够在备库先执行。假设你现在的服务是一主一备，主库A、备库B，这个方案的大致流程是这样的：</p><ol><li>在备库B上执行 set sql_log_bin&#x3D;off，也就是不写binlog，然后执行alter table 语句加上索引；</li><li>执行主备切换；</li><li>这时候主库是B，备库是A。在A上执行 set sql_log_bin&#x3D;off，然后执行alter table 语句加上索引。</li></ol><p>这是一个“古老”的DDL方案。平时在做变更的时候，你应该考虑类似gh-ost这样的方案，更加稳妥。</p><h4 id="语句没有写好"><a href="#语句没有写好" class="headerlink" title="语句没有写好"></a>语句没有写好</h4><p>MySQL 5.7提供了query_rewrite功能，可以把输入的一种语句改写成另外一种模式。</p><p>比如，语句被错误地写成了 select * from t where id + 1 &#x3D; 10000，你可以通过下面的方式，增加一个语句改写规则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> query_rewrite.rewrite_rules(<span class="keyword">pattern</span>, replacement, pattern_database) <span class="keyword">values</span> (&quot;select * from t where id + 1 = ?&quot;, &quot;select * from t where id = ? - 1&quot;, &quot;db1&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> query_rewrite.flush_rewrite_rules();</span><br></pre></td></tr></table></figure><p>这里，call query_rewrite.flush_rewrite_rules()这个存储过程，是让插入的新规则生效，也就是我们说的“查询重写”。你可以用图中的方法来确认改写规则是否生效。</p><p><img src="https://static001.geekbang.org/resource/image/47/8a/47a1002cbc4c05c74841591d20f7388a.png" alt="img"></p><h4 id="MySQL选错索引"><a href="#MySQL选错索引" class="headerlink" title="MySQL选错索引"></a>MySQL选错索引</h4><p>应急方案就是给这个语句加上force index。</p><h3 id="QPS突增问题"><a href="#QPS突增问题" class="headerlink" title="QPS突增问题"></a>QPS突增问题</h3><p>有时候由于业务突然出现高峰，或者应用程序bug，导致某个语句的QPS突然暴涨，也可能导致MySQL压力过大，影响服务。</p><p>当然，最理想的情况是让业务把这个功能下掉，服务自然就会恢复。而下掉一个功能，如果从数据库端处理的话，对应于不同的背景，有不同的方法可用。</p><ol><li>一种是由全新业务的bug导致的。假设你的DB运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</li><li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的QPS就会变成0。</li><li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的SQL语句直接重写成”select 1”返回。</li></ol><p>当然，这个操作的风险很高，需要你特别细致。它可能存在两个副作用：</p><ol><li>如果别的功能里面也用到了这个SQL语句模板，会有误伤；</li><li>很多业务并不是靠这一个语句就能完成逻辑的，所以如果单独把这一个语句以select 1的结果返回的话，可能会导致后面的业务逻辑一起失败。</li></ol><p>所以，方案3是用于止血的，跟前面提到的去掉权限验证一样，应该是你所有选项里优先级最低的一个方案。</p><p>同时你会发现，其实方案1和2都要依赖于规范的运维体系：虚拟化、白名单机制、业务账号分离。由此可见，更多的准备，往往意味着更稳定的系统。</p><h3 id="上线准备"><a href="#上线准备" class="headerlink" title="上线准备"></a>上线准备</h3><p>通过下面这个过程，我们可以预先发现问题。</p><ol><li>上线前，在测试环境，把慢查询日志（slow log）打开，并且把long_query_time设置成0，确保每个语句都会被记录入慢查询日志；</li><li>在测试表里插入模拟线上的数据，做一遍回归测试；</li><li>观察慢查询日志里每类语句的输出，特别留意Rows_examined字段是否与预期一致。（我们在前面文章中已经多次用到过Rows_examined方法了，相信你已经动手尝试过了。如果还有不明白的，欢迎给我留言，我们一起讨论）。</li></ol><p>不要吝啬这段花在上线前的“额外”时间，因为这会帮你省下很多故障复盘的时间。</p><p>如果新增的SQL语句不多，手动跑一下就可以。而如果是新项目的话，或者是修改了原有项目的 表结构设计，全量回归测试都是必要的。这时候，你需要工具帮你检查所有的SQL语句的返回结果。比如，你可以使用开源工具pt-query-digest(<a href="https://www.percona.com/doc/percona-toolkit/3.0/pt-query-digest.html)%E3%80%82">https://www.percona.com/doc/percona-toolkit/3.0/pt-query-digest.html)。</a></p><h2 id="误删数据"><a href="#误删数据" class="headerlink" title="误删数据"></a>误删数据</h2><p>传统的高可用架构是不能预防误删数据的，因为主库的一个drop table命令，会通过binlog传给所有从库和级联从库，进而导致整个集群的实例都会执行这个命令。</p><h3 id="误删行"><a href="#误删行" class="headerlink" title="误删行"></a>误删行</h3><p>如果是使用delete语句误删了数据行，可以用Flashback工具通过闪回把数据恢复回来。</p><p>Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放。而能够使用这个方案的前提是，需要确保binlog_format&#x3D;row 和 binlog_row_image&#x3D;FULL。</p><p>具体恢复数据时，对单个事务做如下处理：</p><ol><li>对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event即可；</li><li>同理，对于delete语句，也是将Delete_rows event改为Write_rows event；</li><li>而如果是Update_rows的话，binlog里面记录了数据行修改前和修改后的值，对调这两行的位置即可。</li></ol><p>如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。</p><p>恢复数据比较安全的做法，是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。</p><p><strong>事前预防</strong></p><ol><li>把sql_safe_updates参数设置为on。这样一来，如果我们忘记在delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错。</li><li>代码上线前，必须经过SQL审计</li></ol><p>使用truncate &#x2F;drop table和drop database命令删除的数据，就没办法通过Flashback来恢复了。这是因为，即使我们配置了binlog_format&#x3D;row，执行这三个命令时，记录的binlog还是statement格式。binlog里面就只有一个truncate&#x2F;drop 语句，这些信息是恢复不出数据的。</p><h3 id="误删库-表"><a href="#误删库-表" class="headerlink" title="误删库&#x2F;表"></a>误删库&#x2F;表</h3><p>要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份binlog。</p><p>在这两个条件都具备的情况下，假如有人中午12点误删了一个库，恢复数据的流程如下：</p><ol><li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点；</li><li>用备份恢复出一个临时库；</li><li>从日志备份里面，取出凌晨0点之后的日志；</li><li>把这些日志，除了误删除数据的语句外，全部应用到临时库。</li></ol><p><strong>建议</strong></p><ol><li>为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用mysqlbinlog命令时，加上一个–database参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其他库日志的情况。</li><li>在应用日志的时候，需要跳过12点误操作的那个语句的binlog：<ul><li>如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用–stop-position参数执行到误操作之前的日志，然后再用–start-position从误操作之后的日志继续执行；</li><li>如果实例使用了GTID模式，就方便多了。假设误操作命令的GTID是gtid1，那么只需要执行set gtid_next&#x3D;gtid1;begin;commit; 先把这个GTID加到临时实例的GTID集合，之后按顺序执行binlog的时候，就会自动跳过误操作的语句。</li></ul></li></ol><p><strong>加速方法</strong></p><p>在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，这样：</p><ol><li>在start slave之前，先通过执行﻿<br>﻿change replication filter replicate_do_table &#x3D; (tbl_name) 命令，就可以让临时库只同步误操作的表；</li><li>这样做也可以用上并行复制技术，来加速整个数据恢复过程。</li><li>如果由于时间太久，备库上已经删除了临时实例需要的binlog的话，我们可以从binlog备份系统中找到需要的binlog，再放回备库中。</li></ol><p>把之前删掉的binlog放回备库的操作步骤，是这样的：</p><ol><li>从备份系统下载master.000005和master.000006这两个文件，放到备库的日志目录下；</li><li>打开日志目录下的master.index文件，在文件开头加入两行，内容分别是 “.&#x2F;master.000005”和“.&#x2F;master.000006”;</li><li>重启备库，目的是要让备库重新识别这两个日志文件；</li><li>现在这个备库上就有了临时库需要的所有binlog了，建立主备关系，就可以正常同步了。</li></ol><p>建议将数据恢复功能做成自动化工具，并经常演练，避免线上出问题无法及时恢复数据。</p><h3 id="延迟恢复备库"><a href="#延迟恢复备库" class="headerlink" title="延迟恢复备库"></a>延迟恢复备库</h3><p>延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY &#x3D; N命令，可以指定这个备库持续保持跟主库有N秒的延迟。</p><p>比如你把N设置为3600，这就代表了如果主库上有数据被误删了，并且在1小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行stop slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。</p><p>这样的话，你就随时可以得到一个，只需要最多再追1小时，就可以恢复出数据的临时实例，也就缩短了整个数据恢复需要的时间。</p><h3 id="预防误删库-表的方法"><a href="#预防误删库-表的方法" class="headerlink" title="预防误删库&#x2F;表的方法"></a>预防误删库&#x2F;表的方法</h3><p>账号分离。这样做的目的是，避免写错命令。比如：</p><ul><li>我们只给业务开发同学DML权限，而不给truncate&#x2F;drop权限。而如果业务开发人员有DDL需求的话，也可以通过开发管理系统得到支持。</li><li>即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</li></ul><p>制定操作规范。这样做的目的，是避免写错要删除的表名。比如：</p><ul><li>在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。</li><li>改表名的时候，要求给表名加固定的后缀（比如加_to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。</li></ul><h3 id="rm-删除数据"><a href="#rm-删除数据" class="headerlink" title="rm 删除数据"></a>rm 删除数据</h3><p>对于一个有高可用机制的MySQL集群来说，最不怕的就是rm删除数据了。这时，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。</p><p>当然了，现在不止是DBA有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批量下线机器的操作，会让你整个MySQL集群的所有节点都全军覆没。</p><p>应对这种情况，我的建议只能是说尽量把你的备份跨机房，或者最好是跨城市保存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL主备一致&quot;&gt;&lt;a href=&quot;#MySQL主备一致&quot; class=&quot;headerlink&quot; title=&quot;MySQL主备一致&quot;&gt;&lt;/a&gt;MySQL主备一致&lt;/h1&gt;&lt;h2 id=&quot;MySQL-主从复制&quot;&gt;&lt;a href=&quot;#MySQL-主从复制&quot; cla</summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://palette-k.github.io/tags/MySQL/"/>
    
    <category term="高可用" scheme="https://palette-k.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于Git分支模型的理解与思考</title>
    <link href="https://palette-k.github.io/2023/11/27/%E5%9F%BA%E4%BA%8EGit%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%9D%E8%80%83/"/>
    <id>https://palette-k.github.io/2023/11/27/%E5%9F%BA%E4%BA%8EGit%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%9D%E8%80%83/</id>
    <published>2023-11-27T02:50:43.000Z</published>
    <updated>2023-11-27T02:51:11.051Z</updated>
    
    <content type="html"><![CDATA[<p>进入企业后，开发过程中为了实现多人同步协作，企业往往会有一套 git 分支规范，这和学习中遇到的分支大有不同。本文是对 git 成熟模型 A successful Git branching model 的理解和对公司约定的 git 分支规范的思考。</p><p>在实际生产开发的过程中，如果每个人都随意的创建分支，随意的提交commit，必将导致整个git仓库非常的混乱，不易于团队协作。Vincent Driessen 同学为了解决这个问题提出了 <a href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>，最后形成了业内普遍采用的 git 工作流程，大家都在约定的流程内使用git，使得团队协作效率大大提高‌。</p><h1 id="为什么使用Git？"><a href="#为什么使用Git？" class="headerlink" title="为什么使用Git？"></a>为什么使用Git？</h1><p>Git 是一个分布式版本管理工具，在多人协作的条件下高效处理任何规模的软件工程，并对项目版本、状态做环境隔离。每一个Git克隆都是一个完整的文件库，含有全部历史记录和修订追踪能力，不依赖于网络连接或中心服务器。最大特色是分支和合并操作非常快速、简便。</p><p>与SVN相比，git有以下5点优势：</p><ol><li><p><strong>版本库本地化，支持离线提交，相对独立不影响协同开发。</strong>每个开发者都拥有自己的版本控制库，在自己的版本库上可以任意的执行提交代码、创建分支等行为。例如，开发者认为自己提交的代码有问题？没关系，因为版本库是自己的，回滚历史、反复提交、归并分支并不会影响到其他开发者。</p></li><li><p><strong>更少的“仓库污染”。</strong>git对于每个工程只会产生一个.git目录，这个工程所有的版本控制信息都在这个目录中，不会像SVN那样在每个目录下都产生.svn目录。</p></li><li><p><strong>把内容按元数据方式存储，完整克隆版本库。</strong>所有版本信息位于.git目录中，它是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签、分支、版本记录等。</p></li><li><p><strong>支持快速切换分支方便合并，比较合并性能好。</strong>在同一目录下即可切换不同的分支，方便合并，且合并文件速度比SVN快。</p></li><li><p><strong>分布式版本库，无单点故障，内容完整性好。</strong>内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p></li></ol><h1 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a>主分支</h1><p>对于 Git 初学者来讲，应该都很熟悉 master-develop 双分支模型吧。我们一般把 <code>origin/master</code> 库认作为主分支，HEAD 的源代码存在于此版本中，并且随时是预备生产状态。而 <code>origin/develop</code> 分支 HEAD 源码始终体现下个发布版的最新变更，当 <code>develop</code>分支的源码到达了一个稳定状态待发布，所有的代码变更需合并到 <code>master</code> 分支，然后标记一个版本号。</p><p>所以，每次变更都合并到了master，这就是新产品的定义。理论上，每当对<code>master</code> 有一个提交操作，我们就可以使用Git钩子脚本来自动构建并且发布软件到生产服务器。</p><h1 id="辅助性分支"><a href="#辅助性分支" class="headerlink" title="辅助性分支"></a>辅助性分支</h1><p>开发模型一般会使用各种辅助性分支，这些分支与关键分支（<code>master</code>和<code>develop</code>）一起，用来支持团队成员并行开发，协助生产发布环境准备，以及快速修复实时在线问题。与关键分支不同，这些分支是有生命周期的，因为它们最终会被移除。</p><p>我们用到的分支类型包括：</p><ul><li>功能分支（<code>feature</code>）</li><li>发布分支（<code>release</code>）</li><li>测试分支（<code>sit</code>）</li><li>预发布分支（<code>uat</code>）</li><li>热修复分支（<code>hotfix</code>）</li></ul><p>每一种分支有一个特定目的，并且有一定程度的规则，比如：可以用哪些分支作为源分支，哪些分支能作为合并目标。</p><h2 id="功能分支（feature）"><a href="#功能分支（feature）" class="headerlink" title="功能分支（feature）"></a>功能分支（feature）</h2><p>功能分支通常为即将发布或者未来发布版开发的新的功能。当新功能开始研发时，负责此需求的工作者应该本地创建一个相应的功能分支进行开发（注意不要将本地分支 push 到远程）。</p><p>可能是 develop&#x2F;release 分支的分支版本，最终必须合并到 develop&#x2F;release 分支中。</p><p>根据企业自身状况，功能分支可能也会从 release&#x2F;版本号 中拉取，因为也许企业需要两个版本的系统并行开发，只有 <code>develop</code> 分支作为主要的开发环境不太能满足这种需求。</p><h3 id="创建一个功能分支"><a href="#创建一个功能分支" class="headerlink" title="创建一个功能分支"></a>创建一个功能分支</h3><p>开始一项功能的开发工作时，基于<code>develop</code>创建分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b feature/v1.0/myfeature develop</span></span><br></pre></td></tr></table></figure><h3 id="合并一个功能到develop分支"><a href="#合并一个功能到develop分支" class="headerlink" title="合并一个功能到develop分支"></a>合并一个功能到develop分支</h3><p>完成的功能可以合并进<code>develop</code>分支，明确加入到未来的发布：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout develop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge -no-ff myfeature</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d myfeature</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin develop</span></span><br></pre></td></tr></table></figure><p>–no-ff 标志导致合并操作创建一个新commit对象，即使该合并操作可以fast-forward。这避免了丢失这个功能分支存在的历史信息，将该功能的所有提交组合在一起。</p><p>如果直接 git merge，不可能从 Git 历史中看到哪些提交一起实现了一个功能，必须手动阅读全部的日志信息。因此回滚一组提交也变得非常困难。</p><h2 id="发布分支（release）"><a href="#发布分支（release）" class="headerlink" title="发布分支（release）"></a>发布分支（release）</h2><p><code>Release</code> 分支是为新产品的发布做准备的，创建时要为即将发行版本分配一个版本号。</p><p><code>Release</code>分支可能从 <code>develop</code> 分支分离，但是最终一定要合并到 <code>develop</code> 和 <code>master</code> 分支上。</p><p>从<code>develop</code>分支创建新的 <code>release</code> 分支的关键时刻是 <code>develop</code> 分支达到了发布的理想状态。<code>release </code>分支允许一些小bugs的修改和准备发布元数据（版本号、开发时间）。</p><h3 id="创建一个release分支"><a href="#创建一个release分支" class="headerlink" title="创建一个release分支"></a>创建一个release分支</h3><p>若当前产品的发行版本是1.1.5，同时有一个大的版本即将发行。<code>develop</code>分支为下次发行做好了准备，决定好下一个版本是1.2。所以此时可以将<code>release</code>分支分离出来，给一个能反映版本号的分支名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b release-1.2 develop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bump-version.sh 1.2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&quot;Bumped version number to 1.2&quot;</span></span></span><br></pre></td></tr></table></figure><p>创建新分支以后，切换到该分支，添加版本号。这里，bump-version.sh 是一个虚构的shell脚本，它可以复制一些文件来反映新的版本（这当然可以手动改变–目的就是修改一些文件）。然后版本号被提交。</p><p>这个新分支可能会存在一段时间，直到该发行版到达它的预定目标。在此期间，bug的修复可能被提交到该分支上（而不是提交到<code>develop</code>分支上）。在这里严格禁止增加大的新features。他们必须合并到<code>develop</code>分支上，然后等待下一次大的发行版。</p><h3 id="完成一个release分支"><a href="#完成一个release分支" class="headerlink" title="完成一个release分支"></a>完成一个release分支</h3><p>当一个<code>release</code>分支准备好成为一个真正的发行版时（即已经通过所有测试），<code>release</code>分支要合并到<code>master</code>上（因为每一次提交到<code>master</code>上的都是一个新定义的发行版）。提交到<code>master</code>上必须打一个标签，以便以后更加方便引用历史版本。最后，在<code>release</code>分支上的修改必须合并到<code>develop</code>上，以便未来的发行版包含这些bugs的修复。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff release-1.2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a 1.2</span></span><br></pre></td></tr></table></figure><p>合并到<code>develop</code>上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout develop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff release-1.2</span></span><br></pre></td></tr></table></figure><p>最后删除掉这个<code>release</code>分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d release-1.2</span></span><br></pre></td></tr></table></figure><h2 id="测试分支（sit）"><a href="#测试分支（sit）" class="headerlink" title="测试分支（sit）"></a>测试分支（sit）</h2><p>测试环境分支，只接受 <code>feature</code> ，<code>hotfix</code>， <code>release</code> 分支的合并。研发内测联调通过后，由研发人员将自己的 <code>feature</code> 分支或 <code>hotfix</code> 分支代码合并到 <code>sit</code> 。该分支对应测试环境，测试人员的专用测试环境。</p><h3 id="创建一个-sit"><a href="#创建一个-sit" class="headerlink" title="创建一个 sit"></a>创建一个 sit</h3><p><code>sit</code> 可以基于 <code>feature</code> 分支创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b sit myfeature</span></span><br></pre></td></tr></table></figure><h3 id="完成一个-sit"><a href="#完成一个-sit" class="headerlink" title="完成一个 sit"></a>完成一个 sit</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b sit myfeature</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d sit</span></span><br></pre></td></tr></table></figure><h2 id="预发布分支（uat）"><a href="#预发布分支（uat）" class="headerlink" title="预发布分支（uat）"></a>预发布分支（uat）</h2><p>产品版本即将发布上线时，必须经过预发布分支的测试。</p><p>预发布环境，只接受 <code>hotfix</code> 、<code>release</code> 分支的代码合并。</p><h3 id="创建一个uat"><a href="#创建一个uat" class="headerlink" title="创建一个uat"></a>创建一个uat</h3><p>一般此分支是基于 <code>release</code> 分支创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b uat-1.2 release</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bump-version.sh 1.2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&quot;Bumped version number to 1.2&quot;</span></span></span><br></pre></td></tr></table></figure><p>如果生产环境下突然出现需要紧急修复的情况，<code>uat</code> 也可以支持 <code>hotfix</code> 的合并</p><h3 id="完成一个uat"><a href="#完成一个uat" class="headerlink" title="完成一个uat"></a>完成一个uat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b uat-1.2 release</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bump-version.sh 1.2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&quot;Bumped version number to 1.2&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d uat-1.2</span></span><br></pre></td></tr></table></figure><h2 id="热修复分支（hotfix）"><a href="#热修复分支（hotfix）" class="headerlink" title="热修复分支（hotfix）"></a>热修复分支（hotfix）</h2><p>热修复分支通常用于紧急修复的情况，项目上线到生产环境后多多少少会有一些漏洞需要进行紧急修复，因此热修复分支可以基于<code>master</code>分支上对应与线上版本的tag创建。</p><p>可以基于 <code>master</code> 分支，必须合并回 <code>develop</code> 和 <code>master</code> 分支。</p><h3 id="创建修补bug分支"><a href="#创建修补bug分支" class="headerlink" title="创建修补bug分支"></a>创建修补bug分支</h3><p><code>hotfix branch</code> 是从 <code>master</code> 分支上面分出来的。例如，1.2 版本是当前的生产环境版本并且有 bug。但是开发分支变化还不稳定，需要分出来一个修补 bug 分支来解决这个问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b hotfix-1.2.1 master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bump-version.sh 1.2.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&quot;Bumped version number to 1.2.1&quot;</span></span></span><br></pre></td></tr></table></figure><p>分支关闭时不要忘记更新版本号，然后修复bug</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;Fixed severe production problem&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="完成一个-hotfix-分支"><a href="#完成一个-hotfix-分支" class="headerlink" title="完成一个 hotfix 分支"></a>完成一个 hotfix 分支</h3><p>完成一个<code>hotfix</code>之后，需要把<code>hotfix</code>合并到<code>master</code>和<code>develop</code>分支去，这样就可以保证修复的这个bug也包含到下一个发行版中。这一点和完成<code>release</code>分支很相似。</p><p>首先，更新<code>master</code>并对<code>release</code>打上tag：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff hotfix-1.2.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a 1.2.1</span></span><br></pre></td></tr></table></figure><p>编辑：你可能也会想使用 -sor-u <key>参数来对你的tag进行加密</p><p>下一步，把bugfix添加到<code>develop</code>分支中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout develop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff hotfix-1.2.1</span></span><br></pre></td></tr></table></figure><p> <strong>如果一个<code>release</code>分支已经存在，那么应该把<code>hotfix</code>合并到这个<code>release</code>分支，而不是合并到<code>develop</code>分支。</strong>当<code>release</code>分支完成后， 将<code>hotfix</code>分支合并回<code>release</code>分支也会使得<code>hotfix</code>被合并到<code>develop</code>分支。</p><p>最后，删除临时分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d hotfix-1.2.1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;进入企业后，开发过程中为了实现多人同步协作，企业往往会有一套 git 分支规范，这和学习中遇到的分支大有不同。本文是对 git 成熟模型 A successful Git branching model 的理解和对公司约定的 git 分支规范的思考。&lt;/p&gt;
&lt;p&gt;在实际生</summary>
      
    
    
    
    
    <category term="git" scheme="https://palette-k.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记</title>
    <link href="https://palette-k.github.io/2023/11/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://palette-k.github.io/2023/11/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-11-23T05:46:04.000Z</published>
    <updated>2023-12-07T06:31:45.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-的基本架构"><a href="#MySQL-的基本架构" class="headerlink" title="MySQL 的基本架构"></a>MySQL 的基本架构</h1><p>要想探究 MySQL 的执行原理，首先要了解 MySQL 的基础架构，从中清楚看到 SQL 语句在 MySQL 的各个模块中的执行过程。</p><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MySQL/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p><p>Server层涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>第一步，先连接到数据库，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>因此，一个用户成功建立连接后，它的权限会维持在建立连接那一刻读到的权限。如果用管理员账号对这个用户的权限做修改，只要这个用户不断开连接，它的权限就不会发生变化。</p><p><strong>那么，什么时候会断开连接呢？</strong></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p><strong>长连接</strong>：指连接成功后，如果客户端持续有请求，则一直使用同一个连接。</p><p><strong>短连接</strong>：指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中<strong>临时使用的内存是管理在连接对象里面的</strong>。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li><p><strong>定期断开长连接</strong>。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</p></li><li><p>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 <strong>mysql_reset_connection</strong>来重新<strong>初始化连接资源</strong>。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。（推荐第二种）</p></li></ol><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以<strong>key-value对</strong>的形式，被直接缓存在内存中。<strong>key是查询的语句，value是查询的结果。</strong>如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。</p><p>但是，一般不建议使用查询缓存，原因是查询缓存很容易失效。只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p><p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>；</span><br></pre></td></tr></table></figure><p>另外，MySQL 8.0版本已经把查询缓存的功能删掉了。</p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p><p>首先，分析器会做“<strong>词法分析</strong>”。MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p><p>然后，分析器会做“<strong>语法分析</strong>”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID)  <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li><li>也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ERROR <span class="number">1142</span> (<span class="number">42000</span>): <span class="keyword">SELECT</span> command denied <span class="keyword">to</span> <span class="keyword">user</span> <span class="string">&#x27;b&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">for</span> <span class="keyword">table</span> <span class="string">&#x27;T&#x27;</span></span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。</p><p>问题：</p><blockquote><p>如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k&#x3D;1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</p></blockquote><p>答案：分析器阶段。</p><p>网友回答：</p><blockquote><p>《高性能mysql》里提到解析器和预处理器。<br>解析器处理语法和解析查询, 生成一课对应的解析树。<br>预处理器进一步检查解析树的合法。比如: 数据表和数据列是否存在, 别名是否有歧义等。如果通过则生成新的解析树，再提交给优化器。</p></blockquote><h1 id="SQL执行过程"><a href="#SQL执行过程" class="headerlink" title="SQL执行过程"></a>SQL执行过程</h1><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_student  A <span class="keyword">where</span> A.age<span class="operator">=</span><span class="string">&#x27;18&#x27;</span> <span class="keyword">and</span> A.name<span class="operator">=</span><span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p></li><li><p>通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id&#x3D;’1’。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p></li><li><p>接下来就是优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p></li><li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p></li></ul><h3 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_student A <span class="keyword">set</span> A.age<span class="operator">=</span><span class="number">19</span> <span class="keyword">where</span> A.ID<span class="operator">=</span><span class="number">50</span>;</span><br></pre></td></tr></table></figure><ul><li>在一张表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句会把表上所有缓存结果清空</li><li>分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</li><li>执行器先找引擎取ID&#x3D;50这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID&#x3D;50这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个 age 值设为19，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li></ul><p>这里涉及到两个日志，redo log 和 binlog，还有一个概念，两阶段提交。</p><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>redo log 是在有一条记录需要更新时，InnoDB 引擎先将记录写到 redo log 里面，并更新内存。同时， InnoDB引擎会在适当的时候，把这个操作记录更新到磁盘里。</p><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos和checkpoint之间的是 redo log 剩余的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示 redo log 满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p><p><strong>redo log 有什么用处呢？</strong></p><blockquote><p>一个事务提交后，对Buffer Pool对应的页的修改还未持久到磁盘。如果Mysql突然宕机，这个事务的更改会不会直接消失？</p></blockquote><p>答案是不会。Mysql InnoDB 引擎使用 redo log来保证事务的持久性。redo log 主要做的事情就是记录页的修改，redo log中的每一条记录包含了表空间号、数据页号、偏移量、具体修改的数据，可能会记录修改数据的长度（取决于redo log的类型）。 某个页面某个偏移量处修改了几个字节的值以及被修改的内容是什么，都由redo log记录。 在事务提交时，我们会将 redo log按照刷盘策略刷到磁盘上去，即使Mysql宕机，重启后也能恢复未写入磁盘的数据，从而保证了事务的持久性。 刷盘策略 innodb_flush_log_at_trx_commit 的默认值为 1，设置为 1 时不会丢失任何数据。 redo log 采用循环写的方式进行写入，大小固定，当写到结尾时，会回到开头循环写日志，会出现前面写的日志被覆盖的情况。</p><blockquote><p>redo log 一般设置多大？</p></blockquote><p>redo log太小的话，会导致很快就被写满，然后不得不强行刷redo log，这样WAL机制的能力就发挥不出来了。因此建议将redo log设置为4个文件、每个文件1GB。</p><h5 id="redo-log写入机制"><a href="#redo-log写入机制" class="headerlink" title="redo log写入机制"></a>redo log写入机制</h5><p>事务在执行过程中，生成的redo log是要先写到redo log buffer的。</p><blockquote><p>redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？</p></blockquote><p>在一个事务的更新过程中，日志是要写多次的。插入数据过程中，需要保存日志，但是不能在还没 commit 的时候直接写到 redo log 文件里。所以，redo log buffer 是一块内存，用来先存 redo log 日志的。在执行第一个插入语句时，数据的内存被修改了， redo log buffer 也写入了日志。</p><p>真正把日志写到 redo log 文件里，是在执行 commit 语句的时候做的。</p><p>redo log可能存在的三种状态，这三种状态分别是：</p><ol><li>存在redo log buffer中，物理上是在MySQL进程内存中，就是图中的红色部分；</li><li>写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面，也就是图中的黄色部分；</li><li>持久化到磁盘，对应的是hard disk，也就是图中的绿色部分。</li></ol><p><img src="https://static001.geekbang.org/resource/image/9d/d4/9d057f61d3962407f413deebc80526d4.png" alt="img"></p><p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种可能取值：</p><ol><li>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中;</li><li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</li><li>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。</li></ol><p>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cache，然后调用fsync持久化到磁盘。</p><p>注意，事务执行中间过程的redo log也是直接写在redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的redo log，也是可能已经持久化到磁盘的。</p><p>除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中。</p><ol><li><strong>一种是，redo log buffer占用的空间即将达到 innodb_log_buffer_size一半的时候，后台线程会主动写盘。</strong>注意，由于这个事务并没有提交，所以这个写盘动作只是write，而没有调用fsync，也就是只留在了文件系统的page cache。</li><li><strong>另一种是，并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。</strong>假设一个事务A执行到一半，已经写了一些redo log到buffer中，这时候有另外一个线程的事务B提交，如果innodb_flush_log_at_trx_commit设置的是1，那么按照这个参数的逻辑，事务B要把redo log buffer里的日志全部持久化到磁盘。这时候，就会带上事务A在redo log buffer里的日志一起持久化到磁盘。</li></ol><p>那也就意味着，redo log在prepare阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于prepare 的redo log，再加上binlog来恢复的。每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只会write到文件系统的page cache中。</p><p><strong>MySQL的“双1”配置</strong>：sync_binlog和innodb_flush_log_at_trx_commit都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare 阶段），一次是binlog。</p><blockquote><p>在什么时候会把线上生产库设置成“非双1”？</p></blockquote><p>目前知道的场景，有以下这些：</p><ol><li>业务高峰期。一般如果有预知的高峰期，DBA会有预案，把主库设置成“非双1”。</li><li>备库延迟，为了让备库尽快赶上主库。</li><li>用备份恢复主库的副本，应用binlog的过程，这个跟上一种场景类似。</li><li>批量导入数据的时候。</li></ol><p>一般情况下，把生产库改成“非双1”配置，是设置innodb_flush_logs_at_trx_commit&#x3D;2、sync_binlog&#x3D;1000。</p><h5 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h5><p>日志逻辑序列号（log sequence number，LSN）：LSN是单调递增的，用来对应redo log的一个个写入点。每次写入长度为length的redo log， LSN的值就会加上length。</p><p>LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。</p><h5 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h5><blockquote><p>从MySQL看到的TPS是每秒两万的话，每秒就会写四万次磁盘。但是，用工具测试出来，磁盘能力也就两万左右，怎么能实现两万的TPS？</p></blockquote><p>如图所示，是三个并发事务(trx1, trx2, trx3)在prepare 阶段，都写完redo log buffer，持久化到磁盘的过程，对应的LSN分别是50、120 和160。</p><p><img src="https://static001.geekbang.org/resource/image/93/cc/933fdc052c6339de2aa3bf3f65b188cc.png" alt="img"></p><p>从图中可以看到，</p><ol><li>trx1是第一个到达的，会被选为这组的 leader；</li><li>等trx1要开始写盘的时候，这个组里面已经有了三个事务，这时候LSN也变成了160；</li><li>trx1去写盘的时候，带的就是LSN&#x3D;160，因此等trx1返回时，所有LSN小于等于160的redo log，都已经被持久化到磁盘；</li><li>这时候trx2和trx3就可以直接返回了。</li></ol><p>所以，一次组提交里面，组员越多，节约磁盘IOPS的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。</p><p>在并发更新场景下，第一个事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能越多，节约IOPS的效果就越好。</p><p>两阶段提交里虽然把写binlog当成一个动作。但实际上，写binlog分为了两步。</p><ol><li>先把binlog从binlog cache中写到磁盘上的binlog文件；</li><li>调用fsync持久化</li></ol><p>MySQL为了让组提交的效果更好，把redo log做fsync的时间拖到了步骤1之后。也就是说，上面的图变成了这样：</p><p><img src="https://static001.geekbang.org/resource/image/5a/28/5ae7d074c34bc5bd55c82781de670c28.png" alt="img"></p><p>这么一来，binlog也可以组提交了。在执行图5中第4步把binlog fsync到磁盘时，如果有多个事务的binlog已经写完了，也是一起持久化的，这样也可以减少IOPS的消耗。</p><p>不过通常情况下第3步执行得会很快，所以binlog的write和fsync间的间隔时间短，导致能集合到一起持久化的binlog比较少，因此binlog的组提交的效果通常不如redo log的效果那么好。</p><p>如果你想提升binlog组提交的效果，可以通过设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count来实现。</p><ol><li>binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync;</li><li>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。</li></ol><p>这两个条件是或的关系，也就是说只要有一个满足条件就会调用fsync。</p><p>所以，当binlog_group_commit_sync_delay设置为0的时候，binlog_group_commit_sync_no_delay_count也无效了。</p><p><strong>WAL机制主要得益于两个方面</strong>：</p><ol><li>redo log 和 binlog都是顺序写，磁盘的顺序写比随机写速度要快；</li><li>组提交机制，可以大幅度降低磁盘的IOPS消耗。</li></ol><blockquote><p>如果你的MySQL现在出现了性能瓶颈，而且瓶颈在IO上，可以通过哪些方法来提升性能呢？</p></blockquote><p>可以考虑以下三种方法：</p><ol><li>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li><li>将sync_binlog 设置为大于1的值（比较常见是100~1000）。这样做的风险是，主机掉电时会丢binlog日志。</li><li>将innodb_flush_log_at_trx_commit设置为2。这样做的风险是，主机掉电的时候会丢数据</li></ol><p>不建议把innodb_flush_log_at_trx_commit 设置成0。因为把这个参数设置成0，表示redo log只保存在内存中，这样的话MySQL本身异常重启也会丢数据，风险太大。而redo log写到文件系统的page cache的速度也是很快的，所以将这个参数设置成2跟设置成0其实性能差不多，但这样做MySQL异常重启时就不会丢数据了，相比之下风险会更小。</p><blockquote><p> 为什么binlog cache是每个线程自己维护的，而redo log buffer是全局共用的？</p></blockquote><p>回答：MySQL这么设计的主要原因是，binlog是不能“被打断的”。一个事务的binlog必须连续写，因此要整个事务完成后，再一起写到文件里。</p><p>而redo log并没有这个要求，中间有生成的日志可以写到redo log buffer中。redo log buffer中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。</p><h4 id="binglog"><a href="#binglog" class="headerlink" title="binglog"></a>binglog</h4><p>MySQL binlog(binary log 即二进制日志文件) **主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)**。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。</p><p><strong>为什么要用两个日志模块，用一个日志模块不行吗?</strong></p><p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p><p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。</p><p><strong>binlog 和 redolog 的区别</strong></p><ul><li>binlog 主要用于数据库还原，属于数据级别的数据恢复。主从复制是 binlog 最常见的一个应用场景。redolog 主要用于保证事务的持久性，属于事务级别的数据恢复。</li><li>redolog 属于 InnoDB 引擎特有，binlog 属于所有引擎共有，因为 binlog 是 mysql 的 Server 层实现的。</li><li>redolog 属于物理日志，主要记录的是某个页的修改。binlog 属于逻辑日志，主要记录的是数据库执行的所有 DDL 和 DML 语句。</li><li>binlog 通过追加的方式进行写入，大小没有限制。redolog 采用循环写的方式写入，大小固定，当写到结尾时，会回到开头循环写日志。</li></ul><h5 id="binlog-写入机制"><a href="#binlog-写入机制" class="headerlink" title="binlog 写入机制"></a>binlog 写入机制</h5><p>事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p><p>系统给binlog cache分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p><ul><li><p>每个线程写入其对应的 binlog_cache_size</p></li><li><p>write 操作把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。</p></li><li><p>fsync 操作才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占磁盘的IOPS。</p></li></ul><p>write 和fsync的时机，是由参数sync_binlog控制的：</p><ol><li>sync_binlog&#x3D;0的时候，表示每次提交事务都只write，不fsync；</li><li>sync_binlog&#x3D;1的时候，表示每次提交事务都会执行fsync；</li><li>sync_binlog&#x3D;N(N&gt;1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。</li></ol><p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100~1000中的某个数值。</p><p>但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。</p><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p><code>redo log</code>（重做日志）让 <code>InnoDB</code> 存储引擎拥有了崩溃恢复能力。</p><p><code>binlog</code>（归档日志）保证了 <code>MySQL</code> 集群架构的数据一致性。</p><p>虽然它们都属于持久化的保证，但是侧重点不同。</p><p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MySQL/%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%E6%97%B6%E6%9C%BA.png"></p><p>为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做。</p><ul><li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li><li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li></ul><p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。</p><p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。</p><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MySQL/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png"></p><h5 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h5><p>假设写入redo log 处于prepare阶段之后、写binlog之前，发生了崩溃（crash），由于此时binlog还没写，redo log也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog还没写，所以也不会传到备库。</p><p>那么问题来了，有没有一个极端的情况呢？假设binlog写完，redo log还没commit前发生crash， <strong>MySQL异常重启会出现什么现象</strong>？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p><ul><li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 redo log 里的事务是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li></ul><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MySQL/2PC%E6%83%85%E5%86%B51.png"></p><p>如果 redo log 设置 commit 阶段发生异常，那会不会回滚事务呢？</p><ul><li><p>它会判断对应的事务binlog是否存在并完整，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据。</p><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MySQL/2PC%E6%83%85%E5%86%B52.png"></p></li></ul><p>这样就解决了数据一致性的问题。</p><blockquote><p>MySQL怎么知道binlog是完整的?</p></blockquote><p>回答：一个事务的binlog是有完整格式的：</p><ul><li><p>statement格式的binlog，最后会有COMMIT；</p></li><li><p>row格式的binlog，最后会有一个XID event。</p></li></ul><p>另外，在MySQL 5.6.2版本以后，还引入了binlog-checksum参数，用来验证binlog内容的正确性。校验checksum的结果可以处理关于binlog日志由于磁盘原因可能会在日志中间出错的情况。</p><blockquote><p>redo log 和 binlog是怎么关联起来的?</p></blockquote><p>回答：它们有一个共同的数据字段，叫XID。崩溃恢复的时候，会按顺序扫描redo log：</p><ul><li><p>如果碰到既有prepare、又有commit的redo log，就直接提交；</p></li><li><p>如果碰到只有parepare、而没有commit的redo log，就拿着XID去binlog找对应的事务。</p></li></ul><h4 id="生产建议"><a href="#生产建议" class="headerlink" title="生产建议"></a>生产建议</h4><p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数建议设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p><p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数也建议设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p><blockquote><p>定期全量备份的周期取决于系统重要性，有的是一天一备，有的是一周一备。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？</p></blockquote><p>好处是“最长恢复时间”更短。</p><p>在一天一备的模式里，最坏情况下需要应用一天的binlog。</p><p>一周一备份，那就需要全备+周一到周日某个时间点的全部binlog用来恢复，时间相比前者需要增加很多；且需要确保整个一周的binlog都完好无损，否则将无法恢复。</p><p>系统的对应指标就是 RTO（恢复目标时间）。当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个RTO是成本换来的，就需要根据业务重要性来评估了。</p><h1 id="数据的存储"><a href="#数据的存储" class="headerlink" title="数据的存储"></a>数据的存储</h1><blockquote><p>为什么一条 SQL 语句正常执行的时候特别快，但是有时候突然又变慢了？</p></blockquote><p><strong>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</strong>。</p><p>平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。</p><p>那么，什么情况会引发数据库的flush过程呢？</p><ul><li><p>redo log 写满了，系统停止所有更新操作，把 checkpoint 往前推进， 在这之前需要将移动的位置之间的日志对应的所有脏页都 flush 到磁盘上。（要尽量避免）</p></li><li><p>系统内存不足，需要新的内存页，也就需要淘汰掉一些数据页。如果淘汰的是脏页，就要先将脏页写到磁盘。</p><p>如果刷脏页一定会写盘，就保证了每个数据页有两种状态：</p><ul><li>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</li><li>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。<br>这样的效率最高。</li></ul></li><li><p>MySQL认为系统“空闲”的时候。有机会就刷一点“脏页”。</p></li><li><p>MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p></li></ul><p>对于第二种情况是很常见的。</p><p>InnoDB 存储引擎是以页为单位来管理存储空间的，我们往 MySQL 插入的数据最终都是存在于页中，准确来说是数据页这种类型，为了减少磁盘 IO 开销，还有一个叫做 Buffer Pool(缓冲池)的区域，存在于内存中。当数据对应的页不存在于 Buffer Pool 中的话，mysql 会先将磁盘上的页缓存到 Buffer Pool 中，这样后面我们直接操作的就是 Buffer Pool 中的页，这样大大提高了读写性能。</p><p><strong>缓冲池中的内存页有三种状态：</strong></p><ul><li>第一种是，还没有使用的；</li><li>第二种是，使用了并且是干净页；</li><li>第三种是，使用了并且是脏页。</li></ul><p>这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p><p>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p><ol><li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li><li>日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。</li></ol><p>所以，InnoDB需要有控制脏页比例的机制，来尽量避免上面的这两种情况。</p><p>测试磁盘随机读写的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest </span><br></pre></td></tr></table></figure><p>InnoDB的刷盘速度参考因素：<strong>脏页比例，redo log写盘速度</strong>。</p><p>参数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%（需多关注脏页比例，不要让其经常接近75%）。InnoDB会根据当前的脏页比例（假设为M），算出一个范围在0到100之间的数字，计算这个数字的伪代码类似这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记(当前日志序号-checkpoint) &#x3D; N，InnoDB 会根据这个 N 计算出一个范围在 0-100 的数字，计算公式为 F2(N)</p><p>取 F1(M) 和 F2(N) 的最大值 R，<strong>之后引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。</strong></p><p>MySQL 中刷脏页可能会有连坐机制，如果这个数据页旁边正好是一个脏页，就会把它的邻居一起刷掉。在 InnoDB 中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为1的时候会有上述的“连坐”机制，值为0时表示不找邻居，自己刷自己的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机IO。机械硬盘的随机IOPS一般只有几百，相同的逻辑操作减少随机IO就意味着系统性能的大幅度提升。</span><br><span class="line"></span><br><span class="line">而如果使用的是SSD这类IOPS比较高的设备的话，我就建议你把innodb_flush_neighbors的值设置成<span class="number">0</span>。因为这时候IOPS往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少SQL语句响应时间。</span><br><span class="line"></span><br><span class="line">在MySQL <span class="number">8.0</span>中，innodb_flush_neighbors参数的默认值已经是<span class="number">0</span>了。</span><br></pre></td></tr></table></figure><blockquote><p>一个内存配置为128GB、innodb_io_capacity设置为20000的大规格实例，正常会建议你将redo log设置成4个1GB的文件。</p><p>但如果你在配置的时候不慎将redo log设置成了1个100M的文件，会发生什么情况呢？又为什么会出现这样的情况呢？</p></blockquote><p>每次事务提交都要写redo log，如果设置太小，很快就会被写满，这时候系统不得不停止所有更新，去推进checkpoint。在这种情况下，连change buffer的优化也失效了。因为checkpoint一直要往前推，这个操作就会触发merge操作，然后又进一步地触发刷脏页操作。</p><h2 id="数据库表的空间回收"><a href="#数据库表的空间回收" class="headerlink" title="数据库表的空间回收"></a>数据库表的空间回收</h2><p>一个InnoDB表包含两部分，即：表结构定义和数据。</p><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><p>在MySQL 8.0版本以前，表结构是存在以.frm为后缀的文件里。</p><p>而MySQL 8.0版本，则已经允许把表结构定义放在系统数据表中了。</p><h3 id="表数据"><a href="#表数据" class="headerlink" title="表数据"></a>表数据</h3><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数innodb_file_per_table控制的：</p><ol><li>这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li><li>这个参数设置为ON表示的是，每个InnoDB表数据存储在一个以 .ibd为后缀的文件中。</li></ol><p>从MySQL 5.6.6版本开始，它的默认值就是ON了。无论是哪个版本，建议设置为 ON。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过 <span class="keyword">drop</span> <span class="keyword">table</span> 命令，系统会直接删除这个文件；如果放在共享空间，即使表删掉了，空间也不会被回收。</span><br><span class="line">而 <span class="keyword">delete</span> 命令，分为记录的复用和数据页的复用。</span><br><span class="line">删除某条记录，InnoDB 只会把记录标记为删除，如果要插入在这个记录删除区间的记录，可能会复用这个位置。但是磁盘文件大小不会被缩小。</span><br><span class="line">删除一个数据页上的所有记录，整个数据页就都可以被复用了。发生页合并时，另一个空出来的页也能被复用了。</span><br></pre></td></tr></table></figure><p>使用 delete 删除不能回收表空间，而没有被使用的空间，看起来像空洞。实际上插入数据使得页分裂也会造成空洞。</p><h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>使用alter table A engine&#x3D;InnoDB命令来重建表。</p><p>在MySQL 5.5版本之前，</p><ul><li>MySQL会自动新建一个与表A结构相同的表B</li><li>按照主键ID递增的顺序，把数据一行一行地从表A里读出来再插入到表B中。</li><li>表B的主键索引更紧凑，数据页的利用率也更高。但是InnoDB不会把整张表占满，每个页留了1&#x2F;16给后续的更新用。</li><li>把表B作为临时表，数据从表A导入表B的操作完成后，用表B替换A，收缩了表A空间。</li></ul><p>显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表A的话，就会造成数据丢失。因此，在整个DDL过程中，表A中不能有更新。也就是说，这个DDL不是Online的。</p><p>而在<strong>MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。</strong></p><p>这个方案在重建表的过程中，允许对表A做增删改操作。重建表的流程：</p><ol><li>建立一个临时文件，扫描表A主键的所有数据页；</li><li>用数据页中表A的记录生成B+树，存储到临时文件中；</li><li>生成临时文件的过程中，将所有对A的操作记录在一个日志文件（row log）中；</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件；</li><li>用临时文件替换表A的数据文件。</li></ol><blockquote><p>DDL之前是要拿MDL写锁的，这样还能叫Online DDL吗？</p></blockquote><p>alter语句在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。为了实现Online，MDL读锁不会阻塞增删改操作，同时 MDL 读锁可以保护这张表，禁止其他线程对这个表同时做 DDL。</p><p>上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很消耗IO和CPU资源的。因此，如果是线上服务，你要很小心地控制操作时间。如果想要比较安全的操作的话，我推荐你使用GitHub开源的gh-ost来做。</p><h3 id="Online-和-inplace"><a href="#Online-和-inplace" class="headerlink" title="Online 和 inplace"></a>Online 和 inplace</h3><p>根据表A重建出来的数据是放在“tmp_file”里的，这个临时文件是InnoDB在内部创建出来的。整个DDL过程都在InnoDB内部完成。对于server层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。</p><blockquote><p>如果你有一个1TB的表，现在磁盘间是1.2TB，能不能做一个inplace的DDL呢？</p></blockquote><p>不能。因为，tmp_file也是要占用临时空间的。</p><p>重建表的这个语句alter table t engine&#x3D;InnoDB，其实隐含的意思是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t engine<span class="operator">=</span>innodb,ALGORITHM<span class="operator">=</span>inplace;</span><br></pre></td></tr></table></figure><p>跟inplace对应的就是拷贝表的方式了，用法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t engine<span class="operator">=</span>innodb,ALGORITHM<span class="operator">=</span><span class="keyword">copy</span>;</span><br></pre></td></tr></table></figure><p>Online 和 inplace 不是一个概念。如果我要给InnoDB表的一个字段加全文索引，写法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> FULLTEXT(field_name);</span><br></pre></td></tr></table></figure><p>这个过程是inplace的，但会阻塞增删改操作，是非Online的。</p><p>如果说这两个逻辑之间的关系是什么的话，可以概括为：</p><ol><li>DDL过程如果是Online的，就一定是inplace的；</li><li>反过来未必，也就是说inplace的DDL，有可能不是Online的。截止到MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引(SPATIAL index)就属于这种情况。</li></ol><blockquote><p>使用optimize table、analyze table和alter table这三种方式重建表的区别？</p></blockquote><ul><li>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁；</li><li>optimize table t 等于alter table + analyze。</li></ul><h1 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h1><p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。</p><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>ACID，原子性、一致性、隔离性、持久性</p><p><strong>原子性：</strong>事务是原子操作，事务内任何一个 SQL 执行失败，所有已执行成功的 SQL 语句必须撤销。通过 undo log 实现。</p><p><strong>隔离性：</strong>事务操作按照一定粒度隔离，通过 读写锁 + MVCC 来实现。</p><p><strong>一致性：</strong>事务开始之前和结束之后，数据库的完整性约束没有破坏。</p><p><strong>持久性：</strong>一个事务一旦被提交，它对数据库中数据的改变就是永久性的。</p><h2 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h2><table><thead><tr><th align="center">启动事务，查询得到值1</th><th align="center">启动事务</th></tr></thead><tbody><tr><td align="center">事务A</td><td align="center">事务B</td></tr><tr><td align="center"></td><td align="center">查询得到值1</td></tr><tr><td align="center"></td><td align="center">讲1改成2</td></tr><tr><td align="center">查询得到值 V1</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">提交事务B</td></tr><tr><td align="center">查询得到值 V2</td><td align="center"></td></tr><tr><td align="center">提交事务A</td><td align="center"></td></tr><tr><td align="center">查询得到值 V3</td><td align="center"></td></tr></tbody></table><p>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。</p><ul><li><p>若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。</p></li><li><p>若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。</p></li><li><p>若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</p></li><li><p>若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。</p></li></ul><p>配置方式：将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="string">&#x27;transaction_isolation&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"></span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br></pre></td></tr></table></figure><h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p><p>在<strong>“可重复读”</strong>隔离级别下，这个视图是在<strong>事务启动时</strong>创建的，整个事务存在期间都用这个视图。</p><p>在<strong>“读提交”</strong>隔离级别下，这个视图是在<strong>每个SQL语句开始执行</strong>的时候创建的。</p><p>这里需要注意的是，<strong>“读未提交”</strong>隔离级别下直接返回记录上的最新值，<strong>没有视图概念</strong>；</p><p>而<strong>“串行化”</strong>隔离级别下直接用<strong>加锁</strong>的方式来避免并行访问。</p><p>这里提到了“视图”的概念，在MySQL里，有两个视图概念：</p><ul><li>一个是view。它是一个用查询语句定义的虚拟表。语法：create view….</li><li>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持读提交和可重复读的隔离级别的实现。</li></ul><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。（事务隔离级别为“可重复读”）</p><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E5%AE%9E%E7%8E%B0.png"></p><p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p><p><em>当系统判断没有事务再需要用到这些回滚日志时，即当系统内没有比这个回滚日志更早的 read-view 的时候，回滚日志会被删除</em></p><h3 id="关于MVCC的理解"><a href="#关于MVCC的理解" class="headerlink" title="关于MVCC的理解"></a>关于MVCC的理解</h3><h4 id="快照在MVCC里是怎么工作的？"><a href="#快照在MVCC里是怎么工作的？" class="headerlink" title="快照在MVCC里是怎么工作的？"></a>快照在MVCC里是怎么工作的？</h4><p><strong>可见性规则：</strong></p><ol><li><p>InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。</p></li><li><p>每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。而对于当前版本之前的版本并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InnoDB 的每一行都会有三个默认隐式字段 row_id, tx_id, roll_point</span><br><span class="line"><span class="number">1.</span>row_id：若表中没有主键，会使用系统的一个默认递增 row_id 作为主键</span><br><span class="line"><span class="number">2.</span>tx_id：事务 id，记录当前操作此记录的事务</span><br><span class="line"><span class="number">3.</span>roll_point：上一个版本对应的 undo log 的指针</span><br></pre></td></tr></table></figure><p>在内部实现中，InnoDB 通过数据行的 <code>row_id </code>和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>roll_point</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前提交的修改和对事务本身做的修改。</p><ol start="3"><li><p>InnoDB 为每个事务构造了一个视图数组，用来保存这个事务启动瞬间，当前正在活跃的所有事务ID。 “活跃”是指，启动了但还没提交。数组中最小的事务id记录为低水位，当前系统创建过的事务id最大值+1 记录为高水位</p></li><li><p>视图数组和高水位，就组成了当前事务的一致性视图 </p></li><li><p>数据版本的可见性规则，就是基于数据的行事务id（ row trx_id） 和一致性视图的对比。对比的结论 就是：一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p></li></ol><ul><li>版本未提交，不可见 </li><li>版本已提交，但是是在视图创建后提交的，不可见 </li><li>版本已提交，而且是在视图创建前提交的，可见</li></ul><p>基于上边提到的可见性规则，在可重复读的隔离级别下，看一个例子。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基于 MySQL 5.7.37</span></span><br><span class="line"><span class="comment">-- 创建表 t、初始化数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">`id` <span class="type">INT</span> ( <span class="number">11</span> ) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`k` <span class="type">INT</span> ( <span class="number">11</span> ) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY ( `id` )) ENGINE <span class="operator">=</span> INNODB;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t ( id, k ) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>),(<span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th><th>事务C</th></tr></thead><tbody><tr><td>1</td><td>start transaction with consistent snapshot;</td><td></td><td></td></tr><tr><td>2</td><td></td><td>start transaction with consistent snapshot;</td><td></td></tr><tr><td>3</td><td></td><td></td><td>update t set k&#x3D;k+1 where id &#x3D; 1;</td></tr><tr><td>4</td><td></td><td>update t set k&#x3D;k+1 where id &#x3D; 1;</td><td></td></tr><tr><td>5</td><td></td><td>select k from t where id &#x3D; 1;</td><td></td></tr><tr><td>6</td><td>select k from t where id &#x3D; 1;</td><td></td><td></td></tr><tr><td>7</td><td>commit;</td><td></td><td></td></tr><tr><td>8</td><td></td><td>commit;</td><td></td></tr></tbody></table><p>假设事务 A,B,C 的事务 id 分别为 100，101，102，三个事务开始之前，id&#x3D;1这行数据的 tx_id &#x3D; 90</p><table><thead><tr><th>时间</th><th>事务A(100)</th><th>事务B(101)</th><th>事务C(102)</th><th>数据版本</th></tr></thead><tbody><tr><td>1</td><td>start transaction with consistent snapshot;<br />视图数组[100]，高水位100</td><td></td><td></td><td>数据版本90（1，1）</td></tr><tr><td>2</td><td></td><td>start transaction with consistent snapshot;<br />视图数组[100，101]，高水位101</td><td></td><td></td></tr><tr><td>3</td><td></td><td></td><td>update t set k&#x3D;k+1 where id &#x3D; 1;<br />视图数组[100，101，102]，高水位102</td><td>数据版本102（1，2）</td></tr><tr><td>4</td><td></td><td>update t set k&#x3D;k+1 where id &#x3D; 1;</td><td></td><td>数据版本101（1，3）</td></tr><tr><td>5</td><td></td><td>select k from t where id &#x3D; 1;</td><td></td><td></td></tr><tr><td>6</td><td>select k from t where id &#x3D; 1;</td><td></td><td></td><td></td></tr><tr><td>7</td><td>commit;</td><td></td><td></td><td></td></tr><tr><td>8</td><td></td><td>commit;</td><td></td><td></td></tr></tbody></table><p>根据可见性规则判断事务A的查询结果：</p><ul><li>(1,3)还没提交，属于情况1，不可见；</li><li>(1,2)虽然提交了，但是是在视图数组创建之后提交的，属于情况2，不可见；</li><li>(1,1)是在视图数组创建之前提交的，可见。</li></ul><blockquote><p>但是关于事务B的update语句，如果按照一致性读，好像不太对？</p><p>事务B的视图是先生成的，之后事务C才提交，不是应该看不见(1,2)吗？它又是怎么算出(1,3)的？</p><p>答案和更新逻辑有关。</p></blockquote><h4 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h4><p>事务B 在更新之前会先查询一次数据，这个查询返回 k 值为 1。</p><p>但是更新数据时，不能再在历史版本上更新了，不然事务 C 会丢失它的更新。因此，事务B<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p><p>“当前读” 实际上是通过加锁实现的。在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是等到事务结束时才释放，这就是两阶段锁协议。</p><p>所以假设事务C没有马上提交，事务B会阻塞直到事务C提交后释放锁，事务B再拿到锁继续执行。</p><p>可重复读的核心就是一致性读，而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p><p>其实，除了 update 语句外，select 语句加上锁，也是当前读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode; # 共享锁 </span><br><span class="line"><span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>; # 排他锁</span><br></pre></td></tr></table></figure><h4 id="MVCC-的好处"><a href="#MVCC-的好处" class="headerlink" title="MVCC 的好处"></a>MVCC 的好处</h4><p>我觉得可以从数据库的三种并发场景来说，<br>第一种是读和读的并发，就是两个线程 A 和 B，同时进行读操作，这时不会产生任何并发问题；<br>第二种是读和写的并发，就是两个线程 A 和 B 分别进行读写操作，这时会对数据库的数据造成以下几个问题：1. 事务隔离性问题 2. 会出现脏读、幻读、不可重复读的问题<br>第三种是写和写的并发，就是两个线程 A 和 B，同时进行写操作，这种情况下可能会出现数据更新丢失问题，而 MVCC 就是为了解决事务操作中并发安全问题的多版本并发控制技术。它是通过数据库记录中的隐式字段、undo 日志和 Read View 实现的。<br>MVCC 主要解决三个问题：</p><ol><li>读写并发阻塞问题，从而提高数据的并发处理能力</li><li>MVCC 采用乐观锁的方式实现，降低了死锁的概率</li><li>解决了一致性读的问题，也就是事务启动时根据某个条件读取到的数据，直到事务结束时再去执行相同的条件，还是读到同一份数据，不会发生变化</li></ol><p>我们在开发过程中主要是根据业务场景使用乐观锁或悲观锁，这两个组合中，MVCC 用来解决读写冲突，乐观锁或悲观锁用来解决写和写的冲突，从而最大程度地提高数据库的并发性能</p><h2 id="事务的启动"><a href="#事务的启动" class="headerlink" title="事务的启动"></a>事务的启动</h2><p>MySQL的事务启动方式有以下几种：</p><ol><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</li><li>set autocommit&#x3D;0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。</li></ol><h4 id="事务启动时机"><a href="#事务启动时机" class="headerlink" title="事务启动时机"></a>事务启动时机</h4><p>begin&#x2F;start transaction命令不是事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句（第一个快照语句），事务才真正启动。</p><p>如果要实现马上启动一个事务，要使用 <strong>start transaction with consistent snapshot</strong> 命令。</p><p><em>读已提交隔离级别下，等同于普通的 start transaction</em></p><h2 id="生产建议-1"><a href="#生产建议-1" class="headerlink" title="生产建议"></a>生产建议</h2><p><strong>尽量不要使用长事务</strong>。</p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><p>在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。</p><p><strong>方法一：</strong></p><p>有些客户端连接框架会默认连接成功后先执行一个set autocommit&#x3D;0的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p><p>因此，建议使用set autocommit&#x3D;1, 通过显式语句的方式来启动事务。</p><p><strong>方法二：</strong></p><p>而对于一个<strong>需要频繁使用事务的业务</strong>，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果想要使用第二种方式并避免长事务的误用，建议使用commit work and chain语法。</p><p>如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p><p>你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(timediff(now(),trx_started))<span class="operator">&gt;</span><span class="number">60</span></span><br></pre></td></tr></table></figure><blockquote><p>你现在知道了系统里面应该避免长事务，如果你是业务开发负责人同时也是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢？</p></blockquote><p><strong>首先，从应用开发端来看：</strong></p><ol><li>确认是否使用了set autocommit&#x3D;0。这个确认工作可以在测试环境中开展，把MySQL的general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。</li><li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用begin&#x2F;commit框起来。我见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务可以去掉。</li><li>业务连接数据库的时候，根据业务本身的预估，通过SET MAX_EXECUTION_TIME命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li></ol><p><strong>其次，从数据库端来看：</strong></p><ol><li>监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警&#x2F;或者kill；</li><li>Percona的pt-kill这个工具不错，推荐使用；</li><li>在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题；</li><li>如果使用的是MySQL 5.6或者更新版本，把innodb_undo_tablespaces设置成2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li></ol><h1 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h1><h2 id="B树：为磁盘而生"><a href="#B树：为磁盘而生" class="headerlink" title="B树：为磁盘而生"></a>B树：为磁盘而生</h2><p>B树也称B-树，是为磁盘等辅存储设备设计的多路平衡查找树，与二叉树相比，B树的每个非叶节点可以有很多个子树。因此，当总节点数量相同时，B树的高度远远小于AVL树和红黑树，磁盘IO大大减少。<br><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MySQL/Pasted%20image%2020221214231623.png"><br>B树的优势除了树高小，还有对访问局部性原理的利用。局部性原理是指，当一个数据被使用时，其附近的数据有较大概率在短时间内被使用。B树将键相近的数据存储在同一个节点，当访问其中某个数据时，数据库会将整个节点读到缓存中；当它临近的数据紧接着被访问时，可以直接在缓存中读取，无需进行磁盘IO；换句话说，B树的缓存命中率更高。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><h3 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h3><ul><li>B树中每个节点（包括叶节点和非叶节点）都存储真实的数据，B+树只有叶子节点存储真实的数据，非叶节点只存储键。这里说的真实数据，可能是行的全部数据（如InnoDB的聚簇索引），也可能只是行的主键（如InnoDB的辅助索引），或者是行所在的地址（如MyIsam的非聚簇索引）。</li><li>B树中一条记录只会出现一次，不会重复出现，而B+树的键则可能重复出现——一定会在叶节点出现，也可能在非叶节点重复出现。</li><li>B+树的叶节点之间通过双向链表链接。</li><li>B树中的非叶节点，记录数比子节点个数少1；而B+树中记录数与子节点个数相同</li></ul><h3 id="B-树优势"><a href="#B-树优势" class="headerlink" title="B+树优势"></a>B+树优势</h3><ul><li><strong>更少的IO次数</strong>：B+树的非叶节点只包含键，而不包含真实数据，因此每个节点存储的记录个数比B数多很多（即阶m更大），因此B+树的高度更低，访问时所需要的IO次数更少。此外，由于每个节点存储的记录数更多，所以对局部性原理的利用更好，缓存命中率更高。</li><li><strong>更适用于范围查询</strong>：在B树中进行范围查询时，首先找到要查找的下限，然后对B树进行中序遍历，直到找到查找的上限。而B+树的范围查询，只需要对链表进行遍历即可。</li><li><strong>更稳定的查询效率</strong>：B树的查询时间复杂度在1到树高之间（分别对应记录在根节点和叶节点），而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点。</li></ul><h3 id="B-树效率估算"><a href="#B-树效率估算" class="headerlink" title="B+树效率估算"></a>B+树效率估算</h3><p>对于InnoDB的B+索引来说，树的高度一般在2-4层。（下面是具体的估算，最好理解后记下来）</p><p>树的高度是由阶数决定的，阶数越大树越矮；而阶数大小又取决于每个节点可以存储多少条记录。InnoDB中每个节点使用一个页，页的大小为16KB，其中元数据只占128字节左右（包括文件管理头信息，页面头信息等等），大多数空间都用来存储数据。</p><ul><li>对于非叶节点，记录只包含索引的键和指向下一层节点的指针。假设每个非叶节点页面存储1000条记录，则每条记录大约占用16字节；当索引列是整型或较短的字符串时，这个假设合理。经常有建议说索引列长度不应过大，原因在于：索引列太长，每个节点包含的记录数太少，会导致树太高，索引的效果会大打折扣，而且索引会浪费更多空间。</li><li>对于叶节点，记录包含了索引的键和值（值可能是行的主键、一行完整数据等），数据量更大。这里假设每个叶节点页面存储100条记录（实际上，当索引为聚簇索引时，这个数字可能不足100；当索引为辅助索引时，可能远大于100）。</li></ul><p>对于一棵3层B+树，第一层（根节点）有1个页面，可以存储1000条记录；第二层有1000个页面，可以存储1000×1000条记录；第三层有1000×1000个页面，每个页面存储100条记录，因此可以存储千万条数据。</p><h3 id="不适用其他类型索引原因"><a href="#不适用其他类型索引原因" class="headerlink" title="不适用其他类型索引原因"></a>不适用其他类型索引原因</h3><ul><li><p>哈希表：链表里存储的value不是有序的，区间查询速度慢；</p></li><li><p>二叉查找树：解决了排序的基本问题，但是无法保证平衡，可能退化成链表；</p></li><li><p>平衡二叉树：通过旋转解决了平衡问题，但是旋转操作效率太低；</p></li><li><p>红黑树：通过舍弃严格平衡和引入红黑节点，解决了AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多；</p></li></ul><h2 id="存储引擎的索引类型"><a href="#存储引擎的索引类型" class="headerlink" title="存储引擎的索引类型"></a>存储引擎的索引类型</h2><p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p><h3 id="联合索引的使用"><a href="#联合索引的使用" class="headerlink" title="联合索引的使用"></a>联合索引的使用</h3><p>我们在进行数据库表设计的时候，往往不会使用物理删除，通常会通过一个 is_deleted 字段实现逻辑删除。假设字段 a 需要设置唯一索引，若使用逻辑删除，就不能单独给这个字段a 设置唯一索引了，而应该设置 uq_index(a,is_deleted)。</p><blockquote><p>假设 is_deleted 为 0 为 未删除，当我们要删除其中一条数据时，将该行数据的 is_deleted 设置为1，这样会出现什么问题呢？该怎么解决这个问题？</p></blockquote><p>如果只将 is_deleted 设置为1，那么此时我们再插入一条数据，该数据标识为未删除。再过一会，我们再将这行数据删除，此时就会违反唯一性约束了。</p><p>针对这个问题，有两种解决方案：</p><ul><li>当需要删除时，将 is_deleted 设置为 null，null 是不走索引的，且 MySQL 中的每个 null 值都是不相同的，因此也就不会受到唯一性约束。</li><li>当需要删除该行数据时，将 is_deleted 设置为该行数据的 id，每行数据的 id 值都是一定的，因此也就不会违反唯一性约束了。</li></ul><h3 id="普通索引与唯一索引的选择"><a href="#普通索引与唯一索引的选择" class="headerlink" title="普通索引与唯一索引的选择"></a>普通索引与唯一索引的选择</h3><h4 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h4><p>假设在 k 上建一个索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> T <span class="keyword">where</span> k<span class="operator">=</span><span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k&#x3D;5条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><p>但是这个查找性能差距微乎其微。</p><p>普通索引要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p><p>极端情况下，如果 k &#x3D; 5这条记录刚好是这个数据页最后一个记录，这时可能会需要读取下一个数据页来取下一个记录，这个操作略微复杂。</p><p>但是对于整型字段，一个数据页可以放近千个key，出现这种情况概率较低。</p><h4 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h4><h5 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h5><p>需要更新一个在内存中的数据页时可以直接更新，但是该数据页没在内存中的话，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在 change buffer 中，避免从磁盘读入该数据页。而下次查询需要访问这个数据页时，将数据页读入内存，执行 change buffer 中的相关操作。</p><p>change buffer 是可持久化的数据，在内存中有拷贝，也会写入到磁盘。其使用的内存是 buffer pool 里的内存，因此其不能无限增大。</p><p>change buffer 的大小可以通过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p><p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4,400)这个记录，就要先判断现在表中是否已经存在k&#x3D;4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。</p><p>因此，唯一性约束更新使用不了 change buffer，只有普通索引可以使用。</p><p>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><h5 id="change-buffer-使用场景"><a href="#change-buffer-使用场景" class="headerlink" title="change buffer 使用场景"></a>change buffer 使用场景</h5><ul><li><p>写多读少的业务，如账单类、日志类。change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p></li><li><p>普通索引和change buffer的配合使用，对于数据量大的表的更新优化效果显著。</p></li><li><p>当有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那应该特别关注这些表里的索引，尽量使用普通索引，然后把change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。</p></li></ul><blockquote><p>change buffer一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致change buffer丢失呢？change buffer丢失可不是小事儿，再从磁盘读入数据可就没有了merge过程，就等于是数据丢失了。会不会出现这种情况呢？</p></blockquote><p>1.change buffer 有一部分在内存有一部分在ibdata（系统表空间）<br>做 purge 操作,应该就会把 change buffer 里相应的数据持久化到 ibdata<br>2.redo log 里记录了数据页的修改以及 change buffer 新写入的信息<br>如果掉电,持久化的 change buffer 数据已经 purge , 不用恢复。主要分析没有持久化的数据<br>情况又分为以下几种:<br>(1) change buffer 写入, redo log 虽然做了 fsync 但未 commit ,binlog 未 fsync 到磁盘,这部分数据丢失<br>(2) change buffer 写入, redo log 写入但没有 commit, binlog 以及fsync到磁盘,先从 binlog 恢复 redo log,再从redo log恢复change buffer<br>(3)change buffer写入,redo log和binlog都已经fsync.那么直接从redo log里恢复。</p><blockquote><p>merge的过程是否会把数据直接写回磁盘？</p></blockquote><p>merge的执行流程是这样的：</p><ol><li>从磁盘读入数据页到内存（老版本的数据页）；</li><li>从change buffer里找出这个数据页的change buffer 记录(可能有多个），依次应用，得到新版数据页；</li><li>写redo log。这个redo log包含了数据的变更和change buffer的变更。</li></ol><p>到这里merge过程就结束了。这时候，数据页和内存中change buffer对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。</p><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>假设你现在维护了一个交易系统，其中交易记录表tradelog包含交易流水号（tradeid）、交易员id（operator）、交易时间（t_modified）等字段。为了便于描述，我们先忽略其他字段。这个表的建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tradelog` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `operator` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `t_modified` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`),</span><br><span class="line">  KEY `t_modified` (`t_modified`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>trade_id在数据库中是varchar类型的，看这个全表扫描的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid<span class="operator">=</span><span class="number">110717</span>;</span><br></pre></td></tr></table></figure><p>对于优化器来说，这个语句相当于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span>  <span class="built_in">CAST</span>(tradid <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">110717</span>;</span><br></pre></td></tr></table></figure><p>也就是说，这条语句触发了我们上面说到的规则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p><p>另一个问题是，id的类型是int，如果执行下面这个语句，是否会导致全表扫描呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> id<span class="operator">=</span>&quot;83126&quot;;</span><br></pre></td></tr></table></figure><p>答案是不会，这个语句相当于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> id <span class="operator">=</span> <span class="built_in">CAST</span>(&quot;83126&quot; <span class="keyword">AS</span> signed <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>可以看到这里只是对参数进行了隐式转换，还是会走id这个索引。</p><h4 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h4><p>假设系统有表trade_detail，用于记录交易的操作细节。为了便于量化分析和复现，我往交易日志表tradelog和交易详情表trade_detail这两个表里插入一些数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `trade_detail` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `trade_step` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/*操作步骤*/</span></span><br><span class="line">  `step_info` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/*步骤信息*/</span></span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">6</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">8</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">9</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">11</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这时候，如果要查询id&#x3D;2的交易的所有操作步骤信息，SQL语句可以这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> l.id<span class="operator">=</span><span class="number">2</span>; <span class="comment">/*语句Q1*/</span></span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/ad/22/adfe464af1d15f3261b710a806c0fa22.png" alt="img"></p><ol><li>第一行显示优化器会先在交易记录表tradelog上查到id&#x3D;2的行，这个步骤用上了主键索引，rows&#x3D;1表示只扫描一行；</li><li>第二行key&#x3D;NULL，表示没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫描。</li></ol><p>这个语句的执行流程如下：</p><ul><li>第1步，是根据id在tradelog表里找到L2这一行；</li><li>第2步，是从L2中取出tradeid字段的值；</li><li>第3步，是根据tradeid值到trade_detail表中查找条件匹配的行。explain的结果里面第二行的key&#x3D;NULL表示的就是，这个过程是通过遍历主键索引的方式，一个一个地判断tradeid的值是否匹配</li></ul><p>这里问题出现在第3步，这两个表的字符集不同，一个是utf8，一个是utf8mb4，所以做表连接查询的时候用不上关联字段的索引。</p><p>如果单独把第3步改成 SQL 语句的话，那就是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trade_detail <span class="keyword">where</span> tradeid<span class="operator">=</span>$L2.tradeid.value; </span><br></pre></td></tr></table></figure><p>其中，$L2.tradeid.value的字符集是utf8mb4。</p><p>字符集utf8mb4是utf8的超集，所以当这两个类型的字符串在做比较的时候，MySQL内部的操作是，先把utf8字符串转成utf8mb4字符集，再做比较。</p><p>实际上这个语句等同于下面这个写法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trade_detail  <span class="keyword">where</span> <span class="keyword">CONVERT</span>(traideid <span class="keyword">USING</span> utf8mb4)<span class="operator">=</span>$L2.tradeid.value; </span><br></pre></td></tr></table></figure><p>对索引字段做了函数操作，优化器就放弃了走搜索树功能。</p><blockquote><p>怎么优化这个查询语句呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> l.id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure></blockquote><ul><li>比较常见的优化方法是，把trade_detail表上的tradeid字段的字符集也改成utf8mb4，这样就没有字符集转换的问题了。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> trade_detail modify tradeid <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">default</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><ul><li>如果能够修改字段的字符集的话，是最好不过了。但如果数据量比较大， 或者业务上暂时不能做这个DDL的话，那就只能采用修改SQL语句的方法了。主动把 l.tradeid转成utf8，就避免了被驱动表上的字符编码转换。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l , trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span><span class="keyword">CONVERT</span>(l.tradeid <span class="keyword">USING</span> utf8) <span class="keyword">and</span> l.id<span class="operator">=</span><span class="number">2</span>; </span><br></pre></td></tr></table></figure><h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>B+树为了维护索引有序性，在插入新值时需要做必要的维护。</p><ul><li>假如此时插入的新值是中间值，需要逻辑上挪动后面的数据，空出位置。</li><li>可能会出现<strong>页分裂</strong>：如果当前插入所在的数据页满了，根据B+树的算法，需要申请一个数据页，挪动部分数据过去，影响性能；原本放到一个页的数据，现在分到两个页种，整体空间利用率降低约50%。</li><li><strong>页合并</strong>：当相邻两个页删除了数据，利用率很低后，会将数据页合并。</li></ul><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like &#x27;张%&#x27; and age=10 and ismale=1;</span><br></pre></td></tr></table></figure><p>执行流程：</p><p>首先这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3。</p><p>在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。</p><p>而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。也就是说，MySQL 5.6 以后，会过滤掉 age 不为 10 且 ismale 不为 1 的数据。</p><p>如果要重建索引 k，你的两个SQL语句可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table T drop index k;</span><br><span class="line">alter table T add index(k);</span><br></pre></td></tr></table></figure><p>如果要重建主键索引，也可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table T drop primary key;</span><br><span class="line">alter table T add primary key(id);</span><br></pre></td></tr></table></figure><blockquote><p>我的问题是，对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好的方法是什么？</p></blockquote><p>重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： alter table T engine&#x3D;InnoDB。</p><blockquote><p>为什么要重建索引呢？什么情况下需要重建索引？</p></blockquote><p>索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。</p><h3 id="优化器是怎么选择索引的？"><a href="#优化器是怎么选择索引的？" class="headerlink" title="优化器是怎么选择索引的？"></a>优化器是怎么选择索引的？</h3><p>我们先建一个简单的表，表里有a、b两个字段，并分别建上索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `a` int(11) DEFAULT NULL,</span><br><span class="line">  `b` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE=InnoDB；</span><br></pre></td></tr></table></figure><p>然后，我们往表t中插入10万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到(100000,100000,100000)。</p><p>我是用存储过程来插入数据的，这里我贴出来方便你复现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">100000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><p>接下来，我们分析一条SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;</span><br></pre></td></tr></table></figure><p>使用 explain 来分析这条语句，发现确实是走了 a 索引。</p><p>再做如下操作：</p><table><thead><tr><th>session A</th><th>session B</th></tr></thead><tbody><tr><td>start transaction with consistent snapshot;</td><td></td></tr><tr><td></td><td>delete from t;<br />call idata();</td></tr><tr><td></td><td>explain select * from t where a between 10000 and 20000;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p>session B把数据都删除后，又调用了 idata这个存储过程，插入了10万行数据。这时候 session B 的查询语句就不会选择索引 a 了。</p><p>使用慢查询日志查看具体的执行情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>; <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t force index(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;<span class="comment">/*Q2*/</span></span><br></pre></td></tr></table></figure><ul><li>第一句，是将慢查询日志的阈值设置为0，表示这个线程接下来的语句都会被记录入慢查询日志中；</li><li>第二句，Q1是session B原来的查询；</li><li>第三句，Q2是加了force index(a)来和session B原来的查询语句执行情况对比。</li></ul><p>发现我们没有使用 foece index 的时候，MySQL用错了索引，导致了更长的执行时间。</p><h4 id="优化器逻辑"><a href="#优化器逻辑" class="headerlink" title="优化器逻辑"></a>优化器逻辑</h4><p>优化器会结合扫描行数、是否使用临时表、是否排序等因素综合判断。扫描行数越少，访问磁盘数据次数越少，消耗CPU资源越少。</p><p>使用 explain 分析出 <code>rows</code> 这个字段值下的扫描行数是多少，这个数据是优化器预估的，而非真实的数据。</p><p>优化器不仅会考虑扫描行数，还会考虑回表次数及代价。这个例子中，优化器可能认为直接扫描主键索引更快，但是从执行时间上看，这个选择不是最优的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze <span class="keyword">table</span> t #可以用来重新统计索引信息。</span><br></pre></td></tr></table></figure><p>重新统计完后，就能成功走索引 a 了。</p><p>依然是基于这个表t，我们看看另外一个语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>)  <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>使用索引a 进行查询，就是扫描1000行；而使用索引b 进行查询，就需要扫描50001行。但使用 explain 分析，这次优化器选择了索引b，而 rows 字段显示为 50198。</p><p>原因是，优化器任务使用索引b 可以避免排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 优化方法</span><br><span class="line"># <span class="number">1.</span> force index </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t force index(a) <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>) <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b,a limit <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> <span class="keyword">order</span> <span class="keyword">by</span> b,a</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>) <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b,a limit <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span>limit <span class="number">100</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>)  <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b limit <span class="number">100</span>)alias limit <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">4.</span>在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</span><br></pre></td></tr></table></figure><h3 id="如何给字符串字段添加索引？"><a href="#如何给字符串字段添加索引？" class="headerlink" title="如何给字符串字段添加索引？"></a>如何给字符串字段添加索引？</h3><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>前缀索引可用在给可变字符串定义前缀长度，即节省空间，又不用额外增加太多查询成本。</p><blockquote><p>如何确定应该使用多长的前缀呢？</p></blockquote><p>你可以使用下面这个语句，算出这个列上有多少个不同的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure><p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引，可以用这个语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> </span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>)）<span class="keyword">as</span> L4,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>)）<span class="keyword">as</span> L5,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>)）<span class="keyword">as</span> L6,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>)）<span class="keyword">as</span> L7,</span><br><span class="line"><span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure><p>当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如5%。然后，在返回的L4~L7中，找出不小于 L * 95%的值，假设这里L6、L7都满足，你就可以选择前缀长度为6。</p><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><p>如果遇到前缀的区分度不够好时，应该怎么办呢？</p><p>比如我们国家的身份证号，一共18位，其中前6位是地址码，所以同个县的人的身份证号前6位一般是相同的。但是如果要维护一个市的身份证号，那这个长度就到前12位才能满足区分度要求了。</p><ul><li>倒序存储</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card <span class="operator">=</span> reverse(<span class="string">&#x27;input_id_card_string&#x27;</span>);</span><br></pre></td></tr></table></figure><p>身份证的后6位更容易区分，倒序存储后，再创建长度为6的前缀索引，解决。</p><ul><li>hash 字段。在表上创建一个整数字段，保存身份证的校验码，给这个字段创建索引。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> id_card_crc <span class="type">int</span> unsigned, <span class="keyword">add</span> index(id_card_crc);</span><br></pre></td></tr></table></figure><p>由于校验码可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你的查询语句where部分要判断id_card的值是否精确相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select field_list from t where id_card_crc=crc32(&#x27;input_id_card_string&#x27;) and id_card=&#x27;input_id_card_string&#x27;</span><br></pre></td></tr></table></figure><p>这样，索引的长度变成了4个字节，比原来小了很多。</p><p><strong>使用倒序存储和使用hash字段这两种方法的异同点：</strong></p><p>相同点：不支持范围查询。</p><p>不同点：</p><ol><li>倒序存储方式在主键索引上，不会消耗额外的存储空间。hash字段需要增加一个字段。但是倒序存储很大可能会使用大于4个字节的前缀长度，这个消耗和hash字段差不多抵消。</li><li>倒序方式每次写和读都需要额外调用一次 reverse 函数，而 hash 字段需要额外调用 crc32() 函数。reverse函数额外消耗的 CPU 资源小一点。</li><li>hash字段的查询性能更稳定。虽然 crc32 算出来的值有冲突概率，但是概率较小，每次查询的平均扫描行数接近 1。倒序存储其实还是使用前缀索引方式，还是会增加扫描行数。</li></ol><blockquote><p>如果你在维护一个学校的学生信息数据库，学生登录名的统一格式是”学号@gmail.com”, 而学号的规则是：十五位的数字，其中前三位是所在城市编号、第四到第六位是学校编号、第七位到第十位是入学年份、最后五位是顺序编号。</p><p>系统登录的时候都需要学生输入登录名和密码，验证正确后才能继续使用系统。就只考虑登录验证这个行为的话，你会怎么设计这个登录名的索引呢？</p></blockquote><p><strong>从优化索引空间角度看，</strong></p><p>由于这个学号的规则，无论是正向还是反向的前缀索引，重复度都比较高。因为维护的只是一个学校的，因此前面6位（其中，前三位是所在城市编号、第四到第六位是学校编号）其实是固定的，邮箱后缀都是@gamil.com，因此可以只存入学年份加顺序编号，它们的长度是9位。</p><p>而其实在此基础上，可以用数字类型来存这9位数字。比如201100001，这样只需要占4个字节。其实这个就是一种hash，只是它用了最简单的转换规则：字符串转数字的规则，而刚好我们设定的这个背景，可以保证这个转换后结果的唯一性。</p><p><strong>从业务量预估优化和收益看，</strong></p><p>一个学校每年预估2万新生，50年才100万记录，能节省多少空间，直接全字段索引。省去了开发转换及局限性风险，碰到超大量迫不得已再用后两种办法。</p><h1 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁是对整个数据库实例加锁。</p><p><strong>使用场景：</strong></p><p>做全库逻辑备份，把整库每个表都 select 出来存成文本。</p><p>加全局读锁命令是：Flush tables with read lock (FTWRL)</p><p>FTWRL 执行的时候要刷脏页的数据到磁盘，因为要保持数据的一致性 ，理解的执行FTWRL时候是 所有事务 都提交完毕的时候</p><p>在备份过程中整个库完全处于只读状态。</p><ul><li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li><li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟</li></ul><blockquote><p>为什么备份过程中要加锁呢？不加锁会怎样？</p></blockquote><p>不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。</p><p>当存储引擎<strong>支持可重复读的隔离级别</strong>且<strong>当前数据库中的所有表使用事务引擎</strong>，我们可以利用一致性视图进行备份，官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p><blockquote><p><strong>既然要全库只读，为什么不使用set global readonly&#x3D;true的方式呢</strong>？</p></blockquote><ol><li><p>在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，我不建议你使用。</p></li><li><p>全库只读 readonly &#x3D; true 还有个情况在 slave 上 如果用户有超级权限的话 readonly 是失效的</p></li><li><p>在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</p></li></ol><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>使用方法：<strong>lock tables … read&#x2F;write</strong>，使用 unlock tables 主动释放锁，或者在客户端断开时自动释放。</p><p>但 lock tables 除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p><h3 id="MDL"><a href="#MDL" class="headerlink" title="MDL"></a>MDL</h3><p>不需要显式使用，在访问一个表时会自动加上。</p><p>在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p><ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><p>MySQL 5.6 支持 online ddl,对表字段的修改不会阻塞读写（事实上是近似的online，仍有极少时间阻塞）。online ddl的过程：</p><ul><li>获取 MDL 写锁(短暂阻塞，这里获取写锁再降级是为了防止并发表结构修改)</li><li>降级成 MDL 读锁</li><li>真正做 DDL（可以理解为prepare状态的）</li><li>升级成 MDL 写锁（短暂阻塞，将DDL操作提交）</li><li>释放 MDL 锁</li></ul><p><em>注意，大多数的 ddl 都支持 online，但也有不支持的，如：添加全文索引，空间索引</em></p><blockquote><p>给一个小表加个字段，导致整个库挂了，这是出了什么问题？</p></blockquote><p>申请MDL锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。</p><blockquote><p>如何安全地给小表加字段？</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># MariaDB 和 AliSQL 支持</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name NOWAIT <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name WAIT N <span class="keyword">add</span> <span class="keyword">column</span> ... </span><br></pre></td></tr></table></figure><blockquote><p>备份一般都会在备库上执行，你在用–single-transaction方法做逻辑备份的过程中，如果主库上的一个小表做了一个DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？</p></blockquote><p>假设这个DDL是针对表t1的， 这里我把备份过程中几个关键的语句列出来：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Q1:<span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">Q2:<span class="keyword">START</span> TRANSACTION  <span class="keyword">WITH</span> CONSISTENT SNAPSHOT；</span><br><span class="line"><span class="comment">/* other tables */</span></span><br><span class="line">Q3:<span class="keyword">SAVEPOINT</span> sp;</span><br><span class="line"><span class="comment">/* 时刻 1 */</span></span><br><span class="line">Q4:<span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> `t1`;</span><br><span class="line"><span class="comment">/* 时刻 2 */</span></span><br><span class="line">Q5:<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `t1`;</span><br><span class="line"><span class="comment">/* 时刻 3 */</span></span><br><span class="line">Q6:<span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> sp;</span><br><span class="line"><span class="comment">/* 时刻 4 */</span></span><br><span class="line"><span class="comment">/* other tables */</span></span><br></pre></td></tr></table></figure><p>在备份开始的时候，为了确保RR（可重复读）隔离级别，再设置一次RR隔离级别(Q1);</p><p>启动事务，这里用 WITH CONSISTENT SNAPSHOT确保这个语句执行完就可以得到一个一致性视图（Q2)；</p><p>设置一个保存点，这个很重要（Q3）；</p><p>show create 是为了拿到表结构(Q4)，然后正式导数据 （Q5），回滚到SAVEPOINT sp，在这里的作用是释放 t1的MDL锁 （Q6。当然这部分属于“超纲”，上文正文里面都没提到。</p><p>DDL从主库传过来的时间按照效果不同，我打了四个时刻。题目设定为小表，我们假定到达后，如果开始执行，则很快能够执行完成。</p><p>参考答案如下：</p><ol><li>如果在Q4语句执行之前到达，现象：没有影响，备份拿到的是DDL后的表结构。</li><li>如果在“时刻 2”到达，则表结构被改过，Q5执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump终止；</li><li>如果在“时刻2”和“时刻3”之间到达，mysqldump占着t1的MDL读锁，binlog被阻塞，现象：主从延迟，直到Q6执行完成。</li><li>从“时刻4”开始，mysqldump释放了MDL读锁，现象：没有影响，备份拿到的是DDL前的表结构。</li></ol><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>MySQL的行锁是在引擎层由各个引擎自己实现的。</p><p>但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。</p><h3 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h3><p>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p><p>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p><p>当出现死锁以后，有两种策略：</p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</li><li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</li></ul><p>第一种方法的默认等待时间为50s，这个时间对于某些在线服务是无法接受的，但是又不能将其设置为很小的值，如果不是死锁而是正常的锁等待的话，会出现误伤。</p><p>正常情况下，我们使用第二组策略。</p><p>当所有事务都要更新同一行，每个被堵住的线程都要判断一次是否由于自己的加入导致了死锁。假设有1000个并发线程需要同时更新同一行，那么死锁检测的操作是100万这个量级的，这期间需要耗费大量的CPU资源。</p><blockquote><p>如何解决由这种热点行更新导致的性能问题？</p></blockquote><ol><li>确保这个业务不出现死锁，可以临时把死锁检测关掉。（有风险，不采用）</li><li>控制并发度。利用中间件控制流量，对于相同行的更新，在进入数据库前排队。</li><li>将热点行数据拆分成逻辑上的多行来减少锁冲突，但业务逻辑复杂。</li></ol><blockquote><p>如果你要删除一个表里面的前10000行数据，有以下三种方法可以做到：</p><ul><li>第一种，直接执行delete from T limit 10000;</li><li>第二种，在一个连接中循环执行20次 delete from T limit 500;</li><li>第三种，在20个连接中同时执行delete from T limit 500</li></ul><p>哪一种方法最好？说说理由。</p></blockquote><p>第二种方式是相对较好的。</p><p>第一种方式（即：直接执行delete from T limit 10000）里面，单个语句占用时间长，锁的时间也比较长；而且大事务还会导致主从延迟。</p><p>第三种方式（即：在20个连接中同时执行delete from T limit 500），会人为造成锁冲突。</p><h2 id="Next-key-Lock"><a href="#Next-key-Lock" class="headerlink" title="Next-key Lock"></a>Next-key Lock</h2><p>间隙锁，锁的就是两个值之间的空隙。<strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。</strong></p><p>间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。也就是说，我们的表t初始化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +suprenum]。</p><blockquote><p>备注：这篇文章中，如果没有特别说明，我们把间隙锁记为开区间，把next-key lock记为前开后闭区间。</p></blockquote><p>这个suprenum是InnoDB给每个索引加了一个不存在的最大值suprenum，为了保证next-key lock的前开后闭区间。</p><h3 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h3><p><em>此规则适用于5.x系列&lt;&#x3D;5.7.24，8.0系列 &lt;&#x3D;8.0.13</em></p><ol><li>原则1：加锁基本单位是 next-key lock。前开后闭区间。（但是具体执行时，会分成间隙锁和行锁两段来执行）</li><li>原则2：查找过程中访问到的对象才会加锁</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><p>来看一个例子理解以上规则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><h4 id="案例一：等值查询间隙锁"><a href="#案例一：等值查询间隙锁" class="headerlink" title="案例一：等值查询间隙锁"></a>案例一：等值查询间隙锁</h4><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;<br />update t set d &#x3D; d+1 where id &#x3D; 7;</td><td></td><td></td></tr><tr><td></td><td>insert into t values(8,8,8);<br />(blocked)</td><td></td></tr><tr><td></td><td></td><td>update t set d &#x3D; d+1 where id &#x3D; 10;<br />(Query OK)</td></tr></tbody></table><p>由于表t中没有id&#x3D;7的记录，所以用我们上面提到的加锁规则判断一下的话：</p><ol><li>加锁单位是next-key lock，session A加锁范围就是(5,10]；</li><li>这是一个等值查询(id&#x3D;7)，而id&#x3D;10不满足查询条件，next-key lock退化成间隙锁，因此最终加锁的范围是(5,10)。</li></ol><h4 id="案例二：非唯一索引等值锁"><a href="#案例二：非唯一索引等值锁" class="headerlink" title="案例二：非唯一索引等值锁"></a>案例二：非唯一索引等值锁</h4><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;<br />select id from t where c &#x3D; 5 lock in share mode;</td><td></td><td></td></tr><tr><td></td><td>update t set d &#x3D; d+1 where id &#x3D; 5;<br />(Query OK)</td><td></td></tr><tr><td></td><td></td><td>insert into t values(7,7,7);<br />(blocked)</td></tr></tbody></table><p>这里session A要给索引c上c&#x3D;5的这一行加上读锁。</p><ol><li>根据原则1，加锁单位是next-key lock，因此会给(0,5]加上next-key lock。</li><li>要注意c是普通索引，因此仅访问c&#x3D;5这一条记录是不能马上停下来的，需要向右遍历，查到c&#x3D;10才放弃。根据原则2，访问到的都要加锁，因此要给(5,10]加next-key lock。</li><li>但是同时这个符合优化2：等值判断，向右遍历，最后一个值不满足c&#x3D;5这个等值条件，因此退化成间隙锁(5,10)。</li><li>根据原则2 ，<strong>只有访问到的对象才会加锁</strong>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么session B的update语句可以执行完成。</li></ol><p>但session C要插入一个(7,7,7)的记录，就会被session A的间隙锁(5,10)锁住。</p><p>lock in share mode只锁覆盖索引， for update会给主键索引上满足条件的行加上行锁。锁是加在索引上的，如果你要用lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将session A的查询语句改成select d from t where c&#x3D;5 lock in share mode。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><p>在查找c&#x3D;5的时候，先锁住了(0,5]。但是因为c不是唯一索引，为了确认还有没有别的记录c&#x3D;5，就要向右遍历，找到c&#x3D;10才确认没有了，这个过程满足优化2，所以加了间隙锁(5,10)。</p><p>同样的，执行c&#x3D;10这个逻辑的时候，加锁的范围是(5,10] 和 (10,15)；执行c&#x3D;20这个逻辑的时候，加锁的范围是(15,20] 和 (20,25)。</p><p>通过这个分析，我们可以知道，这条语句在索引c上加的三个记录锁的顺序是：先加c&#x3D;5的记录锁，再加c&#x3D;10的记录锁，最后加c&#x3D;20的记录锁。</p><p>这些锁是“在执行过程中一个一个加的”，而不是一次性加上去的。</p><h4 id="案例三：主键索引范围锁"><a href="#案例三：主键索引范围锁" class="headerlink" title="案例三：主键索引范围锁"></a>案例三：主键索引范围锁</h4><p>对于我们这个表t，下面这两条查询语句，加锁范围相同吗？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">11</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>语句2：</p><ol><li>开始执行的时候，要找到第一个id&#x3D;10的行，因此本该是next-key lock(5,10]。 根据优化1， 主键id上的等值条件，退化成行锁，只加了id&#x3D;10这一行的行锁。</li><li>范围查找就往后继续找，找到id&#x3D;15这一行停下来，因此需要加next-key lock(10,15]</li></ol><p>分析一下这条查询语句的加锁范围：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">9</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">12</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>利用上面的加锁规则，我们知道这个语句的加锁范围是主键索引上的 (0,5]、(5,10]和(10, 15)。</p><ol><li>首先这个查询语句的语义是order by id desc，要拿到满足条件的所有行，优化器必须先找到“第一个id&lt;12的值”。</li><li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到id&#x3D;12的这个值，只是最终没找到，但找到了(10,15)这个间隙。</li><li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到id&#x3D;5这一行，所以会加一个next-key lock (0,5]。</li></ol><p>也就是说，在执行过程中，通过树搜索的方式定位记录的时候，用的是“等值查询”的方法。</p><h4 id="案例四：非唯一索引范围锁"><a href="#案例四：非唯一索引范围锁" class="headerlink" title="案例四：非唯一索引范围锁"></a>案例四：非唯一索引范围锁</h4><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;<br />select * from t where c&gt;&#x3D;10 and c&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>insert into t values(8,8,8);<br />(blocked)</td><td></td></tr><tr><td></td><td></td><td>update t set d &#x3D; d+1 where c &#x3D; 15;<br />(blocked)</td></tr></tbody></table><p>在第一次用c&#x3D;10定位记录的时候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终sesion A加的锁是，索引c上的(5,10] 和(10,15] 这两个next-key lock。</p><p>这里需要扫描到c&#x3D;15才停止扫描，是合理的，因为InnoDB要扫到c&#x3D;15，才知道不需要继续往后找了。</p><h4 id="案例五：唯一索引范围锁bug"><a href="#案例五：唯一索引范围锁bug" class="headerlink" title="案例五：唯一索引范围锁bug"></a>案例五：唯一索引范围锁bug</h4><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;<br />select * from t where id&gt;10 and id&lt;&#x3D;15 for update;</td><td></td><td></td></tr><tr><td></td><td>update t set d &#x3D; d+1 where id &#x3D; 20;<br />(blocked)</td><td></td></tr><tr><td></td><td></td><td>insert into t values(16,16,16);<br />(blocked)</td></tr></tbody></table><p>session A是一个范围查询，按照原则1的话，应该是索引id上只加(10,15]这个next-key lock，并且因为id是唯一键，所以循环判断到id&#x3D;15这一行就应该停止了。</p><p>但是实现上，InnoDB会往前扫描到第一个不满足条件的行为止，也就是id&#x3D;20。而且由于这是个范围扫描，因此索引id上的(15,20]这个next-key lock也会被锁上。</p><h4 id="案例六·：limit语句加锁"><a href="#案例六·：limit语句加锁" class="headerlink" title="案例六·：limit语句加锁"></a>案例六·：limit语句加锁</h4><p>limit 语句可以判断满足条件的语句有n条，然后直接返回，不会走到判断最后一个值不满足等值条件。</p><p><strong>在删除数据的时候尽量加limit</strong>。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围</p><blockquote><p>&lt;&#x3D;到底是间隙锁还是行锁？</p></blockquote><p>其实，这个问题，你要跟“执行过程”配合起来分析。在InnoDB要去找“第一个值”的时候，是按照等值去找的，用的是等值判断的规则；找到第一个值以后，要在索引内找“下一个值”，对应于我们规则中说的范围查找。</p><blockquote><p>所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义的。</p><p>那么，一个空表有间隙吗？这个间隙是由谁定义的？你怎么验证这个结论呢？</p></blockquote><p>一个空表就只有一个间隙。比如，在空表上执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>这个查询语句加锁的范围就是next-key lock (-∞, supremum]。</p><h3 id="MVCC➕Next-key-Lock-防止幻读"><a href="#MVCC➕Next-key-Lock-防止幻读" class="headerlink" title="MVCC➕Next-key-Lock 防止幻读"></a>MVCC➕Next-key-Lock 防止幻读</h3><p><code>InnoDB</code> 存储引擎在 RR 级别下通过 <code>MVCC</code> 和 <code>Next-key Lock</code> 来解决幻读问题：</p><p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p><p><strong>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读</strong></p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks">Next-key Lock</a> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p><h3 id="解决幻读的方法"><a href="#解决幻读的方法" class="headerlink" title="解决幻读的方法"></a>解决幻读的方法</h3><p>解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。解决幻读的方式主要有以下几种：</p><ol><li>将事务隔离级别调整为 <code>SERIALIZABLE</code> 。</li><li>在可重复读的事务级别下，给事务操作的这张表添加表锁。</li><li>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-key Lock（Record Lock+Gap Lock）</code>。</li></ol><h2 id="业务设计问题"><a href="#业务设计问题" class="headerlink" title="业务设计问题"></a>业务设计问题</h2><blockquote><p>业务上有这样的需求，A、B两个用户，如果互相关注，则成为好友。设计上是有两张表，一个是like表，一个是friend表，like表有user_id、liker_id两个字段，我设置为复合唯一索引即uk_user_id_liker_id。语句执行逻辑是这样的：</p></blockquote><blockquote><p>以A关注B为例：<br>第一步，先查询对方有没有关注自己（B有没有关注A）<br>select * from like where user_id &#x3D; B and liker_id &#x3D; A;</p></blockquote><blockquote><p>如果有，则成为好友<br>insert into friend;</p></blockquote><blockquote><p>没有，则只是单向关注关系<br>insert into like;</p></blockquote><blockquote><p>但是如果A、B同时关注对方，会出现不会成为好友的情况。因为上面第1步，双方都没关注对方。第1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效。请问这种情况，在MySQL锁层面有没有办法处理？</p></blockquote><p>先根据上边的场景建两张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">like</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `liker_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_user_id_liker_id` (`user_id`,`liker_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `friend` (</span><br><span class="line">  id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `friend_1_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `firned_2_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_friend` (`friend_1_id`,`firned_2_id`)</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><table><thead><tr><th>session 1(A关注B)</th><th>session 2(B关注A)</th></tr></thead><tbody><tr><td>begin;<br />select * from <code>like</code> where user_id &#x3D; B and liker_id &#x3D; A;（返回空）</td><td></td></tr><tr><td></td><td>begin;<br />select * from <code>like</code> where user_id &#x3D; A and liker_id &#x3D; B;（返回空）</td></tr><tr><td></td><td>insert into <code>like</code>(user_id,liker_id) values(B,A);</td></tr><tr><td>insert into <code>like</code>(user_id,liker_id) values(A,B);</td><td></td></tr><tr><td>commit;</td><td></td></tr><tr><td></td><td>commit;</td></tr></tbody></table><p>也就是说，在并发情况下，A和B在查询对方有没有关注自己的时候 select 语句查出来的结果为空，因此，session 1的逻辑就是“既然B没有关注A，那就只插入一个单向关注关系”。session 2也同样是这个逻辑。</p><p>解决方法如下：</p><p>首先，要给“like”表增加一个字段，比如叫作 relation_ship，并设为整型，取值1、2、3。</p><blockquote><p>值是1的时候，表示user_id 关注 liker_id;<br>值是2的时候，表示liker_id 关注 user_id;<br>值是3的时候，表示互相关注。</p></blockquote><p>然后，当 A关注B的时候，逻辑改成如下所示的样子：</p><p>应用代码里面，比较A和B的大小，如果A&lt;B，就执行下面的逻辑</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>; <span class="comment">/*启动事务*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `<span class="keyword">like</span>`(user_id, liker_id, relation_ship) <span class="keyword">values</span>(A, B, <span class="number">1</span>) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> relation_ship<span class="operator">=</span>relation_ship <span class="operator">|</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> relation_ship <span class="keyword">from</span> `<span class="keyword">like</span>` <span class="keyword">where</span> user_id<span class="operator">=</span>A <span class="keyword">and</span> liker_id<span class="operator">=</span>B;</span><br><span class="line"><span class="comment">/*代码中判断返回的 relation_ship，</span></span><br><span class="line"><span class="comment">  如果是1，事务结束，执行 commit</span></span><br><span class="line"><span class="comment">  如果是3，则执行下面这两个语句：</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">insert</span> ignore <span class="keyword">into</span> friend(friend_1_id, friend_2_id) <span class="keyword">values</span>(A,B);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>如果A&gt;B，则执行下面的逻辑</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>; <span class="comment">/*启动事务*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `<span class="keyword">like</span>`(user_id, liker_id, relation_ship) <span class="keyword">values</span>(B, A, <span class="number">2</span>) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> relation_ship<span class="operator">=</span>relation_ship <span class="operator">|</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> relation_ship <span class="keyword">from</span> `<span class="keyword">like</span>` <span class="keyword">where</span> user_id<span class="operator">=</span>B <span class="keyword">and</span> liker_id<span class="operator">=</span>A;</span><br><span class="line"><span class="comment">/*代码中判断返回的 relation_ship，</span></span><br><span class="line"><span class="comment">  如果是2，事务结束，执行 commit</span></span><br><span class="line"><span class="comment">  如果是3，则执行下面这两个语句：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">insert</span> ignore <span class="keyword">into</span> friend(friend_1_id, friend_2_id) <span class="keyword">values</span>(B,A);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>这个设计里，让“like”表里的数据保证user_id &lt; liker_id，这样不论是A关注B，还是B关注A，在操作“like”表的时候，如果反向的关系已经存在，就会出现行锁冲突。</p><p>然后，insert … on duplicate语句，确保了在事务内部，执行了这个SQL语句后，就强行占住了这个行锁，之后的select 判断relation_ship这个逻辑时就确保了是在行锁保护下的读操作。</p><p>操作符 “|” 是按位或，连同最后一句insert语句里的ignore，是为了保证重复调用时的幂等性。</p><p>这样，即使在双方“同时”执行关注操作，最终数据库里的结果，也是like表里面有一条关于A和B的记录，而且relation_ship的值是3， 并且friend表里面也有了A和B的这条记录。</p><blockquote><p>这里提到了insert … on duplicate语句，但是这个语句可能会造成 death lock 问题。</p></blockquote><p>如果有两个事务并发的执行同样的语句，那么就会产生death lock，如：</p><table><thead><tr><th>时间</th><th>session 1</th><th>session 2</th></tr></thead><tbody><tr><td>T1</td><td>begin;<br />insert on duplicate key</td><td></td></tr><tr><td>T2</td><td>key已存在，获取该记录的S锁</td><td>begin;<br />insert on duplicate key</td></tr><tr><td>T3</td><td>对读取的记录进行修改</td><td>key已存在，获取该记录的S锁</td></tr><tr><td>T4</td><td></td><td>对读取的记录进行修改</td></tr><tr><td>T5</td><td>把修改写入存储引擎，给该记录加上 X 锁，session2存在 S 锁，等待 session2 释放 S 锁</td><td></td></tr><tr><td>T6</td><td></td><td>把修改写进存储引擎，给该记录加上 X 锁，session1 存在 S 锁，等待 session1 释放 S 锁</td></tr><tr><td>T7</td><td></td><td>死锁</td></tr></tbody></table><p>那么，再来看看为什么上面的方法不会存在死锁问题呢？</p><p>原因是加入了 relation_ship这个字段，在并发情况下 insert 的时候，实际上 insert 的是不同行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL-的基本架构&quot;&gt;&lt;a href=&quot;#MySQL-的基本架构&quot; class=&quot;headerlink&quot; title=&quot;MySQL 的基本架构&quot;&gt;&lt;/a&gt;MySQL 的基本架构&lt;/h1&gt;&lt;p&gt;要想探究 MySQL 的执行原理，首先要了解 MySQL 的基础架构</summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://palette-k.github.io/tags/MySQL/"/>
    
    <category term="架构" scheme="https://palette-k.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>对设计模式的理解</title>
    <link href="https://palette-k.github.io/2023/11/20/%E5%AF%B9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://palette-k.github.io/2023/11/20/%E5%AF%B9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2023-11-20T04:55:41.000Z</published>
    <updated>2024-01-17T08:19:13.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><em>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。同时设计模式也是软件开发人员在软件开发过程中面临的一般问题的解决方案。</em></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式主要是会定义一系列的算法或策略，其中的算法和策略都是独立封装，互不影响的。通过策略模式，可以在运行时选择不同的策略进行匹配，而不需要修改客户端的代码。</p><p>我们可以参考 xxl-job 里的路由策略编写逻辑，其中的路由策略就是一个标准的策略模式例子。现给出 xxl-job 的路由策略结构图。</p><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/xxl-job%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>同时观察 xxl-job 的源码，XxlJobTrigger 中的 processTrigger() 方法中有一段关于路由策略的逻辑</p><ol><li>根据传入的 jobInfo 获取到路由策略的参数</li><li>如果是分片广播，则for循环调用外部传入的index获取执行器地址并调用执行器。</li><li>反之根据参数获取路由策略调用获取对应地址并调用即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processTrigger</span><span class="params">(XxlJobGroup group, XxlJobInfo jobInfo, <span class="type">int</span> finalFailRetryCount, TriggerTypeEnum triggerType, <span class="type">int</span> index, <span class="type">int</span> total)</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// param</span></span><br><span class="line">       <span class="type">ExecutorBlockStrategyEnum</span> <span class="variable">blockStrategy</span> <span class="operator">=</span> ExecutorBlockStrategyEnum.match(jobInfo.getExecutorBlockStrategy(), ExecutorBlockStrategyEnum.SERIAL_EXECUTION);  <span class="comment">// block strategy</span></span><br><span class="line">       <span class="type">ExecutorRouteStrategyEnum</span> <span class="variable">executorRouteStrategyEnum</span> <span class="operator">=</span> ExecutorRouteStrategyEnum.match(jobInfo.getExecutorRouteStrategy(), <span class="literal">null</span>);    <span class="comment">// route strategy</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shardingParam</span> <span class="operator">=</span> (ExecutorRouteStrategyEnum.SHARDING_BROADCAST==executorRouteStrategyEnum)?String.valueOf(index).concat(<span class="string">&quot;/&quot;</span>).concat(String.valueOf(total)):<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1、save log-id</span></span><br><span class="line">       <span class="type">XxlJobLog</span> <span class="variable">jobLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobLog</span>();</span><br><span class="line">       jobLog.setJobGroup(jobInfo.getJobGroup());</span><br><span class="line">       jobLog.setJobId(jobInfo.getId());</span><br><span class="line">       jobLog.setTriggerTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">       XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().save(jobLog);</span><br><span class="line">       logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job trigger start, jobId:&#123;&#125;&quot;</span>, jobLog.getId());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2、init trigger-param</span></span><br><span class="line">       <span class="type">TriggerParam</span> <span class="variable">triggerParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TriggerParam</span>();</span><br><span class="line">       triggerParam.setJobId(jobInfo.getId());</span><br><span class="line">       triggerParam.setExecutorHandler(jobInfo.getExecutorHandler());</span><br><span class="line">       triggerParam.setExecutorParams(jobInfo.getExecutorParam());</span><br><span class="line">       triggerParam.setExecutorBlockStrategy(jobInfo.getExecutorBlockStrategy());</span><br><span class="line">       triggerParam.setExecutorTimeout(jobInfo.getExecutorTimeout());</span><br><span class="line">       triggerParam.setLogId(jobLog.getId());</span><br><span class="line">       triggerParam.setLogDateTime(jobLog.getTriggerTime().getTime());</span><br><span class="line">       triggerParam.setGlueType(jobInfo.getGlueType());</span><br><span class="line">       triggerParam.setGlueSource(jobInfo.getGlueSource());</span><br><span class="line">       triggerParam.setGlueUpdatetime(jobInfo.getGlueUpdatetime().getTime());</span><br><span class="line">       triggerParam.setBroadcastIndex(index);</span><br><span class="line">       triggerParam.setBroadcastTotal(total);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3、init address</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       ReturnT&lt;String&gt; routeAddressResult = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (group.getRegistryList()!=<span class="literal">null</span> &amp;&amp; !group.getRegistryList().isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (ExecutorRouteStrategyEnum.SHARDING_BROADCAST == executorRouteStrategyEnum) &#123;</span><br><span class="line">               <span class="keyword">if</span> (index &lt; group.getRegistryList().size()) &#123;</span><br><span class="line">                   address = group.getRegistryList().get(index);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   address = group.getRegistryList().get(<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               routeAddressResult = executorRouteStrategyEnum.getRouter().route(triggerParam, group.getRegistryList());</span><br><span class="line">               <span class="keyword">if</span> (routeAddressResult.getCode() == ReturnT.SUCCESS_CODE) &#123;</span><br><span class="line">                   address = routeAddressResult.getContent();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           routeAddressResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, I18nUtil.getString(<span class="string">&quot;jobconf_trigger_address_empty&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4、trigger remote executor</span></span><br><span class="line">       ReturnT&lt;String&gt; triggerResult = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (address != <span class="literal">null</span>) &#123;</span><br><span class="line">           triggerResult = runExecutor(triggerParam, address);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           triggerResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="literal">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码中有一个地方是用来定位到该任务的路由策略的，其中 ExecutorRouteStrategyEnum 就是一个切入点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">routeAddressResult = executorRouteStrategyEnum.getRouter().route(triggerParam, group.getRegistryList());</span><br></pre></td></tr></table></figure><p>在 ExecutorRouteStrategyEnum 这个枚举类里枚举了 xxl-job 目前的策略名称，还有一个 match() 方法通过策略名称进行匹配，找到该策略所对应的 route() 方法执行相应的路由策略逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorRouteStrategyEnum <span class="title function_">match</span><span class="params">(String name, ExecutorRouteStrategyEnum defaultItem)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (ExecutorRouteStrategyEnum item: ExecutorRouteStrategyEnum.values()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (item.name().equals(name)) &#123;</span><br><span class="line">                   <span class="keyword">return</span> item;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> defaultItem;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="策略模式的优势"><a href="#策略模式的优势" class="headerlink" title="策略模式的优势"></a>策略模式的优势</h3><ul><li><p>策略模式中定义了一个公共的抽象类，每个策略都可以通过重写抽象类中的方法实现其算法逻辑。</p></li><li><p>可以以相同的方式调用所有策略，减少了各种策略类与使用策略之间的耦合。</p></li><li><p>策略都是相对独立的类，策略之间互不影响，可以随业务需求拓展，简化了单元测试。</p></li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式提供了一种将对象的实例化过程封装在工厂类中的方式。通过使用工厂模式，可以将对象的创建与使用代码分离，提供一种统一的接口来创建不同类型的对象。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>现有一个需求，要求对前端传进来的参数做校验，并组装这些参数供后续使用，每次传过来的参数根据规则不同有增减。这个需求可以用工厂模式实现，我们不关心不同的参数如何校验和组装，只想要接收前端传来的参数，最终以它想要的形式返回回去。</p><p>现给出使用工厂模式实现该需求的结构图：</p><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/rpa%E4%B8%9A%E5%8A%A1%E7%AD%96%E7%95%A5%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>基于工厂模式，创建一个策略接口，用于规范化策略的实现。</p><p>定义策略工厂类，用于创建并获取策略。</p><p>导入任务时，向业务策略工厂类传递业务策略类别，获取并执行相应的业务策略，最后组装并返回任务字段信息。</p><h3 id="工厂模式和策略模式的区别"><a href="#工厂模式和策略模式的区别" class="headerlink" title="工厂模式和策略模式的区别"></a>工厂模式和策略模式的区别</h3><p>工厂模式关注的是<em>对象的创建</em>：好比想要一台电脑、想要一台计算器，工厂给你生产出来。</p><p>策略模式关注的是<em>行为的封装</em>：好比要开发一台电脑或者计算器，你想实现加减法。是 a+b 还是 b+a，由你决定；是 a×10÷10+b 还是 (a+b)，也由你决定。对外暴露的就是加减功能，用户能知道有这俩功能就行。</p><h3 id="工厂模式的优势"><a href="#工厂模式的优势" class="headerlink" title="工厂模式的优势"></a>工厂模式的优势</h3><ul><li>对于复杂的参数的构造对象，可以很好地对外层屏蔽代码的复杂性。</li><li>可以自定义对象实例化规则，例如在对象存在某个字段时做特殊操作，在工厂中统一处理。</li><li>上层代码完全不了解实现层的情况，因此并不会影响到上层代码的调用，达到解耦目的。</li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是为其他对象提供一种代理以控制对这个对象的访问。</p><p>现给出代理模式的结构图：</p><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><h3 id="代理模式的简单实现"><a href="#代理模式的简单实现" class="headerlink" title="代理模式的简单实现"></a>代理模式的简单实现</h3><p>代理模式分为静态代理和动态代理。</p><ul><li>静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。</li><li>动态：在程序运行时，运用反射机制动态创建而成</li></ul><p><strong>静态代理:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DateService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">del</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DateServiceImplA</span> <span class="keyword">implements</span> <span class="title class_">DateService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功添加！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功删除！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DateServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">DateService</span> &#123;</span><br><span class="line">    DateService server;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DateServiceProxy</span><span class="params">(DateService server)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.server = server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        server.add();</span><br><span class="line">        System.out.println(<span class="string">&quot;程序执行add方法，记录日志.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">()</span> &#123;</span><br><span class="line">        server.del();</span><br><span class="line">        System.out.println(<span class="string">&quot;程序执行del方法，记录日志.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DateService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateServiceProxy</span>();</span><br><span class="line">        service.add();</span><br><span class="line">        service.del();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态代理：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DateService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">del</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DateServiceImplA</span> <span class="keyword">implements</span> <span class="title class_">DateService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功添加！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功删除！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DateService service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyInvocationHandler</span><span class="params">(DateService service)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getDateServiceProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(), service.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(service, args); <span class="comment">// 让service调用方法，方法返回值</span></span><br><span class="line">        System.out.println(proxy.getClass().getName() + <span class="string">&quot;代理类执行&quot;</span> + method.getName() + <span class="string">&quot;方法，返回&quot;</span> + result +  <span class="string">&quot;，记录日志！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DateService</span> <span class="variable">serviceA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateServiceImplA</span>();</span><br><span class="line">        <span class="type">DateService</span> <span class="variable">serviceProxy</span> <span class="operator">=</span> (DateService) <span class="keyword">new</span> <span class="title class_">ProxyInvocationHandler</span>(serviceA).getDateServiceProxy();</span><br><span class="line">        serviceProxy.add();</span><br><span class="line">        serviceProxy.del();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功添加！</span></span><br><span class="line"><span class="comment">$Proxy0代理类执行add方法，返回null，记录日志！</span></span><br><span class="line"><span class="comment">成功删除！</span></span><br><span class="line"><span class="comment">$Proxy0代理类执行del方法，返回null，记录日志！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我之前曾经写过一个手写缓存的项目，在自己创建一个缓存结构的时候，实现了Spring动态代理</p><p>生成缓存测试入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">expireTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       ICache&lt;String, String&gt; cache = CacheBs.&lt;String, String&gt;newInstance()</span><br><span class="line">               .size(<span class="number">3</span>)</span><br><span class="line">               .build();</span><br><span class="line">       cache.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       cache.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>自定义的缓存类CacheBs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ICache&lt;K,V&gt; <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">       Cache&lt;K, V&gt; cache = <span class="keyword">new</span> <span class="title class_">Cache</span>&lt;&gt;();</span><br><span class="line">       cache.map(map);</span><br><span class="line">       cache.sizeLimit(size);</span><br><span class="line">       cache.cacheEvict(evict);</span><br><span class="line">       cache.removeListeners(removeListeners);</span><br><span class="line">       cache.load(load);</span><br><span class="line">       cache.persist(persist);</span><br><span class="line">       cache.slowListeners(slowListeners);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//初始化</span></span><br><span class="line">       cache.init();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> CacheProxy.getProxy(cache);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>缓存代理类 CacheProxy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取对象代理</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> cache 对象代理</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 代理信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; ICache&lt;K,V&gt; <span class="title function_">getProxy</span><span class="params">(<span class="keyword">final</span> ICache&lt;K,V&gt; cache)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(ObjectUtil.isNull(cache))&#123;</span><br><span class="line">          <span class="keyword">return</span> (ICache&lt;K, V&gt;) <span class="keyword">new</span> <span class="title class_">NoneProxy</span>(cache).proxy();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> cache.getClass();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果targetClass本身是个接口或者targetClass是JDK Proxy生成的，则使用JDK动态代理</span></span><br><span class="line">      <span class="comment">//参考 spring AOP 判断</span></span><br><span class="line">      <span class="keyword">if</span>(clazz.isInterface() || Proxy.isProxyClass(clazz))&#123;</span><br><span class="line">          <span class="keyword">return</span> (ICache&lt;K, V&gt;) <span class="keyword">new</span> <span class="title class_">DynamicProxy</span>(cache).proxy();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (ICache&lt;K, V&gt;) <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(cache).proxy();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>JDK 代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, ICacheProxy &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICache target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxy</span><span class="params">(ICache target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">proxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象调用其方法的</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicProxy</span>(target);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(handler.getClass().getClassLoader(),target.getClass().getInterfaces(),handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这种方式虽然实现了异步执行，但是存在一个缺陷：</span></span><br><span class="line"><span class="comment">     * 强制用户返回值为 Future 的子类</span></span><br><span class="line"><span class="comment">     * 如何实现才能不影响原来的值？？</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ICacheProxyBsContext</span> <span class="variable">context</span> <span class="operator">=</span> CacheProxyBsContext.newInstance()</span><br><span class="line">                .method(method).params(args).target(target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CacheProxyBs.newInstance().context(context).execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cglib 代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>, ICacheProxy &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICache target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CglibProxy</span><span class="params">(ICache target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">proxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//目标对象类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//通过字节码技术创建目标对象类的子类实例作为代理</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">ICacheProxyBsContext</span> <span class="variable">context</span> <span class="operator">=</span> CacheProxyBsContext.newInstance()</span><br><span class="line">                .method(method).params(objects).target(target);</span><br><span class="line">        <span class="keyword">return</span> CacheProxyBs.newInstance().context(context).execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理模式应用"><a href="#代理模式应用" class="headerlink" title="代理模式应用"></a>代理模式应用</h3><p>远程代理，为一个对象在不同的地址空间提供局部代表，可以隐藏一个对象存在于不同地址空间的事实。</p><p>虚拟代理，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层，通过它来存放实例化需要很长时间的真实对象。</p><p>安全代理，用来控制真实对象访问时的权限，一般用于对象应该有不同的访问权限的时候。</p><p>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它(C++智能指针)；例如上面的房产中介代理就是一种智能指引代理，代理附加了一些额外的功能，例如带看房等。</p><h3 id="代理模式的优点"><a href="#代理模式的优点" class="headerlink" title="代理模式的优点"></a>代理模式的优点</h3><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式主要是用于解决一个全局使用的类频繁地创建与销毁的问题，它保证了一个类只有一个实例，并提供一个访问它的访问点。</p><p>单例模式使用了双端检锁的方式实现，其中 Spring 的 bean 单例作用域就是一个典型的单例模式。</p><p>Spring 通过 <code>ConcurrentHashMap</code> 实现单例注册表的特殊方式实现单例模式。</p><p>Spring 实现单例的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象添加到单例注册表</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="built_in">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="literal">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多线程下的双端检锁</strong></p><p>下面的代码在多线程环境下不是原子执行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance=<span class="keyword">new</span> <span class="title class_">DoubleCheckSingleton</span>();</span><br></pre></td></tr></table></figure><p>正常的底层执行顺序会转变成三步：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 给<span class="title class_">DoubleCheckSingleton</span>类的实例instance分配内存</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 调用实例instance的构造函数来初始化成员变量</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>) 将instance指向分配的内存地址</span><br></pre></td></tr></table></figure><p>假如现在有线程A和线程B，线程A 按照 123 的顺序执行，不会出任何问题。</p><p>但是如果线程A在重排序的情况下，上面的执行顺序会变成1,3,2。现在假设A线程按1,3,2三个步骤顺序执行，当执行到第二步的时候。B线程开始调用这个方法，那么在第一个null的检查的时候，就有可能看到这个实例不是null，然后直接返回这个实例开始使用，但其实是有问题的，因为对象还没有初始化，状态还处于不可用的状态，故而会导致异常发生。 </p><p>要解决这个问题，可以通过volatile关键词来避免指令重排序，那么在变量赋值之后，会有一个内存屏障。也就说只有执行完1,2,3步操作后，读取操作才能看到，读操作不会被重排序到写操作之前。这样以来就解决了对象状态不完整的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式优势"><a href="#单例模式优势" class="headerlink" title="单例模式优势"></a>单例模式优势</h3><ul><li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul><h3 id="定义私有化构造函数防止类被实例化"><a href="#定义私有化构造函数防止类被实例化" class="headerlink" title="定义私有化构造函数防止类被实例化"></a>定义私有化构造函数防止类被实例化</h3><p>当在一个类中定义了私有构造函数时，它将限制其他代码在类外部直接实例化该类的对象。这意味着除了类内部的代码，其他代码无法通过调用类的构造函数来创建类的实例。</p><p>通过定义私有构造函数，可以实现以下几个方面的控制：</p><ol><li>防止类被意外地实例化：私有构造函数可以确保类的实例化只能在类的内部进行。这样可以防止其他代码意外地创建该类的对象，确保该类的使用符合设计意图。</li><li>实现单例模式：单例模式是一种设计模式，它要求一个类只能有一个实例。通过在类中定义私有构造函数，并在类内部控制实例的创建和访问，可以确保只有一个类的实例存在。</li><li>提供静态工厂方法：私有构造函数可以与静态工厂方法一起使用，使类的实例化过程更加灵活和可控。静态工厂方法是类中的一个静态方法，用于创建和返回类的实例，可以在创建实例之前进行一些额外的逻辑判断或操作。</li></ol><p>举例：</p><p>假设我们有一个名为 “Logger” 的日志记录器类，我们希望在整个应用程序中只有一个日志记录器实例。我们可以使用单例模式来实现这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger instance;</span><br><span class="line">    <span class="keyword">private</span> List&lt;string&gt; logs;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Logger</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        logs = <span class="keyword">new</span> <span class="title class_">List</span>&lt;string&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Log</span><span class="params">(string message)</span></span><br><span class="line">    &#123;</span><br><span class="line">        logs.Add(message);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Log: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintLogs</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Logs:&quot;</span>);</span><br><span class="line">        foreach (string log in logs)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(log);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，Logger 类被设计为单例模式。它具有一个私有的构造函数，以及一个公共的静态属性 Instance，用于获取 Logger 类的实例。当第一次访问 Instance 属性时，将创建一个 Logger 实例，并在后续的访问中返回该实例。</p><p>现在，我们可以在应用程序的任何地方使用 Logger 类来记录日志，而无需多次实例化它。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logger.Instance.Log(<span class="string">&quot;Error occurred: NullReferenceException&quot;</span>);</span><br><span class="line">Logger.Instance.Log(<span class="string">&quot;Warning: Invalid input detected&quot;</span>);</span><br><span class="line">Logger.Instance.PrintLogs();</span><br></pre></td></tr></table></figure><p>通过 Logger.Instance，我们可以在不同的代码部分获取同一个 Logger 实例，并使用 Log 方法记录日志信息。最后，我们可以使用 PrintLogs 方法打印所有已记录的日志。</p><p>这样，通过单例模式，我们确保了整个应用程序中只有一个 Logger 实例存在，避免了多个日志记录器实例导致的资源浪费或日志信息的不一致性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;p&gt;&lt;em&gt;设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。同时设计模式也</summary>
      
    
    
    
    
    <category term="设计模式" scheme="https://palette-k.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
