<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Palette</title>
  <icon>https://www.gravatar.com/avatar/f6d0550c9229791f51dcfd63ef1e86d9</icon>
  <subtitle>个人博客</subtitle>
  <link href="https://palette-k.github.io/atom.xml" rel="self"/>
  
  <link href="https://palette-k.github.io/"/>
  <updated>2023-11-20T10:06:37.227Z</updated>
  <id>https://palette-k.github.io/</id>
  
  <author>
    <name>Palette</name>
    <email>1148432487@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对设计模式的理解</title>
    <link href="https://palette-k.github.io/2023/11/20/%E5%AF%B9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://palette-k.github.io/2023/11/20/%E5%AF%B9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2023-11-20T04:55:41.000Z</published>
    <updated>2023-11-20T10:06:37.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><em>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。同时设计模式也是软件开发人员在软件开发过程中面临的一般问题的解决方案。</em></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式主要是会定义一系列的算法或策略，其中的算法和策略都是独立封装，互不影响的。通过策略模式，可以在运行时选择不同的策略进行匹配，而不需要修改客户端的代码。</p><p>我们可以参考 xxl-job 里的路由策略编写逻辑，其中的路由策略就是一个标准的策略模式例子。现给出 xxl-job 的路由策略结构图。</p><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/xxl-job%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>同时观察 xxl-job 的源码，XxlJobTrigger 中的 processTrigger() 方法中有一段关于路由策略的逻辑</p><ol><li>根据传入的 jobInfo 获取到路由策略的参数</li><li>如果是分片广播，则for循环调用外部传入的index获取执行器地址并调用执行器。</li><li>反之根据参数获取路由策略调用获取对应地址并调用即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processTrigger</span><span class="params">(XxlJobGroup group, XxlJobInfo jobInfo, <span class="type">int</span> finalFailRetryCount, TriggerTypeEnum triggerType, <span class="type">int</span> index, <span class="type">int</span> total)</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// param</span></span><br><span class="line">       <span class="type">ExecutorBlockStrategyEnum</span> <span class="variable">blockStrategy</span> <span class="operator">=</span> ExecutorBlockStrategyEnum.match(jobInfo.getExecutorBlockStrategy(), ExecutorBlockStrategyEnum.SERIAL_EXECUTION);  <span class="comment">// block strategy</span></span><br><span class="line">       <span class="type">ExecutorRouteStrategyEnum</span> <span class="variable">executorRouteStrategyEnum</span> <span class="operator">=</span> ExecutorRouteStrategyEnum.match(jobInfo.getExecutorRouteStrategy(), <span class="literal">null</span>);    <span class="comment">// route strategy</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shardingParam</span> <span class="operator">=</span> (ExecutorRouteStrategyEnum.SHARDING_BROADCAST==executorRouteStrategyEnum)?String.valueOf(index).concat(<span class="string">&quot;/&quot;</span>).concat(String.valueOf(total)):<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1、save log-id</span></span><br><span class="line">       <span class="type">XxlJobLog</span> <span class="variable">jobLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobLog</span>();</span><br><span class="line">       jobLog.setJobGroup(jobInfo.getJobGroup());</span><br><span class="line">       jobLog.setJobId(jobInfo.getId());</span><br><span class="line">       jobLog.setTriggerTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">       XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().save(jobLog);</span><br><span class="line">       logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job trigger start, jobId:&#123;&#125;&quot;</span>, jobLog.getId());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2、init trigger-param</span></span><br><span class="line">       <span class="type">TriggerParam</span> <span class="variable">triggerParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TriggerParam</span>();</span><br><span class="line">       triggerParam.setJobId(jobInfo.getId());</span><br><span class="line">       triggerParam.setExecutorHandler(jobInfo.getExecutorHandler());</span><br><span class="line">       triggerParam.setExecutorParams(jobInfo.getExecutorParam());</span><br><span class="line">       triggerParam.setExecutorBlockStrategy(jobInfo.getExecutorBlockStrategy());</span><br><span class="line">       triggerParam.setExecutorTimeout(jobInfo.getExecutorTimeout());</span><br><span class="line">       triggerParam.setLogId(jobLog.getId());</span><br><span class="line">       triggerParam.setLogDateTime(jobLog.getTriggerTime().getTime());</span><br><span class="line">       triggerParam.setGlueType(jobInfo.getGlueType());</span><br><span class="line">       triggerParam.setGlueSource(jobInfo.getGlueSource());</span><br><span class="line">       triggerParam.setGlueUpdatetime(jobInfo.getGlueUpdatetime().getTime());</span><br><span class="line">       triggerParam.setBroadcastIndex(index);</span><br><span class="line">       triggerParam.setBroadcastTotal(total);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3、init address</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       ReturnT&lt;String&gt; routeAddressResult = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (group.getRegistryList()!=<span class="literal">null</span> &amp;&amp; !group.getRegistryList().isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (ExecutorRouteStrategyEnum.SHARDING_BROADCAST == executorRouteStrategyEnum) &#123;</span><br><span class="line">               <span class="keyword">if</span> (index &lt; group.getRegistryList().size()) &#123;</span><br><span class="line">                   address = group.getRegistryList().get(index);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   address = group.getRegistryList().get(<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               routeAddressResult = executorRouteStrategyEnum.getRouter().route(triggerParam, group.getRegistryList());</span><br><span class="line">               <span class="keyword">if</span> (routeAddressResult.getCode() == ReturnT.SUCCESS_CODE) &#123;</span><br><span class="line">                   address = routeAddressResult.getContent();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           routeAddressResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, I18nUtil.getString(<span class="string">&quot;jobconf_trigger_address_empty&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4、trigger remote executor</span></span><br><span class="line">       ReturnT&lt;String&gt; triggerResult = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (address != <span class="literal">null</span>) &#123;</span><br><span class="line">           triggerResult = runExecutor(triggerParam, address);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           triggerResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="literal">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码中有一个地方是用来定位到该任务的路由策略的，其中 ExecutorRouteStrategyEnum 就是一个切入点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">routeAddressResult = executorRouteStrategyEnum.getRouter().route(triggerParam, group.getRegistryList());</span><br></pre></td></tr></table></figure><p>在 ExecutorRouteStrategyEnum 这个枚举类里枚举了 xxl-job 目前的策略名称，还有一个 match() 方法通过策略名称进行匹配，找到该策略所对应的 route() 方法执行相应的路由策略逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorRouteStrategyEnum <span class="title function_">match</span><span class="params">(String name, ExecutorRouteStrategyEnum defaultItem)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (ExecutorRouteStrategyEnum item: ExecutorRouteStrategyEnum.values()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (item.name().equals(name)) &#123;</span><br><span class="line">                   <span class="keyword">return</span> item;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> defaultItem;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="策略模式的优势"><a href="#策略模式的优势" class="headerlink" title="策略模式的优势"></a>策略模式的优势</h3><ul><li><p>策略模式中定义了一个公共的抽象类，每个策略都可以通过重写抽象类中的方法实现其算法逻辑。</p></li><li><p>可以以相同的方式调用所有策略，减少了各种策略类与使用策略之间的耦合。</p></li><li><p>策略都是相对独立的类，策略之间互不影响，可以随业务需求拓展，简化了单元测试。</p></li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式提供了一种将对象的实例化过程封装在工厂类中的方式。通过使用工厂模式，可以将对象的创建与使用代码分离，提供一种统一的接口来创建不同类型的对象。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>现有一个需求，要求对前端传进来的参数做校验，并组装这些参数供后续使用，每次传过来的参数根据规则不同有增减。这个需求可以用工厂模式实现，我们不关心不同的参数如何校验和组装，只想要接收前端传来的参数，最终以它想要的形式返回回去。</p><p>现给出使用工厂模式实现该需求的结构图：</p><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/rpa%E4%B8%9A%E5%8A%A1%E7%AD%96%E7%95%A5%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>基于工厂模式，创建一个策略接口，用于规范化策略的实现。</p><p>定义策略工厂类，用于创建并获取策略。</p><p>导入任务时，向业务策略工厂类传递业务策略类别，获取并执行相应的业务策略，最后组装并返回任务字段信息。</p><h3 id="工厂模式和策略模式的区别"><a href="#工厂模式和策略模式的区别" class="headerlink" title="工厂模式和策略模式的区别"></a>工厂模式和策略模式的区别</h3><p>工厂模式关注的是<em>对象的创建</em>：好比想要一台电脑、想要一台计算器，工厂给你生产出来。</p><p>策略模式关注的是<em>行为的封装</em>：好比要开发一台电脑或者计算器，你想实现加减法。是 a+b 还是 b+a，由你决定；是 a×10÷10+b 还是 (a+b)，也由你决定。对外暴露的就是加减功能，用户能知道有这俩功能就行。</p><h3 id="工厂模式的优势"><a href="#工厂模式的优势" class="headerlink" title="工厂模式的优势"></a>工厂模式的优势</h3><ul><li><p>对于复杂的参数的构造对象，可以很好地对外层屏蔽代码的复杂性。</p></li><li><p>上层代码完全不了解实现层的情况，因此并不会影响到上层代码的调用，达到解耦目的。</p></li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是为其他对象提供一种代理以控制对这个对象的访问。</p><p>现给出代理模式的结构图：</p><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><h3 id="代理模式应用"><a href="#代理模式应用" class="headerlink" title="代理模式应用"></a>代理模式应用</h3><p>远程代理，为一个对象在不同的地址空间提供局部代表，可以隐藏一个对象存在于不同地址空间的事实。</p><p>虚拟代理，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层，通过它来存放实例化需要很长时间的真实对象。</p><p>安全代理，用来控制真实对象访问时的权限，一般用于对象应该有不同的访问权限的时候。</p><p>智能指引，指调用真实的对象时，代理处理另外一件事。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式主要是用于解决一个全局使用的类频繁地创建与销毁的问题，它保证了一个类只有一个实例，并提供一个访问它的访问点。</p><p>单例模式使用了双端检锁的方式实现，其中 Spring 的 bean 单例作用域就是一个典型的单例模式。</p><p>Spring 通过 <code>ConcurrentHashMap</code> 实现单例注册表的特殊方式实现单例模式。</p><p>Spring 实现单例的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象添加到单例注册表</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="built_in">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="literal">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多线程下的双端检锁</strong></p><p>下面的代码在多线程环境下不是原子执行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance=<span class="keyword">new</span> <span class="title class_">DoubleCheckSingleton</span>();</span><br></pre></td></tr></table></figure><p>正常的底层执行顺序会转变成三步：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 给<span class="title class_">DoubleCheckSingleton</span>类的实例instance分配内存</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 调用实例instance的构造函数来初始化成员变量</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>) 将instance指向分配的内存地址</span><br></pre></td></tr></table></figure><p>假如现在有线程A和线程B，线程A 按照 123 的顺序执行，不会出任何问题。</p><p>但是如果线程A在重排序的情况下，上面的执行顺序会变成1,3,2。现在假设A线程按1,3,2三个步骤顺序执行，当执行到第二步的时候。B线程开始调用这个方法，那么在第一个null的检查的时候，就有可能看到这个实例不是null，然后直接返回这个实例开始使用，但其实是有问题的，因为对象还没有初始化，状态还处于不可用的状态，故而会导致异常发生。 </p><p>要解决这个问题，可以通过volatile关键词来避免指令重排序，那么在变量赋值之后，会有一个内存屏障。也就说只有执行完1,2,3步操作后，读取操作才能看到，读操作不会被重排序到写操作之前。这样以来就解决了对象状态不完整的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式优势"><a href="#单例模式优势" class="headerlink" title="单例模式优势"></a>单例模式优势</h3><ul><li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;p&gt;&lt;em&gt;设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。同时设计模式也</summary>
      
    
    
    
    
    <category term="设计模式" scheme="https://palette-k.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java8新特性</title>
    <link href="https://palette-k.github.io/2023/11/14/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://palette-k.github.io/2023/11/14/java8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2023-11-14T04:21:37.000Z</published>
    <updated>2023-11-21T01:35:57.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h1><p>Java8 新增了一些新特性，详情请参考 <a href="https://www.oracle.com/java/technologies/javase/8-whats-new.html">ORACLE官网—JDK8新增功能</a></p><p>本篇文章仅整理出常用的几个特性，日常开发中可灵活使用。</p><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>以前，我们可以使用<code>Collections</code> 工具类的 <code>Comparator</code> 比较器对给定的 <code>List</code> 集合进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;peter&quot;</span>, <span class="string">&quot;anna&quot;</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&quot;xenia&quot;</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在有了 lambda 表达式以后，推荐使用以下方法比较大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br><span class="line">names.sort((a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口（Functional Interface）就是只包含一个抽象方法的声明。针对该接口类型的所有 Lambda 表达式都会与这个抽象方法匹配。</p><p><code>@FunctionalInterface</code>保证接口内只有一个抽象方法。一旦添加了第二个抽象方法，编译器会立刻抛出错误提示。不过，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lyf.lambda.demo3.a01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01UserFunctionalInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用函数式接口中的方法</span></span><br><span class="line">        method((arr) -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">                sum += n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义的函数式接口作为方法参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Operator op)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> op.getSum(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;sum = &quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>[] arr)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用类的构造器及方法"><a href="#引用类的构造器及方法" class="headerlink" title="引用类的构造器及方法"></a>引用类的构造器及方法</h2><p>Java 8 允许使用 <code>::</code> 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaClassSuper</span> &#123;</span><br><span class="line">    LambdaInterface <span class="title function_">sf</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaClass</span> <span class="keyword">extends</span> <span class="title class_">LambdaClassSuper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LambdaInterface <span class="title function_">staticF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LambdaInterface <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.调用静态函数，返回类型必须是functional-interface</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">t</span> <span class="operator">=</span> LambdaClass::staticF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.实例方法调用</span></span><br><span class="line">        <span class="type">LambdaClass</span> <span class="variable">lambdaClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaClass</span>();</span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">lambdaInterface</span> <span class="operator">=</span> lambdaClass::f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.超类上的方法调用</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">superf</span> <span class="operator">=</span> <span class="built_in">super</span>::sf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 构造方法调用</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">tt</span> <span class="operator">=</span> LambdaClassSuper::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - i);</span><br><span class="line"><span class="comment">//i =3;</span></span><br></pre></td></tr></table></figure><p>lambda 表达式可以引用外边变量，但是该变量默认拥有 final 属性，不能被修改，如果修改，编译时就报错。</p><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p><code>Stream</code>依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。</p><p>它的源数据可以是 <code>Collection</code>、<code>Array</code> 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="comment">//返回符合条件的stream</span></span><br><span class="line">    Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; <span class="string">&quot;abc&quot;</span>.equals(s));</span><br><span class="line">    <span class="comment">//计算流符合条件的流的数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringStream.count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//forEach遍历-&gt;打印元素</span></span><br><span class="line">    strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//limit 获取到1个元素的stream</span></span><br><span class="line">    Stream&lt;String&gt; limit = strings.stream().limit(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//toArray 比如我们想看这个limitStream里面是什么，比如转换成String[],比如循环</span></span><br><span class="line">    String[] array = limit.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map 对每个元素进行操作返回新流</span></span><br><span class="line">    Stream&lt;String&gt; map = strings.stream().map(s -&gt; s + <span class="string">&quot;22&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sorted 排序并打印</span></span><br><span class="line">    strings.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Collectors collect 把abc放入容器中</span></span><br><span class="line">    List&lt;String&gt; collect = strings.stream().filter(string -&gt; <span class="string">&quot;abc&quot;</span>.equals(string)).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//把list转为string，各元素用，号隔开</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mergedString</span> <span class="operator">=</span> strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组的统计，比如用</span></span><br><span class="line">    List&lt;Integer&gt; number = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">IntSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> number.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span>+statistics.getMax());</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span>+statistics.getMin());</span><br><span class="line">    System.out.println(<span class="string">&quot;平均数 : &quot;</span>+statistics.getAverage());</span><br><span class="line">    System.out.println(<span class="string">&quot;所有数之和 : &quot;</span>+statistics.getSum());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//concat 合并流</span></span><br><span class="line">    List&lt;String&gt; strings2 = Arrays.asList(<span class="string">&quot;xyz&quot;</span>, <span class="string">&quot;jqx&quot;</span>);</span><br><span class="line">    Stream.concat(strings2.stream(),strings.stream()).count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意 一个Stream只能操作一次，不能断开，否则会报错。</span></span><br><span class="line">    <span class="type">Stream</span> <span class="variable">stream</span> <span class="operator">=</span> strings.stream();</span><br><span class="line">    <span class="comment">//第一次使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//第二次使用</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">    <span class="comment">//报错 java.lang.IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是可以这样, 连续使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date-Time API"></a>Date-Time API</h2><p><strong>日期格式化</strong></p><p>Java8 之前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oldFormat</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">date</span>  <span class="operator">=</span> sdf.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format HH:mm:ss</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> sdft.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdfdt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">datetime</span> <span class="operator">=</span> sdfdt.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, datetime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java8 之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newFormat</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format HH:mm:ss</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now().withNano(<span class="number">0</span>);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">dateTimeStr</span> <span class="operator">=</span> dateTime.format(dateTimeFormatter);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, dateTimeStr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取指定日期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDayNew</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="comment">//获取当前月第一天：</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">firstDayOfThisMonth</span> <span class="operator">=</span> today.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">    <span class="comment">// 取本月最后一天</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastDayOfThisMonth</span> <span class="operator">=</span> today.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">    <span class="comment">//取下一天：</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">nextDay</span> <span class="operator">=</span> lastDayOfThisMonth.plusDays(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//当年最后一天</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastday</span> <span class="operator">=</span> today.with(TemporalAdjusters.lastDayOfYear());</span><br><span class="line">    <span class="comment">//2021年最后一个周日，如果用Calendar是不得烦死。</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastMondayOf2021</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-12-31&quot;</span>).with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java8-新特性&quot;&gt;&lt;a href=&quot;#Java8-新特性&quot; class=&quot;headerlink&quot; title=&quot;Java8 新特性&quot;&gt;&lt;/a&gt;Java8 新特性&lt;/h1&gt;&lt;p&gt;Java8 新增了一些新特性，详情请参考 &lt;a href=&quot;https://www.</summary>
      
    
    
    
    
    <category term="java" scheme="https://palette-k.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈RocketMQ负载均衡策略</title>
    <link href="https://palette-k.github.io/2023/11/14/%E6%B5%85%E8%B0%88RocketMQ%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/"/>
    <id>https://palette-k.github.io/2023/11/14/%E6%B5%85%E8%B0%88RocketMQ%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/</id>
    <published>2023-11-14T01:01:52.000Z</published>
    <updated>2023-11-14T03:57:33.255Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列存在生产者和消费者，其中RocketMQ的生产者和消费者都有分组。</p><h3 id="生产者负载均衡"><a href="#生产者负载均衡" class="headerlink" title="生产者负载均衡"></a>生产者负载均衡</h3><p>生产者发送消息到RocketMQ时，RocketMQ将根据生产者负载均衡将消息均匀存储在多个队列中。</p><h4 id="RoundRobin模式"><a href="#RoundRobin模式" class="headerlink" title="RoundRobin模式"></a>RoundRobin模式</h4><p>对于非顺序消息（普通消息、定时&#x2F;延时消息、事务消息），<strong>默认且只能使用</strong>RoundRobin模式。</p><p>生产者发送消息时，以消息为粒度，按照轮询方式将消息发送到指定主题中的所有可写目标队列中，保证消息尽可能均衡分布到所有队列。</p><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>当生产者某条消息发送失败时，RocketMQ会决定在接下来一段事件内，跳过本地失败队列所在节点，实现自适应的故障转移。</p><h4 id="MessageGroupHash模式"><a href="#MessageGroupHash模式" class="headerlink" title="MessageGroupHash模式"></a>MessageGroupHash模式</h4><p>对于顺序消息场景，<strong>默认且只能使用</strong>MessageGroupHash模式的负载均衡策略。</p><p>生产者发送消息时，以消息组为粒度，按照内置的Hash算法，将相同消息组的消息分配到同一队列中，保证同消息组的消息按照发送的先后顺序存储。</p><h5 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h5><ul><li><strong>避免出现热点队列：</strong>如果业务侧将消息集中在少量或唯一的的消息组，则服务端存储消息时，也会集中存储在少量或唯一的队列中。不利于水平扩展。建议在设计消息组时，尽量将消息分散开。例如采用较离散的订单ID、用户名作为消息组的关键字，既能保证消息被分散到多个消息组中，又能保证统一终端用户的消息按顺序处理。</li><li><strong>避免绑定单队列发送：</strong>单队列容易产生性能瓶颈和容灾风险。</li></ul><h3 id="消费者负载均衡"><a href="#消费者负载均衡" class="headerlink" title="消费者负载均衡"></a>消费者负载均衡</h3><p>消费者消费RocketMQ上的消息时，可通过消费者负载均衡策略，将主题内的消息分配给指定消费者分组中多个消费者共同分担。</p><h4 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h4><p>每个消费者分组只初始化唯一一个消费者，每个消费者可消费到消费者分组内所有的消息，各消费者分组都订阅相同的消息，以此实现单客户端级别的广播一对多推送效果。</p><p>通俗点讲，就是消费者分组内唯一的消费者消费了分组内所有的消息。这个场景下其实不涉及消费者的负载均衡，因为只有一个消费者在消费。</p><p>该方式一般可用于网关推送、配置推送等场景。</p><h4 id="共享消费"><a href="#共享消费" class="headerlink" title="共享消费"></a>共享消费</h4><p>每个消费者分组下初始化了多个消费者，这些消费者共同分担消费者分组内的所有消息，实现消费者分组内流量的水平拆分和均衡负载。</p><p>通俗点讲，就是消费者分组内所有消费者共同消费了分组内所有的消息。</p><p>该方式一般可用于微服务解耦场景。</p><h4 id="消息粒度负载均衡"><a href="#消息粒度负载均衡" class="headerlink" title="消息粒度负载均衡"></a>消息粒度负载均衡</h4><p>对于PushConsumer和SimpleConsumer类型的消费者，<strong>默认且仅使用</strong>消息粒度负载均衡策略。</p><p>同一个队列中的消息，可被平均分配给多个消费者共同消费。</p><p><strong>那消息粒度负载均衡性是怎么保证消息不被重复消费的呢？</strong></p><p>消息粒度的负载均衡机制，是基于内部的单条消息确认语义实现的。<strong>消费者获取某条消息后，服务端会将该消息加锁</strong>，保证这条消息对其他消费者不可见，直到该消息消费成功或消费超时。因此，即使多个消费者同时消费同一队列的消息，服务端也可保证消息不会被多个消费者重复消费。</p><h4 id="队列粒度负载均衡"><a href="#队列粒度负载均衡" class="headerlink" title="队列粒度负载均衡"></a>队列粒度负载均衡</h4><p>对于历史版本（服务端4.x&#x2F;3.x版本）的消费者，包括PullConsumer、DefaultPushConsumer、DefaultPullConsumer、LitePullConsumer等，默认且仅能使用队列粒度负载均衡策略。</p><p>在该策略下，同一消费者分组内的多个消费者讲按照队列粒度消费消息，即每个队列仅被一个消费者消费。</p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>队列粒度负载均衡策略适用于流式计算、数据聚合等需要明确对消息进行聚合、批处理的场景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;消息队列存在生产者和消费者，其中RocketMQ的生产者和消费者都有分组。&lt;/p&gt;
&lt;h3 id=&quot;生产者负载均衡&quot;&gt;&lt;a href=&quot;#生产者负载均衡&quot; class=&quot;headerlink&quot; title=&quot;生产者负载均衡&quot;&gt;&lt;/a&gt;生产者负载均衡&lt;/h3&gt;&lt;p&gt;生产者发送</summary>
      
    
    
    
    
    <category term="RocketMQ" scheme="https://palette-k.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ重试机制</title>
    <link href="https://palette-k.github.io/2023/11/14/RocketMQ%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/"/>
    <id>https://palette-k.github.io/2023/11/14/RocketMQ%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/</id>
    <published>2023-11-14T01:01:22.000Z</published>
    <updated>2023-11-14T03:57:44.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><p>触发消息发送重试机制的条件如下：</p><ul><li>客户端消息发送请求调用失败或请求超时</li><li>网络异常造成连接失败或请求超时。</li><li>服务端节点处于重启或下线等状态造成连接失败。</li><li>服务端运行慢造成请求超时。</li><li>服务端返回失败错误码<ul><li>系统逻辑错误：因运行逻辑不正确造成的错误。</li><li>系统流控错误：因容量超限造成的流控错误。</li></ul></li></ul><p>消息重试时间间隔如下：</p><ul><li><p>无序消息：重试时间为阶梯时间<br><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/RocketMQ/%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94.png"></p></li><li><p>顺序消息：重试时间为固定时间，默认为3s</p></li></ul><p>RocketMQ的重试机制涉及发送端重试和消费端重试，消费端重试关联死信队列</p><h3 id="发送端重试"><a href="#发送端重试" class="headerlink" title="发送端重试"></a>发送端重试</h3><p>RocketMQ 在客户端中内置了请求重试逻辑，支持在初始化时配置消息发送<strong>最大重试次数（默认为 2 次</strong>），失败时会按照设置的重试次数重新发送。直到消息发送成功，或者达到最大重试次数时结束，并在最后一次失败后返回调用错误的响应。对于<strong>同步发送和异步发送，均支持消息发送重试</strong>。</p><ul><li>同步发送：调用线程会一直阻塞，直到某次重试成功或最终重试失败（返回错误码或抛出异常）。</li><li>异步发送：调用线程不会阻塞，但调用结果会通过回调的形式，以异常事件或者成功事件返回。</li></ul><p>我们也手动设置重试次数。代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultMQProducer</span>  &#123;</span><br><span class="line"><span class="comment">//设置消息发送失败时的最大重试次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRetryTimesWhenSendFailed</span><span class="params">(<span class="type">int</span> retryTimesWhenSendFailed)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.retryTimesWhenSendFailed = retryTimesWhenSendFailed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>();</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;0.0.0.0:9876;0.0.0.1:9876&quot;</span>);</span><br><span class="line">producer.setRetryTimesWhenSendFailed(<span class="number">3</span>);</span><br><span class="line">producer.start();</span><br></pre></td></tr></table></figure><p>或者在配置文件 application.yaml 中配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rocketmq:  </span><br><span class="line">name-server: <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">9876</span>  </span><br><span class="line">producer:  </span><br><span class="line">group: producer-group  </span><br><span class="line">enable-msg-trace: <span class="literal">false</span>  </span><br><span class="line">retry-times-when-send-async-failed: <span class="number">3</span>  </span><br><span class="line">retry-times-when-send-failed: <span class="number">3</span>  </span><br><span class="line">send-message-timeout: <span class="number">60000</span>  </span><br><span class="line">consumer:  </span><br><span class="line">group: consumer-group</span><br></pre></td></tr></table></figure><h3 id="消费端重试"><a href="#消费端重试" class="headerlink" title="消费端重试"></a>消费端重试</h3><ul><li>只有在消息模式为<strong>MessageModel.CLUSTERING</strong>集群模式时，Broker才会自动进行重试，广播消息是不会重试的。</li></ul><p>分析了ConsumeMessageConcurrentlyService的源码，Consumer消费完成后会返回一个状态码，ConsumeConcurrentlyStatus是一个记录了并发消费状态的枚举类，共有两种状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ConsumeConcurrentlyStatus</span> &#123;</span><br><span class="line">   <span class="comment">//消费成功</span></span><br><span class="line">   ConsumeConcurrentlyStatus,</span><br><span class="line"></span><br><span class="line">   <span class="comment">//消费失败，一段时间后重试</span></span><br><span class="line">   RECONSUME_LATER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们拿并发消费时举例，MessageListenerConcurrently 中当捕获到异常时会设置下一级别的消费时间间隔并返回“再次消费”的状态码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;  </span><br><span class="line"><span class="keyword">for</span> (MessageExt messageExt : msgs) &#123;  </span><br><span class="line">log.debug(<span class="string">&quot;received msg: &#123;&#125;&quot;</span>, messageExt);  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line"><span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();  </span><br><span class="line">handleMessage(messageExt);  </span><br><span class="line"><span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> System.currentTimeMillis() - now;  </span><br><span class="line">log.debug(<span class="string">&quot;consume &#123;&#125; cost: &#123;&#125; ms&quot;</span>, messageExt.getMsgId(), costTime);  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;  <span class="comment">// 捕获到异常</span></span><br><span class="line">log.warn(<span class="string">&quot;consume message failed. messageExt:&#123;&#125;, error:&#123;&#125;&quot;</span>, messageExt, e);  </span><br><span class="line"><span class="comment">//设置下一个超时时间间隔</span></span><br><span class="line">context.setDelayLevelWhenNextConsume(delayLevelWhenNextConsume);  </span><br><span class="line"><span class="comment">// 返回状态码</span></span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常重试"><a href="#异常重试" class="headerlink" title="异常重试"></a>异常重试</h4><p>RocketMQ可在broker.conf文件中配置Consumer端的重试次数和重试时间间隔，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br></pre></td></tr></table></figure><p>我们可以在代码中指定最大重试次数，利用RocketMQConstant.MAX_RETRY_TIMES判断，如果超过最大重试次数，则提前返回“消费成功”，让 MQ 停止重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>:RocketMQ消息消费者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageConsumer</span> <span class="keyword">implements</span> <span class="title class_">MessageListenerConcurrently</span> &#123;</span><br><span class="line">   <span class="meta">@Value(&quot;$&#123;spring.rocketmq.namesrvAddr&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;DefaultConsumer&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@PostConstruct</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           consumer.setNamesrvAddr(namesrvAddr);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//从消息队列头部开始消费</span></span><br><span class="line">           consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//设置集群消费模式</span></span><br><span class="line">           consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//订阅主题</span></span><br><span class="line">           consumer.subscribe(<span class="string">&quot;DefaultCluster&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//注册消息监听器</span></span><br><span class="line">           consumer.registerMessageListener(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//启动消费端</span></span><br><span class="line">           consumer.start();</span><br><span class="line"></span><br><span class="line">           log.info(<span class="string">&quot;Message Consumer Start...&quot;</span>);</span><br><span class="line">           System.err.println(<span class="string">&quot;Message Consumer Start...&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">           log.error(<span class="string">&quot;Message Consumer Start Error!!&quot;</span>,e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (CollectionUtils.isEmpty(msgs)) &#123;</span><br><span class="line">           <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">MessageExt</span> <span class="variable">message</span> <span class="operator">=</span> msgs.get(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//逐条消费</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">messageBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), RemotingHelper.DEFAULT_CHARSET);</span><br><span class="line">           System.err.println(<span class="string">&quot;Message Consumer: Handle New Message: messageId: &quot;</span> + message.getMsgId() + <span class="string">&quot;,topic: &quot;</span> +</span><br><span class="line">                   message.getTopic() + <span class="string">&quot;,tags: &quot;</span> + message.getTags() + <span class="string">&quot;,messageBody: &quot;</span> + messageBody);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//模拟业务异常</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           log.error(<span class="string">&quot;Consume Message Error!!&quot;</span>, e);</span><br><span class="line">           <span class="comment">//抛出异常时，返回ConsumeConcurrentlyStatus.RECONSUME_LATER，尝试重试。当重试指定次数后返回ConsumeConcurrentlyStatus.CONSUME_SUCCESS</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">reconsumeTimes</span> <span class="operator">=</span> message.getReconsumeTimes();</span><br><span class="line">           System.err.println(<span class="string">&quot;Now Retry Times: &quot;</span> + reconsumeTimes);</span><br><span class="line">           <span class="keyword">if</span> (reconsumeTimes &gt;= RocketMQConstant.MAX_RETRY_TIMES) &#123;</span><br><span class="line">               <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用监听器监听时，可以在 service 层里抛出异常，RocketMQ 检测到异常后会自动返回 ConsumeConcurrentlyStatus.RECONSUME_LATER 的状态码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = TopicConstant.RPA_CALLBACK_RESULT_TASK,  </span></span><br><span class="line"><span class="meta">consumerGroup = &quot;$&#123;rocketmq.consumer.group&#125;&quot;+ &quot;-test-mq&quot;, consumeThreadMax = 2)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line">TestService testService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SneakyThrows</span>  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String msg)</span> &#123;  </span><br><span class="line">     log.info(<span class="string">&quot;收到信息：msg:&#123;&#125;&quot;</span>, msg);  </span><br><span class="line">     testService.receiveMsgTest(msg);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="超时重试"><a href="#超时重试" class="headerlink" title="超时重试"></a>超时重试</h4><p>当 Consumer 处理时间过长，在一定时间内没有返回 Broker 消费状态，Broker 也会自动重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageConsumer</span> <span class="keyword">implements</span> <span class="title class_">MessageListenerConcurrently</span> &#123;</span><br><span class="line">   <span class="meta">@Value(&quot;$&#123;spring.rocketmq.namesrvAddr&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;DefaultConsumer&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@PostConstruct</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           consumer.setNamesrvAddr(namesrvAddr);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//从消息队列头部开始消费</span></span><br><span class="line">           consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//设置集群消费模式</span></span><br><span class="line">           consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//设置消费超时时间(分钟)</span></span><br><span class="line">           consumer.setConsumeTimeout(RocketMQConstant.CONSUMER_TIMEOUT_MINUTES);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//订阅主题</span></span><br><span class="line">           consumer.subscribe(<span class="string">&quot;DefaultCluster&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//注册消息监听器</span></span><br><span class="line">           consumer.registerMessageListener(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//启动消费端</span></span><br><span class="line">           consumer.start();</span><br><span class="line"></span><br><span class="line">           log.info(<span class="string">&quot;Message Consumer Start...&quot;</span>);</span><br><span class="line">           System.err.println(<span class="string">&quot;Message Consumer Start...&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">           log.error(<span class="string">&quot;Message Consumer Start Error!!&quot;</span>,e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (CollectionUtils.isEmpty(msgs)) &#123;</span><br><span class="line">           <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">MessageExt</span> <span class="variable">message</span> <span class="operator">=</span> msgs.get(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//逐条消费</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">messageBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), RemotingHelper.DEFAULT_CHARSET);</span><br><span class="line">           System.err.println(<span class="string">&quot;Message Consumer: Handle New Message: messageId: &quot;</span> + message.getMsgId() + <span class="string">&quot;,topic: &quot;</span> +</span><br><span class="line">                   message.getTopic() + <span class="string">&quot;,tags: &quot;</span> + message.getTags() + <span class="string">&quot;,messageBody: &quot;</span> + messageBody);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//模拟耗时操作2分钟，大于设置的消费超时时间</span></span><br><span class="line">           Thread.sleep(<span class="number">1000L</span> * <span class="number">60</span> * <span class="number">2</span>);</span><br><span class="line">           <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           log.error(<span class="string">&quot;Consume Message Error!!&quot;</span>, e);</span><br><span class="line">           <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;重试机制&quot;&gt;&lt;a href=&quot;#重试机制&quot; class=&quot;headerlink&quot; title=&quot;重试机制&quot;&gt;&lt;/a&gt;重试机制&lt;/h2&gt;&lt;p&gt;触发消息发送重试机制的条件如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端消息发送请求调用失败或请求超时&lt;/li&gt;
&lt;li&gt;网络异常</summary>
      
    
    
    
    
    <category term="RocketMQ" scheme="https://palette-k.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>初识RocketMQ</title>
    <link href="https://palette-k.github.io/2023/11/13/%E5%88%9D%E8%AF%86RocketMQ/"/>
    <id>https://palette-k.github.io/2023/11/13/%E5%88%9D%E8%AF%86RocketMQ/</id>
    <published>2023-11-13T03:52:27.000Z</published>
    <updated>2023-11-14T03:57:04.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h1><ol><li>消息由生产者初始化并发送到云消息队列 RocketMQ 版服务端。</li><li>消息按照到达云消息队列 RocketMQ 版服务端的顺序存储到主题的指定队列中。</li><li>消费者按照指定的订阅关系从云消息队列 RocketMQ 版服务端中获取消息并消费<br><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/RocketMQ/RocketMQ%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B.png"></li></ol><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>主题是用于标识同一类业务的消息。主题是一个逻辑概念，并不是真实存在的消息容器。</p><p>在拆分主题时，需要考虑拆分粒度：</p><ul><li>消息类型：顺序消息和普通消息要使用不同的主题</li><li>消息业务：业务上没有关联性的要使用不同的主题</li><li>消息量级：数量级或时效性不同的业务建议使用不同的主题</li></ul><p>创建和管理主题会占用一定系统资源，生产环境下，主题管理应尽量避免自动化机制。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是消息存储和传输的实际容器，主题中有多个队列组成，以此实现队列数量的水平拆分和队列内部的流式存储。</p><p><strong>队列的主要作用</strong></p><ul><li>存储顺序性：先进先出，通过offset对消息进行标记管理</li><li><strong>流式操作语义</strong>：可确保消息从任意offset读取任意数量的消息，实现类似聚合读取、回溯读取等特性</li></ul><p><strong>常见队列增加场景</strong></p><ul><li>增加队列实现物理节点负载均衡</li><li>增加队列实现顺序消息性能扩展</li><li>非顺序消息消费的负载均衡与队列数无关</li></ul><h1 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h1><p>异构系统间需要维持强一致的同步，上游的事件变更需要按照顺序传递到下游进行处理，这类场景下需要使用顺序消息保证数据传输的顺序。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>数据实时增量同步：当涉及到系统同步数据库中数据时，往往需要使用顺序消息。否则，在查询过程中易出现读取到已删除的数据的情况。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序消息发送。</span></span><br><span class="line"><span class="type">MessageBuilder</span> <span class="variable">messageBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messageBuilder.setTopic(<span class="string">&quot;topic&quot;</span>)</span><br><span class="line">        <span class="comment">//设置消息索引键，可根据关键字精确查找某条消息。</span></span><br><span class="line">        .setKeys(<span class="string">&quot;messageKey&quot;</span>)</span><br><span class="line">        <span class="comment">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span><br><span class="line">        .setTag(<span class="string">&quot;messageTag&quot;</span>)</span><br><span class="line">        <span class="comment">//设置顺序消息的排序分组，该分组尽量保持离散，避免热点排序分组。</span></span><br><span class="line">        .setMessageGroup(<span class="string">&quot;fifoGroup001&quot;</span>)</span><br><span class="line">        <span class="comment">//消息体。</span></span><br><span class="line">        .setBody(<span class="string">&quot;messageBody&quot;</span>.getBytes())</span><br><span class="line">        .build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//发送消息，需要关注发送结果，并捕获失败等异常</span></span><br><span class="line">    <span class="type">SendReceipt</span> <span class="variable">sendReceipt</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">    System.out.println(sendReceipt.getMessageId());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费顺序消息时，需要确保当前消费者分组是顺序投递模式，否则仍然按并发乱序投递。</span></span><br><span class="line"><span class="comment">//消费示例一：使用PushConsumer消费顺序消息，只需要在消费监听器处理即可。</span></span><br><span class="line"><span class="type">MessageListener</span> <span class="variable">messageListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeResult <span class="title function_">consume</span><span class="params">(MessageView messageView)</span> &#123;</span><br><span class="line">        System.out.println(messageView);</span><br><span class="line">        <span class="comment">//根据消费结果返回状态。</span></span><br><span class="line">        <span class="keyword">return</span> ConsumeResult.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//消费示例二：使用SimpleConsumer消费顺序消息，主动获取消息进行消费处理并提交消费结果。</span></span><br><span class="line"><span class="comment">//需要注意的是，同一个MessageGroup的消息，如果前序消息没有消费完成，再次调用Receive是获取不到后续消息的。</span></span><br><span class="line">List&lt;MessageView&gt; messageViewList = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    messageViewList = simpleConsumer.receive(<span class="number">10</span>, Duration.ofSeconds(<span class="number">30</span>));</span><br><span class="line">    messageViewList.forEach(messageView -&gt; &#123;</span><br><span class="line">        System.out.println(messageView);</span><br><span class="line">        <span class="comment">//消费处理完成后，需要主动调用ACK提交消费结果。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            simpleConsumer.ack(messageView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">    <span class="comment">//如果遇到系统流控等原因造成拉取失败，需要重新发起获取消息请求。</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定时-延时消息"><a href="#定时-延时消息" class="headerlink" title="定时&#x2F;延时消息"></a>定时&#x2F;延时消息</h1><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="1-分布式定时调度"><a href="#1-分布式定时调度" class="headerlink" title="1 分布式定时调度"></a>1 分布式定时调度</h3><p>在分布式定时调度场景下，需要实现精确的定时任务，比如每晚22:00执行一次数据同步，每隔5分钟触发一次任务推送。<br>RocketMQ在其中就充当一个定时任务触发器，我们发送到MQ上的消息会根据固定的时刻推送。</p><h3 id="2-任务超时处理"><a href="#2-任务超时处理" class="headerlink" title="2 任务超时处理"></a>2 任务超时处理</h3><p>电商支付场景下，订单下单后暂未支付，不可以直接关闭订单，而需要等待一段事件后才能关闭订单。<br>RocketMQ 可以实现超时任务的检查触发。</p><h2 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时/延时消息发送</span></span><br><span class="line"><span class="type">MessageBuilder</span> <span class="variable">messageBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageBuilder</span>();</span><br><span class="line"><span class="comment">//以下示例表示：延迟时间为10分钟之后的Unix时间戳。</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">deliverTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis() + <span class="number">10L</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messageBuilder.setTopic(<span class="string">&quot;topic&quot;</span>)</span><br><span class="line">        <span class="comment">//设置消息索引键，可根据关键字精确查找某条消息。</span></span><br><span class="line">        .setKeys(<span class="string">&quot;messageKey&quot;</span>)</span><br><span class="line">        <span class="comment">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span><br><span class="line">        .setTag(<span class="string">&quot;messageTag&quot;</span>)</span><br><span class="line">        .setDeliveryTimestamp(deliverTimeStamp)</span><br><span class="line">        <span class="comment">//消息体</span></span><br><span class="line">        .setBody(<span class="string">&quot;messageBody&quot;</span>.getBytes())</span><br><span class="line">        .build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//发送消息，需要关注发送结果，并捕获失败等异常。</span></span><br><span class="line">    <span class="type">SendReceipt</span> <span class="variable">sendReceipt</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">    System.out.println(sendReceipt.getMessageId());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费示例一：使用PushConsumer消费定时消息，只需要在消费监听器处理即可。</span></span><br><span class="line"><span class="type">MessageListener</span> <span class="variable">messageListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeResult <span class="title function_">consume</span><span class="params">(MessageView messageView)</span> &#123;</span><br><span class="line">        System.out.println(messageView.getDeliveryTimestamp());</span><br><span class="line">        <span class="comment">//根据消费结果返回状态。</span></span><br><span class="line">        <span class="keyword">return</span> ConsumeResult.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费示例二：使用SimpleConsumer消费定时消息，主动获取消息进行消费处理并提交消费结果。</span></span><br><span class="line">List&lt;MessageView&gt; messageViewList = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    messageViewList = simpleConsumer.receive(<span class="number">10</span>, Duration.ofSeconds(<span class="number">30</span>));</span><br><span class="line">    messageViewList.forEach(messageView -&gt; &#123;</span><br><span class="line">        System.out.println(messageView);</span><br><span class="line">        <span class="comment">//消费处理完成后，需要主动调用ACK提交消费结果。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            simpleConsumer.ack(messageView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">    <span class="comment">//如果遇到系统流控等原因造成拉取失败，需要重新发起获取消息请求。</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h1><h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><p>分布式系统调用的特点是一个核心业务逻辑的执行，同时需要调用多个下游业务进行处理。因此，为了保证核心业务和多个下游业务的执行结果一致，需要用到事务消息。</p><p>以电商场景为例，用户支付订单后，会修改物流发货、积分变更、购物车状态清空等多个子系统的变更。</p><h2 id="事务消息处理流程"><a href="#事务消息处理流程" class="headerlink" title="事务消息处理流程"></a>事务消息处理流程</h2><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/RocketMQ/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.png"></p><ol><li>生产者将消息发送至云消息队列 RocketMQ 版服务端。</li><li>云消息队列 RocketMQ 版服务端将消息持久化成功之后，向生产者返回Ack确认消息已经发送成功，此时消息被标记为“暂不能投递”，这种状态下的消息即为半事务消息。</li><li>生产者开始执行本地事务逻辑。</li><li>生产者根据本地事务执行结果向服务端提交二次确认结果（Commit或是Rollback），服务端收到确认结果后处理逻辑如下：<ul><li>二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。</li><li>二次确认结果为Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。</li></ul></li><li>在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。</li><li>生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li><li>生产者根据检查到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行处理。</li></ol><h2 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h2><p>事务消息相比普通消息发送时需要修改以下几点：</p><ul><li>发送事务消息前，需要开启事务并关联本地的事务执行。</li><li>为保证事务一致性，在构建生产者时，必须设置事务检查器和预绑定事务消息发送的主题列表，客户端内置的事务检查器会对绑定的事务主题做异常状态恢复。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示demo，模拟订单表查询服务，用来确认订单事务是否提交成功。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkOrderById</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示demo，模拟本地事务的执行结果。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">doLocalTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClientException &#123;</span><br><span class="line">    <span class="type">ClientServiceProvider</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceProvider</span>();</span><br><span class="line">    <span class="type">MessageBuilder</span> <span class="variable">messageBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageBuilder</span>();</span><br><span class="line">    <span class="comment">//构造事务生产者：事务消息需要生产者构建一个事务检查器，用于检查确认异常半事务的中间状态。</span></span><br><span class="line">    <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> provider.newProducerBuilder()</span><br><span class="line">            .setTransactionChecker(messageView -&gt; &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 事务检查器一般是根据业务的ID去检查本地事务是否正确提交还是回滚，此处以订单ID属性为例。</span></span><br><span class="line"><span class="comment">                 * 在订单表找到了这个订单，说明本地事务插入订单的操作已经正确提交；如果订单表没有订单，说明本地事务已经回滚。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> messageView.getProperties().get(<span class="string">&quot;OrderId&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (Strings.isNullOrEmpty(orderId)) &#123;</span><br><span class="line">                    <span class="comment">// 错误的消息，直接返回Rollback。</span></span><br><span class="line">                    <span class="keyword">return</span> TransactionResolution.ROLLBACK;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> checkOrderById(orderId) ? TransactionResolution.COMMIT : TransactionResolution.ROLLBACK;</span><br><span class="line">            &#125;)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">//开启事务分支。</span></span><br><span class="line">    <span class="keyword">final</span> Transaction transaction;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        transaction = producer.beginTransaction();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//事务分支开启失败，直接退出。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messageBuilder.setTopic(<span class="string">&quot;topic&quot;</span>)</span><br><span class="line">            <span class="comment">//设置消息索引键，可根据关键字精确查找某条消息。</span></span><br><span class="line">            .setKeys(<span class="string">&quot;messageKey&quot;</span>)</span><br><span class="line">            <span class="comment">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span><br><span class="line">            .setTag(<span class="string">&quot;messageTag&quot;</span>)</span><br><span class="line">            <span class="comment">//一般事务消息都会设置一个本地事务关联的唯一ID，用来做本地事务回查的校验。</span></span><br><span class="line">            .addProperty(<span class="string">&quot;OrderId&quot;</span>, <span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">            <span class="comment">//消息体。</span></span><br><span class="line">            .setBody(<span class="string">&quot;messageBody&quot;</span>.getBytes())</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">//发送半事务消息</span></span><br><span class="line">    <span class="keyword">final</span> SendReceipt sendReceipt;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sendReceipt = producer.send(message, transaction);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">        <span class="comment">//半事务消息发送失败，事务可以直接退出并回滚。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行本地事务，并确定本地事务结果。</span></span><br><span class="line"><span class="comment">     * 1. 如果本地事务提交成功，则提交消息事务。</span></span><br><span class="line"><span class="comment">     * 2. 如果本地事务提交失败，则回滚消息事务。</span></span><br><span class="line"><span class="comment">     * 3. 如果本地事务未知异常，则不处理，等待事务消息回查。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">localTransactionOk</span> <span class="operator">=</span> doLocalTransaction();</span><br><span class="line">    <span class="keyword">if</span> (localTransactionOk) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transaction.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            <span class="comment">// 业务可以自身对实时性的要求选择是否重试，如果放弃重试，可以依赖事务消息回查机制进行事务状态的提交。</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transaction.rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            <span class="comment">// 建议记录异常信息，回滚异常时可以无需重试，依赖事务消息回查机制进行事务状态的提交。</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="死信消息"><a href="#死信消息" class="headerlink" title="死信消息"></a>死信消息</h1><p>消息消费异常进行消费重试时，达到最大重试次数后会转为死信状态，RocketMQ 支持将这些死信消息保存至指定Topic，方便后续进行业务恢复或回溯。</p><h2 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h2><p>消息重试失败后，可以选择将死信消息存储到指定的死信 topic 中，创建另一个消费者组消费死信消息来处理异常链路或分析死信消息。</p><h2 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h2><ul><li>死信Topic只支持普通消息和顺序消息类型的Topic，事务消息类型和定时消息类型的Topic不能作为死信Topic。</li><li>不支持将生产原消息的Topic作为死信Topic（避免出现循环雪崩的问题）。在死信消息转存流程中，若系统发现死信Topic和生产消息的原Topic相同，则该条消息将被丢弃。</li><li>不同Topic的死信消息可以保存到同一个Topic中。</li><li>删除某个ConsumerGroup时，对应的死信Topic不会被删除。</li><li>若某个Topic被死信策略引用，删除该Topic前，您必须先解除该Topic的死信策略关系</li></ul><h1 id="Kafka、RabbitMQ和RocketMQ"><a href="#Kafka、RabbitMQ和RocketMQ" class="headerlink" title="Kafka、RabbitMQ和RocketMQ"></a>Kafka、RabbitMQ和RocketMQ</h1><table><thead><tr><th>项</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>吞吐量</td><td>万级(5.95w&#x2F;s)</td><td>10万级（17.3w&#x2F;s）</td><td>10万级（11.6w&#x2F;s）</td></tr><tr><td>时效性</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td></tr><tr><td>可用性</td><td>基于主从架构的高可用性。但集群扩展麻烦。</td><td>非常高。支持集群部署</td><td>非常高。分布式架构</td></tr><tr><td>消息可靠性</td><td>经过参数优化配置，可以保证数据不丢失</td><td>kafka收到消息后会写入磁盘缓冲区，没有直接落到物理磁盘上，机器故障可能会导致磁盘缓冲区内数据消失</td><td>经过参数优化配置，可以保证数据不丢失</td></tr><tr><td>性能稳定性</td><td>消息堆积时，性能不稳定</td><td>分区多时性能不稳定</td><td>队列较多、消息堆积时性能稳定</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;领域模型&quot;&gt;&lt;a href=&quot;#领域模型&quot; class=&quot;headerlink&quot; title=&quot;领域模型&quot;&gt;&lt;/a&gt;领域模型&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;消息由生产者初始化并发送到云消息队列 RocketMQ 版服务端。&lt;/li&gt;
&lt;li&gt;消息按照到达云消息队列 R</summary>
      
    
    
    
    
    <category term="RocketMQ" scheme="https://palette-k.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://palette-k.github.io/2023/08/24/%E9%93%BE%E8%A1%A8/"/>
    <id>https://palette-k.github.io/2023/08/24/%E9%93%BE%E8%A1%A8/</id>
    <published>2023-08-24T02:09:00.000Z</published>
    <updated>2023-08-24T02:34:40.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置一个虚拟头结点，使得链表中所有元素的删除操作都统一</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/design-linked-list/description/">707. 设计链表</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义链表节点结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>); <span class="comment">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; (_size - <span class="number">1</span>) || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = _dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123; <span class="comment">// 如果--index 就会陷入死循环</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        newNode-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表最后面添加一个节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果index大于链表的长度，则返回空</span></span><br><span class="line">    <span class="comment">// 如果index小于0，则置为0，作为链表的新头节点。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    LinkedNode* _dummyHead;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a><br>双指针，把链表的指针翻转一下，其实就是不断把 cur 指向 pre 的过程，画图可理解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode* temp;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line"></span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span>(cur)&#123;</span><br><span class="line"></span><br><span class="line">             temp = cur -&gt; next;</span><br><span class="line"></span><br><span class="line">             cur -&gt; next = pre;</span><br><span class="line"></span><br><span class="line">             pre = cur;</span><br><span class="line"></span><br><span class="line">             cur = temp;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a><br><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/linkedList/%E4%BA%A4%E6%8D%A2%E8%8A%82%E7%82%B9.png" alt="链表交换节点"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          ListNode* dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          dummyNode -&gt; next = head;</span><br><span class="line"></span><br><span class="line">          ListNode* cur = dummyNode;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span>(cur -&gt; next != <span class="literal">nullptr</span> &amp;&amp; cur -&gt; next -&gt; next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line"></span><br><span class="line">              ListNode* tmp = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">              ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next; <span class="comment">// 记录临时节点</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">              cur-&gt;next = cur -&gt; next -&gt; next;</span><br><span class="line"></span><br><span class="line">              cur -&gt; next -&gt; next = tmp;</span><br><span class="line"></span><br><span class="line">              cur -&gt; next -&gt; next -&gt; next = tmp1;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">               cur = cur-&gt;next-&gt;next; <span class="comment">// cur移动两位，准备下一轮交换</span></span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> dummyNode -&gt; next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">           dummyHead -&gt; next = head;</span><br><span class="line"></span><br><span class="line">           ListNode* fast = dummyHead;</span><br><span class="line"></span><br><span class="line">           ListNode* slow = dummyHead;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span>(n-- &amp;&amp; fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">               fast = fast -&gt; next;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">           fast = fast -&gt; next; <span class="comment">// fast 移动 n + 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">               fast = fast -&gt; next;</span><br><span class="line"></span><br><span class="line">               slow = slow -&gt; next;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         slow -&gt; next = slow -&gt; next -&gt; next;</span><br><span class="line">        <span class="comment">// ListNode *tmp = slow-&gt;next;  C++释放内存的逻辑</span></span><br><span class="line">        <span class="comment">// slow-&gt;next = tmp-&gt;next;</span></span><br><span class="line">        <span class="comment">// delete nth;</span></span><br><span class="line">         <span class="keyword">return</span> dummyHead -&gt; next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a><br>简单题，只要将 A 移动到 与 B 的开端同步时，指针不断加一，判断 A B指向的节点是否相等即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line"></span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求A B长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">            lenA ++;</span><br><span class="line"></span><br><span class="line">            curA = curA -&gt; next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span>(curB != <span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">            lenB ++;</span><br><span class="line"></span><br><span class="line">            curB = curB -&gt; next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curA = headA;</span><br><span class="line"></span><br><span class="line">        curB = headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使得 A 是较长的那个链表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lenA &lt; lenB)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>(lenA,lenB);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>(curA,curB);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A 移动，与 B 齐平</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(gap --)&#123;</span><br><span class="line"></span><br><span class="line">            curA  = curA -&gt; next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curA &amp;&amp; curB)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curA == curB)&#123;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> curA;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curA = curA -&gt; next;</span><br><span class="line"></span><br><span class="line">            curB = curB -&gt; next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a><br>定义快慢指针，快指针一次走两步，慢指针一次走一步，如果有环，则快慢指针一定在环内相遇<br>记录下它们的相遇节点，头节点和相遇节点同时移动，它们的相遇点就是环的入口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode* fast = head;</span><br><span class="line"></span><br><span class="line">        ListNode* slow = head;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast -&gt; next != <span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">            fast = fast -&gt; next -&gt; next;</span><br><span class="line"></span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line"></span><br><span class="line">                ListNode* index2 = fast;</span><br><span class="line"></span><br><span class="line">                ListNode* index1 = head;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line"></span><br><span class="line">                    index1 = index1 -&gt; next;</span><br><span class="line"></span><br><span class="line">                    index2 = index2 -&gt; next;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove-linked-list-elements/&quot;&gt;20</summary>
      
    
    
    
    <category term="算法" scheme="https://palette-k.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="链表" scheme="https://palette-k.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://palette-k.github.io/2023/08/24/%E6%95%B0%E7%BB%84/"/>
    <id>https://palette-k.github.io/2023/08/24/%E6%95%B0%E7%BB%84/</id>
    <published>2023-08-24T02:01:00.000Z</published>
    <updated>2023-08-24T02:36:31.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p><a href="https://leetcode.cn/problems/search-insert-position/">35.搜索插入位置</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二分查找  +  target不在数组中, return r + 1;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34.在排序数组中查找元素的第一个和最后一个位置</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[3,4,6] target = 2或7，&#123;-1，-1&#125;</span><br><span class="line">[3,4,6] target = 4     &#123;1,1&#125;</span><br><span class="line">[3,4,6] target = 5     &#123;-1,-1&#125;</span><br><span class="line">2个二分查找 寻找左边界和右边界</span><br><span class="line">寻找左边界，nums[target] == target的时候更新right</span><br><span class="line">寻找右边界，nums[target] == target的时候更新left</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sqrtx/">69.x 的平方根</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接二分查找[0,x] target = x / mid </span><br><span class="line">特判 x == 0 || x == 1</span><br><span class="line">如果没找到 target, 直接返回 r （舍弃算术平方根的小数部分）</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/valid-perfect-square/">367.有效的完全平方数</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二分查找 [0,num] target = num , 判断 mid * mid == num?</span><br><span class="line">注意将变量设为 long long</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用快慢指针，快指针遍历整个数组，慢指针负责寻找不等于val值（本题该移除出来得元素值）的元素，并放进数组里（覆盖）</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26.删除有序数组的重复项</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用快慢指针，快指针遍历整个数组，慢指针负责寻找不等于val值（本题中的前一个元素值），并放数组里（覆盖）</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/move-zeroes/">283.移动零</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用快慢指针，快指针遍历整个数组，慢指针负责寻找不等于0的值，最后再将0值覆盖给剩余的元素（注意边界）</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/backspace-string-compare/">844.比较含退格的字符串</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;#&#x27;为删除键，如果为&#x27;#&#x27;,则出栈，如果不为&#x27;#&#x27;，则入栈</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用双指针，分别在数组的两端，比较两个指针指向的元素的平方，把较大的放在数组的右边，并移动指针（向中间移动）；只能移动两边中较大的元素，因为无论是正数还是负数，平方后最大的元素只能出现在两边，不能出现在中间！！</span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a><br>滑动窗口，通过判断数组元素之间的和，对数组长度进行变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">              subLength = (j - i + <span class="number">1</span>); <span class="comment">// 取子序列的长度</span></span><br><span class="line">              result = result &lt; subLength ? result : subLength;</span><br><span class="line">              sum -= nums[i++]; <span class="comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span></span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a><br>思路与算法</p><p>我们可以使用滑动窗口解决本题，left 和 right 分别表示满足要求的窗口的左右边界，同时我们使用哈希表存储这个窗口内的数以及出现的次数。</p><p>我们每次将 right 移动一个位置，并将 fruits[right] 加入哈希表。如果此时哈希表不满足要求（即哈希表中出现超过两个键值对），那么我们需要不断移动 left，并将 fruits[left] 从哈希表中移除，直到哈希表满足要求为止。</p><p>需要注意的是，将 fruits[left]从哈希表中移除后，如果 fruits[left]在哈希表中的出现次数减少为 0，需要将对应的键值对从哈希表中移除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; <span class="keyword">public</span>: <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span></span>&#123;   </span><br><span class="line">          <span class="type">int</span> n = fruits.<span class="built_in">size</span>(); </span><br><span class="line">          unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt; <span class="type">int</span> left = <span class="number">0</span>, ans = <span class="number">0</span>; </span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right) &#123; </span><br><span class="line">          ++cnt[fruits[right]]; </span><br><span class="line">          <span class="keyword">while</span> (cnt.<span class="built_in">size</span>() &gt; <span class="number">2</span>) &#123; </span><br><span class="line">          <span class="keyword">auto</span> it = cnt.<span class="built_in">find</span>(fruits[left]); </span><br><span class="line">          --it-&gt;second; </span><br><span class="line">          <span class="keyword">if</span> (it-&gt;second == <span class="number">0</span>) &#123; </span><br><span class="line">             cnt.<span class="built_in">erase</span>(it); </span><br><span class="line">              &#125; </span><br><span class="line">          ++left; </span><br><span class="line">      &#125; </span><br><span class="line">       ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> ans; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a><br>滑动窗口—困难</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="type">int</span> <span class="variable">slen</span> <span class="operator">=</span> s.length();</span><br><span class="line"></span><br><span class="line">          <span class="type">int</span> <span class="variable">tlen</span> <span class="operator">=</span> t.length();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(slen == <span class="number">0</span> || tlen == <span class="number">0</span> || slen &lt; tlen)&#123;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="type">char</span>[] charArrayS = s.toCharArray();</span><br><span class="line"></span><br><span class="line">          <span class="type">char</span>[] charArrayT = t.toCharArray();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">          <span class="type">int</span>[] winFreq = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">          <span class="type">int</span>[] tFreq = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="type">char</span> c : charArrayT)&#123;</span><br><span class="line"></span><br><span class="line">              tFreq[c]++; <span class="comment">//收集 t 中字符个数</span></span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 窗口内 t 字符的个数</span></span><br><span class="line"></span><br><span class="line">          <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> slen + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">          <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span>(right &lt; slen)&#123;  <span class="comment">//右边界向右滑动，直到滑动窗口内有 t 中所有字符</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(tFreq[charArrayS[right]] == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                  right++;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(winFreq[charArrayS[right]] &lt; tFreq[charArrayS[right]])&#123;</span><br><span class="line"></span><br><span class="line">                  distance++; <span class="comment">// 标记 distance</span></span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">              winFreq[charArrayS[right]]++; <span class="comment">// 标记滑动窗口此时最右的字符</span></span><br><span class="line"></span><br><span class="line">              right++; <span class="comment">// 向右滑动</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">              <span class="keyword">while</span>(distance == tlen)&#123;  <span class="comment">// 滑动窗口内有 t 中所有字符</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; minLen)&#123;</span><br><span class="line"></span><br><span class="line">                    minLen = right - left;</span><br><span class="line"></span><br><span class="line">                    begin = left;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(tFreq[charArrayS[left]] == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                  left++;  <span class="comment">// 左边界向右滑动</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(winFreq[charArrayS[left]] == tFreq[charArrayS[left]])&#123;</span><br><span class="line"></span><br><span class="line">                  distance--; <span class="comment">//标记完 左边界继续向右滑动跳出此循环</span></span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">              winFreq[charArrayS[left]]--;</span><br><span class="line"></span><br><span class="line">              left++;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(minLen == slen + <span class="number">1</span>)&#123;  <span class="comment">// 没被赋值的情况</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin+minLen);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II </a><br>模拟</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 使用vector定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="type">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span> (loop --) &#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">            <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">            offset += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;h2 id=&quot;二分&quot;&gt;&lt;a href=&quot;#二分&quot; class=&quot;headerlink&quot; title=&quot;二分&quot;&gt;&lt;/a&gt;二分&lt;/h2&gt;&lt;p&gt;&lt;a </summary>
      
    
    
    
    <category term="算法" scheme="https://palette-k.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://palette-k.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
