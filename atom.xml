<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Palette</title>
  <icon>https://www.gravatar.com/avatar/f6d0550c9229791f51dcfd63ef1e86d9</icon>
  <subtitle>个人博客</subtitle>
  <link href="https://palette-k.github.io/atom.xml" rel="self"/>
  
  <link href="https://palette-k.github.io/"/>
  <updated>2024-11-11T09:31:39.272Z</updated>
  <id>https://palette-k.github.io/</id>
  
  <author>
    <name>Palette</name>
    <email>1148432487@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RocketMQ的最佳实践</title>
    <link href="https://palette-k.github.io/2024/11/11/RocketMQ%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://palette-k.github.io/2024/11/11/RocketMQ%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2024-11-11T08:48:27.000Z</published>
    <updated>2024-11-11T09:31:39.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="幂等性保证"><a href="#幂等性保证" class="headerlink" title="幂等性保证"></a>幂等性保证</h1><p>对于非幂等的请求，我们在业务里要做幂等性保证。</p><h2 id="在消息队列中的幂等性体现"><a href="#在消息队列中的幂等性体现" class="headerlink" title="在消息队列中的幂等性体现"></a>在消息队列中的幂等性体现</h2><p>消息队列中，很可能一条消息被冗余部署的多个消费者收到，对于非幂等的操作，比如用户的注册，就需要做幂等性保证，否则消息将会被重复消费。可以将情况概括为以下几种:</p><ul><li><p>生产者重复发送：由于网络抖动，导致生产者没有收到broker的ack而再次重发消息，实际上broker收到了多条重复的消息，造成消息重复</p></li><li><p>消费者重复消费：由于网络抖动，消费者没有返回ack给broker，导致消费者重试消费。</p></li><li><p>rebalance时的重复消费:由于网络抖动，在rebalance重分配时也可能出现消费者重复消费某条消息。</p></li></ul><h2 id="如何保证幂等性消费"><a href="#如何保证幂等性消费" class="headerlink" title="如何保证幂等性消费"></a>如何保证幂等性消费</h2><ul><li>mysql插入业务id作为主键，主键是唯一的，所以一次只能插入一条</li><li>使用redis或zk的分布式锁(主流的方案)</li><li>添加业务性的判断，过滤掉已修改状态的数据</li></ul><h1 id="消息顺序消费"><a href="#消息顺序消费" class="headerlink" title="消息顺序消费"></a>消息顺序消费</h1><h2 id="为什么要保证消息有序"><a href="#为什么要保证消息有序" class="headerlink" title="为什么要保证消息有序"></a>为什么要保证消息有序</h2><p>比如有这么一个物联网的应用场景，IOT中的设备在初始化时需要按顺序接收这样的消息:</p><ul><li>设置设备名称</li><li>设置设备的网络</li><li>重启设备使配置生效</li></ul><p>如果这个顺序颠倒了，可能就没有办法让设备的配置生效，因为只有重启设备才能让配置生效，但重启的消息却在设置设备消息之前被消费</p><h2 id="如何保证消息顺序消费"><a href="#如何保证消息顺序消费" class="headerlink" title="如何保证消息顺序消费"></a>如何保证消息顺序消费</h2><p><strong>全局有序：</strong>消费的所有消息都严格按照发送消息的顺序进行消费。在 RocketMQ 中，要实现全局有序，只能使用一个队列，并且由一个消费者进行消费。这意味着无论消息来自哪个业务场景，都必须按照顺序依次处理，对系统的性能和扩展性有很大的限制。</p><p><strong>局部有序：</strong>消费的部分消息按照发送消息的顺序进行消费。对于需要保证顺序的业务场景，将相关消息发送到同一个队列，然后由专门的消费者去处理这个队列。这样，不同业务场景的消息可以在不同的队列中并行处理，而同一业务场景下的消息则按照顺序被消费，既保证了特定业务的消息顺序，又提高了系统的整体性能。</p><h1 id="快速处理积压消息"><a href="#快速处理积压消息" class="headerlink" title="快速处理积压消息"></a>快速处理积压消息</h1><p>在RocketMQ中，如果消费者消费速度过慢，而生产者生产消息的速度又远超于消费者消费消息的速度，那么就会造成大量消息积压在MQ中。</p><h2 id="如何查看消息积压的情况"><a href="#如何查看消息积压的情况" class="headerlink" title="如何查看消息积压的情况"></a>如何查看消息积压的情况</h2><p>在console控制台中可以查看：</p><p><img src="https://i0.hdslb.com/bfs/article/f639109a5b76ffdb5b01dcd021b56d39171301454.png" alt="image-20241111170719497"></p><p>如果生产者在10ms内发送了一万条消息，大量的消息都被推送到了现有的消息队列里，导致消息堆积，扩充消息队列和增加消费者都不能将已经在队列里排队的消息迅速消费完，此时应该如何解决呢？</p><p>解决方式如下图所示，可以增加一个消费组2，里面只有一个用于转发消息的消费者，将现有的3个队列里的消息全部转发到另外几个新建的topic，并在broker内新建几个消息队列，新建一个专门用来消费积压消息的消费组3，配置相应的消费者来消费这些积压消息。</p><p><img src="https://i0.hdslb.com/bfs/article/ca29e11e8dfd2a976dad92e2bddebef6171301454.png" alt="image-20241111173059635"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;幂等性保证&quot;&gt;&lt;a href=&quot;#幂等性保证&quot; class=&quot;headerlink&quot; title=&quot;幂等性保证&quot;&gt;&lt;/a&gt;幂等性保证&lt;/h1&gt;&lt;p&gt;对于非幂等的请求，我们在业务里要做幂等性保证。&lt;/p&gt;
&lt;h2 id=&quot;在消息队列中的幂等性体现&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="RocketMQ" scheme="https://palette-k.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ存储方式探究</title>
    <link href="https://palette-k.github.io/2024/11/05/RocketMQ%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%A9%B6/"/>
    <id>https://palette-k.github.io/2024/11/05/RocketMQ%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%A9%B6/</id>
    <published>2024-11-05T03:52:27.000Z</published>
    <updated>2024-11-07T01:37:30.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>首先，在RocketMQ管理页面手动创建一个Topic，配置如下图：</p><p><img src="https://i0.hdslb.com/bfs/article/e9f0e8d4c0b43b9974882fd692501822171301454.png" alt="image-20241105135116773"></p><p>这里解释一下图中的几个参数：</p><p><strong>writeQueueNums</strong>：客户端在发送消息时，可以向多少个队列进行发送；</p><p><strong>readQueueNums</strong>：客户端在消费消息时，可以从多少个队列进行拉取；</p><p><strong>perm</strong>：当前 Topic 读写权限，2 只允许读、4 只允许写、6 允许读写，默认是 6。</p><p>RocketMQ 主要有 3 个消息相关的文件：commitlog、consumequeue 和 index。</p><p>writeQueueNums 参数控制 consumequeue 的文件数量。往 MyTestTopic 这个 Topic 发送了 100 条消息，这些消息保存在了 commitlog 文件。而 consumequeue 文件如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx MyTestTopic]# pwd</span><br><span class="line">/root/store/consumequeue/MyTestTopic</span><br><span class="line">[root@xxx MyTestTopic]# ls</span><br><span class="line">0  1  2  3  4  5  6  7</span><br></pre></td></tr></table></figure><p>可以看到，consumequeue 的保存是在 consumequeue 目录下为每个 Topic 建一个目录，用保存这个 Topic 的 consumequeue 文件。consumequeue 文件为每个 Topic 基于偏移量创建了一个索引。</p><p>index 文件保存的是消息基于 key 的 HASH 索引。</p><h1 id="commitlog"><a href="#commitlog" class="headerlink" title="commitlog"></a>commitlog</h1><p>commitlog 是 RocketMQ 保存消息的文件，保存了消息主体以及元数据的存储主体 。commitlog 并没有按照 Topic 来分割，Broker单个实例下所有的队列的消息都写入同一个 commitlog。</p><p>为了追求高效写入，RocketMQ 使用了磁盘顺序写，所有主题的消息按顺序存储在同一个文件中。同时为了避免消息在消息存储服务器中无限地累积，引入了消息文件过期机制与文件存储空间报警机制。</p><p>commitlog 单个文件大小默认是1G，可以通过参数 mappedFileSizeCommitLog 来修改。</p><p>下面是服务器磁盘上保存的 commitlog 文件（文件大小 1G）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx commitlog]# pwd</span><br><span class="line">/root/store/commitlog</span><br><span class="line">[root@xxx commitlog]# ls</span><br><span class="line">00000000000000000000  00000000001073741824</span><br></pre></td></tr></table></figure><p>可以看到：commitlog 文件的命名以保存在文件中的消息最小的偏移量来命名的，后一个文件的名字是前一个文件名加文件大小。这样通过偏移量查找消息时可以先用<strong>二分查找找到消息所在的文件，然后通过偏移量减去文件名就可以方便地找到消息在文件中的物理地址，定位消息位于那个文件中，并获取到消息实体数据</strong>。</p><p>为了让 commitlog 操作效率更高，RocketMQ 使用了 mmap 将磁盘上日志文件映射到用户态的内存地址中，减少日志文件从磁盘到用户态内存之间的数据拷贝。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AllocateMappedFileService 类 mmapOperation 方法</span></span><br><span class="line"><span class="comment">//是否开启堆外内存</span></span><br><span class="line"><span class="keyword">if</span> (messageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  mappedFile = ServiceLoader.load(MappedFile.class).iterator().next();</span><br><span class="line">  mappedFile.init(req.getFilePath(), req.getFileSize(), messageStore.getTransientStorePool());</span><br><span class="line"> &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">  log.warn(<span class="string">&quot;Use default implementation.&quot;</span>);</span><br><span class="line">  mappedFile = <span class="keyword">new</span> <span class="title class_">MappedFile</span>(req.getFilePath(), req.getFileSize(), messageStore.getTransientStorePool());</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> mappedFile = <span class="keyword">new</span> <span class="title class_">MappedFile</span>(req.getFilePath(), req.getFileSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入消息时，如果 isTransientStorePoolEnable 方法返回 true，则消息数据先写入堆外内存，然后异步线程把堆外内存数据刷到 PageCache，如果返回 false 则直接写入 PageCache。后面根据刷盘策略把 PageCache 中数据持久化到磁盘。如下图：</p><p><img src="https://i0.hdslb.com/bfs/article/0db81b7afe57e291a4cdb76da12efd01171301454.png" alt="image-20241105145146308"></p><p>页缓存(PageCache)是OS对文件的缓存，用于加速对文件的读写。一般来说，程序对文件进行顺序读写的速度几<br>乎接近于内存的读写速度，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化，将一部分<br>的内存用作PageCache。对于数据的写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将<br>Cache内的数据刷盘至物理磁盘上。对于数据的读取，如果一次读取文件时出现未命中PageCache的情况，OS从<br>物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取。</p><p>无论先写对堆外内存还是直接写 PageCache，文件数据都会映射到 MappedByteBuffer。如下图：</p><p><img src="https://i0.hdslb.com/bfs/article/985f7c41b800443bf6e9418c14473f30171301454.png" alt="image-20241105151037955"></p><p>不同的是，如果消息先写入堆外内存，则 MappedByteBuffer 主要用来读消息，堆外内存用来写消息。这一定程度上实现了读写分离，减少 PageCache 写入压力。</p><p>再看一下文件映射的代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MappedFile 类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="type">int</span> fileSize)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"> <span class="built_in">this</span>.fileName = fileName;</span><br><span class="line"> <span class="built_in">this</span>.fileSize = fileSize;</span><br><span class="line"> <span class="built_in">this</span>.file = <span class="keyword">new</span> <span class="title class_">File</span>(fileName);</span><br><span class="line"> <span class="built_in">this</span>.fileFromOffset = Long.parseLong(<span class="built_in">this</span>.file.getName());</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.fileChannel = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="built_in">this</span>.file, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">  <span class="built_in">this</span>.mappedByteBuffer = <span class="built_in">this</span>.fileChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, fileSize);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"> &#125; <span class="comment">//省略 catch finally</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了 Java 中 FileChannel 的 map 方法来实现 mmap。</p><p>有一个细节需要注意：<strong>创建 MappedFile 后会进行文件预热</strong>，目的是为了预先将 PageCache 加载到内存，防止读写数据发生缺页中断时再加载，影响性能。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AllocateMappedFileService 类 mmapOperation 方法</span></span><br><span class="line"><span class="comment">// pre write mappedFile</span></span><br><span class="line"><span class="keyword">if</span> (mappedFile.getFileSize() &gt;= <span class="built_in">this</span>.messageStore.getMessageStoreConfig()</span><br><span class="line"> .getMappedFileSizeCommitLog()</span><br><span class="line"> &amp;&amp;</span><br><span class="line"> <span class="built_in">this</span>.messageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line"> mappedFile.warmMappedFile(<span class="built_in">this</span>.messageStore.getMessageStoreConfig().getFlushDiskType(),</span><br><span class="line">  <span class="built_in">this</span>.messageStore.getMessageStoreConfig().getFlushLeastPagesWhenWarmMapedFile());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RocketMQ主要通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型将磁<br>盘上的物理文件直接映射到用户态的内存地址中，<strong>这种Mmap的方式减少了传统IO将磁盘文件数据在操作系统内</strong><br><strong>核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销</strong>。将对文件的操作转化为直<br>接对内存地址进行操作，从而极大地提高了文件的读写效率。正因为需要使用内存映射机制，故RocketMQ的文件<br>存储都使用定长结构来存储，方便一次将整个文件映射至内存。</p><h1 id="consumequeue"><a href="#consumequeue" class="headerlink" title="consumequeue"></a>consumequeue</h1><p>所有 Topic 的消息都写到同一个 commitlog 文件，如果直接在 commitlog 文件中查找消息，只能从文件头开始查找，肯定会很慢。因此 RocketMQ 引入了 consumequeue，基于 Topic 来保存偏移量。</p><p>consumequeue 的文件结构如下图：</p><p><img src="https://i0.hdslb.com/bfs/article/a825087ba68baa53637abad617f6a299171301454.png" alt="image-20241105154157947"></p><p>其中前 8 个字节保存消息在 commitlog 中的偏移量，中间 4 个字节保存消息消息大小，最后 8 个字节保存消息中 tag 的 hashcode。</p><p><strong>这里为什么要保存一个 tag 的 hashcode 呢？</strong></p><p>如果一个 Consumer 订阅了 TopicA 这个 Topic 中的 Tag1 和 Tag2 这两个 tag，那这个 Consumer 的订阅关系如下图：</p><p><img src="https://i0.hdslb.com/bfs/article/311ed31552b5de2f046d9a9ed901c9b5171301454.png" alt="image-20241105160910796"></p><p>可以看到，订阅关系这个对象封装了 Topic、tag 以及所订阅 tag 的 hashcode 集合。</p><p>Consumer 发送拉取消息请求时，会把订阅关系传给 Broker（Broker 解析成 SubscriptionData 对象），Broker 使用 consumequeue 获取消息时，首先判断最后 8 个字节的 tag hashcode 是否在 SubscriptionData 的 codeSet 中，如果不在就跳过，如果存在就根据偏移量从 commitlog 中获取消息返回给 Consumer。如下图：</p><p><img src="https://i0.hdslb.com/bfs/article/7582d11892ce2e741db4987bdd2a4ab7171301454.png" alt="image-20241105162316898"></p><p>跟 commitlog 一样，consumequeue 也会使用 mmap 映射为 MappedFile 存储对象。</p><h1 id="index"><a href="#index" class="headerlink" title="index"></a>index</h1><p>每个消息在业务层面的唯一标识码要设置到 keys 字段，方便将来定位消息丢失问题。服务器为每个消息创建哈希索引，应用可以通过 topic、key 来查询这条消息内容，以及消息被谁消费。为了支持按照消息的某一个属性来查询，RocketMQ 引入了 index 索引文件。index 文件结构如下图：</p><p><img src="https://i0.hdslb.com/bfs/article/facad55232f1464ce9571d323eb23165171301454.png" alt="image-20241106181830135"></p><p>主要由三部分组成：IndexHeader、HashSlog 和 Index 条目。跟 commitlog 一样，Index 文件也会使用 mmap 映射为 MappedFile 存储对象。</p><h2 id="IndexHeader"><a href="#IndexHeader" class="headerlink" title="IndexHeader"></a>IndexHeader</h2><p>IndexHead 由如下 6 个属性组成，这些熟悉定义在类 IndexHeader：</p><p>1.beginTimestamp：index 文件中最小的消息存储时间；</p><p>2.endTimestamp：index 文件中最大的消息存储时间；</p><p>3.beginPhyoffset：index 文件中包含的消息中最小的 commitlog 偏移量；</p><p>4.endPhyoffset：index 文件中包含的消息中最大的 commitlog 偏移量；</p><p>5.hashSlotcount：index 文件中包含的 hash 槽的数量；</p><p>6.indexCount：index 文件中包含的 index 条目个数。</p><h2 id="HashSlog"><a href="#HashSlog" class="headerlink" title="HashSlog"></a>HashSlog</h2><p>HashSlot 就是 Java HashMap 中的 hash 槽，默认有 500 万个。每个 HashSlot 使用 4 个字节 int 类型保存<strong>最后一个 Index 条目的位置</strong>。</p><p><strong>为什么是保存的最后一个 index 条目呢？</strong></p><p>因为 index 条目保存的是 key 的 hashcode，存在 hash 冲突的情况下，Hashslog 使用链表法解决，在 Index 条目中<strong>会保存相同 Hash 值的前一个条目位置。</strong></p><p><img src="https://i0.hdslb.com/bfs/article/86687a3d5066cc42b0f614bce58a8d7c171301454.png" alt="image-20241106183853315"></p><h2 id="index-条目"><a href="#index-条目" class="headerlink" title="index 条目"></a>index 条目</h2><p>index 条目录由 4 个属性组成：</p><p>1.key hashcode：要查找消息的 key 的 hashcode；</p><p>2.phyOffset：消息在 commitlog 文件中的物理偏移量；</p><p>3.timediff：该消息存储时间与 beginTimestamp 的差值。通过 key 查找消息时，在 key 相同的情况下，还要看 timediff 是否在区间范围内 ，不在时间范围内的就不返回，参考下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IndexFile 类</span></span><br><span class="line"><span class="type">long</span> <span class="variable">timeRead</span> <span class="operator">=</span> <span class="built_in">this</span>.indexHeader.getBeginTimestamp() + timeDiff;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">timeMatched</span> <span class="operator">=</span> (timeRead &gt;= begin) &amp;&amp; (timeRead &lt;= end);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (keyHash == keyHashRead &amp;&amp; timeMatched) &#123;</span><br><span class="line"> phyOffsets.add(phyOffsetRead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.prevIndex：key 发生 hash 冲突后保存相同 hash code 的前一个 index 条目位置。</p><p>index 条目默认有 2000 万个。</p><h2 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h2><p><img src="https://i0.hdslb.com/bfs/article/a19c43f4ed094bce5ed263361df6fd9e171301454.png" alt="image-20241106201638352"></p><h1 id="文件构建"><a href="#文件构建" class="headerlink" title="文件构建"></a>文件构建</h1><p><strong>consumequeue 和 index 文件的内容是什么时候写入呢？</strong></p><p>在 MessageStore 初始化的时候会启动一个线程 ReputMessageService，这个线程的逻辑是死循环里面每个 1ms 执行一次，从 commitlog 中获取消息然后写入 consumequeue 和 index 文件。参考下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultMessageStore 类 doReput 方法</span></span><br><span class="line"><span class="type">DispatchRequest</span> <span class="variable">dispatchRequest</span> <span class="operator">=</span></span><br><span class="line"> DefaultMessageStore.<span class="built_in">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dispatchRequest.getBufferSize() == -<span class="number">1</span> ? dispatchRequest.getMsgSize() : dispatchRequest.getBufferSize();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123;</span><br><span class="line"> <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  DefaultMessageStore.<span class="built_in">this</span>.doDispatch(dispatchRequest);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(DispatchRequest req)</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (CommitLogDispatcher dispatcher : <span class="built_in">this</span>.dispatcherList) &#123;</span><br><span class="line">  dispatcher.dispatch(req);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 dispatcherList 的定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.dispatcherList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//CommitLogDispatcherBuildConsumeQueue 类用来写 consumequeue</span></span><br><span class="line"><span class="built_in">this</span>.dispatcherList.addLast(<span class="keyword">new</span> <span class="title class_">CommitLogDispatcherBuildConsumeQueue</span>());</span><br><span class="line"><span class="comment">//CommitLogDispatcherBuildIndex 类用来写 index 文件</span></span><br><span class="line"><span class="built_in">this</span>.dispatcherList.addLast(<span class="keyword">new</span> <span class="title class_">CommitLogDispatcherBuildIndex</span>());</span><br></pre></td></tr></table></figure><p>可以看到，即使 Broker 挂了，只要 commitlog 在，就可以重新构建出 consumequeue 和 index 文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;首先，在RocketMQ管理页面手动创建一个Topic，配置如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.c</summary>
      
    
    
    
    
    <category term="RocketMQ" scheme="https://palette-k.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>一键解标功能需求分析</title>
    <link href="https://palette-k.github.io/2024/05/27/%E4%B8%80%E9%94%AE%E8%A7%A3%E6%A0%87/"/>
    <id>https://palette-k.github.io/2024/05/27/%E4%B8%80%E9%94%AE%E8%A7%A3%E6%A0%87/</id>
    <published>2024-05-27T09:00:15.000Z</published>
    <updated>2024-06-24T05:46:33.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一键解标功能需求分析"><a href="#一键解标功能需求分析" class="headerlink" title="一键解标功能需求分析"></a>一键解标功能需求分析</h1><p>需求说明：</p><p>1.明月AI标讯平台导航栏新增菜单“招标解读”</p><p>2.用户上传招标文件（&lt;150页，且&lt;10万字），文件类型限制为（docx、doc、pdf），上传完成AI输出招标文件分析结果（关键指标），每条分析结果支持反向定位到原始依据页面</p><p>3.新增招标解读Agent，后端调用该Agent获取招标文件的分析结果</p><p>4.新增招标解读历史记录模块，支持用户查询自己历史解读的标讯结果</p><p><img src="https://i0.hdslb.com/bfs/article/f46da9b94916d8508d58315358e52657171301454.png" alt="image-20240527170616307"></p><p>最终产品效果图：</p><p><img src="https://i0.hdslb.com/bfs/article/08f376a603b51e8268b1c71a84cdb092171301454.png" alt="image-20240527182251434"></p><h2 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h2><h3 id="招标文件解析表"><a href="#招标文件解析表" class="headerlink" title="招标文件解析表"></a>招标文件解析表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `func_bid_doc_analysis` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `file_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;招标文件名称&#x27;</span>,</span><br><span class="line">  `file_url` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;招标文件url&#x27;</span>,</span><br><span class="line">  `original_content` longtext COMMENT <span class="string">&#x27;招标文件原始文本&#x27;</span>,</span><br><span class="line">  `analyze_content` json <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;解析内容&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;文件md5&#x27;</span>,</span><br><span class="line">  `created_at` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `created_by` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;创建用户&#x27;</span>,</span><br><span class="line">  `updated_at` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `updated_by` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;修改用户&#x27;</span>,</span><br><span class="line">  `is_deleted` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否已删除：0-未删除，其他表示已删除&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;招标文件解析表&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="接口功能设计"><a href="#接口功能设计" class="headerlink" title="接口功能设计"></a>接口功能设计</h2><h3 id="上传招标文件"><a href="#上传招标文件" class="headerlink" title="上传招标文件"></a>上传招标文件</h3><p>前置校验：</p><ul><li><p>文件不能为空</p></li><li><p>文件类型限制为（docx、doc、pdf）</p></li><li><p>招标文件（&lt;150页，且&lt;10万字）</p></li></ul><p>若文件类型为 docx 或 doc ，转换为 pdf</p><p>将 pdf 文件上传到cos </p><p>新增到招标文件表</p><p>返回结果：文件id、文件名称、文件url</p><p>异常结果：</p><ul><li>转换格式失败</li><li>检测文件页数和字数失败</li></ul><h3 id="解析招标文件"><a href="#解析招标文件" class="headerlink" title="解析招标文件"></a>解析招标文件</h3><p>Agent：参照已有的信息提取Agent，具体产品来写</p><p>前置校验：</p><ul><li>该招标文件是否为本人上传</li></ul><p>按页提取 pdf 文件文本</p><p>标识页码，调用一键解标 Agent ，返回解析结果（原始依据包含页码）</p><p>更新解析内容到招标文件解读表</p><p>返回解析结果</p><p>异常结果：</p><ul><li>按页提取文件文本失败</li><li>解析招标文件失败</li></ul><h3 id="查询该用户上传的招标文件列表"><a href="#查询该用户上传的招标文件列表" class="headerlink" title="查询该用户上传的招标文件列表"></a>查询该用户上传的招标文件列表</h3><p>根据上传人查询招标文件表</p><p>校验是否是该登录用户的招标文件</p><p>返回结果：</p><p>文件id、文件名称、文件url、创建时间（按创建日期倒序）</p><h3 id="查询该招标文件的解析结果"><a href="#查询该招标文件的解析结果" class="headerlink" title="查询该招标文件的解析结果"></a>查询该招标文件的解析结果</h3><p>根据文件id查询招标文件表</p><p>校验：</p><ul><li><p>该文件是否存在</p></li><li><p>校验是否是该登录用户的招标文件</p></li></ul><p>返回解析结果</p><h2 id="改进功能点"><a href="#改进功能点" class="headerlink" title="改进功能点"></a>改进功能点</h2><p>上文是初步的一个技术方案，在开发过程中，仍还有很多细节没有关注到，所以后面我们的重点放在如何对接口的功能设计进行改造上。</p><h3 id="解析文件异步处理"><a href="#解析文件异步处理" class="headerlink" title="解析文件异步处理"></a>解析文件异步处理</h3><p>最初的方案是前端做一个假的loading界面，调用解析文件接口，这个接口会同步返回解析结果。但是如果这时候，用户手动刷新了一下界面，前端调用的解析请求就没了，想要再次解析，只能手动发起。如果每次用户都在快解析结束的时候刷新，那调用 agent 的花销就是一笔大数目了。</p><p>综合前端、用户的体验，决定把解析文件的操作做异步处理。还有一个衍生的问题，产品认为流式传输比非流式要准确，所以建议我们后端接收流，把流式的结果拼接成完整的结果。</p><p>产品刚把 agent 写好，就提了这么些需求。而且更麻烦的是，产品需要我整合两个 agent 的信息。离上线还有一天，突然就得大改，内心慌得一批…</p><p>整理一下产品的需求：</p><ol><li>解析文件修改为异步</li><li>调用流式API，拼接结果</li><li>等待两个 agent 结果，组装成 json 存入数据库</li></ol><p>异步很好处理，使用 CompletableFuture 的 runAsync 方法，搞定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(()-&gt;dealWithContent());</span><br></pre></td></tr></table></figure><p>流式API需要就可以借助AI问问相关的API怎么用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">client.post()</span><br><span class="line">               .uri(agentChatUrl)</span><br><span class="line">               .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">               .body(BodyInserters.fromValue(JSON.toJSONString(request)))</span><br><span class="line">               .header(Constants.MOONAI_ACCOUNT_HEADER, userName)</span><br><span class="line">               .header(Constants.AUTHORIZATION_HEADER, token).retrieve()</span><br><span class="line">               .onStatus(HttpStatus::isError, response -&gt; response.bodyToMono(Result.class)</span><br><span class="line">                       .flatMap(errorBody -&gt; Mono.error(<span class="keyword">new</span> <span class="title class_">MingYueAiException</span>(errorBody.getCode(), errorBody.getMsg()))))</span><br><span class="line">               .bodyToFlux(String.class)</span><br><span class="line">               .doFinally((signalType) -&gt; countDownLatch.countDown())</span><br><span class="line">               .subscribe(data -&gt; &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!<span class="string">&quot;[DONE]&quot;</span>.equals(data)) &#123;</span><br><span class="line">                       <span class="comment">// data 转换成 ChatCompletionChunk</span></span><br><span class="line">                       <span class="type">ChatCompletionChunk</span> <span class="variable">chunk</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           chunk = objectMapper.readValue(data, ChatCompletionChunk.class);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> chunk.getChoices().get(<span class="number">0</span>).getMessage().getContent();</span><br><span class="line">                       <span class="comment">// 拼接 content</span></span><br><span class="line">                       <span class="keyword">if</span> (StringUtils.isNotEmpty(content)) &#123;</span><br><span class="line">                           stringBuilder.append(content);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;, error -&gt; &#123;</span><br><span class="line">                   isError.append(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">                   log.error(<span class="string">&quot;error:&quot;</span>, error);</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><p>可以在 subscribe 里对 data 进行聚合，只要没有结束，就可以把 content 拿出来拼接。</p><p>至于等待两个流式调用的结果，上面的代码也体现了。在 doFinally 里使用 countDownLatch，确保两个agent都被调用，最后将两个 content 都放进 List 里，作为 json 存入数据库。</p><p>既然解析文件的操作都是异步的了，其实也没必要把上传和解析分为两个接口来实现了，一开始上传时就自动解析，前端轮询查询解析内容的接口，拿到解析内容结果，这是最稳妥的办法。因为上传文件还涉及到 word 转 pdf 的过程，可能会花费10秒，如果在这期间，用户点击到别的页面，那前端就永远拿不到返回值，也永远不会主动调用解析文件的接口了，在用户的视角看就是他所上传的招标文件一直在解析中。</p><h3 id="幂等性问题"><a href="#幂等性问题" class="headerlink" title="幂等性问题"></a>幂等性问题</h3><p>解析文件这一步确实是异步了，但是如果在解析的过程中，我疯狂点击这个解析的接口，那就会有很多个调用 agent 的方法，这样就花了很多不必要的钱。</p><p>我们可以定义一个 ConcurrentHashMap，key存储招标文件id，value存储当前时间。在每次解析前，我都去内存里判断当前时间和 value 的间隔有没有超过一分钟，如果在一分钟以内，限制它的提交。最后解析完，把这次的key移除掉，允许它再次解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.CURRENT_ANALYSIS_DOC_MAP.put(funcBidDocAnalysis.getId(), System.currentTimeMillis());</span><br></pre></td></tr></table></figure><p>为什么要对时间做限制呢？因为实际上我们是允许用户<strong>重新解析</strong>的，如果解析内容有异常，在json里会有一个 isError 字段去标识，前端根据这个标识去给用户提供一个重新解析的按钮，后端也可以根据这个标识判断是否需要调用 agent。这样做比多加一个解析状态的字段要高效且简洁。</p><p>另外，我们还添加了一个文件md5的字段，约定了用户只要上传同一个招标文件，就可以复用其解析内容。用户体验上，可以无须等待就显示解析内容；产品花费上，对于同一个招标文件，可以少一次调用。</p><h3 id="重新解析"><a href="#重新解析" class="headerlink" title="重新解析"></a>重新解析</h3><p>发版上线了一段时间，突然有用户反馈说，点击页面上的“重新解析”不生效，赶紧看日志排查原因。</p><p>日志表明，该用户第一次异步解析，调用了 agent 失败了，他点击重新解析后，又调用失败了。他所看到的是点击“重新解析”后，页面没有任何变化，所以他反馈了这个问题。</p><p>确实，我们虽然允许用户重新解析了，但是重新解析的过程中，我们的页面没有任何变化，用户感知不到我们后台在重新解析。</p><p>这时候我们就和前端小伙伴看了这块逻辑，他说，一开始我们的解析内容为空，他就会在页面显示正在加载中，并轮询调用查询接口查解析内容，等待我们后端异步返回。所以，在重新解析的接口里，我们要先将这条标书文件的解析内容设置为空，更新数据库，并异步调用 agent。这样用户就能在页面直接感受到我们后台的运作了。</p><h3 id="自定义typeHandler"><a href="#自定义typeHandler" class="headerlink" title="自定义typeHandler"></a>自定义typeHandler</h3><p>解析内容实际上是聚合了两个 agent 的 json，为了存储方便，我们将两个 json 组装成一个 List<JSONObject>， 以 json 的形式存入数据库中。那这就引发了一个新的问题，我们需要从数据库中查到解析内容，以 List<JSONObject> 的形式返回给前端，且存入数据库时该字段为json。</JSONObject></JSONObject></p><p> 一开始我是手动实现这一过程的，每次从数据库中查出来的解析内容，都被自动判定为 String 类型，所以我要手动转换成 JsonArray 的形式，再返回给前端 or 存入数据库，否则它会以字符串的形式返回&#x2F;入库。</p><p>在这一步出过一次生产问题，因为逻辑删除的时候没有考虑到 String 转换的问题，删掉该文件后，顺便把解析内容篡改成了 String 类型，再次上传相同的文件，根据文件md5找到的解析内容（已经是篡改过的了），就没办法转换成 List<JSONObject> 再入库了。紧急措施就是在删除接口查出来的解析内容设置为Null，这样更新的时候不会篡改掉原有的解析内容字段。</JSONObject></p><p>但是更优雅的做法是自定义 typeHandler。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一定要加这两行注解</span></span><br><span class="line"><span class="meta">@MappedTypes(List.class)</span></span><br><span class="line"><span class="meta">@MappedJdbcTypes(JdbcType.VARCHAR)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonObjectListTypeHandler</span> <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;List&lt;JSONObject&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, List&lt;JSONObject&gt; parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(parameter);</span><br><span class="line">ps.setString(i, json);</span><br><span class="line">&#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;Error converting List&lt;JSONObject&gt; to json&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;JSONObject&gt; <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"><span class="keyword">return</span> parseJson(rs.getString(columnName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;JSONObject&gt; <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"><span class="keyword">return</span> parseJson(rs.getString(columnIndex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;JSONObject&gt; <span class="title function_">getNullableResult</span><span class="params">(CallableStatement cs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"><span class="keyword">return</span> parseJson(cs.getString(columnIndex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;JSONObject&gt; <span class="title function_">parseJson</span><span class="params">(String json)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isNotEmpty(json))&#123;</span><br><span class="line"><span class="keyword">return</span> mapper.readValue(json, List.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;Error converting json to List&lt;JSONObject&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再在实体类加上注解（注意这都是必须添加上的，缺一不可）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;func_bid_doc_analysis&quot;,autoResultMap = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FuncBidDocAnalysis</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(typeHandler = JsonObjectListTypeHandler.class)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;JSONObject&gt; analyzeContent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个小小的需求，就涵盖了很多的技术要点。把功能实现很容易，难得是怎么把功能完善合理，节省花销，创造更大的收益，让用户体验更佳。很少做这种 to C 的需求，希望借此机会多积累点经验值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一键解标功能需求分析&quot;&gt;&lt;a href=&quot;#一键解标功能需求分析&quot; class=&quot;headerlink&quot; title=&quot;一键解标功能需求分析&quot;&gt;&lt;/a&gt;一键解标功能需求分析&lt;/h1&gt;&lt;p&gt;需求说明：&lt;/p&gt;
&lt;p&gt;1.明月AI标讯平台导航栏新增菜单“招标解读”&lt;/</summary>
      
    
    
    
    
    <category term="场景设计" scheme="https://palette-k.github.io/tags/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket的使用场景</title>
    <link href="https://palette-k.github.io/2024/05/07/websocket%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://palette-k.github.io/2024/05/07/websocket%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2024-05-07T02:08:08.000Z</published>
    <updated>2024-05-07T08:50:06.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>HTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。</p><p>优点：</p><ul><li><p>支持双向通信，实时性更强。</p></li><li><p>更好的二进制支持。</p></li><li><p>较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。</p></li><li><p>支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等</p></li></ul><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>websocket是前后端通过长连接通信的常用解决方案，相比于定时轮询的方式，突出的就是一个时效性，对于消息的接收和推送是实时的。</p><p>什么场景下会用到 websocket 呢？</p><h2 id="站内信"><a href="#站内信" class="headerlink" title="站内信"></a>站内信</h2><p>websocket 的双向通信能让我们迅速联想到实时聊天、点赞评论通知、站内信等等，那接下来就具体讲讲使用 websocket 实现站内信的设计思路。</p><p>分布式场景下，当服务端由于访问压力过高，启动两个服务的时候，那么客户端连接就会出现 session 不共享的问题，在服务端B上根本没有客户端a的session信息，那么必然是不能进行发送的：</p><p><img src="https://i0.hdslb.com/bfs/article/5310eac35d9d8bd4fd9e966cf7b0e010171301454.png" alt="image-20240507145005489"></p><h3 id="redis-websocket-springboot"><a href="#redis-websocket-springboot" class="headerlink" title="redis+websocket+springboot"></a>redis+websocket+springboot</h3><p>使用 redis 可以很好地解决这个问题，还记得登录时也遇到过 session 不共享地问题吗？那也是使用 redis + JWT 来解决的。</p><p><img src="https://i0.hdslb.com/bfs/article/c74cea2682aebf00947912ee97f94a6f171301454.png" alt="image-20240507150417178"></p><p>redis 监听配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>： redis监听配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：weirx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>：2021/3/22 14:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>：3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * description: 手动注册Redis监听到IOC</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisConnectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: org.springframework.data.redis.listener.RedisMessageListenerContainer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>: weirx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@time</span>: 2021/3/22 14:11</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisMessageListenerContainer <span class="title function_">redisMessageListenerContainer</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="type">RedisMessageListenerContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisMessageListenerContainer</span>();</span><br><span class="line">        container.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webSocket配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>： websocket配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：weirx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>：2021/3/22 14:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>：3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * description: 这个配置类的作用是要注入ServerEndpointExporter，</span></span><br><span class="line"><span class="comment">     * 这个bean会自动注册使用了<span class="doctag">@ServerEndpoint</span>注解声明的Websocket endpoint。</span></span><br><span class="line"><span class="comment">     * 如果是使用独立的servlet容器，而不是直接使用springboot的内置容器，</span></span><br><span class="line"><span class="comment">     * 就不要注入ServerEndpointExporter，因为它将由容器自己提供和管理。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: org.springframework.web.socket.server.standard.ServerEndpointExporter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>: weirx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@time</span>: 2021/3/22 14:12</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerEndpointExporter <span class="title function_">serverEndpointExporter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerEndpointExporter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        stringRedisTemplate.convertAndSend(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义SubscribeListener监听，实现MessageListener接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.ObjectUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.MessageListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>： redis监听</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：weirx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>：2021/3/22 14:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>：3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscribeListener</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前websocket的session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Session <span class="title function_">getSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSession</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.session = session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtil.isNotEmpty(session) &amp;&amp; session.isOpen()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.getBasicRemote().sendText(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;发送消息异常，msg = &#123;&#125; , e = &#123;&#125;&quot;</span>, msg, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebSocket服务提供类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description: <span class="doctag">@ServerEndpoint</span> 注解是一个类层次的注解，</span></span><br><span class="line"><span class="comment"> * 它的功能主要是将目前的类定义成一个websocket服务器端,注解的值将被用于监听用户连接的终端访问URL地址,</span></span><br><span class="line"><span class="comment"> * 客户端可以通过这个URL来连接到WebSocket服务器端使用springboot的唯一区别是要<span class="doctag">@Component</span>声明下，</span></span><br><span class="line"><span class="comment"> * 而使用独立容器是由容器自己管理websocket的，但在springboot中连容器都是spring管理的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: weirx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021/3/22 14:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/websocket/server/&#123;loginName&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为<span class="doctag">@ServerEndpoint</span>不支持注入，所以使用SpringUtils获取IOC实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RedisMessageListenerContainer</span> <span class="variable">redisMessageListenerContainer</span> <span class="operator">=</span></span><br><span class="line">            ApplicationContextProvider.getBean(RedisMessageListenerContainer.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">onlineCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * concurrent包的线程安全Set，用来存放每个客户端对应的webSocket对象。</span></span><br><span class="line"><span class="comment">     * 若要实现服务端与单一客户端通信的话，可以使用Map来存放，其中Key可以为用户标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;WebSocketServer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis监听</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SubscribeListener subscribeListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 可选的参数。session为与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(<span class="meta">@PathParam(&quot;loginName&quot;)</span> String loginName, Session session)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.session = session;</span><br><span class="line">        <span class="comment">//加入set中</span></span><br><span class="line">        webSocketSet.add(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//在线数加1</span></span><br><span class="line">        addOnlineCount();</span><br><span class="line">        log.info(<span class="string">&quot;有新连接[&quot;</span> + loginName + <span class="string">&quot;]加入！当前在线人数为&#123;&#125;&quot;</span>, getOnlineCount());</span><br><span class="line">        subscribeListener = <span class="keyword">new</span> <span class="title class_">SubscribeListener</span>();</span><br><span class="line">        subscribeListener.setSession(session);</span><br><span class="line">        <span class="comment">//设置订阅topic</span></span><br><span class="line">        redisMessageListenerContainer.addMessageListener(</span><br><span class="line">                subscribeListener, <span class="keyword">new</span> <span class="title class_">ChannelTopic</span>(Constants.TOPIC_PREFIX + loginName));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//从set中删除</span></span><br><span class="line">        webSocketSet.remove(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//在线数减1</span></span><br><span class="line">        subOnlineCount();</span><br><span class="line">        redisMessageListenerContainer.removeMessageListener(subscribeListener);</span><br><span class="line">        log.info(<span class="string">&quot;有一连接关闭！当前在线人数为&#123;&#125;&quot;</span>, getOnlineCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 可选的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;来自客户端的消息:&#123;&#125;&quot;</span>, message);</span><br><span class="line">        <span class="comment">//群发消息</span></span><br><span class="line">        <span class="keyword">for</span> (WebSocketServer item : webSocketSet) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                item.sendMessage(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;发送消息异常：msg = &#123;&#125;&quot;</span>, e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生错误时调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable error)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;发生错误，&#123;&#125;&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法与上面几个方法不一样。没有用注解，是根据自己需要添加的方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOnlineCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> onlineCount.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOnlineCount</span><span class="params">()</span> &#123;</span><br><span class="line">        WebSocketServer.onlineCount.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subOnlineCount</span><span class="params">()</span> &#123;</span><br><span class="line">        WebSocketServer.onlineCount.getAndDecrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis消息发布：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">send</span><span class="params">(String loginName, String msg)</span> &#123;</span><br><span class="line">    <span class="comment">//推送站内信webSocket</span></span><br><span class="line">    redisUtil.publish(<span class="string">&quot;TOPIC&quot;</span> + loginName, msg);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h3><p>springcloud gateway是目前在微服务当中使用较为广泛的网关，我们可以通过以下配置达到websocket的动态代理： 静态路由配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">websocket</span>  <span class="comment"># 路由 ID，保持唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb:ws://inbox-model</span> <span class="comment"># uri指目标服务地址，lb代表从注册中心获取服务</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/websocket/server/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=0</span></span><br></pre></td></tr></table></figure><p>动态路由配置：使用动态路由，需要网关支持且开放动态路由功能</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;:</span> <span class="string">&quot;websocket&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;order&quot;:</span> <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;predicates&quot;:</span> [&#123;</span><br><span class="line">        <span class="attr">&quot;args&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;pattern&quot;:</span> <span class="string">&quot;/websocket/server/**&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;Path&quot;</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="attr">&quot;uri&quot;:</span> <span class="string">&quot;lb:ws://inbox-model&quot;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>nginx 配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /websocket &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://gateway;</span><br><span class="line">    <span class="comment">#以下三项是官方指定配置</span></span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">    <span class="comment">#超时时间的配置，如果不配置，在一段时间内会导致客户端接收不到消息，根据登录session的超时时间保持一致就行</span></span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">3600s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h3><h4 id="系统通知-System-Notice"><a href="#系统通知-System-Notice" class="headerlink" title="系统通知(System Notice)"></a><strong>系统通知(System Notice)</strong></h4><p>系统通知一般是由后台管理员发出，然后指定某一类（全体，个人等）用户接收。基于此设想，可以把系统通知大致分为两张表：</p><ol><li><strong>t_manager_system_notice（管理员系统通知表）</strong> ：记录管理员发出的通知 ；</li><li><strong>t_user_system_notice（用户系统通知表）</strong> ： 存储用户接受的通知。</li></ol><p>t_manager_system_notice（管理员系统通知表）</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>system_notice_id</td><td>bigint</td><td>系统通知id</td></tr><tr><td>title</td><td>varchar</td><td>标题</td></tr><tr><td>content</td><td>text</td><td>内容</td></tr><tr><td>type</td><td>varchar</td><td>发送用户群体：single,all,vip</td></tr><tr><td>state</td><td>tinyint</td><td>是否被拉取过</td></tr><tr><td>recipient_id</td><td>bigint</td><td>接收通知的用户id，若type不是single，则该值为0</td></tr><tr><td>manager_id</td><td>bigint</td><td>发布通知的管理员id</td></tr><tr><td>publish_time</td><td>timestamp</td><td>发布时间</td></tr></tbody></table><p>t_user_system_notice（用户系统通知表）</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>user_notice_id</td><td>bigint</td><td>主键id</td></tr><tr><td>state</td><td>tinyint</td><td>是否已读</td></tr><tr><td>system_notice_id</td><td>bigint</td><td>系统通知的id</td></tr><tr><td>recipient_id</td><td>bigint</td><td>接收通知的用户id</td></tr><tr><td>pull_time</td><td>timstamp</td><td>拉取时间</td></tr></tbody></table><p><strong>当管理员发布一条通知后，将通知插入 t_manager_system_notice 表中，然后系统定时的从 t_manager_system_notice 表中拉取通知，然后根据通知的 type 将通知插入 t_user_system_notice 表中。</strong></p><p>如果通知的 type 是 single 的，那就只需要插入一条记录到 t_user_system_notice 中。如果是全体用户，那么就需要将一个通知批量根据不同的用户 ID 插入到 t_user_system_notice 中，这个数据量就需要根据平台的用户量来计算。</p><p>举个例子： 管理员 A 发布了一个活动的通知，他需要将这个通知发布给全体用户，当拉取时间到来时，系统会将这一条通知取出。随后系统到用户表中查询选取所有用户的 ID，然后将这一条通知的信息根据所有用户的 ID，批量插入 t_user_system_notice 中。用户需要查看系统通知时，从 t_user_system_notice 表中查询就行了。</p><p>注意：</p><ol><li>因为一次拉取的数据量可能很大，所以两次拉取的时间间隔可以设置的长一些。</li><li><strong>拉取 t_manager_system_notice 表中的通知时，需要判断 state，如果已经拉取过，就不需要重复拉取， 否则会造成重复消费。</strong></li></ol><h4 id="事件提醒-EventRemind"><a href="#事件提醒-EventRemind" class="headerlink" title="事件提醒(EventRemind)"></a><strong>事件提醒(EventRemind)</strong></h4><p>之所以称提醒类型的消息为事件提醒，是因为此类消息均是通过用户的行为产生的，如下：</p><ul><li>xxx 在某个评论中@了你；</li><li>xxx 点赞了你的文章；</li><li>xxx 点赞了你的评论；</li><li>xxx 回复了你的文章；</li><li>xxx 回复了你的评论。</li></ul><p>事件提醒表 t_event_remind</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>event_remind_id</td><td>bigint</td><td>消息id</td></tr><tr><td>action</td><td>varchar</td><td>动作类型，如点赞、艾特、回复等</td></tr><tr><td>source_id</td><td>bigint</td><td>事件源id，如评论id、文章id</td></tr><tr><td>source_type</td><td>varchar</td><td>事件源类型：comment、post等</td></tr><tr><td>source_content</td><td>varchar</td><td>事件源内容，比如回复的内容、评论等</td></tr><tr><td>url</td><td>varchar</td><td>事件所发生的地点链接 url</td></tr><tr><td>state</td><td>tinyint</td><td>是否已读</td></tr><tr><td>sender_id</td><td>bigint</td><td>操作者id，即谁关注了你、at了你</td></tr><tr><td>recipient_id</td><td>bigint</td><td>接受通知的用户id</td></tr><tr><td>remind_time</td><td>timestatmp</td><td>提醒时间</td></tr></tbody></table><h5 id="消息聚合"><a href="#消息聚合" class="headerlink" title="消息聚合"></a><strong>消息聚合</strong></h5><p>消息聚合只适用于事件提醒，以聚合之后的点赞消息来说：</p><ul><li>100 人 {点赞} 了你的 {文章 ID &#x3D; 1} ：《A》；</li><li>100 人 {点赞} 了你的 {文章 ID &#x3D; 2} ：《B》；</li><li>100 人 {点赞} 了你的 {评论 ID &#x3D; 3} ：《C》；</li></ul><p>聚合之后的消息明显有两个特征，即：action 和 source type，这是系统消息和私信都不具备的， 所以我个人认为事件提醒的设计要稍微比系统消息和私信复杂。</p><p><strong>如何聚合？</strong></p><p>稍稍观察下聚合的消息就可以发现：某一类的聚合消息之间是按照 source type 和 source id 来分组的， 因此我们可以得出以下伪 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_event_remind <span class="keyword">WHERE</span> recipient_id <span class="operator">=</span> 用户ID</span><br><span class="line"><span class="keyword">AND</span> action <span class="operator">=</span> 点赞 <span class="keyword">AND</span> state <span class="operator">=</span> <span class="literal">FALSE</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> source_id , source_type;</span><br></pre></td></tr></table></figure><p>SQL 层面的结果集处理还是很麻烦的，所以我的想法先把用户所有的点赞消息先查出来， 然后在程序里面进行分组，这样会简单不少。</p><h5 id="站内消息系统的设计"><a href="#站内消息系统的设计" class="headerlink" title="站内消息系统的设计"></a>站内消息系统的设计</h5><p>聊天室表 t_private_chat</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>private_chat_id</td><td>bigint</td><td>聊天室id</td></tr><tr><td>user1_id</td><td>bigint</td><td>用户1的id</td></tr><tr><td>user2_id</td><td>bigint</td><td>用户2的id</td></tr><tr><td>last_message</td><td>varchar</td><td>最后一条消息的内容</td></tr></tbody></table><p>私信表 t_private_message</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>private_message_id</td><td>bigint</td><td>私信id</td></tr><tr><td>content</td><td>text</td><td>私信内容</td></tr><tr><td>state</td><td>tinyint</td><td>是否已读</td></tr><tr><td>sender_remove</td><td>tinyint</td><td>发送消息的人是否删除掉了这条消息</td></tr><tr><td>recipient_remove</td><td>tinyint</td><td>接受人是否把这条消息从聊天记录删除</td></tr><tr><td>sender_id</td><td>bigint</td><td>发送者id</td></tr><tr><td>recipent_id</td><td>bigint</td><td>接收者id</td></tr><tr><td>send_time</td><td>timestamp</td><td>发送时间</td></tr></tbody></table><h5 id="消息设置"><a href="#消息设置" class="headerlink" title="消息设置"></a>消息设置</h5><p>可以看到 b 站还添加了陌生人选项，也就是说如果给你发送私信的用户不是你关注的用户，那么视之为陌生人私信，就不接受。</p><p>以下是我对于消息设置的设计：</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>user_id</td><td>bigint</td><td>用户id</td></tr><tr><td>like_message</td><td>tinyint</td><td>是否接收点赞消息</td></tr><tr><td>reply_message</td><td>tinyint</td><td>是否接收回复消息</td></tr><tr><td>at_message</td><td>tinyint</td><td>是否接收at消息</td></tr><tr><td>stranger_message</td><td>tinyint</td><td>是否接收陌生人私信</td></tr></tbody></table><h3 id="扩展性设计"><a href="#扩展性设计" class="headerlink" title="扩展性设计"></a>扩展性设计</h3><p>实现了站内信功能以后，要是以后需要实现邮件、短信呢？拿到一个需求进行功能设计的时候，往往需要考虑其扩展性。</p><p>为了给这个需求后续的扩展附加功能，同时代码的改动最小化，我们可以引入策略模式来实现。</p><ul><li>消息类型分为：站内信，短信，邮件</li><li>推送范围分为：个人，组织机构，地域，用户组</li></ul><p>定义抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ISendMessageService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description: 发送</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: com.botany.spore.core.result.Result</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: weirx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021/3/18 13:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inboxMessageTemplateDOMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> personMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inboxBusinessConfigDO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> claimUser</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Result <span class="title function_">send</span><span class="params">(InboxMessageTemplateDO inboxMessageTemplateDOMap, Map&lt;String, Object&gt; personMap,</span></span><br><span class="line"><span class="params">                            InboxBusinessConfigDO inboxBusinessConfigDO, String claimUser)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用发消息时，如何使用？又如何确定我发送的是何种消息，走哪个实现类？看如下调用位置代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String messageType, Map&lt;String, InboxMessageTemplateDO&gt; templateDOMap,</span></span><br><span class="line"><span class="params">                         Map&lt;String, Object&gt; personListByPushRange, InboxBusinessConfigDO inboxBusinessConfigDO, String username)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (String msgType : messageType.split(Constants.COMMA)) &#123;</span><br><span class="line">        <span class="type">ISendMessageService</span> <span class="variable">sendMessageService</span> <span class="operator">=</span></span><br><span class="line">                SendMessageTypeEnum.newInstance(SendMessageTypeEnum.getEnum(msgType));</span><br><span class="line">        sendMessageService.send(templateDOMap.get(msgType), personListByPushRange, inboxBusinessConfigDO, username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类内部：根据不同的code会返回不同的bean实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 站内信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MESSAGE(<span class="string">&quot;sendMessageService&quot;</span>, <span class="string">&quot;站内信&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ISendMessageService <span class="title function_">create</span><span class="params">(String code)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (ISendMessageService) ApplicationContextProvider.getBean(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到上面为止，一个简单的策略模式就完成了。假如我们后面扩展微信，那么只需要新增实现类，同时在枚举中添加新的枚举就好了，不需要修改整个发送消息业务代码。同理，推送范围也是如此。</p><h2 id="平台与客户端通信"><a href="#平台与客户端通信" class="headerlink" title="平台与客户端通信"></a>平台与客户端通信</h2><p>RPA项目中，启动一个RPA应用实际上是通过xxl-job的executor执行器，而xxl-job内定位到的执行器都是内网ip，那平台侧是怎么找到指定的执行器的呢？</p><p>这其中就存在平台侧和客户端侧的通信了。实际上，只要在xxl-job上建立一个与客户端通信的长链接，那么客户端的回调、注册等操作都能被监测到，而且平台也能指使客户端去做一些操作，不需要将平台和客户端放到同一个网段下。</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * websocket 服务端处理类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rpa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/15 13:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ServerEndpoint(path = &quot;$&#123;websocket.path&#125;&quot;, port = &quot;$&#123;websocket.port&#125;&quot;, maxFramePayloadLength = &quot;$&#123;websocket.maxFramePayloadLength&#125;&quot;, bossLoopGroupThreads = &quot;$&#123;websocket.bossLoopGroupThreads&#125;&quot;, workerLoopGroupThreads = &quot;$&#123;websocket.workerLoopGroupThreads&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerWebSocketEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 握手前调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@BeforeHandshake</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handshake</span><span class="params">(Session session, HttpHeaders headers)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> headers.get(ExecutorConstant.WEBSOCKET_HEADER_CLIENT_ID);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(clientId))&#123;</span><br><span class="line">            <span class="comment">// 校验 token</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> headers.get(ExecutorConstant.WEBSOCKET_HEADER_AUTHORIZATION);</span><br><span class="line">            <span class="type">String</span> <span class="variable">tenantCode</span> <span class="operator">=</span> headers.get(ExecutorConstant.WEBSOCKET_HEADER_TENANT_CODE);</span><br><span class="line"></span><br><span class="line">            ReturnT&lt;String&gt; t = JwtRsaUtil.verifyToken(token, tenantCode);</span><br><span class="line">            <span class="keyword">if</span>(t.getCode() == ReturnT.SUCCESS_CODE)&#123;</span><br><span class="line">                <span class="comment">// 缓存 clientId、username</span></span><br><span class="line">                session.setAttribute(AdminConstant.WEBSOCKET_ATTR_CLIENT_ID, clientId);</span><br><span class="line">                session.setAttribute(AdminConstant.WEBSOCKET_ATTR_USERNAME, t.getContent());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接成功后调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> session.getAttribute(AdminConstant.WEBSOCKET_ATTR_CLIENT_ID);</span><br><span class="line">        log.info(<span class="string">&quot;websocket连接建立，连接管理器加入对应连接：clientId:&#123;&#125;&quot;</span>, clientId);</span><br><span class="line">        ServerSessionManager.add(clientId, session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> payload 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Session session, String payload)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> session.getAttribute(AdminConstant.WEBSOCKET_ATTR_CLIENT_ID);</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">decrypt</span> <span class="operator">=</span> AesUtil.decrypt(payload, clientId);</span><br><span class="line">        <span class="keyword">if</span>(decrypt != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> JSON.parseObject(decrypt, Message.class);</span><br><span class="line">            <span class="keyword">if</span>(message.isAnswer())&#123;</span><br><span class="line">                <span class="built_in">this</span>.handleResponse(message);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.handleRequest(message, session);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">eventId</span> <span class="operator">=</span> message.getEventId();</span><br><span class="line">        <span class="keyword">if</span>(eventId != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">MessageContext</span> <span class="variable">messageContext</span> <span class="operator">=</span> ServerSessionManager.messageContextMap.get(eventId);</span><br><span class="line">            <span class="keyword">if</span>(messageContext != <span class="literal">null</span>)&#123;</span><br><span class="line">                messageContext.setResponse(message.getBody());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                log.warn(<span class="string">&quot;收到响应时，请求已断开：message:&#123;&#125;&quot;</span>, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;响应消息缺少事件id：message:&#123;&#125;&quot;</span>, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Message message, Session session)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> message.getPath(), eventId = message.getEventId(), body = message.getBody();</span><br><span class="line">        <span class="type">ReturnT</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (AdminConstant.INTERFACE_URL_CALLBACK.equals(uri)) &#123;</span><br><span class="line">                List&lt;HandleCallbackParam&gt; callbackParamList = GsonTool.fromJson(body, List.class, HandleCallbackParam.class);</span><br><span class="line">                t = XxlJobAdminConfig.getAdminConfig().getAdminBiz().callback(callbackParamList);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AdminConstant.INTERFACE_URL_REGISTRY.equals(uri)) &#123;</span><br><span class="line">                <span class="type">RegistryParam</span> <span class="variable">registryParam</span> <span class="operator">=</span> GsonTool.fromJson(body, RegistryParam.class);</span><br><span class="line">                t = XxlJobAdminConfig.getAdminConfig().getAdminBiz().registry(registryParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AdminConstant.INTERFACE_URL_REGISTRY_REMOVE.equals(uri)) &#123;</span><br><span class="line">                <span class="type">RegistryParam</span> <span class="variable">registryParam</span> <span class="operator">=</span> GsonTool.fromJson(body, RegistryParam.class);</span><br><span class="line">                t = XxlJobAdminConfig.getAdminConfig().getAdminBiz().registryRemove(registryParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AdminConstant.INTERFACE_URL_TASK_LIST.equals(uri))&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> GsonTool.fromJson(body, String.class);</span><br><span class="line">                t = XxlJobAdminConfig.getAdminConfig().getAdminBiz().taskList(clientId);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                t = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;invalid request, uri-mapping(&quot;</span>+ uri +<span class="string">&quot;) not found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;websocket请求处理异常：message:&#123;&#125;; error:&#123;&#125;&quot;</span>, message, e.getMessage());</span><br><span class="line">            t = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> session.getAttribute(AdminConstant.WEBSOCKET_ATTR_CLIENT_ID);</span><br><span class="line">        ServerSessionManager.response(clientId, eventId, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwable 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> session.getAttribute(AdminConstant.WEBSOCKET_ATTR_CLIENT_ID);</span><br><span class="line">        log.warn(<span class="string">&quot;websocket连接发生异常：clientId:&#123;&#125;; error:&#123;&#125;&quot;</span>, clientId, throwable.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> session.getAttribute(AdminConstant.WEBSOCKET_ATTR_CLIENT_ID);</span><br><span class="line">        <span class="keyword">if</span>(clientId != <span class="literal">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;websocket连接关闭，连接管理器移除对应连接：clientId:&#123;&#125;&quot;</span>, clientId);</span><br><span class="line">            ServerSessionManager.remove(clientId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * websocket 客户端处理类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rpa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/15 13:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketClientHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractWebSocketHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 执行器 */</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorBiz executorBiz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WebSocketClientHandler</span><span class="params">(ExecutorBiz executorBiz)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executorBiz = executorBiz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接成功后调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span>&#123;</span><br><span class="line">        <span class="comment">// 设置传入的文本最大限制</span></span><br><span class="line">        session.setTextMessageSizeLimit(ExecutorConstant.WEBSOCKET_INCOMING_TEXT_MAXIMUM_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到文本消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> textMessage 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage textMessage)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> session.getHandshakeHeaders().getFirst(ExecutorConstant.WEBSOCKET_HEADER_CLIENT_ID);</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> textMessage.getPayload();</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">decrypt</span> <span class="operator">=</span> AesUtil.decrypt(payload, clientId);</span><br><span class="line">        <span class="keyword">if</span>(decrypt != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> JSON.parseObject(decrypt, Message.class);</span><br><span class="line">            <span class="keyword">if</span>(message.isAnswer())&#123;</span><br><span class="line">                <span class="built_in">this</span>.handleResponse(message);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.handleRequest(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">eventId</span> <span class="operator">=</span> message.getEventId();</span><br><span class="line">        <span class="keyword">if</span>(eventId != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">MessageContext</span> <span class="variable">messageContext</span> <span class="operator">=</span> WebSocketClient.messageContextMap.get(eventId);</span><br><span class="line">            <span class="keyword">if</span>(messageContext != <span class="literal">null</span>)&#123;</span><br><span class="line">                messageContext.setResponse(message.getBody());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                log.warn(<span class="string">&quot;收到响应时，请求已断开：message:&#123;&#125;&quot;</span>, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;响应消息缺少事件id：message:&#123;&#125;&quot;</span>, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> message.getPath(), eventId = message.getEventId(), body = message.getBody();</span><br><span class="line">        <span class="type">ReturnT</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ExecutorConstant.INTERFACE_URL_BEAT.equals(uri)) &#123;</span><br><span class="line">                t = executorBiz.beat();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorConstant.INTERFACE_URL_IDLE_BEAT.equals(uri)) &#123;</span><br><span class="line">                <span class="type">IdleBeatParam</span> <span class="variable">idleBeatParam</span> <span class="operator">=</span> GsonTool.fromJson(body, IdleBeatParam.class);</span><br><span class="line">                t = executorBiz.idleBeat(idleBeatParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorConstant.INTERFACE_URL_GLOBAL_IDLE_BEAT.equals(uri)) &#123;</span><br><span class="line">                <span class="type">IdleBeatParam</span> <span class="variable">idleBeatParam</span> <span class="operator">=</span> GsonTool.fromJson(body, IdleBeatParam.class);</span><br><span class="line">                t = executorBiz.globalIdleBeat(idleBeatParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorConstant.INTERFACE_URL_RUN.equals(uri)) &#123;</span><br><span class="line">                <span class="type">TriggerParam</span> <span class="variable">triggerParam</span> <span class="operator">=</span> GsonTool.fromJson(body, TriggerParam.class);</span><br><span class="line">                t = executorBiz.run(triggerParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorConstant.INTERFACE_URL_KILL.equals(uri)) &#123;</span><br><span class="line">                <span class="type">KillParam</span> <span class="variable">killParam</span> <span class="operator">=</span> GsonTool.fromJson(body, KillParam.class);</span><br><span class="line">                t = executorBiz.kill(killParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorConstant.INTERFACE_URL_LOG.equals(uri)) &#123;</span><br><span class="line">                <span class="type">LogParam</span> <span class="variable">logParam</span> <span class="operator">=</span> GsonTool.fromJson(body, LogParam.class);</span><br><span class="line">                t = executorBiz.log(logParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;invalid request, uri-mapping(&quot;</span>+ uri +<span class="string">&quot;) not found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;websocket请求处理异常：message:&#123;&#125;; error:&#123;&#125;&quot;</span>, message, e.getMessage());</span><br><span class="line">            t = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        WebSocketClient.response(eventId, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwable 异常信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleTransportError</span><span class="params">(WebSocketSession session, Throwable throwable)</span>&#123;</span><br><span class="line">        log.warn(<span class="string">&quot;websocket连接发生异常：sessionId:&#123;&#125;; error:&#123;&#125;&quot;</span>, session.getId(), throwable.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> closeStatus 关闭状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus closeStatus)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;websocket连接关闭：sessionId:&#123;&#125;&quot;</span>, session.getId());</span><br><span class="line">        WebSocketClient.removeSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否支持分片消息（不支持）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsPartialMessages</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定时任务清除长连接"><a href="#定时任务清除长连接" class="headerlink" title="定时任务清除长连接"></a>定时任务清除长连接</h2><p>如果项目中引用了 websocket，往往需要有个定时任务定期清除websocket的长链接。原因就是，比如用户直接关掉了浏览器，这样后端没有办法知道这个长链接已经关闭了，所以需要定期清除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * websocket会话缓存管理</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@author</span> heshengsheng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardSessionCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会话缓存，可以多开窗口，即一个用户可以同时有多个websocket连接，存储结构是ConcurrentMap中存放Set，map的key是一个用户，set集合中是一个用户的多个websocket连接</span></span><br><span class="line"><span class="comment">     * 用非线程安全的set原因：即使用线程安全的set，也无法保证set和map跨集合操作的数据一致性（即线程安全的set仅保证单个集合操作的线程安全），多个集合操作的数据一致性需要自己加锁实现，既然自己要加更大粒度的锁保证数据的一致性，就无需用线程安全的set（普通set性能更高）</span></span><br><span class="line"><span class="comment">     * 关于synchronized的性能：set是每个key（用户）一个，对每个key的set加锁竞争极小，synchronized有一个锁升级的过程，没有竞争的时候是偏向锁（偏向锁是在对象头上做标记，不会产生系统调用），不影响性能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;String, Set&lt;Session&gt;&gt; sessionSetMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Set&lt;Session&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sessionSetMap中key的拼装规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getUserKey</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加会话到缓存，多线程安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addSession</span><span class="params">(Long userId, Session session)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getUserKey(userId);</span><br><span class="line">        addSession(key, session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addSession</span><span class="params">(String key, Session session)</span> &#123;</span><br><span class="line">        addSession(key, session, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addSession</span><span class="params">(String key, Session session, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="type">Set</span> <span class="variable">sessionSet</span> <span class="operator">=</span> sessionSetMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (sessionSet == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//没有key</span></span><br><span class="line">            sessionSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">            sessionSet.add(session);</span><br><span class="line">            <span class="comment">//新增成功返回null，失败返回原来的Set（前面虽然读取到没有key，但是可能有多个线程同时新增，所以要用putIfAbsent）</span></span><br><span class="line">            <span class="type">Set</span> <span class="variable">putSet</span> <span class="operator">=</span> sessionSetMap.putIfAbsent(key, sessionSet);</span><br><span class="line">            <span class="keyword">if</span> (putSet != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//存在key，加锁添加会话到set中（被其他线程先新增key的情况）</span></span><br><span class="line">                addSessionLock(putSet, key, session, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//存在key，加锁添加会话到set中</span></span><br><span class="line">            addSessionLock(sessionSet, key, session, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁添加会话到set中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addSessionLock</span><span class="params">(Set sessionSet, String key, Session session, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="comment">//用set对象加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (sessionSet) &#123;</span><br><span class="line">            <span class="comment">//双重检测（加锁成功之前，set可能被其他线程remove）</span></span><br><span class="line">            <span class="keyword">if</span> (sessionSet == sessionSetMap.get(key)) &#123;</span><br><span class="line">                <span class="comment">//set没有变化，添加session</span></span><br><span class="line">                sessionSet.add(session);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//set有变化，重试操作（避免意外问题，最多操作10次）</span></span><br><span class="line">                <span class="keyword">if</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                    addSession(key, session, ++count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存中的会话，多线程安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeSession</span><span class="params">(Long userId, Session session)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getUserKey(userId);</span><br><span class="line">        removeSession(key, session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeSession</span><span class="params">(String key, Session session)</span> &#123;</span><br><span class="line">        <span class="type">Set</span> <span class="variable">sessionSet</span> <span class="operator">=</span> sessionSetMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (sessionSet != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//存在key，用set对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (sessionSet) &#123;</span><br><span class="line">                <span class="comment">//删除session</span></span><br><span class="line">                sessionSet.remove(session);</span><br><span class="line">                <span class="keyword">if</span> (sessionSet.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//set大小为0，删除key</span></span><br><span class="line">                    sessionSetMap.remove(key, sessionSet);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按key发送信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendByKey</span><span class="params">(Long userId, String msg)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getUserKey(userId);</span><br><span class="line">        sendByKey(key, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendByKey</span><span class="params">(String key, String msg)</span> &#123;</span><br><span class="line">        Set&lt;Session&gt; sessionSet = sessionSetMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (sessionSet != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//读取的时候加锁（synchronized没有竞争的时候是偏向锁，不影响性能）</span></span><br><span class="line">            <span class="keyword">synchronized</span> (sessionSet) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Session session : sessionSet) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                            session.getAsyncRemote().sendText(msg);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.warn(<span class="string">&quot;sendByKey error, key:&#123;&#125;, session:&#123;&#125;, msg:&#123;&#125;&quot;</span>, key, session, msg, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除缓存中已关闭的会话（定时任务调用，避免缓存中有未删除的已关闭会话，可以半小时到1小时调用一次）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clearClosedSession</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;clearClosedSession 执行前map size:&#123;&#125;&quot;</span>, sessionSetMap.size());</span><br><span class="line">        <span class="keyword">for</span> (String key : sessionSetMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Set&lt;Session&gt; sessionSet = sessionSetMap.get(key);</span><br><span class="line">                <span class="keyword">if</span> (sessionSet != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//读取的时候加锁（synchronized没有竞争的时候是偏向锁，不影响性能）</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (sessionSet) &#123;</span><br><span class="line">                        <span class="comment">//没有数据就清除</span></span><br><span class="line">                        <span class="keyword">if</span> (sessionSet.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                            sessionSetMap.remove(key, sessionSet);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Iterator&lt;Session&gt; it = sessionSet.iterator();</span><br><span class="line">                        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                            <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> it.next();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//用isOpen还是isActive判断</span></span><br><span class="line">                                <span class="keyword">if</span> (!session.isOpen()) &#123;</span><br><span class="line">                                    <span class="comment">//删除session</span></span><br><span class="line">                                    it.remove();</span><br><span class="line">                                    <span class="keyword">if</span> (sessionSet.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                                        <span class="comment">//set大小为0，删除key</span></span><br><span class="line">                                        sessionSetMap.remove(key, sessionSet);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                log.warn(<span class="string">&quot;clearClosedSession error, key:&#123;&#125;, session:&#123;&#125;&quot;</span>, key, session, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;clearClosedSession error, key:&#123;&#125;&quot;</span>, key, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;clearClosedSession 执行后map size:&#123;&#125;&quot;</span>, sessionSetMap.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;HTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="WebSocket" scheme="https://palette-k.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>序列化</title>
    <link href="https://palette-k.github.io/2024/04/30/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://palette-k.github.io/2024/04/30/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-04-30T11:28:26.000Z</published>
    <updated>2024-05-07T09:03:29.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><p>序列化是指把对象转换为字节序列的过程，我们称之为对象的序列化，就是把内存中的这些对象变成一连串的字节(bytes)描述的过程。</p><p>而反序列化则相反，就是把持久化的字节文件数据恢复为对象的过程。</p><p><strong>序列化场景：</strong></p><ul><li>需要把内存中的对象状态数据保存到一个文件或者数据库中的时候，这个场景是比较常见的，例如我们利用mybatis框架编写持久层insert对象数据到数据库中时;</li><li>网络通信时需要用套接字在网络中传送对象时，如我们使用RPC协议进行网络通信时;</li></ul><h1 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h1><p>对于JVM来说，要进行持久化的类必须要有一个标记，只有持有这个标记JVM才允许类创建的对象可以通过其IO系统转换为字节数据，从而实现持久化，而这个标记就是Serializable接口。而在反序列化的过程中则需要使用serialVersionUID来确定由那个类来加载这个对象，所以我们在实现Serializable接口的时候，一般还会要去尽量显示地定义serialVersionUID，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; </span><br></pre></td></tr></table></figure><p>在反序列化的过程中，如果接收方为对象加载了一个类，如果该对象的serialVersionUID与对应持久化时的类不同，那么反序列化的过程中将会导致InvalidClassException异常。例如，在之前反序列化的例子中，我们故意将User类的serialVersionUID改为2L，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2L</span>; </span><br></pre></td></tr></table></figure><p>那么此时，在反序例化时就会导致异常，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException: cn.wudimanong.serializable.User; local <span class="keyword">class</span> <span class="title class_">incompatible</span>: stream <span class="type">classdesc</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1</span>, local <span class="keyword">class</span> <span class="title class_">serialVersionUID</span> = <span class="number">2</span> </span><br><span class="line">    at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class="number">687</span>) </span><br><span class="line">    at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class="number">1880</span>) </span><br><span class="line">    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="number">1746</span>) </span><br><span class="line">    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="number">2037</span>) </span><br><span class="line">    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="number">1568</span>) </span><br><span class="line">    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="number">428</span>) </span><br><span class="line">    at cn.wudimanong.serializable.SerializableTest.readObj(SerializableTest.java:<span class="number">31</span>) </span><br><span class="line">    at cn.wudimanong.serializable.SerializableTest.main(SerializableTest.java:<span class="number">44</span>) </span><br></pre></td></tr></table></figure><p>如果我们在序列化中没有显示地声明serialVersionUID，则序列化运行时将会根据该类的各个方面计算该类默认的serialVersionUID值。但是，Java官方强烈建议所有要序列化的类都显示地声明serialVersionUID字段，因为如果高度依赖于JVM默认生成serialVersionUID，可能会导致其与编译器的实现细节耦合，这样可能会导致在反序列化的过程中发生意外的InvalidClassException异常。因此，为了保证跨不同Java编译器实现的serialVersionUID值的一致，实现Serializable接口的必须显示地声明serialVersionUID字段。</p><p>此外serialVersionUID字段地声明要尽可能使用private关键字修饰，这是因为该字段的声明只适用于声明的类，该字段作为成员变量被子类继承是没有用处的!有个特殊的地方需要注意的是，数组类是不能显示地声明serialVersionUID的，因为它们始终具有默认计算的值，不过数组类反序列化过程中也是放弃了匹配serialVersionUID值的要求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;序列化和反序列化&quot;&gt;&lt;a href=&quot;#序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化和反序列化&quot;&gt;&lt;/a&gt;序列化和反序列化&lt;/h1&gt;&lt;p&gt;序列化是指把对象转换为字节序列的过程，我们称之为对象的序列化，就是把内存中的这些对象变成一连</summary>
      
    
    
    
    
    <category term="序列化" scheme="https://palette-k.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>nginx的使用</title>
    <link href="https://palette-k.github.io/2024/02/18/nginx%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://palette-k.github.io/2024/02/18/nginx%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2024-02-18T10:37:44.000Z</published>
    <updated>2024-02-18T10:38:09.647Z</updated>
    
    <content type="html"><![CDATA[<p>nginx进阶：</p><p>·    正向代理和反向代理</p><p>正向代理指的是代理客户端， 代替用户向服务器发送请求， 从而隐藏用户的信息。</p><p>反向代理指的是代理服务器， 通过反向代理，服务器可以分流请求， 而且实际执行请求的服务器处于内网时， 通过反向代理服务器，也能将请求从公网转到内网。 同时隐藏了内网服务器的信息。</p><p>keepAlive</p><p>busybox</p><p>Docker desktop — 搭一个 nginx 验证</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;nginx进阶：&lt;/p&gt;
&lt;p&gt;·    正向代理和反向代理&lt;/p&gt;
&lt;p&gt;正向代理指的是代理客户端， 代替用户向服务器发送请求， 从而隐藏用户的信息。&lt;/p&gt;
&lt;p&gt;反向代理指的是代理服务器， 通过反向代理，服务器可以分流请求， 而且实际执行请求的服务器处于内网时， 通过</summary>
      
    
    
    
    
    <category term="nginx" scheme="https://palette-k.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>了解Quartz</title>
    <link href="https://palette-k.github.io/2024/02/18/%E4%BA%86%E8%A7%A3quartz/"/>
    <id>https://palette-k.github.io/2024/02/18/%E4%BA%86%E8%A7%A3quartz/</id>
    <published>2024-02-18T07:49:29.000Z</published>
    <updated>2024-02-18T08:33:40.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h1><p><strong>Quartz</strong>是一款轻量级且特性丰富的任务调度库，它是基于<strong>Java</strong>实现的调度框架，本文会针对日常任务调度的使用场景来演示<strong>Quartz</strong>的使用姿势。</p><h1 id="源码角度分析"><a href="#源码角度分析" class="headerlink" title="源码角度分析"></a>源码角度分析</h1><p>都说<strong>Quartz</strong>是任务调度框架，从源码就可以看出其本质也就是工作线程轮询并执行继续的调度任务。</p><p><strong>Quartz</strong>将任务定义为<strong>Job</strong>，Job是工作任务调度的接口，该接口定义了<strong>execute</strong>方法，所以当我们需要提交任务给<strong>Quartz</strong>时，就需要继承<strong>Job</strong>接口并在<strong>execute</strong>方法里告知要执行的任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now()</span><br><span class="line">                .format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        log.info(<span class="string">&quot;任务执行时间:&#123;&#125;&quot;</span>, dateTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了<strong>Job</strong>，就需要安排调度计划，在<strong>Quartz</strong>这个框架中，<strong>Trigger</strong>就是告知调度器如何进行任务触发的触发器，使用代码如下所示:</p><ol><li>基于<strong>JobBuilder</strong>创建job，并声称<strong>job</strong>的名称。</li><li>定义触发器，该触发器立即启动并设置名称为<strong>testTrigger</strong>，触发器属于<strong>testTriggerGroup</strong>分组中，执行计划为1秒1次。</li></ol><p>最后就是声明<strong>scheduler</strong>将触发器和任务关联，通过<strong>scheduler</strong>的<strong>scheduleJob</strong>方法关联，就会形成一个以<strong>Job</strong>为工作内容，并按照触发器的安排进行任务的调度的任务定时被调度器执行。 注意该方法还会返回第一次执行的时间，一旦调用<strong>start</strong>，当前方法调度工作就正式开始了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">// 获取任务调度的实例</span></span><br><span class="line">       <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 定义任务调度实例, 并与TestJob绑定</span></span><br><span class="line">       <span class="type">JobDetail</span> <span class="variable">job</span> <span class="operator">=</span> JobBuilder.newJob(MyJob.class)</span><br><span class="line">               .withIdentity(<span class="string">&quot;myJob&quot;</span>, <span class="string">&quot;myJobGroup&quot;</span>)</span><br><span class="line">               .build();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 定义触发器, 会马上执行一次, 接着1秒执行一次</span></span><br><span class="line">       <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">               .withIdentity(<span class="string">&quot;testTrigger&quot;</span>, <span class="string">&quot;testTriggerGroup&quot;</span>)</span><br><span class="line">               .startNow()</span><br><span class="line">               .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(<span class="number">1</span>))</span><br><span class="line">               .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用触发器调度任务的执行 获取任务调度时间</span></span><br><span class="line">       <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span>scheduler.scheduleJob(job, trigger);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 开启任务</span></span><br><span class="line">       scheduler.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看出<strong>Quartz</strong>的工作核心就是，通过<strong>Job</strong>来指定任务的详情，结合触发器<strong>Trigger</strong>指定任务的执行时间和间隔还有次数等信息，再让调度器<strong>scheduler</strong>定期去执行前两者关联而生成的定时任务。</p><h1 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h1><h2 id="Quartz横向扩展带来的问题"><a href="#Quartz横向扩展带来的问题" class="headerlink" title="Quartz横向扩展带来的问题"></a>Quartz横向扩展带来的问题</h2><p>虽说<strong>Quartz</strong>支持集群模式实现横向扩展，也就是我们常说的分布式调度，但需要业务方面通过一些手段实现节点任务执行的互斥和安全，从而避免任务重复执行等一些问题，常见的解决方案分别由数据库锁和分布式锁两种:</p><p>在调度进行任务争抢时先对数据库表上锁，只有拿到锁的节点才可以进行获取任务并调度，这种是常规情况下的解决方案，但这种实现方式有着很强的侵入性，且在高并发的场景性能表现也不是很出色，所以大部分情况下，我们不是很推荐通过数据表的形式实现分布式任务调度一致性。</p><p>通常情况下，采用<strong>redis分布式锁</strong>是针对<strong>Quartz</strong>框架分布式任务调度的较好解决方案，通过在内存中进行任务争抢，大大提分布式调度性能，但还是存在调度空跑问题，即先抢到锁的节点获取仅有的任务，而其他节点随后得锁后却没有执行任务，造成一次空跑。</p><h2 id="任务分片问题"><a href="#任务分片问题" class="headerlink" title="任务分片问题"></a>任务分片问题</h2><p>试想一个场景，原本一个节点负责调度全国系统的所有任务，随着业务激增我们将<strong>Quartz</strong>设置为集群模式，希望各个节点负责执行不同省份的任务。其他调度框架例如<strong>XXL-JOB</strong>，可以通过配置中心决定这个调度规则例如工具任务的编号知晓省份通过hash取模分配给不同的省份。</p><p><img src="https://qiniuyun.sharkchili.com/img202401081220268.png" alt="在这里插入图片描述"></p><p>而<strong>Quartz</strong>因为没有对应的页面和配置中心，所以实现任务分片需要通过硬编码的形式来实现，有着很强的代码侵入以及实现的复杂性。</p><h1 id="横向对比其他方案"><a href="#横向对比其他方案" class="headerlink" title="横向对比其他方案"></a>横向对比其他方案</h1><p>所以对于简单且较为轻量的任务调度场景，我们可优先考虑<strong>Quartz</strong>，若希望在集群环境下实现分布式调度以及任务分片等复杂的需求时，可参照下面酌情考虑这些更高效中心化的任务调度中心<strong>xxl-job</strong>或者<strong>elastic-job</strong>：</p><table><thead><tr><th>对比项</th><th align="center">Quartz</th><th align="center">elastic-job</th><th align="center">xxl-job</th></tr></thead><tbody><tr><td>集群、弹性扩容</td><td align="center">多节点，部署，通过竞争数据库锁来保证只有一个节点执行任务</td><td align="center">通过zookeeper的注册与发现，可以动态的添加服务器。支持水平扩容</td><td align="center">使用Quartz基于数据库的分布式功能，服务器超出一定数量会给数据库造成一定的压力</td></tr><tr><td>任务分片</td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td>管理界面</td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td>高级功能</td><td align="center">❌</td><td align="center">弹性扩容，多种作业模式，失效转移，运行状态收集，多线程处理数据，幂等性，容错处理，spring命名空间支持</td><td align="center">弹性扩容，分片广播，故障转移，Rolling实时日志，GLUE（支持在线编辑代码，免发布），任务进度监控，任务依赖，数据加密，邮件报警，运行报表，国际化</td></tr><tr><td>缺点</td><td align="center">没有管理界面，以及不支持任务分片等。不适用于分布式场景</td><td align="center">需要引入zookeeper，mesos，增加系统复杂度，学习成本较高</td><td align="center">调度中心通过获取DB锁来保证集群中执行任务的唯一性，如果短任务很多，随着调度中心集群数量增加，那么数据库的锁竞争会比较厉害，性能不好。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概述&quot;&gt;&lt;a href=&quot;#基本概述&quot; class=&quot;headerlink&quot; title=&quot;基本概述&quot;&gt;&lt;/a&gt;基本概述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Quartz&lt;/strong&gt;是一款轻量级且特性丰富的任务调度库，它是基于&lt;strong&gt;Java&lt;/str</summary>
      
    
    
    
    
    <category term="xxl-job" scheme="https://palette-k.github.io/tags/xxl-job/"/>
    
    <category term="quartz" scheme="https://palette-k.github.io/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>xxl-job的策略解析</title>
    <link href="https://palette-k.github.io/2024/02/09/xxl-job%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/"/>
    <id>https://palette-k.github.io/2024/02/09/xxl-job%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/</id>
    <published>2024-02-09T09:23:54.000Z</published>
    <updated>2024-02-18T11:07:45.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阻塞处理策略"><a href="#阻塞处理策略" class="headerlink" title="阻塞处理策略"></a>阻塞处理策略</h2><h3 id="单机串行（默认）"><a href="#单机串行（默认）" class="headerlink" title="单机串行（默认）"></a>单机串行（默认）</h3><p>调度进入单机执行器后，调度请求进入FIFO队列中并以串行方式运行</p><h3 id="丢弃后续调度（推荐）"><a href="#丢弃后续调度（推荐）" class="headerlink" title="丢弃后续调度（推荐）"></a>丢弃后续调度（推荐）</h3><p>调度请求进入单机执行器，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败</p><h3 id="覆盖之前调度（不推荐）"><a href="#覆盖之前调度（不推荐）" class="headerlink" title="覆盖之前调度（不推荐）"></a>覆盖之前调度（不推荐）</h3><p>调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度</p><h2 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h2><h3 id="调用核心"><a href="#调用核心" class="headerlink" title="调用核心"></a>调用核心</h3><p>要想了解路由策略在何时执行的，我们不妨从入口触发器的代码开始研究。我们找到XxlJobTrigger的trigger方法。我们在代码中看到这么一段关于路由的逻辑，我们不妨步入查看一下processTrigger做了些什么。</p><p>源码如下，由于代码比较长，笔者将代码核心部分贴出来，如下所示，它的整体步骤为:</p><ol><li>根据传入的job获取路由策略参数。</li><li>如果是分片广播则for循环调用外部传入的index获取执行器地址并调用执行器。</li><li>反之根据参数获取路由策略调用获取对应地址并调用即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processTrigger</span><span class="params">(XxlJobGroup group, XxlJobInfo jobInfo, <span class="type">int</span> finalFailRetryCount, TriggerTypeEnum triggerType, <span class="type">int</span> index, <span class="type">int</span> total)</span>&#123;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">       <span class="comment">//根据传入job获取配置的路由策略</span></span><br><span class="line">       <span class="type">ExecutorRouteStrategyEnum</span> <span class="variable">executorRouteStrategyEnum</span> <span class="operator">=</span> ExecutorRouteStrategyEnum.match(jobInfo.getExecutorRouteStrategy(), <span class="literal">null</span>);    <span class="comment">// route strategy</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3、根据路由策略找到对应执行器的地址</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       ReturnT&lt;String&gt; routeAddressResult = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (group.getRegistryList()!=<span class="literal">null</span> &amp;&amp; !group.getRegistryList().isEmpty()) &#123;</span><br><span class="line">           <span class="comment">//如果是分片广播的路由策略，则调用所有执行器执行一遍</span></span><br><span class="line">           <span class="keyword">if</span> (ExecutorRouteStrategyEnum.SHARDING_BROADCAST == executorRouteStrategyEnum) &#123;</span><br><span class="line">               <span class="keyword">if</span> (index &lt; group.getRegistryList().size()) &#123;</span><br><span class="line">                   address = group.getRegistryList().get(index);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   address = group.getRegistryList().get(<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//根据job配置信息找到对应路由策略类获取对应执行器的地址</span></span><br><span class="line">               routeAddressResult = executorRouteStrategyEnum.getRouter().route(triggerParam, group.getRegistryList());</span><br><span class="line">               <span class="keyword">if</span> (routeAddressResult.getCode() == ReturnT.SUCCESS_CODE) &#123;</span><br><span class="line">                   address = routeAddressResult.getContent();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           routeAddressResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, I18nUtil.getString(<span class="string">&quot;jobconf_trigger_address_empty&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4、trigger remote executor</span></span><br><span class="line">       ReturnT&lt;String&gt; triggerResult = <span class="literal">null</span>;</span><br><span class="line">       <span class="comment">//如果地址不为空则直接执行任务</span></span><br><span class="line">       <span class="keyword">if</span> (address != <span class="literal">null</span>) &#123;</span><br><span class="line">           triggerResult = runExecutor(triggerParam, address);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           triggerResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="literal">null</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="第一个"><a href="#第一个" class="headerlink" title="第一个"></a>第一个</h3><p>执行器地址表中的第一个</p><p>第一个：选择adressList中第一个的机器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteFirst</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(addressList.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>心跳的机制和频率</strong>：每隔30s更新一次注册表内的机器信息，删除超过90s未更新的机器，新增更新时间&gt;当前时间+90s的机器</p><blockquote><p>每5s起一个任务，该任务30s运行完毕，在第一个路由策略下如何运行？</p></blockquote><p>始终是执行器地址表中的第一个机器执行任务。</p><blockquote><p>并发任务在第一个策略和在轮询策略是怎么分配执行机器的？</p></blockquote><p>一个任务执行完成的时间超过任务调度的间隔时间， 那么就会出现并发任务的问题。</p><p>如果使用的是第一个策略， </p><p>那么，调度每次都会发往第一个机器， 当第一次任务调度还在进行中，收到第二次任务调度， 则会根据阻塞处理策略处理第二次调度， 可以单机串行， 丢弃后续调度或者覆盖当前调度。</p><p>如果使用的是轮询策略，</p><p>那么， 第一次调度和第二次调度会落在不同的机器上，任务就会并行执行。当操作相同的数据时就会遇到并发的问题。</p><p>常用的解决并发任务的方案是：单机路由策略（如：第一个、一致性哈希） + 阻塞策略（如：单机串行、丢弃后续调度或覆盖当前调度）来处理。</p><h3 id="最后一个"><a href="#最后一个" class="headerlink" title="最后一个"></a>最后一个</h3><p>执行器地址表中的最后一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteLast</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(addressList.get(addressList.size()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>每5s起一个任务，该任务30s运行完毕，在最后一个路由策略下如何运行？</p></blockquote><p>始终是执行器地址表中的最后一个机器执行任务。</p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>如果有n个执行器，轮询执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteRound</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;Integer, AtomicInteger&gt; routeCountEachJob = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">CACHE_VALID_TIME</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> jobId)</span> &#123;</span><br><span class="line">        <span class="comment">// cache clear</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &gt; CACHE_VALID_TIME) &#123;</span><br><span class="line">            routeCountEachJob.clear();</span><br><span class="line">            CACHE_VALID_TIME = System.currentTimeMillis() + <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> routeCountEachJob.get(jobId);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="literal">null</span> || count.get() &gt; <span class="number">1000000</span>) &#123;</span><br><span class="line">            <span class="comment">// 初始化时主动Random一次，缓解首次压力</span></span><br><span class="line">            count = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// count++</span></span><br><span class="line">            count.addAndGet(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        routeCountEachJob.put(jobId, count);</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> addressList.get(count(triggerParam.getJobId())%addressList.size());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>本来有两台机器，此时有一台停止了，在轮询路由策略下如何执行？</p></blockquote><p>还是在轮询，每次轮到这个节点执行失败不插入数据，周期不正常。</p><h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>如果有n个执行器，随机执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteRandom</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">localRandom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> addressList.get(localRandom.nextInt(addressList.size()));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本来有两台机器，此时有一台停止了，在随机路由策略下如何执行？</p></blockquote><p>还是在随机，不会自动剔除掉故障的节点，周期不正常。</p><h3 id="忙碌转移"><a href="#忙碌转移" class="headerlink" title="忙碌转移"></a>忙碌转移</h3><p>下发任务前向执行器节点发起rpc心跳请求查询是否忙碌，如果执行器节点返回忙碌则转移到其他执行器节点执行</p><p>具体步骤如下：</p><ol><li>遍历执行器地址。</li><li>调用执行器的idle方法查看是否忙碌。</li><li>如果忙碌则打个日志，继续遍历下一个。</li><li>找到不忙碌的直接调用执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteBusyover</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">idleBeatResultSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">//遍历执行器地址</span></span><br><span class="line">        <span class="keyword">for</span> (String address : addressList) &#123;</span><br><span class="line">            <span class="comment">// beat</span></span><br><span class="line">            ReturnT&lt;String&gt; idleBeatResult = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ExecutorBiz</span> <span class="variable">executorBiz</span> <span class="operator">=</span> XxlJobScheduler.getExecutorBiz(address);</span><br><span class="line">                <span class="comment">//调用执行器的idle方法查看是否忙碌</span></span><br><span class="line">                idleBeatResult = executorBiz.idleBeat(<span class="keyword">new</span> <span class="title class_">IdleBeatParam</span>(triggerParam.getJobId()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//如果忙碌则打个日志，继续遍历下一个</span></span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">                idleBeatResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;&quot;</span>+e );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到不忙碌的直接调用执行</span></span><br><span class="line">            idleBeatResultSB.append( (idleBeatResultSB.length()&gt;<span class="number">0</span>)?<span class="string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span>:<span class="string">&quot;&quot;</span>)</span><br><span class="line">                    .append(I18nUtil.getString(<span class="string">&quot;jobconf_idleBeat&quot;</span>) + <span class="string">&quot;：&quot;</span>)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;address：&quot;</span>).append(address)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;code：&quot;</span>).append(idleBeatResult.getCode())</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;msg：&quot;</span>).append(idleBeatResult.getMsg());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// beat success</span></span><br><span class="line">            <span class="keyword">if</span> (idleBeatResult.getCode() == ReturnT.SUCCESS_CODE) &#123;</span><br><span class="line">                idleBeatResult.setMsg(idleBeatResultSB.toString());</span><br><span class="line">                idleBeatResult.setContent(address);</span><br><span class="line">                <span class="keyword">return</span> idleBeatResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, idleBeatResultSB.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到idleBeat的逻辑就是通过loadJobThread判断执行器是否忙碌，如果忙碌则返回失败，反之返回成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">idleBeat</span><span class="params">(IdleBeatParam idleBeatParam)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isRunningOrHasQueue</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isRunningOrHasQueue</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">JobThread</span> <span class="variable">jobThread</span> <span class="operator">=</span> XxlJobExecutor.loadJobThread(idleBeatParam.getJobId());</span><br><span class="line">    <span class="keyword">if</span> (jobThread != <span class="literal">null</span> &amp;&amp; jobThread.isRunningOrHasQueue()) &#123;</span><br><span class="line">        isRunningOrHasQueue = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRunningOrHasQueue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;job thread is running or has trigger queue.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadJobThread方法逻辑也很简单，每一个执行的任务都会存到jobThreadRepository 中，以任务id为key，线程为value，如果map中存在则说明该任务还在执行，说明执行器忙碌。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;Integer, JobThread&gt; jobThreadRepository = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Integer, JobThread&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> JobThread <span class="title function_">loadJobThread</span><span class="params">(<span class="type">int</span> jobId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobThreadRepository.get(jobId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>在主节点或主服务器故障时，自动切换到备份节点或备份服务器，以保证服务的可用性和连续性。</p><p>具体步骤如下：</p><ol><li>遍历执行器地址。</li><li>调用执行器的beat方法查看是否故障。</li><li>如果故障则打个日志，继续遍历下一个。</li><li>找到不故障的直接调用执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteFailover</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">beatResultSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (String address : addressList) &#123;</span><br><span class="line">            <span class="comment">// beat</span></span><br><span class="line">            ReturnT&lt;String&gt; beatResult = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ExecutorBiz</span> <span class="variable">executorBiz</span> <span class="operator">=</span> XxlJobScheduler.getExecutorBiz(address);</span><br><span class="line">                beatResult = executorBiz.beat();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">                beatResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;&quot;</span>+e );</span><br><span class="line">            &#125;</span><br><span class="line">            beatResultSB.append( (beatResultSB.length()&gt;<span class="number">0</span>)?<span class="string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span>:<span class="string">&quot;&quot;</span>)</span><br><span class="line">                    .append(I18nUtil.getString(<span class="string">&quot;jobconf_beat&quot;</span>) + <span class="string">&quot;：&quot;</span>)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;address：&quot;</span>).append(address)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;code：&quot;</span>).append(beatResult.getCode())</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;msg：&quot;</span>).append(beatResult.getMsg());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// beat success</span></span><br><span class="line">            <span class="keyword">if</span> (beatResult.getCode() == ReturnT.SUCCESS_CODE) &#123;</span><br><span class="line"></span><br><span class="line">                beatResult.setMsg(beatResultSB.toString());</span><br><span class="line">                beatResult.setContent(address);</span><br><span class="line">                <span class="keyword">return</span> beatResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, beatResultSB.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最近最久未使用"><a href="#最近最久未使用" class="headerlink" title="最近最久未使用"></a>最近最久未使用</h3><p>选择最近最久未使用的节点来处理请求。这种算法根据节点上一次使用的时间戳，选择最长时间未使用的节点来分配请求。</p><ol><li>用jobLRUMap 来缓存每一个地址的使用情况。</li><li>如果缓存时间过期，则将jobLRUMap 清空。</li><li>根据jobId从jobLRUMap 获取对应的地址列表。</li><li>获取第一个(因为linkHashMap)取一次元素，该元素就会排到末尾，所以第一个永远是最近最少使用的。</li><li>调用linkHashMap的get方法获取最近最少使用的address。</li><li>返回地址值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteLRU</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;Integer, LinkedHashMap&lt;String, String&gt;&gt; jobLRUMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Integer, LinkedHashMap&lt;String, String&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">CACHE_VALID_TIME</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">route</span><span class="params">(<span class="type">int</span> jobId, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cache clear</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &gt; CACHE_VALID_TIME) &#123;</span><br><span class="line">            jobLRUMap.clear();</span><br><span class="line">            CACHE_VALID_TIME = System.currentTimeMillis() + <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init lru</span></span><br><span class="line">        LinkedHashMap&lt;String, String&gt; lruItem = jobLRUMap.get(jobId);</span><br><span class="line">        <span class="keyword">if</span> (lruItem == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * LinkedHashMap</span></span><br><span class="line"><span class="comment">             *      a、accessOrder：true=访问顺序排序（get/put时排序）；false=插入顺序排期；</span></span><br><span class="line"><span class="comment">             *      b、removeEldestEntry：新增元素时将会调用，返回true时会删除最老元素；可封装LinkedHashMap并重写该方法，比如定义最大容量，超出是返回true即可实现固定长度的LRU算法；</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            lruItem = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">            jobLRUMap.putIfAbsent(jobId, lruItem);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put new</span></span><br><span class="line">        <span class="keyword">for</span> (String address: addressList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lruItem.containsKey(address)) &#123;</span><br><span class="line">                lruItem.put(address, address);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove old</span></span><br><span class="line">        List&lt;String&gt; delKeys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String existKey: lruItem.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!addressList.contains(existKey)) &#123;</span><br><span class="line">                delKeys.add(existKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delKeys.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String delKey: delKeys) &#123;</span><br><span class="line">                lruItem.remove(delKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">eldestKey</span> <span class="operator">=</span> lruItem.entrySet().iterator().next().getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">eldestValue</span> <span class="operator">=</span> lruItem.get(eldestKey);</span><br><span class="line">        <span class="keyword">return</span> eldestValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> route(triggerParam.getJobId(), addressList);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最不经常使用"><a href="#最不经常使用" class="headerlink" title="最不经常使用"></a>最不经常使用</h3><p>选择最不经常使用的节点来处理请求。这种算法根据节点上一次使用的次数，选择最不经常使用的节点来分配请求。</p><ol><li>用 jobLfuMap 来缓存每一个地址的使用情况。</li><li>如果缓存时间过期，则将 jobLfuMap 清空。</li><li>根据 jobId 从 jobLfuMap 获取对应的地址列表。</li><li>获取第一个(因为linkHashMap)取一次元素，该元素就会排到末尾，所以第一个永远是最不经常使用的。</li><li>调用linkHashMap的get方法获取最不经常使用的address。</li><li>返回地址值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteLFU</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;Integer, HashMap&lt;String, Integer&gt;&gt; jobLfuMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Integer, HashMap&lt;String, Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">CACHE_VALID_TIME</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">route</span><span class="params">(<span class="type">int</span> jobId, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cache clear</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &gt; CACHE_VALID_TIME) &#123;</span><br><span class="line">            jobLfuMap.clear();</span><br><span class="line">            CACHE_VALID_TIME = System.currentTimeMillis() + <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lfu item init</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; lfuItemMap = jobLfuMap.get(jobId);     <span class="comment">// Key排序可以用TreeMap+构造入参Compare；Value排序暂时只能通过ArrayList；</span></span><br><span class="line">        <span class="keyword">if</span> (lfuItemMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            lfuItemMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">            jobLfuMap.putIfAbsent(jobId, lfuItemMap);   <span class="comment">// 避免重复覆盖</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put new</span></span><br><span class="line">        <span class="keyword">for</span> (String address: addressList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lfuItemMap.containsKey(address) || lfuItemMap.get(address) &gt;<span class="number">1000000</span> ) &#123;</span><br><span class="line">                lfuItemMap.put(address, <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(addressList.size()));  <span class="comment">// 初始化时主动Random一次，缓解首次压力</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove old</span></span><br><span class="line">        List&lt;String&gt; delKeys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String existKey: lfuItemMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!addressList.contains(existKey)) &#123;</span><br><span class="line">                delKeys.add(existKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delKeys.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String delKey: delKeys) &#123;</span><br><span class="line">                lfuItemMap.remove(delKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load least userd count address</span></span><br><span class="line">        List&lt;Map.Entry&lt;String, Integer&gt;&gt; lfuItemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;(lfuItemMap.entrySet());</span><br><span class="line">        Collections.sort(lfuItemList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getValue().compareTo(o2.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Map.Entry&lt;String, Integer&gt; addressItem = lfuItemList.get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">minAddress</span> <span class="operator">=</span> addressItem.getKey();</span><br><span class="line">        addressItem.setValue(addressItem.getValue() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> addressItem.getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> route(triggerParam.getJobId(), addressList);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><p>根据jobId和执行器地址列表来做路由。</p><ul><li>执行器地址（ip:port) hash到TreeMap</li><li>为了避免增减节点时负载不均衡，加入虚拟节点。每个物理节点虚拟为100个虚拟节点分散到TreeMap中</li><li>重写Hash算法避免原生hash算法不均衡问题</li><li>采用TreeMap的tailMap功能找到大于等于当前hash值的节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteConsistentHash</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">VIRTUAL_NODE_NUM</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get hash code on 2^32 ring (md5散列的方式计算hash值)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">hash</span><span class="params">(String key)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// md5 byte</span></span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;MD5 not supported&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.reset();</span><br><span class="line">        <span class="type">byte</span>[] keyBytes = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            keyBytes = key.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown string :&quot;</span> + key, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        md5.update(keyBytes);</span><br><span class="line">        <span class="type">byte</span>[] digest = md5.digest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hash code, Truncate to 32-bits</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> ((<span class="type">long</span>) (digest[<span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (digest[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">truncateHashCode</span> <span class="operator">=</span> hashCode &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">        <span class="keyword">return</span> truncateHashCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hashJob</span><span class="params">(<span class="type">int</span> jobId, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------A1------A2-------A3------</span></span><br><span class="line">        <span class="comment">// -----------J1------------------</span></span><br><span class="line">        TreeMap&lt;Long, String&gt; addressRing = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String address: addressList) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; VIRTUAL_NODE_NUM; i++) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">addressHash</span> <span class="operator">=</span> hash(<span class="string">&quot;SHARD-&quot;</span> + address + <span class="string">&quot;-NODE-&quot;</span> + i);</span><br><span class="line">                addressRing.put(addressHash, address);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">jobHash</span> <span class="operator">=</span> hash(String.valueOf(jobId));</span><br><span class="line">        SortedMap&lt;Long, String&gt; lastRing = addressRing.tailMap(jobHash);</span><br><span class="line">        <span class="keyword">if</span> (!lastRing.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> lastRing.get(lastRing.firstKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addressRing.firstEntry().getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> hashJob(triggerParam.getJobId(), addressList);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分片广播"><a href="#分片广播" class="headerlink" title="分片广播"></a>分片广播</h3><p>广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务。</p><p>要取出要更新的id，然后判断取模是不是本台机器处理，如果是本台机器需要处理的，再根据id查询数据，处理数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分片广播任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@XxlJob(&quot;shardingJobHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shardingJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分片参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line"></span><br><span class="line">    XxlJobHelper.log(<span class="string">&quot;分片参数：当前分片序号 = &#123;&#125;, 总分片数 = &#123;&#125;&quot;</span>, shardIndex, shardTotal);</span><br><span class="line">    <span class="comment">//获取需要处理的所有门店列表</span></span><br><span class="line">    List&lt;StoreInfo&gt; storeInfoList = storeInfoMapper.selectList(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;StoreInfo&gt;().lambda().orderByDesc(StoreInfo::getStoreCode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前分片需要处理的门店列表</span></span><br><span class="line">    List&lt;StoreInfo&gt; shardStoreInfoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; storeInfoList.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % shardTotal == shardIndex) &#123;</span><br><span class="line">            <span class="comment">//将当前分片需要处理的门店加入list</span></span><br><span class="line">            shardStoreInfoList.add(storeInfoList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理业务逻辑...</span></span><br><span class="line">    service.doBusiness(shardStoreInfoList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由策略适用场景"><a href="#路由策略适用场景" class="headerlink" title="路由策略适用场景"></a>路由策略适用场景</h2><table><thead><tr><th>路由策略</th><th>适用场景</th></tr></thead><tbody><tr><td>第一个</td><td>当只有一台机器注册</td></tr><tr><td>最后一个</td><td>当只有一台机器注册</td></tr><tr><td>轮询</td><td>有多台机器， 且希望每台机器平等的享有被调度的可能</td></tr><tr><td>随机</td><td>有多台机器， 且不关心哪台机器执行任务</td></tr><tr><td>忙碌转移</td><td>有多台机器， 希望第一次检测到空闲的机器执行任务。</td></tr><tr><td>故障转移</td><td>有多台机器，希望第一次检测到存活的机器执行任务， 且不关心该机器是否正在处理任务</td></tr><tr><td>最近最久未使用</td><td>有多台机器， 希望闲置最久的机器优先被使用</td></tr><tr><td>最不经常使用</td><td>有多台机器， 希望使用频率低的机器优先被使用</td></tr><tr><td>一致性哈希</td><td>有多台机器， 希望均匀地分布请求， 且在机器的数量变化时， 还能有很好的扩展性和容错性， 拥有相同jobId的任务调度请求， 大概率会落在相同的机器上。</td></tr><tr><td>分片广播</td><td>有多台机器，且对于执行时间长的任务，希望能分散到各个节点上执行，从而加快完成的速度</td></tr></tbody></table><h3 id="rpa分发任务到执行器的策略"><a href="#rpa分发任务到执行器的策略" class="headerlink" title="rpa分发任务到执行器的策略"></a>rpa分发任务到执行器的策略</h3><p>单机只运行一个任务策略。在RPA情景下， 一般只会有一个执行器注册执行调度中心， 为了防止用户电脑上执行的程序中断， 应该单机串行， 调度请求排队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteGlobalBusyover</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">idleBeatResultSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String address : addressList) &#123;</span><br><span class="line">            <span class="comment">// beat</span></span><br><span class="line">            ReturnT&lt;String&gt; idleBeatResult = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ExecutorBiz</span> <span class="variable">executorBiz</span> <span class="operator">=</span> XxlJobScheduler.getExecutorBiz(address);</span><br><span class="line">                <span class="comment">// 单机只运行一个任务策略 检测</span></span><br><span class="line">                idleBeatResult = executorBiz.globalIdleBeat(<span class="keyword">new</span> <span class="title class_">IdleBeatParam</span>(triggerParam.getJobId()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">                idleBeatResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;&quot;</span>+e );</span><br><span class="line">            &#125;</span><br><span class="line">            idleBeatResultSB.append( (idleBeatResultSB.length()&gt;<span class="number">0</span>)?<span class="string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span>:<span class="string">&quot;&quot;</span>)</span><br><span class="line">                    .append(I18nUtil.getString(<span class="string">&quot;jobconf_idleBeat&quot;</span>) + <span class="string">&quot;：&quot;</span>)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;address：&quot;</span>).append(address)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;code：&quot;</span>).append(idleBeatResult.getCode())</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;msg：&quot;</span>).append(idleBeatResult.getMsg());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// beat success</span></span><br><span class="line">            <span class="keyword">if</span> (idleBeatResult.getCode() == ReturnT.SUCCESS_CODE) &#123;</span><br><span class="line">                idleBeatResult.setMsg(idleBeatResultSB.toString());</span><br><span class="line">                idleBeatResult.setContent(address);</span><br><span class="line">                <span class="keyword">return</span> idleBeatResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, idleBeatResultSB.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中检测是否存在一个运行中的任务逻辑如下：</p><ol><li>获取所有的正在运行中的任务线程</li><li>再挨个遍历，如果任务线程没有在运行，则直接返回成功</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">globalIdleBeat</span><span class="params">(IdleBeatParam idleBeatParam)</span> &#123;</span><br><span class="line"></span><br><span class="line">       logger.info(<span class="string">&quot;globalIdleBeat check&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// get all job thread</span></span><br><span class="line">       ConcurrentMap&lt;Integer, JobThread&gt; jobThreadRepository = XxlJobExecutor.getJobThreadRepository();</span><br><span class="line">       <span class="keyword">if</span> (jobThreadRepository.size() == <span class="number">0</span>) &#123;</span><br><span class="line">           logger.info(<span class="string">&quot;globalIdleBeat empty&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// isRunningOrHasQueue</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">isRunningOrHasQueue</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// check is job status</span></span><br><span class="line">       <span class="keyword">for</span> (Integer jobid : jobThreadRepository.keySet()) &#123;</span><br><span class="line">           <span class="type">JobThread</span> <span class="variable">jobThread</span> <span class="operator">=</span> XxlJobExecutor.loadJobThread(jobid);</span><br><span class="line">           <span class="keyword">if</span> (jobThread != <span class="literal">null</span> &amp;&amp; jobThread.isRunningOrHasQueue()) &#123;</span><br><span class="line">               isRunningOrHasQueue = <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (isRunningOrHasQueue) &#123;</span><br><span class="line">               logger.info(<span class="string">&quot;job thread [&quot;</span> + jobThread.getName() + <span class="string">&quot;] is running or has trigger queue.&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;job thread [&quot;</span> + jobThread.getHandler() + <span class="string">&quot;] is running or has trigger queue.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           logger.info(<span class="string">&quot;job thread [&quot;</span> + jobThread.getName() + <span class="string">&quot;] is empty&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="分布式组件负载均衡策略"><a href="#分布式组件负载均衡策略" class="headerlink" title="分布式组件负载均衡策略"></a>分布式组件负载均衡策略</h2><p>Spring Cloud Gateway中负载均衡使用了路由策略。在微服务架构中，通常存在多个相同或相似的微服务实例，每个实例都提供相同的服务接口，但可能运行在不同的主机或容器上。</p><p>负载策略有： </p><ul><li>Path Route Predicate：基于请求的路径进行匹配，支持Ant风格的路径表达式，如<code>/foo/**</code>。</li><li>Query Route Predicate：基于请求的查询参数进行匹配，支持正则表达式，如<code>name=foo.*</code>。</li><li>Method Route Predicate：基于请求的方法进行匹配，如<code>GET</code>、<code>POST</code>等。</li><li>Header Route Predicate：基于请求头进行匹配，如<code>Host</code>、<code>User-Agent</code>等。</li><li>Cookie Route Predicate：基于请求的Cookie进行匹配，如<code>SESSIONID=123456</code>。</li><li>RemoteAddr Route Predicate：基于请求的IP地址进行匹配，如<code>192.168.1.100</code>。</li><li>Host Route Predicate：基于请求的Host头进行匹配，如<code>example.com</code>。</li><li>Cloud Foundry Route Service Route Predicate：用于支持Cloud Foundry的路由服务。</li><li>Weight Route Predicate：根据服务的权重进行<a href="https://cloud.tencent.com/product/clb?from_column=20065&from=20065">负载均衡</a>路由。</li></ul><p>Nginx的upstream支持如下六种方式的负载均衡算法</p><ul><li>轮询：默认方式</li><li>weight：加权轮询</li><li>ip_hash：依据发出请求的 客户端IP 的hash值来分配服务器，可以保证同IP发出的请求路由到同一服务器。<strong>与“一致性hash”路由相似</strong></li><li>url_hash：根据请求的 URL 的hash值来分配服务器。<strong>与“一致性hash”路由相似</strong></li><li>least_conn：最少连接，把请求转发给连接数较少的后端服务器。<strong>与“忙碌转移”路由相似</strong></li><li>fair：由第三方模块提供，可以根据页面大小、加载时间长短智能的进行负载均衡。<strong>与“忙碌转移”路由相似</strong><br>此外，可以用backup将某服务器标记为备用，当主服务器不可用时，将用它处理请求。<strong>与“故障转移”路由相似</strong></li></ul><h2 id="xxl-job如何实现调度器集群任务不重复执行的"><a href="#xxl-job如何实现调度器集群任务不重复执行的" class="headerlink" title="xxl-job如何实现调度器集群任务不重复执行的"></a>xxl-job如何实现调度器集群任务不重复执行的</h2><p>从定时任务处理器中可以看到，在真正调度任务之前，当前的触发器会对xxl_job_lock表上个写锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preparedStatement = conn.prepareStatement(  <span class="string">&quot;select * from xxl_job_lock where lock_name = &#x27;schedule_lock&#x27; for update&quot;</span> );</span><br><span class="line">preparedStatement.execute();</span><br></pre></td></tr></table></figure><p>xxl_job_lock仅仅是作为定时任务调度的锁，正是因为写锁的存在，保证一个触发器触发任务时，别的触发器会被阻塞。</p><p>最后将事务提交完成任务的触发，然后休眠，其他触发可以抢占后续工作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commit</span></span><br><span class="line">   <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 事务提交</span></span><br><span class="line">       conn.commit();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!scheduleThreadToStop) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         conn.setAutoCommit(connAutoCommit);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!scheduleThreadToStop) &#123;</span><br><span class="line">         logger.error(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 休眠</span></span><br><span class="line">          conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!scheduleThreadToStop) &#123;</span><br><span class="line">          logger.error(e.getMessage(), e);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;阻塞处理策略&quot;&gt;&lt;a href=&quot;#阻塞处理策略&quot; class=&quot;headerlink&quot; title=&quot;阻塞处理策略&quot;&gt;&lt;/a&gt;阻塞处理策略&lt;/h2&gt;&lt;h3 id=&quot;单机串行（默认）&quot;&gt;&lt;a href=&quot;#单机串行（默认）&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="xxl-job" scheme="https://palette-k.github.io/tags/xxl-job/"/>
    
  </entry>
  
  <entry>
    <title>xxl-job原理与实践</title>
    <link href="https://palette-k.github.io/2024/02/06/xxl-job%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>https://palette-k.github.io/2024/02/06/xxl-job%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</id>
    <published>2024-02-06T10:22:15.000Z</published>
    <updated>2024-02-18T08:57:13.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xxl-job-的概念"><a href="#xxl-job-的概念" class="headerlink" title="xxl-job 的概念"></a>xxl-job 的概念</h1><h2 id="诞生背景"><a href="#诞生背景" class="headerlink" title="诞生背景"></a>诞生背景</h2><p>我们在日常项目开发中，可能会用到分布式调度，在这期间我们可能会遇到这些问题:</p><ol><li>同一个服务中可能存在多个互斥的任务，需要统一调度和协调。</li><li>定时任务运行期间，为了确保任务能够稳定运行，我们希望能够做到高可用、监控运维、故障告警。</li><li>需要统一管理和追踪个个服务节点定时任务的情况，以及任务属性信息，比如:任务所属服务、所属责任人等信息。</li></ol><p>所以我们这里就需要用到xxl-job这个轻量级框架。</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><ul><li><strong>调度模块（调度中心）</strong>：<br>负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块；<br>支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。</li><li><strong>执行模块（执行器）</strong>：<br>负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；<br>接收“调度中心”的执行请求、终止请求和日志请求等。</li></ul><p>这里放一张官网的系统架构图：</p><p><img src="https://www.xuxueli.com/doc/static/xxl-job/images/img_Qohm.png" alt="输入图片说明"></p><p>在真正了解 xxl-job 之前，可以带着以下的问题去进行系统性的学习：</p><ul><li>执行器是如何自动注册到调度中心的？</li><li>调度中心是如何管理执行器的？</li><li>调度中心是如何触发任务的？</li><li>任务是怎么回调jobHandler的？</li><li>任务执行超时会有什么应对策略吗？</li></ul><h1 id="服务端启动流程"><a href="#服务端启动流程" class="headerlink" title="服务端启动流程"></a>服务端启动流程</h1><p><img src="https://qiniuyun.sharkchili.com/img202304260835617.png" alt="在这里插入图片描述"></p><p>要想设计一个分布式任务调度中心，我们需要下面几个东西:</p><ol><li>注册服务</li><li>RPC通信框架</li><li>调度服务</li><li>日志服务</li><li>告警服务</li></ol><h2 id="整体过程概述"><a href="#整体过程概述" class="headerlink" title="整体过程概述"></a>整体过程概述</h2><p>在 <code>xxl-job-admin</code> 的 XxlJobAdminConfig 中，可以看到它在 bean 完成初始化之后通过 InitializingBean 进行了一些特殊操作。</p><p>它继承InitializingBean所实现的afterPropertiesSet方法执行了下面的操作。代码很简单创建一个调度器之后就调用init进行初始化。我们不妨查看init做了什么操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       adminConfig = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">       xxlJobScheduler = <span class="keyword">new</span> <span class="title class_">XxlJobScheduler</span>();</span><br><span class="line">       xxlJobScheduler.init();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 步入了init我们看到了各种helper类的启动操作。从注释中我们也可以看出这些操作分别是:</p><ol><li>初始化i18n。</li><li>JobTriggerPoolHelper这里面会完成一些线程池初始化的操作。</li><li>初始化注册监控相关，在这个操作里面，会每隔30秒进行一次注册表维护。</li><li>初始化失败处理监控器，对失败的情况进行监控，这里面会涉及一些失败发送邮箱或者重试的操作。</li><li>初始化任务完成器，将一些长时间没有响应的任务进行结束处理。</li><li>初始化报表统计，会进行一些成功失败的报表统计。</li><li>初始化调度器，执行任务调度处理。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// init i18n</span></span><br><span class="line">        initI18n();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// admin trigger pool start</span></span><br><span class="line">        JobTriggerPoolHelper.toStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// admin registry monitor run</span></span><br><span class="line">        JobRegistryHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// admin fail-monitor run</span></span><br><span class="line">        JobFailMonitorHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// admin lose-monitor run ( depend on JobTriggerPoolHelper )</span></span><br><span class="line">        JobCompleteHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// admin log report start</span></span><br><span class="line">        JobLogReportHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start-schedule  ( depend on JobTriggerPoolHelper )</span></span><br><span class="line">        JobScheduleHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin success.&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="初始化触发器"><a href="#初始化触发器" class="headerlink" title="初始化触发器"></a>初始化触发器</h2><p>我们先来看看JobTriggerPoolHelper.toStart();这段代码内部的逻辑，非常简单，无非就是初始化两个线程池，一个线程池是名为快触发线程池，另一个则是慢触发线程池。</p><p>从配置参数中我们可以看到这两个线程池的区别:</p><ol><li>快线程池的最大线程数默认为200，慢线程池为100。</li><li>快线程池最多容纳1000个任务，慢线程池默认容纳2000个任务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        fastTriggerPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax(),</span><br><span class="line">                <span class="number">60L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">1000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;xxl-job, admin JobTriggerPoolHelper-fastTriggerPool-&quot;</span> + r.hashCode());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        slowTriggerPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax(),</span><br><span class="line">                <span class="number">60L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;xxl-job, admin JobTriggerPoolHelper-slowTriggerPool-&quot;</span> + r.hashCode());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题来了，什么时候使用快触发线程池，什么时候使用慢触发线程池呢？</p></blockquote><p>从添加触发器的代码中可以看到如果一分钟执行超过10次的任务就会通过 slowTriggerPool 执行，反之就通过 fastTriggerPool 执行。</p><p>这也是设计者执行的巧妙所在，将那些可以快速执行的任务放到快线程池中快速执行完成。</p><p>而将那些耗时且频繁的任务放到慢线程池中堆着慢慢消化，合理分配避免某些快任务因为慢任务而导致执行频率低下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTrigger</span><span class="params">(......)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// choose thread pool</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">triggerPool_</span> <span class="operator">=</span> fastTriggerPool;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">jobTimeoutCount</span> <span class="operator">=</span> jobTimeoutCountMap.get(jobId);</span><br><span class="line">        <span class="keyword">if</span> (jobTimeoutCount!=<span class="literal">null</span> &amp;&amp; jobTimeoutCount.get() &gt; <span class="number">10</span>) &#123;      <span class="comment">// job-timeout 10 times in 1 min</span></span><br><span class="line">            triggerPool_ = slowTriggerPool;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// trigger</span></span><br><span class="line">        triggerPool_.execute(......)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="维护注册表信息"><a href="#维护注册表信息" class="headerlink" title="维护注册表信息"></a>维护注册表信息</h2><p>接下来就是 JobRegistryHelper 的start方法。</p><p>该方法首先会声明一个线程池，从语义上可以猜测出这个线程池是负责注册或者删除执行器的线程池。而且这个线程池的拒绝策略也很特殊，会将任务再次执行一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for registry or remove</span></span><br><span class="line">registryOrRemoveThreadPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line"><span class="number">2</span>,</span><br><span class="line"><span class="number">10</span>,</span><br><span class="line"><span class="number">30L</span>,</span><br><span class="line">TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2000</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;xxl-job, admin JobRegistryMonitorHelper-registryOrRemoveThreadPool-&quot;</span> + r.hashCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">r.run();</span><br><span class="line">logger.warn(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, registry or remove too fast, match threadpool rejected handler(run now).&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后续我们又会看到这样一个守护线程，它做的事情很简单:</p><ol><li>将超过90s的注册器删除。</li><li>从xxl_job_registry查找出更新时间大于现在+90s的执行器，即可能是最新注册的执行器，以appname作为key，相关地址作为value并将其存放到appAddressMap中。</li><li>从appAddressMap取出所有appName对应的地址,更新xxl_job_group执行器地址列表,组装成 addressListStr生成一个group并将其保存到xxl_job_group表中。</li><li>休眠30s后继续1-3的操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for monitor</span></span><br><span class="line">registryMonitorThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 从xxl_job_group找到所有的注册器的信息</span></span><br><span class="line">List&lt;XxlJobGroup&gt; groupList = XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().findByAddressType(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (groupList!=<span class="literal">null</span> &amp;&amp; !groupList.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove dead address (admin/executor)   将超过90s的注册器删除</span></span><br><span class="line">List&lt;Integer&gt; ids = XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().findDead(RegistryConfig.DEAD_TIMEOUT, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="keyword">if</span> (ids!=<span class="literal">null</span> &amp;&amp; ids.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().removeDead(ids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从xxl_job_registry查找出更新时间大于现在+90s的执行器，以appname作为key，相关地址作为value并将其存放到appAddressMap中</span></span><br><span class="line">HashMap&lt;String, List&lt;String&gt;&gt; appAddressMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">List&lt;XxlJobRegistry&gt; list = XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().findAll(RegistryConfig.DEAD_TIMEOUT, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (XxlJobRegistry item: list) &#123;</span><br><span class="line"><span class="keyword">if</span> (RegistryConfig.RegistType.EXECUTOR.name().equals(item.getRegistryGroup())) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">appname</span> <span class="operator">=</span> item.getRegistryKey();</span><br><span class="line">List&lt;String&gt; registryList = appAddressMap.get(appname);</span><br><span class="line"><span class="keyword">if</span> (registryList == <span class="literal">null</span>) &#123;</span><br><span class="line">registryList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!registryList.contains(item.getRegistryValue())) &#123;</span><br><span class="line">registryList.add(item.getRegistryValue());</span><br><span class="line">&#125;</span><br><span class="line">appAddressMap.put(appname, registryList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fresh group address</span></span><br><span class="line"><span class="keyword">for</span> (XxlJobGroup group: groupList) &#123;</span><br><span class="line"><span class="comment">//从appAddressMap取出所有appName对应的地址,更新xxl_job_group执行器地址列表,组装成 addressListStr</span></span><br><span class="line">List&lt;String&gt; registryList = appAddressMap.get(group.getAppname());</span><br><span class="line"><span class="type">String</span> <span class="variable">addressListStr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (registryList!=<span class="literal">null</span> &amp;&amp; !registryList.isEmpty()) &#123;</span><br><span class="line">Collections.sort(registryList);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">addressListSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (String item:registryList) &#123;</span><br><span class="line">addressListSB.append(item).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">addressListStr = addressListSB.toString();</span><br><span class="line">addressListStr = addressListStr.substring(<span class="number">0</span>, addressListStr.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基于addressListStr生成group</span></span><br><span class="line">group.setAddressList(addressListStr);</span><br><span class="line">group.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">//更新group更新时间</span></span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().update(group);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//休眠30s</span></span><br><span class="line">TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread stop&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="失败管理监视器"><a href="#失败管理监视器" class="headerlink" title="失败管理监视器"></a>失败管理监视器</h2><p>我们再来看看JobFailMonitorHelper的start代码。大体步骤为:</p><ol><li>从xxl_job_log找到执行失败的任务。</li><li>lock log 将xxl_job_log表中这些任务alarm_status设置为-1，意为上锁，如果没锁成功下次循环继续上锁。</li><li>从xxl_job_log获取这些job的id。</li><li>根据xxl_job_log的id从xxl_job_info获取到这个任务的信息。</li><li>查看xxl_job_info失败的任务重试次数是否大于0，大于0则继续重试执行。</li><li>对于失败的任务，判断info是否为空，如果不为空，则进行告警，然后基于乐观锁更新xxl_job_log告警信息。</li><li>休眠10s，继续1-6的操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">monitorThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// monitor</span></span><br><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//从xxl_job_log找到执行失败的任务</span></span><br><span class="line">List&lt;Long&gt; failLogIds = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findFailJobLogIds(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">if</span> (failLogIds!=<span class="literal">null</span> &amp;&amp; !failLogIds.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> failLogId: failLogIds) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lock log 将xxl_job_log表中这些任务alarm_status设置为-1，意为上锁，如果没锁成功下次循环继续</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lockRet</span> <span class="operator">=</span> XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (lockRet &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从xxl_job_log获取日志信息</span></span><br><span class="line"><span class="type">XxlJobLog</span> <span class="variable">log</span> <span class="operator">=</span> XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().load(failLogId);</span><br><span class="line"><span class="comment">//根据xxl_job_log的id从xxl_job_info获取到这个任务的信息</span></span><br><span class="line"><span class="type">XxlJobInfo</span> <span class="variable">info</span> <span class="operator">=</span> XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().loadById(log.getJobId());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、fail retry monitor 查看失败的任务重试次数是否大于0，大于0则继续重试</span></span><br><span class="line"><span class="keyword">if</span> (log.getExecutorFailRetryCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">JobTriggerPoolHelper.trigger(log.getJobId(), TriggerTypeEnum.RETRY, (log.getExecutorFailRetryCount()-<span class="number">1</span>), log.getExecutorShardingParam(), log.getExecutorParam(), <span class="literal">null</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">retryMsg</span> <span class="operator">=</span> <span class="string">&quot;&lt;br&gt;&lt;br&gt;&lt;span style=\&quot;color:#F39C12;\&quot; &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>+ I18nUtil.getString(<span class="string">&quot;jobconf_trigger_type_retry&quot;</span>) +<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; &lt;/span&gt;&lt;br&gt;&quot;</span>;</span><br><span class="line">log.setTriggerMsg(log.getTriggerMsg() + retryMsg);</span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateTriggerInfo(log);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、fail alarm monitor</span></span><br><span class="line"><span class="type">int</span> <span class="variable">newAlarmStatus</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 告警状态：0-默认、-1=锁定状态、1-无需告警、2-告警成功、3-告警失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果info不为空，则进行告警</span></span><br><span class="line"><span class="keyword">if</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">alarmResult</span> <span class="operator">=</span> XxlJobAdminConfig.getAdminConfig().getJobAlarmer().alarm(info, log);</span><br><span class="line">newAlarmStatus = alarmResult?<span class="number">2</span>:<span class="number">3</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">newAlarmStatus = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基于乐观锁更新xxl_job_log告警信息</span></span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, -<span class="number">1</span>, newAlarmStatus);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job fail monitor thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job fail monitor thread stop&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="任务结束处理器"><a href="#任务结束处理器" class="headerlink" title="任务结束处理器"></a>任务结束处理器</h2><p>我们继续前进查看 JobCompleteHelper 的源码。第一步也还是创建一个回调线程池，参数如下，可以看到拒绝策略任然是再次执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for callback</span></span><br><span class="line">callbackThreadPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line"><span class="number">2</span>,</span><br><span class="line"><span class="number">20</span>,</span><br><span class="line"><span class="number">30L</span>,</span><br><span class="line">TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">3000</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;xxl-job, admin JobLosedMonitorHelper-callbackThreadPool-&quot;</span> + r.hashCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">r.run();</span><br><span class="line">logger.warn(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, callback too fast, match threadpool rejected handler(run now).&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再往后查看代码，我们会发现一个守护线程monitorThread，查看它的核心工作代码如下，具体步骤为:</p><ol><li>找到运行中状态超过10min的任务id。</li><li>拿着这个任务id组装出一个log对象</li><li>基于这个表对象将任务结果通过updateHandleInfoAndFinish设置为结束。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// monitor</span></span><br><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 任务结果丢失处理：调度记录停留在 &quot;运行中&quot; 状态超过10min，且对应执行器心跳注册失败不在线，则将本地调度主动标记失败；</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">losedTime</span> <span class="operator">=</span> DateUtil.addMinutes(<span class="keyword">new</span> <span class="title class_">Date</span>(), -<span class="number">10</span>);</span><br><span class="line"><span class="comment">//找到丢失的任务id</span></span><br><span class="line">List&lt;Long&gt; losedJobIds  = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findLostJobIds(losedTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (losedJobIds!=<span class="literal">null</span> &amp;&amp; losedJobIds.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Long logId: losedJobIds) &#123;</span><br><span class="line"><span class="comment">//基于logId组装XxlJobLog</span></span><br><span class="line"><span class="type">XxlJobLog</span> <span class="variable">jobLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobLog</span>();</span><br><span class="line">jobLog.setId(logId);</span><br><span class="line"></span><br><span class="line">jobLog.setHandleTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">jobLog.setHandleCode(ReturnT.FAIL_CODE);</span><br><span class="line">jobLog.setHandleMsg( I18nUtil.getString(<span class="string">&quot;joblog_lost_fail&quot;</span>) );</span><br><span class="line"><span class="comment">//基于jobLog将任务结果结束</span></span><br><span class="line">XxlJobCompleter.updateHandleInfoAndFinish(jobLog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job fail monitor thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">60</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>再来看看updateHandleInfoAndFinish的代码，逻辑也很简单，根据log对象的code值组装对应的msg到xxlJobLog中，然后更新到xxl_job_log表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">updateHandleInfoAndFinish</span><span class="params">(XxlJobLog xxlJobLog)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据xxlJobLog任务的code得到对应的msg并将其设置到xxlJobLog中</span></span><br><span class="line">        finishJob(xxlJobLog);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// text最大64kb 避免长度过长</span></span><br><span class="line">        <span class="keyword">if</span> (xxlJobLog.getHandleMsg().length() &gt; <span class="number">15000</span>) &#123;</span><br><span class="line">            xxlJobLog.setHandleMsg( xxlJobLog.getHandleMsg().substring(<span class="number">0</span>, <span class="number">15000</span>) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新xxl_job_log中这个任务的信息</span></span><br><span class="line">        <span class="keyword">return</span> XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateHandleInfo(xxlJobLog);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="报表处理"><a href="#报表处理" class="headerlink" title="报表处理"></a>报表处理</h2><p>还记得我们登录xxl-job-admin时，哪个报表界面吗？这个页面的数据就是通过JobLogReportHelper进行处理的。对此，我们不妨打开源码一探究竟。</p><p>核心逻辑为:</p><ol><li>获取今天、昨天、前天的任务总数、正在运行数、成功数，得出统计信息更新到表中。</li><li>查看日志保留天数，如果到期则将过期日志删除。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 1、log-report refresh: refresh log report in 3 days</span></span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                          <span class="comment">// 获取Calendar都西昂</span></span><br><span class="line">                          <span class="type">Calendar</span> <span class="variable">itemDay</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">                          <span class="comment">//查看今天-i天时的数据，按照循环3次我们可以得出回查看今天、昨天、前天的数据</span></span><br><span class="line">                          itemDay.add(Calendar.DAY_OF_MONTH, -i);</span><br><span class="line">                          itemDay.set(Calendar.HOUR_OF_DAY, <span class="number">0</span>);</span><br><span class="line">                          itemDay.set(Calendar.MINUTE, <span class="number">0</span>);</span><br><span class="line">                          itemDay.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">                          itemDay.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                          <span class="type">Date</span> <span class="variable">todayFrom</span> <span class="operator">=</span> itemDay.getTime();</span><br><span class="line"></span><br><span class="line">                          itemDay.set(Calendar.HOUR_OF_DAY, <span class="number">23</span>);</span><br><span class="line">                          itemDay.set(Calendar.MINUTE, <span class="number">59</span>);</span><br><span class="line">                          itemDay.set(Calendar.SECOND, <span class="number">59</span>);</span><br><span class="line">                          itemDay.set(Calendar.MILLISECOND, <span class="number">999</span>);</span><br><span class="line"></span><br><span class="line">                          <span class="type">Date</span> <span class="variable">todayTo</span> <span class="operator">=</span> itemDay.getTime();</span><br><span class="line"></span><br><span class="line">                          <span class="comment">// 初始化一个xxlJobLogReport对象</span></span><br><span class="line">                          <span class="type">XxlJobLogReport</span> <span class="variable">xxlJobLogReport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobLogReport</span>();</span><br><span class="line">                          xxlJobLogReport.setTriggerDay(todayFrom);</span><br><span class="line">                          xxlJobLogReport.setRunningCount(<span class="number">0</span>);</span><br><span class="line">                          xxlJobLogReport.setSucCount(<span class="number">0</span>);</span><br><span class="line">                          xxlJobLogReport.setFailCount(<span class="number">0</span>);</span><br><span class="line">                          <span class="comment">//查出当天触发的任务数、正在运行数、成功数</span></span><br><span class="line">                          Map&lt;String, Object&gt; triggerCountMap = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findLogReport(todayFrom, todayTo);</span><br><span class="line">                          <span class="keyword">if</span> (triggerCountMap!=<span class="literal">null</span> &amp;&amp; triggerCountMap.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="type">int</span> <span class="variable">triggerDayCount</span> <span class="operator">=</span> triggerCountMap.containsKey(<span class="string">&quot;triggerDayCount&quot;</span>)?Integer.valueOf(String.valueOf(triggerCountMap.get(<span class="string">&quot;triggerDayCount&quot;</span>))):<span class="number">0</span>;</span><br><span class="line">                              <span class="type">int</span> <span class="variable">triggerDayCountRunning</span> <span class="operator">=</span> triggerCountMap.containsKey(<span class="string">&quot;triggerDayCountRunning&quot;</span>)?Integer.valueOf(String.valueOf(triggerCountMap.get(<span class="string">&quot;triggerDayCountRunning&quot;</span>))):<span class="number">0</span>;</span><br><span class="line">                              <span class="type">int</span> <span class="variable">triggerDayCountSuc</span> <span class="operator">=</span> triggerCountMap.containsKey(<span class="string">&quot;triggerDayCountSuc&quot;</span>)?Integer.valueOf(String.valueOf(triggerCountMap.get(<span class="string">&quot;triggerDayCountSuc&quot;</span>))):<span class="number">0</span>;</span><br><span class="line">                              <span class="type">int</span> <span class="variable">triggerDayCountFail</span> <span class="operator">=</span> triggerDayCount - triggerDayCountRunning - triggerDayCountSuc;</span><br><span class="line"></span><br><span class="line">                              xxlJobLogReport.setRunningCount(triggerDayCountRunning);</span><br><span class="line">                              xxlJobLogReport.setSucCount(triggerDayCountSuc);</span><br><span class="line">                              xxlJobLogReport.setFailCount(triggerDayCountFail);</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          <span class="comment">// 将上述结果更新到xxl_job_log_report表中</span></span><br><span class="line">                          <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> XxlJobAdminConfig.getAdminConfig().getXxlJobLogReportDao().update(xxlJobLogReport);</span><br><span class="line">                          <span class="keyword">if</span> (ret &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                              XxlJobAdminConfig.getAdminConfig().getXxlJobLogReportDao().save(xxlJobLogReport);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                          logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job log report thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 2、log-clean: switch open &amp; once each day</span></span><br><span class="line">                  <span class="comment">//设置了保留日志天数且日志保留了24小时，则进入if逻辑内部</span></span><br><span class="line">                  <span class="keyword">if</span> (XxlJobAdminConfig.getAdminConfig().getLogretentiondays()&gt;<span class="number">0</span></span><br><span class="line">                          &amp;&amp; System.currentTimeMillis() - lastCleanLogTime &gt; <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>) &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 通过日志保留天数算出清除log时间</span></span><br><span class="line">                      <span class="type">Calendar</span> <span class="variable">expiredDay</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">                      expiredDay.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span> * XxlJobAdminConfig.getAdminConfig().getLogretentiondays());</span><br><span class="line">                      expiredDay.set(Calendar.HOUR_OF_DAY, <span class="number">0</span>);</span><br><span class="line">                      expiredDay.set(Calendar.MINUTE, <span class="number">0</span>);</span><br><span class="line">                      expiredDay.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">                      expiredDay.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br><span class="line">                      <span class="type">Date</span> <span class="variable">clearBeforeTime</span> <span class="operator">=</span> expiredDay.getTime();</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// clean expired log</span></span><br><span class="line">                      List&lt;Long&gt; logIds = <span class="literal">null</span>;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          logIds = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findClearLogIds(<span class="number">0</span>, <span class="number">0</span>, clearBeforeTime, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">                          <span class="keyword">if</span> (logIds!=<span class="literal">null</span> &amp;&amp; logIds.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="comment">//删除过期日期数据</span></span><br><span class="line">                              XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().clearLog(logIds);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> (logIds!=<span class="literal">null</span> &amp;&amp; logIds.size()&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// update clean time</span></span><br><span class="line">                      lastCleanLogTime = System.currentTimeMillis();</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                          logger.error(e.getMessage(), e);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure><h2 id="任务调度处理器-重点"><a href="#任务调度处理器-重点" class="headerlink" title="任务调度处理器(重点)"></a>任务调度处理器(重点)</h2><p>接下来就是xxl-job工作调度的核心源码 JobScheduleHelper，我们还是分两段来查看这其中的逻辑。先来看看第一段逻辑，这段逻辑是由 scheduleThread 这个守护线程处理的，它的逻辑主要是负责安排任务的执行时间的:</p><ol><li>查出未来5s要执行的任务。</li><li>如果发现这个任务执行时间距离现在已经过期5s，则根据策略要么立即触发要么安排下次处理时间。</li><li>如果发现这个任务在过期时间小于5s要么现在立刻执行，要么安排下次一次执行时间，并将这个时间。</li><li>剩下的都是未过期即将被执行的任务则全部存到一个ringdata的线程安全map中，这个map以秒为key，所有这个时间点执行的任务构成的list为value。</li><li>将job的时间安排结果更新到xxl_job_info表中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// schedule thread</span></span><br><span class="line">        scheduleThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">5000</span> - System.currentTimeMillis()%<span class="number">1000</span> );</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!scheduleThreadToStop) &#123;</span><br><span class="line">                        logger.error(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success.&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//查出可以读取的任务数，这里为6000，也就是说这个线程一次可以处理6000个任务信息</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">preReadCount</span> <span class="operator">=</span> (XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax() + XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax()) * <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!scheduleThreadToStop) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Scan Job</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="type">Boolean</span> <span class="variable">connAutoCommit</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">preReadSuc</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        conn = XxlJobAdminConfig.getAdminConfig().getDataSource().getConnection();</span><br><span class="line">                        connAutoCommit = conn.getAutoCommit();</span><br><span class="line">                        conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">//上写锁，然后操作xxl_job_info表</span></span><br><span class="line">                        preparedStatement = conn.prepareStatement(  <span class="string">&quot;select * from xxl_job_lock where lock_name = &#x27;schedule_lock&#x27; for update&quot;</span> );</span><br><span class="line">                        preparedStatement.execute();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// tx start</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 1、查出未来5s要执行的任务</span></span><br><span class="line">                        <span class="type">long</span> <span class="variable">nowTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                        List&lt;XxlJobInfo&gt; scheduleList = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleJobQuery(nowTime + PRE_READ_MS, preReadCount);</span><br><span class="line">                        <span class="keyword">if</span> (scheduleList!=<span class="literal">null</span> &amp;&amp; scheduleList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 2、push time-ring</span></span><br><span class="line">                            <span class="keyword">for</span> (XxlJobInfo jobInfo: scheduleList) &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 如果现在时间大于任务下次处理时间+5s，即当前任务到期了还没执行则进入if逻辑</span></span><br><span class="line">                                <span class="keyword">if</span> (nowTime &gt; jobInfo.getTriggerNextTime() + PRE_READ_MS) &#123;</span><br><span class="line">                                    <span class="comment">// 2.1、trigger-expire &gt; 5s：pass &amp;&amp; make next-trigger-time</span></span><br><span class="line">                                    logger.warn(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule misfire, jobId = &quot;</span> + jobInfo.getId());</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 如果任务的处理策略是FIRE_ONCE_NOW则立刻执行</span></span><br><span class="line">                                    <span class="type">MisfireStrategyEnum</span> <span class="variable">misfireStrategyEnum</span> <span class="operator">=</span> MisfireStrategyEnum.match(jobInfo.getMisfireStrategy(), MisfireStrategyEnum.DO_NOTHING);</span><br><span class="line">                                    <span class="keyword">if</span> (MisfireStrategyEnum.FIRE_ONCE_NOW == misfireStrategyEnum) &#123;</span><br><span class="line">                                        <span class="comment">// FIRE_ONCE_NOW 》 trigger</span></span><br><span class="line">                                        JobTriggerPoolHelper.trigger(jobInfo.getId(), TriggerTypeEnum.MISFIRE, -<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                                        logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule push trigger : jobId = &quot;</span> + jobInfo.getId() );</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 如果任务不是要求FIRE_ONCE_NOW则更新一下下次处理的时间</span></span><br><span class="line">                                    refreshNextValidTime(jobInfo, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nowTime &gt; jobInfo.getTriggerNextTime()) &#123;<span class="comment">//过期时间小于5s</span></span><br><span class="line">                                    <span class="comment">// 2.2、trigger-expire &lt; 5s：direct-trigger &amp;&amp; make next-trigger-time</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 1、则提交到线程池中等待执行</span></span><br><span class="line">                                    JobTriggerPoolHelper.trigger(jobInfo.getId(), TriggerTypeEnum.CRON, -<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                                    logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule push trigger : jobId = &quot;</span> + jobInfo.getId() );</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 2、设置下一次处理时间</span></span><br><span class="line">                                    refreshNextValidTime(jobInfo, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//如果下次处理时间还在5s内再次更新一下时间</span></span><br><span class="line">                                    <span class="keyword">if</span> (jobInfo.getTriggerStatus()==<span class="number">1</span> &amp;&amp; nowTime + PRE_READ_MS &gt; jobInfo.getTriggerNextTime()) &#123;</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">// 1、make ring second</span></span><br><span class="line">                                        <span class="type">int</span> <span class="variable">ringSecond</span> <span class="operator">=</span> (<span class="type">int</span>)((jobInfo.getTriggerNextTime()/<span class="number">1000</span>)%<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">// 2、push time ring将任务存到ringData这个ConcurrentHashMap中</span></span><br><span class="line">                                        pushTimeRing(ringSecond, jobInfo.getId());</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">// 3、设置下次执行时间</span></span><br><span class="line">                                        refreshNextValidTime(jobInfo, <span class="keyword">new</span> <span class="title class_">Date</span>(jobInfo.getTriggerNextTime()));</span><br><span class="line"></span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">// 2.3、trigger-pre-read：time-ring trigger &amp;&amp; make next-trigger-time</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 1、make ring second</span></span><br><span class="line">                                    <span class="type">int</span> <span class="variable">ringSecond</span> <span class="operator">=</span> (<span class="type">int</span>)((jobInfo.getTriggerNextTime()/<span class="number">1000</span>)%<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 2、push time ring</span></span><br><span class="line">                                    pushTimeRing(ringSecond, jobInfo.getId());</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 3、fresh next</span></span><br><span class="line">                                    refreshNextValidTime(jobInfo, <span class="keyword">new</span> <span class="title class_">Date</span>(jobInfo.getTriggerNextTime()));</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 3、update trigger info</span></span><br><span class="line">                            <span class="keyword">for</span> (XxlJobInfo jobInfo: scheduleList) &#123;</span><br><span class="line">                                XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleUpdate(jobInfo);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            preReadSuc = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// tx stop</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!scheduleThreadToStop) &#123;</span><br><span class="line">                            logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#scheduleThread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">........</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>接下来就是任务调度的逻辑了，这里的处理也很简单，从上文创建的rindData取出当前时间前2s的任务，然后提交到线程池中执行，避免没必要的延迟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ringThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!ringThreadToStop) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// align second</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span> - System.currentTimeMillis() % <span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!ringThreadToStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 提前2s获取即将执行的任务存到ringItemData中</span></span><br><span class="line">                        List&lt;Integer&gt; ringItemData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">nowSecond</span> <span class="operator">=</span> Calendar.getInstance().get(Calendar.SECOND);   <span class="comment">// 避免处理耗时太长，跨过刻度，向前校验一个刻度；</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                            List&lt;Integer&gt; tmpData = ringData.remove( (nowSecond+<span class="number">60</span>-i)%<span class="number">60</span> );</span><br><span class="line">                            <span class="keyword">if</span> (tmpData != <span class="literal">null</span>) &#123;</span><br><span class="line">                                ringItemData.addAll(tmpData);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// ring trigger</span></span><br><span class="line">                        logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, time-ring beat : &quot;</span> + nowSecond + <span class="string">&quot; = &quot;</span> + Arrays.asList(ringItemData) );</span><br><span class="line">                        <span class="keyword">if</span> (ringItemData.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// ringItemData中的任务全部提交到线程池中执行</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> jobId: ringItemData) &#123;</span><br><span class="line">                                <span class="comment">// do trigger</span></span><br><span class="line">                                JobTriggerPoolHelper.trigger(jobId, TriggerTypeEnum.CRON, -<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// clear</span></span><br><span class="line">                            ringItemData.clear();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!ringThreadToStop) &#123;</span><br><span class="line">                            logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#ringThread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#ringThread stop&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h1 id="客户端启动流程"><a href="#客户端启动流程" class="headerlink" title="客户端启动流程"></a>客户端启动流程</h1><h2 id="基于配置类了解作业执行器"><a href="#基于配置类了解作业执行器" class="headerlink" title="基于配置类了解作业执行器"></a>基于配置类了解作业执行器</h2><p>现在来探寻一下 xxl-job 客户端，源码项目在：xxl-job-executor-sample-springboot</p><p>要想了解spring boot项目，我们都可以从项目中的配置类中看到核心类或者操作，于是我们找到了XxlJobConfig。</p><p>XxlJobConfig有个方法xxlJobExecutor，这就是创建执行器的方法，可以看到这里面所作的操作非常简单，你拿着配置文件中配置文件中的adminAddresses、appname、address等各种信息创建一个执行器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述appname、address等信息都是来自于配置文件中。</p><h2 id="基于XxlJobSpringExecutor了解客户端初始化流程"><a href="#基于XxlJobSpringExecutor了解客户端初始化流程" class="headerlink" title="基于XxlJobSpringExecutor了解客户端初始化流程"></a>基于XxlJobSpringExecutor了解客户端初始化流程</h2><p>从类图中我们不难看出它继承了和xxl-job相关的XxlJobExecutor以及一个和spring相关的SmartInitializingSingleton接口。</p><p><img src="https://qiniuyun.sharkchili.com/img202304271422230.png" alt="在这里插入图片描述"></p><h3 id="SmartInitializingSingleton的概念"><a href="#SmartInitializingSingleton的概念" class="headerlink" title="SmartInitializingSingleton的概念"></a>SmartInitializingSingleton的概念</h3><p>该接口也是SpringBoot的一个扩展点，它会在spring将所有的单例bean初始化之后，执行afterSingletonsInstantiated这个方法。所以查看我们的XxlJobSpringExecutor这个方法实现。</p><p>可以看到这个类主要做了以下三件事:</p><ol><li>初始化JobHandler的方法。</li><li>刷新GlueFactory这个工厂。</li><li>调用XxlJobExecutor的start方法。</li></ol><h2 id="基于afterSingletonsInstantiated了解执行器启动流程"><a href="#基于afterSingletonsInstantiated了解执行器启动流程" class="headerlink" title="基于afterSingletonsInstantiated了解执行器启动流程"></a>基于afterSingletonsInstantiated了解执行器启动流程</h2><h3 id="初始化所有-JobHandler-方法"><a href="#初始化所有-JobHandler-方法" class="headerlink" title="初始化所有 JobHandler 方法"></a>初始化所有 JobHandler 方法</h3><p>接下来我们开始了解每一个方法的具体逻辑，我们首先步入initJobHandlerMethodRepository(applicationContext);方法查看一下详情。</p><p>代码如下，具体含义笔者以及详细注释，整体来说分为3步:</p><ol><li>获取spring容器中所有bean。</li><li>过滤出懒加载的bean。</li><li>看看这个bean的方法是否包含XxlJob这个注解。</li><li>将带有XxlJob注解的方法注册到xxl-job-admin上。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initJobHandlerMethodRepository</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取容器中所有的bean</span></span><br><span class="line">        String[] beanDefinitionNames = applicationContext.getBeanNamesForType(Object.class, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拿到所有懒加载的bean</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Lazy</span> <span class="variable">onBean</span> <span class="operator">=</span> applicationContext.findAnnotationOnBean(beanDefinitionName, Lazy.class);</span><br><span class="line">            <span class="keyword">if</span> (onBean!=<span class="literal">null</span>)&#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;xxl-job annotation scan, skip @Lazy Bean:&#123;&#125;&quot;</span>, beanDefinitionName);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                bean = applicationContext.getBean(beanDefinitionName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查看这个懒加载的bean是否有XxlJob注解，如果有则继续往后走</span></span><br><span class="line">            Map&lt;Method, XxlJob&gt; annotatedMethods = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                annotatedMethods = MethodIntrospector.selectMethods(bean.getClass(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">MethodIntrospector</span>.MetadataLookup&lt;XxlJob&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> XxlJob <span class="title function_">inspect</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> AnnotatedElementUtils.findMergedAnnotation(method, XxlJob.class);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;xxl-job method-jobhandler resolve error for bean[&quot;</span> + beanDefinitionName + <span class="string">&quot;].&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (annotatedMethods==<span class="literal">null</span> || annotatedMethods.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成并将该处理器的方法注册到xxl-job-admin上</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Method, XxlJob&gt; methodXxlJobEntry : annotatedMethods.entrySet()) &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">executeMethod</span> <span class="operator">=</span> methodXxlJobEntry.getKey();</span><br><span class="line">                <span class="type">XxlJob</span> <span class="variable">xxlJob</span> <span class="operator">=</span> methodXxlJobEntry.getValue();</span><br><span class="line">                <span class="comment">// 注册xxl-job-admin上</span></span><br><span class="line">                registJobHandler(xxlJob, bean, executeMethod);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="刷新GlueFactory"><a href="#刷新GlueFactory" class="headerlink" title="刷新GlueFactory"></a>刷新GlueFactory</h3><p>我们继续查看refreshInstance方法，没有什么特殊逻辑，无非是将glueFactory 指向一个全新的工厂而已。最终代码会new SpringGlueFactory();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">refreshInstance</span><span class="params">(<span class="type">int</span> type)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">glueFactory = <span class="keyword">new</span> <span class="title class_">GlueFactory</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">glueFactory = <span class="keyword">new</span> <span class="title class_">SpringGlueFactory</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="了解XxlJobExecutor的start方法-重点"><a href="#了解XxlJobExecutor的start方法-重点" class="headerlink" title="了解XxlJobExecutor的start方法(重点)"></a>了解XxlJobExecutor的start方法(重点)</h3><p>终于我们来到的最核心的不妨，在XxlJobSpringExecutor的afterSingletonsInstantiated中调用了一个super.start();，这个super就是我们的XxlJobExecutor，具体逻辑如下。</p><p>可以看到它整体分为以下几个步骤:</p><ol><li>初始化日志文件存放路径。</li><li>初始化xxl-job-admin地址列表。</li><li>初始化过期日志文件清理线程。</li><li>初始化回调结果通知xxl-job-admin线程。</li><li>初始化 executor-server监听调度器的请求器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化日志路径</span></span><br><span class="line">        XxlJobFileAppender.initLogPath(logPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化admin地址列表</span></span><br><span class="line">        initAdminBizList(adminAddresses, accessToken);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化日志文件清理线程</span></span><br><span class="line">        JobLogFileCleanThread.getInstance().start(logRetentionDays);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化回调线程</span></span><br><span class="line">        TriggerCallbackThread.getInstance().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 executor-server监听调度器的请求器</span></span><br><span class="line">        initEmbedServer(address, ip, port, appname, accessToken);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="XxlJobExecutor的start方法流程详解"><a href="#XxlJobExecutor的start方法流程详解" class="headerlink" title="XxlJobExecutor的start方法流程详解"></a>XxlJobExecutor的start方法流程详解</h2><h3 id="初始化日志"><a href="#初始化日志" class="headerlink" title="初始化日志"></a>初始化日志</h3><p>首先是initLogPath方法，逻辑其实很简单就是通过配置文件获取路径然后进行拼接，最后设置到glueSrcPath 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">logBasePath</span> <span class="operator">=</span> <span class="string">&quot;/data/applogs/xxl-job/jobhandler&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">glueSrcPath</span> <span class="operator">=</span> logBasePath.concat(<span class="string">&quot;/gluesource&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initLogPath</span><span class="params">(String logPath)</span>&#123;</span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="keyword">if</span> (logPath!=<span class="literal">null</span> &amp;&amp; logPath.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">logBasePath = logPath;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mk base dir</span></span><br><span class="line"><span class="type">File</span> <span class="variable">logPathDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(logBasePath);</span><br><span class="line"><span class="keyword">if</span> (!logPathDir.exists()) &#123;</span><br><span class="line">logPathDir.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">logBasePath = logPathDir.getPath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// mk glue dir</span></span><br><span class="line"><span class="type">File</span> <span class="variable">glueBaseDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(logPathDir, <span class="string">&quot;gluesource&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!glueBaseDir.exists()) &#123;</span><br><span class="line">glueBaseDir.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">glueSrcPath = glueBaseDir.getPath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化-admin-地址"><a href="#初始化-admin-地址" class="headerlink" title="初始化 admin 地址"></a>初始化 admin 地址</h3><p>然后是initAdminBizList方法,逻辑也很简单，将我们的配置文件中配置的adminAddresses通过逗号进行切割，然后存放到adminBizList中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;AdminBiz&gt; adminBizList;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initAdminBizList</span><span class="params">(String adminAddresses, String accessToken)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="keyword">if</span> (adminAddresses!=<span class="literal">null</span> &amp;&amp; adminAddresses.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//adminAddresses以逗号切割遍历存到adminBizList中</span></span><br><span class="line">           <span class="keyword">for</span> (String address: adminAddresses.trim().split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (address!=<span class="literal">null</span> &amp;&amp; address.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="type">AdminBiz</span> <span class="variable">adminBiz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdminBizClient</span>(address.trim(), accessToken);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (adminBizList == <span class="literal">null</span>) &#123;</span><br><span class="line">                       adminBizList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;AdminBiz&gt;();</span><br><span class="line">                   &#125;</span><br><span class="line">                   adminBizList.add(adminBiz);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="清除过期日志"><a href="#清除过期日志" class="headerlink" title="清除过期日志"></a>清除过期日志</h3><p>该方法时JobLogFileCleanThread的start方法，逻辑比较长，我们分为两段来说</p><p>首先判断日志保留天数，这个logRetentionDays 的值是从配置文件中来的，如果发现小于3天则直接返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果日志保留天数小于3天直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (logRetentionDays &lt; <span class="number">3</span> ) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>然后这个方法创建了一个localThread线程，其run方法核心逻辑如下：</p><ol><li>得到所有文件位置。</li><li>算出今天的时间。</li><li>计算出这个文件的时间。</li><li>如果创建时间至今超过logRetentionDays (这里配置为30天)，则将通过递归的方式删除这些日志文件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 得到所有文件路径</span></span><br><span class="line">                        File[] childDirs = <span class="keyword">new</span> <span class="title class_">File</span>(XxlJobFileAppender.getLogPath()).listFiles();</span><br><span class="line">                        <span class="keyword">if</span> (childDirs!=<span class="literal">null</span> &amp;&amp; childDirs.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 算出今天的时间</span></span><br><span class="line">                            <span class="type">Calendar</span> <span class="variable">todayCal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">                            todayCal.set(Calendar.HOUR_OF_DAY,<span class="number">0</span>);</span><br><span class="line">                            todayCal.set(Calendar.MINUTE,<span class="number">0</span>);</span><br><span class="line">                            todayCal.set(Calendar.SECOND,<span class="number">0</span>);</span><br><span class="line">                            todayCal.set(Calendar.MILLISECOND,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="type">Date</span> <span class="variable">todayDate</span> <span class="operator">=</span> todayCal.getTime();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (File childFile: childDirs) &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// valid</span></span><br><span class="line">                                <span class="keyword">if</span> (!childFile.isDirectory()) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (childFile.getName().indexOf(<span class="string">&quot;-&quot;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 得到文件创建时间</span></span><br><span class="line">                                <span class="type">Date</span> <span class="variable">logFileCreateDate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">                                    logFileCreateDate = simpleDateFormat.parse(childFile.getName());</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                                    logger.error(e.getMessage(), e);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (logFileCreateDate == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//如果这个文件创建时间至今超过30天则直接递归删除文件及其子文件</span></span><br><span class="line">                                <span class="keyword">if</span> ((todayDate.getTime()-logFileCreateDate.getTime()) &gt;= logRetentionDays * (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>) ) &#123;</span><br><span class="line">                                    FileUtil.deleteRecursively(childFile);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.DAYS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><h3 id="初始化回调线程回调结果给admin"><a href="#初始化回调线程回调结果给admin" class="headerlink" title="初始化回调线程回调结果给admin"></a>初始化回调线程回调结果给admin</h3><p>继续查看start方法中TriggerCallbackThread的start，我们查看其run方法，它的主要作用是将当前任务的执行结果告诉给xxl-job-admin，步骤也很简单:</p><ol><li>从队列中取出一个任务的执行结果HandleCallbackParam。</li><li>将结果存到callbackParamList中。</li><li>调用doCallback将结果发送给xxl-job-admin。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!toStop)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//从callBackQueue获取到对应jobId的执行结果</span></span><br><span class="line">                        <span class="type">HandleCallbackParam</span> <span class="variable">callback</span> <span class="operator">=</span> getInstance().callBackQueue.take();</span><br><span class="line">                        <span class="keyword">if</span> (callback != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            </span><br><span class="line">                            List&lt;HandleCallbackParam&gt; callbackParamList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HandleCallbackParam&gt;();</span><br><span class="line">                            <span class="type">int</span> <span class="variable">drainToNum</span> <span class="operator">=</span> getInstance().callBackQueue.drainTo(callbackParamList);</span><br><span class="line">                            <span class="comment">//将回调结果存到callbackParamList</span></span><br><span class="line">                            callbackParamList.add(callback);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 将结果回调给xxl-job-admin</span></span><br><span class="line">                            <span class="keyword">if</span> (callbackParamList!=<span class="literal">null</span> &amp;&amp; callbackParamList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                                doCallback(callbackParamList);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>查看doCallback的实现细节，它的工作过程也很简单，遍历出对应的xxl-job实例，发送结果某一个发送失败，则遍历下一个实例继续发送，直到成功为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doCallback</span><span class="params">(List&lt;HandleCallbackParam&gt; callbackParamList)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">callbackRet</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 遍历xxl-job-admin服务所对应的对象adminBiz</span></span><br><span class="line">        <span class="keyword">for</span> (AdminBiz adminBiz: XxlJobExecutor.getAdminBizList()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//调用adminBiz的回调接口将结果发送给xxl-job-admin服务</span></span><br><span class="line">                ReturnT&lt;String&gt; callbackResult = adminBiz.callback(callbackParamList);</span><br><span class="line">                <span class="comment">//如果成功记录一个日志并退出循环，如果失败，则继续遍历其他实例发送回调结果</span></span><br><span class="line">                <span class="keyword">if</span> (callbackResult!=<span class="literal">null</span> &amp;&amp; ReturnT.SUCCESS_CODE == callbackResult.getCode()) &#123;</span><br><span class="line">                    callbackLog(callbackParamList, <span class="string">&quot;&lt;br&gt;----------- xxl-job job callback finish.&quot;</span>);</span><br><span class="line">                    callbackRet = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果回调失败，则打个日志</span></span><br><span class="line">                    callbackLog(callbackParamList, <span class="string">&quot;&lt;br&gt;----------- xxl-job job callback fail, callbackResult:&quot;</span> + callbackResult);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                callbackLog(callbackParamList, <span class="string">&quot;&lt;br&gt;----------- xxl-job job callback error, errorMsg:&quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!callbackRet) &#123;</span><br><span class="line">            appendFailCallbackFile(callbackParamList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="注册内嵌服务等待服务端调用-重点"><a href="#注册内嵌服务等待服务端调用-重点" class="headerlink" title="注册内嵌服务等待服务端调用(重点)"></a>注册内嵌服务等待服务端调用(重点)</h3><p>到了最关键的一步initEmbedServer(address, ip, port, appname, accessToken);，这一步就是可以确保我们的执行器可以收到调度器的关键所在。 它的工作流程就是组装端口等参数，通过netty的方式将服务开启并等待调度器的调用。现在不妨我们自顶向下查看一下它的实现细节。</p><p>从调用我们可以看到它的步骤也很清晰:</p><ol><li>获取端口号以及ip地址。于端口号和ip地址组装服务地址。</li><li>获取token。</li><li>基于上述所有参数调用embedServer的start启动内嵌服务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initEmbedServer</span><span class="params">(String address, String ip, <span class="type">int</span> port, String appname, String accessToken)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取端口号和ip地址</span></span><br><span class="line">        port = port&gt;<span class="number">0</span>?port: NetUtil.findAvailablePort(<span class="number">9999</span>);</span><br><span class="line">        ip = (ip!=<span class="literal">null</span>&amp;&amp;ip.trim().length()&gt;<span class="number">0</span>)?ip: IpUtil.getIp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于端口号和ip地址生成当前服务地址</span></span><br><span class="line">        <span class="keyword">if</span> (address==<span class="literal">null</span> || address.trim().length()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ip_port_address</span> <span class="operator">=</span> IpUtil.getIpPort(ip, port);   <span class="comment">// registry-address：default use address to registry , otherwise use ip:port if address is null</span></span><br><span class="line">            address = <span class="string">&quot;http://&#123;ip_port&#125;/&quot;</span>.replace(<span class="string">&quot;&#123;ip_port&#125;&quot;</span>, ip_port_address);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取token</span></span><br><span class="line">        <span class="keyword">if</span> (accessToken==<span class="literal">null</span> || accessToken.trim().length()==<span class="number">0</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job accessToken is empty. To ensure system security, please set the accessToken.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于上述服务初始化内嵌服务，并将其启动</span></span><br><span class="line">        embedServer = <span class="keyword">new</span> <span class="title class_">EmbedServer</span>();</span><br><span class="line">        embedServer.start(address, port, appname, accessToken);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>了解了整体流程之后，我们再来看看细节。即embedServer的start的具体实现。</p><p>我们步入start方法会看到一个名为thread的线程，代码比较长，我们分段来解读。首先它会创建两个NIO group。然后再创建一个业务线程池，初始为0，最大线程数为200，队列中可以容纳2000个任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">            <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">            <span class="type">ThreadPoolExecutor</span> <span class="variable">bizThreadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                    <span class="number">0</span>,</span><br><span class="line">                    <span class="number">200</span>,</span><br><span class="line">                    <span class="number">60L</span>,</span><br><span class="line">                    TimeUnit.SECONDS,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2000</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;xxl-job, EmbedServer bizThreadPool-&quot;</span> + r.hashCode());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;xxl-job, EmbedServer bizThreadPool is EXHAUSTED!&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure><p>基于上述的参数启动ServerBootstrap，并将配置文件中appName和当前应用地址信息作为参数，将服务注册到xxl-job-admin上。然后就是调用 future.channel().closeFuture().sync()等待调度器调用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ServerBootstrap</span></span><br><span class="line">                    <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">                    bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                            .channel(NioServerSocketChannel.class)</span><br><span class="line">                            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    channel.pipeline()</span><br><span class="line">                                            .addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">30</span> * <span class="number">3</span>, TimeUnit.SECONDS))  <span class="comment">// beat 3N, close if idle</span></span><br><span class="line">                                            .addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>())</span><br><span class="line">                                            .addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>))  <span class="comment">// merge request &amp; reponse to FULL</span></span><br><span class="line">                                            .addLast(<span class="keyword">new</span> <span class="title class_">EmbedHttpServerHandler</span>(executorBiz, accessToken, bizThreadPool));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">                            .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 绑定端口号</span></span><br><span class="line">                    <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(port).sync();</span><br><span class="line"></span><br><span class="line">                    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job remoting server start success, nettype = &#123;&#125;, port = &#123;&#125;&quot;</span>, EmbedServer.class, port);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 注册到xxl-job上</span></span><br><span class="line">                    startRegistry(appname, address);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 等待调用</span></span><br><span class="line">                    future.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure><p>上文提到一个注册服务到xxl-job-admin的操作，我们查看startRegistry源码，我们查看其内部源码也是基于一个线程的带有while循环的run方法来实现的，核心逻辑如下，很简单，获取xxl-job-admin实例，调用其注册方法将当前服务注册上去，如果成功就结束循环，如果失败就遍历其他实例继续尝试注册，这一点和上文的回调处理器工作流程差不多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RegistryParam</span> <span class="variable">registryParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryParam</span>(RegistryConfig.RegistType.EXECUTOR.name(), appname, address);</span><br><span class="line">                        <span class="comment">//遍历xxl-job-admin对象，注册当前服务，只要成功就结束循环</span></span><br><span class="line">                        <span class="keyword">for</span> (AdminBiz adminBiz: XxlJobExecutor.getAdminBizList()) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                ReturnT&lt;String&gt; registryResult = adminBiz.registry(registryParam);</span><br><span class="line">                                <span class="keyword">if</span> (registryResult!=<span class="literal">null</span> &amp;&amp; ReturnT.SUCCESS_CODE == registryResult.getCode()) &#123;</span><br><span class="line">                                    registryResult = ReturnT.SUCCESS;</span><br><span class="line">                                    logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job registry success, registryParam:&#123;&#125;, registryResult:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;registryParam, registryResult&#125;);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job registry fail, registryParam:&#123;&#125;, registryResult:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;registryParam, registryResult&#125;);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job registry error, registryParam:&#123;&#125;&quot;</span>, registryParam, e);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure><p>上述操作完成之后，线程会休眠30s，然后继续向xxl-job-admin注册当前服务信息，起到一个保持心跳的作用。自此我们的客户端启动流程就结束了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                           <span class="comment">//休眠30s之后继续注册，起到一个保持心跳的效果</span></span><br><span class="line">                           TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                           logger.warn(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, executor registry thread interrupted, error msg:&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure><h3 id="EmbedHttpServerHandler详解"><a href="#EmbedHttpServerHandler详解" class="headerlink" title="EmbedHttpServerHandler详解"></a>EmbedHttpServerHandler详解</h3><p>还记得我们上文注册内嵌服务时候的逻辑吗？这一步中它们组装了一个处理器，这个就是处理调度器请求的核心所在。</p><p><img src="https://qiniuyun.sharkchili.com/img202304271422498.png" alt="在这里插入图片描述"></p><p>我们不妨找到这个类，对其channelRead0方法打个断点。</p><p><img src="https://qiniuyun.sharkchili.com/img202304271422608.png" alt="在这里插入图片描述"></p><p>从断点参数中我们可以看到这个方法收到调取器的参数之后，会将其提交到业务线程中，调用process方法调用当前服务的方法完成请求。</p><p>自此，一次完整的job调度就完成了。</p><h1 id="编写任务自动注册组件"><a href="#编写任务自动注册组件" class="headerlink" title="编写任务自动注册组件"></a>编写任务自动注册组件</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>使用 xxl-job 时会存在一个问题，编写好任务后，虽然@XxlJob注解会将方法注册到xxl-job-admin，但是任务需要我们手动添加。此时，我们希望有这样一个工具，可以让我们只需一个注解即可将执行器和任务直接注册到xxl-job-admin上，这样我们只需在编码阶段写好任务将项目启动，就可以将任务注册到xxl-job-admin中。</p><p><img src="https://qiniuyun.sharkchili.com/img202304211256304.png" alt="在这里插入图片描述"></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>我们可以借由spring-boot自动装配机制，并定义一个注解，扫描容器中所有执行器和带有这个注解的任务，然后调用xxl-job的api将这些任务注册到xxl-job-admin中。</p><h2 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h2><p>在正式编写组件前，先引入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- xxl-job-core --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;xxl-job.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hutool.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先我们从xxl-job-admin中将这两个类拷过来。</p><p><img src="https://qiniuyun.sharkchili.com/img202304211256957.png" alt="在这里插入图片描述"></p><p>我们在web界面操作xxl-job-admin时发现所有操作都需要基于一个cookie，而这个cookie是需要登录才能得到的。所以我们要定义一个接口，后续将登录和获取cookie保存到内存的操作补充上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JobLoginService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录xxl-job-admin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取登录后的cookie</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getCookie</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理然后编写一个接口，定义所有关于执行器的bean的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JobGroupService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询执行器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;XxlJobGroup&gt; <span class="title function_">getJobGroup</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动注册执行器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">autoRegisterGroup</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精确查询执行器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">preciselyCheck</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文提到我们也需要将任务注册到xxl-job上，所以在这里我们也把这个接口定义上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JobInfoService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询xxl-job-admin上是否有这个任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobGroupId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executorHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;XxlJobInfo&gt; <span class="title function_">getJobInfo</span><span class="params">(Integer jobGroupId, String executorHandler)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加任务到xxl-job-admin上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xxlJobInfo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Integer <span class="title function_">addJobInfo</span><span class="params">(XxlJobInfo xxlJobInfo)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此所有我们需要的行为都有了，我们就需要开始将逻辑补充上了。首先是登录和获取cookie的方法。代码含义都详细注释了，读者可以自行查阅，这里简单说明一下登录进行的操作就是:</p><ol><li>调用xxl-job登录接口</li><li>成功后获取cookie</li><li>将cookie缓存到map中</li></ol><p>而获取cookie的方式也很简单，从map中取出来返回出去就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobLoginServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">JobLoginService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置文件获取的xxl-job地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置文件获取的登录用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从xxl-job获取的登录密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存cookie的密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; loginCookie = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用登录接口将XXL_JOB_LOGIN_IDENTITY缓存下来后续使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//调用登录接口</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> adminAddresses + <span class="string">&quot;/login&quot;</span>;</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .form(<span class="string">&quot;userName&quot;</span>, username)</span><br><span class="line">                .form(<span class="string">&quot;password&quot;</span>, password)</span><br><span class="line">                .execute();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取登录后的cookie</span></span><br><span class="line">        List&lt;HttpCookie&gt; cookies = response.getCookies();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//尝试获得XXL_JOB_LOGIN_IDENTITY</span></span><br><span class="line">        Optional&lt;HttpCookie&gt; cookieOpt = cookies.stream()</span><br><span class="line">                .filter(cookie -&gt; cookie.getName().equals(<span class="string">&quot;XXL_JOB_LOGIN_IDENTITY&quot;</span>))</span><br><span class="line">                .findFirst();</span><br><span class="line">        <span class="keyword">if</span> (!cookieOpt.isPresent()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;get xxl-job cookie error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果存在这个cookie则将其缓存起来</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cookieOpt.get().getValue();</span><br><span class="line">        loginCookie.put(<span class="string">&quot;XXL_JOB_LOGIN_IDENTITY&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试从内存中获取cookie，如果没有则尝试3次登录即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCookie</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cookieStr</span> <span class="operator">=</span> loginCookie.get(<span class="string">&quot;XXL_JOB_LOGIN_IDENTITY&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (cookieStr != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;XXL_JOB_LOGIN_IDENTITY=&quot;</span> + cookieStr;</span><br><span class="line">            &#125;</span><br><span class="line">            login();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;get xxl-job cookie error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是执行器注册的逻辑了，整体来说有两个方法，分别是精确查询执行器和注册执行器的方法，含义都详尽注释在代码上，读者可自行参阅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobGroupServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">JobGroupService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.title&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行器地址类型：0=自动注册、1=手动录入</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.addressType:0&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer addressType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行器地址列表，多地址逗号分隔(手动录入)</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.addressList:&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String addressList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobLoginService jobLoginService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精确查询执行器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preciselyCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//调用xxl-job模糊查询job的api</span></span><br><span class="line">        List&lt;XxlJobGroup&gt; jobGroup = getJobGroup();</span><br><span class="line">        <span class="comment">//精确匹配执行器名称</span></span><br><span class="line">        Optional&lt;XxlJobGroup&gt; has = jobGroup.stream()</span><br><span class="line">                .filter(xxlJobGroup -&gt; xxlJobGroup.getAppname().equals(appName)</span><br><span class="line">                        &amp;&amp; xxlJobGroup.getTitle().equals(title))</span><br><span class="line">                .findAny();</span><br><span class="line">        <span class="comment">//返回该执行器是否存在</span></span><br><span class="line">        <span class="keyword">return</span> has.isPresent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询执行器列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;XxlJobGroup&gt; <span class="title function_">getJobGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> adminAddresses + <span class="string">&quot;/jobgroup/pageList&quot;</span>;</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .form(<span class="string">&quot;appname&quot;</span>, appName)</span><br><span class="line">                .form(<span class="string">&quot;title&quot;</span>, title)</span><br><span class="line">                .cookie(jobLoginService.getCookie())</span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> response.body();</span><br><span class="line">        <span class="type">JSONArray</span> <span class="variable">array</span> <span class="operator">=</span> JSONUtil.parse(body).getByPath(<span class="string">&quot;data&quot;</span>, JSONArray.class);</span><br><span class="line">        List&lt;XxlJobGroup&gt; list = array.stream()</span><br><span class="line">                .map(o -&gt; JSONUtil.toBean((JSONObject) o, XxlJobGroup.class))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用xxl-job保存执行器的api，将执行器保存到xxl-job上</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">autoRegisterGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//组装请求地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> adminAddresses + <span class="string">&quot;/jobgroup/save&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//组装表单参数</span></span><br><span class="line">        <span class="type">HttpRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .form(<span class="string">&quot;appname&quot;</span>, appName)</span><br><span class="line">                .form(<span class="string">&quot;title&quot;</span>, title);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组装地址类型和注册地址</span></span><br><span class="line">        httpRequest.form(<span class="string">&quot;addressType&quot;</span>, addressType);</span><br><span class="line">        <span class="keyword">if</span> (addressType.equals(<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Strings.isBlank(addressList)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;手动录入模式下,执行器地址列表不能为空&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            httpRequest.form(<span class="string">&quot;addressList&quot;</span>, addressList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行请求，带上我们之前缓存的cookie</span></span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpRequest.cookie(jobLoginService.getCookie())</span><br><span class="line">                .execute();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">code</span> <span class="operator">=</span> JSONUtil.parse(response.body()).getByPath(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回200就说明注册成功</span></span><br><span class="line">        <span class="keyword">return</span> code.equals(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是任务注册的接口实现了，核心方法也是模糊查询任务列表和注册任务两个方法，读者参阅注释即可理解，这里不多赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobInfoServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">JobInfoService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//xxl-job地址</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobLoginService jobLoginService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模糊查询任务列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobGroupId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executorHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;XxlJobInfo&gt; <span class="title function_">getJobInfo</span><span class="params">(Integer jobGroupId, String executorHandler)</span> &#123;</span><br><span class="line">        <span class="comment">//组装查询url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> adminAddresses + <span class="string">&quot;/jobinfo/pageList&quot;</span>;</span><br><span class="line">        <span class="comment">//调用查询接口</span></span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .form(<span class="string">&quot;jobGroup&quot;</span>, jobGroupId)</span><br><span class="line">                .form(<span class="string">&quot;executorHandler&quot;</span>, executorHandler)</span><br><span class="line">                .form(<span class="string">&quot;triggerStatus&quot;</span>, -<span class="number">1</span>)</span><br><span class="line">                .cookie(jobLoginService.getCookie())</span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> response.body();</span><br><span class="line">        <span class="type">JSONArray</span> <span class="variable">array</span> <span class="operator">=</span> JSONUtil.parse(body).getByPath(<span class="string">&quot;data&quot;</span>, JSONArray.class);</span><br><span class="line">        List&lt;XxlJobInfo&gt; list = array.stream()</span><br><span class="line">                .map(o -&gt; JSONUtil.toBean((JSONObject) o, XxlJobInfo.class))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回任务列表</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个任务到任务列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xxlJobInfo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">addJobInfo</span><span class="params">(XxlJobInfo xxlJobInfo)</span> &#123;</span><br><span class="line">        <span class="comment">//组装查询url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> adminAddresses + <span class="string">&quot;/jobinfo/add&quot;</span>;</span><br><span class="line">        <span class="comment">//执行添加逻辑</span></span><br><span class="line">        Map&lt;String, Object&gt; paramMap = BeanUtil.beanToMap(xxlJobInfo);</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .form(paramMap)</span><br><span class="line">                .cookie(jobLoginService.getCookie())</span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理并返回结果</span></span><br><span class="line">        <span class="type">JSON</span> <span class="variable">json</span> <span class="operator">=</span> JSONUtil.parse(response.body());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">code</span> <span class="operator">=</span> json.getByPath(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (code.equals(<span class="number">200</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Convert.toInt(json.getByPath(<span class="string">&quot;content&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;add jobInfo error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此所有核心工作方法都完成了。我们就可以基于spring-boot的自动装配自动调用这些方法完成执行器和任务的注册。</p><p>首先我们定义一个注解，用于要注册到xxl-job的任务的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于实现任务自动注册</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> XxlRegister &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务执行的cron表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">cron</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务描述</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">jobDesc</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default jobDesc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务作者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">author</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default Author&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 默认为 ROUND 轮询方式</span></span><br><span class="line"><span class="comment">     * 可选： FIRST 第一个</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    String <span class="title function_">executorRouteStrategy</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;ROUND&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果是1则自动注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">triggerStatus</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们要编写一个XxlJobAutoRegister扫描容器中带有XxlJob、XxlRegister的方法，并通过xxl-job-admin的api将其注册上去。</p><p>代码逻辑很简单，通过ApplicationContextAware获取容器中的bean，然后基于ApplicationListener监听容器加载情况，在容器准备好提供服务时，做下面这几件事:</p><ol><li>通过ApplicationContextAware找到所有的bean</li><li>遍历bean，找到带有XxlJob的方法。</li><li>查看带有XxlJob的方法是否有XxlRegister，如果有则将其注册到xxl-job-admin</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobAutoRegister</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationReadyEvent&gt;,</span><br><span class="line">        ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobGroupService jobGroupService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobInfoService jobInfoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationReadyEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">//注册执行器</span></span><br><span class="line">        addJobGroup();</span><br><span class="line">        <span class="comment">//注册任务</span></span><br><span class="line">        addJobInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动注册执行器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addJobGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果存在执行器，则直接返回，说明已经注册过了</span></span><br><span class="line">        <span class="keyword">if</span> (jobGroupService.preciselyCheck())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//否则手动注册一下执行器</span></span><br><span class="line">        <span class="keyword">if</span> (jobGroupService.autoRegisterGroup())</span><br><span class="line">            log.info(<span class="string">&quot;auto register xxl-job group success!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将带有XxlRegister的注解的方法提交到xxl-job-admin中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addJobInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;XxlJobGroup&gt; jobGroups = jobGroupService.getJobGroup();</span><br><span class="line">        <span class="type">XxlJobGroup</span> <span class="variable">xxlJobGroup</span> <span class="operator">=</span> jobGroups.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//拿到所有的bean名称</span></span><br><span class="line">        String[] beanDefinitionNames = applicationContext.getBeanNamesForType(Object.class, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(beanDefinitionName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到这个bean中带有XxlJob的方法</span></span><br><span class="line">            Map&lt;Method, XxlJob&gt; methodWithXxlJob = MethodIntrospector.selectMethods(bean.getClass(),</span><br><span class="line">                    (MethodIntrospector.MetadataLookup&lt;XxlJob&gt;) method -&gt; AnnotatedElementUtils.findMergedAnnotation(method, XxlJob.class));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Method, XxlJob&gt; methodXxlJobEntry : methodWithXxlJob.entrySet()) &#123;</span><br><span class="line">                <span class="comment">//带有XxlJob的方法名</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">executeMethod</span> <span class="operator">=</span> methodXxlJobEntry.getKey();</span><br><span class="line">                <span class="comment">//XxlJob注解配置的值</span></span><br><span class="line">                <span class="type">XxlJob</span> <span class="variable">xxlJob</span> <span class="operator">=</span> methodXxlJobEntry.getValue();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果executeMethod带有XxlRegister注解</span></span><br><span class="line">                <span class="keyword">if</span> (executeMethod.isAnnotationPresent(XxlRegister.class)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    List&lt;XxlJobInfo&gt; jobInfo = jobInfoService.getJobInfo(xxlJobGroup.getId(), xxlJob.value());</span><br><span class="line">                    <span class="keyword">if</span> (!jobInfo.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">//因为是模糊查询，需要再判断一次</span></span><br><span class="line">                        Optional&lt;XxlJobInfo&gt; first = jobInfo.stream()</span><br><span class="line">                                .filter(xxlJobInfo -&gt; xxlJobInfo.getExecutorHandler().equals(xxlJob.value()))</span><br><span class="line">                                .findFirst();</span><br><span class="line">                        <span class="comment">//如果任务已经存在则不管了</span></span><br><span class="line">                        <span class="keyword">if</span> (first.isPresent())</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//创建任务并注册</span></span><br><span class="line">                    <span class="type">XxlRegister</span> <span class="variable">xxlRegister</span> <span class="operator">=</span> executeMethod.getAnnotation(XxlRegister.class);</span><br><span class="line">                    <span class="type">XxlJobInfo</span> <span class="variable">xxlJobInfo</span> <span class="operator">=</span> createXxlJobInfo(xxlJobGroup, xxlJob, xxlRegister);</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">jobInfoId</span> <span class="operator">=</span> jobInfoService.addJobInfo(xxlJobInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于XxlRegister封装成一个xxlJobInfo对象提交到xxl-job-admin中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xxlJobGroup</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xxlJob</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xxlRegister</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> XxlJobInfo <span class="title function_">createXxlJobInfo</span><span class="params">(XxlJobGroup xxlJobGroup, XxlJob xxlJob, XxlRegister xxlRegister)</span> &#123;</span><br><span class="line">        <span class="type">XxlJobInfo</span> <span class="variable">xxlJobInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobInfo</span>();</span><br><span class="line">        xxlJobInfo.setJobGroup(xxlJobGroup.getId());</span><br><span class="line">        xxlJobInfo.setJobDesc(xxlRegister.jobDesc());</span><br><span class="line">        xxlJobInfo.setAuthor(xxlRegister.author());</span><br><span class="line">        xxlJobInfo.setScheduleType(<span class="string">&quot;CRON&quot;</span>);</span><br><span class="line">        xxlJobInfo.setScheduleConf(xxlRegister.cron());</span><br><span class="line">        xxlJobInfo.setGlueType(<span class="string">&quot;BEAN&quot;</span>);</span><br><span class="line">        xxlJobInfo.setExecutorHandler(xxlJob.value());</span><br><span class="line">        xxlJobInfo.setExecutorRouteStrategy(xxlRegister.executorRouteStrategy());</span><br><span class="line">        xxlJobInfo.setMisfireStrategy(<span class="string">&quot;DO_NOTHING&quot;</span>);</span><br><span class="line">        xxlJobInfo.setExecutorBlockStrategy(<span class="string">&quot;SERIAL_EXECUTION&quot;</span>);</span><br><span class="line">        xxlJobInfo.setExecutorTimeout(<span class="number">0</span>);</span><br><span class="line">        xxlJobInfo.setExecutorFailRetryCount(<span class="number">0</span>);</span><br><span class="line">        xxlJobInfo.setGlueRemark(<span class="string">&quot;GLUE代码初始化&quot;</span>);</span><br><span class="line">        xxlJobInfo.setTriggerStatus(xxlRegister.triggerStatus());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xxlJobInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>自此我们的组件开发完成了，为了让上面的XxlJobAutoRegister，我们需要编写一个配置类XxlJobPlusConfig，他会扫描XxlJobAutoRegister的包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.xxl.job.plus.executor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobPlusConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写一个spring.factories，将XxlJobPlusConfig路径写入，确保其他引入该组件时会自动装配XxlJobAutoRegister将指定的xxl-job注册上去。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span></span><br><span class="line">  <span class="string">com.xxl.job.plus.executor.config.XxlJobPlusConfig</span></span><br></pre></td></tr></table></figure><h2 id="引入组件并进行测试"><a href="#引入组件并进行测试" class="headerlink" title="引入组件并进行测试"></a>引入组件并进行测试</h2><p>首先将上述组件打包，然后在需要使用这个组件的应用中引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.cn.hydra&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;xxljob-autoregister-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这里直接使用xxl源码自带的spring-boot项目。</p><p><img src="https://qiniuyun.sharkchili.com/img202304211256822.png" alt="在这里插入图片描述"></p><p>编写一个自定义的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(TestService.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XxlJob(value = &quot;testJob&quot;)</span></span><br><span class="line">    <span class="meta">@XxlRegister(cron = &quot;0 0 0 * * ? *&quot;,</span></span><br><span class="line"><span class="meta">            author = &quot;shark-chili&quot;,</span></span><br><span class="line"><span class="meta">            jobDesc = &quot;测试job&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJob</span><span class="params">()</span>&#123;</span><br><span class="line">       logger.info(<span class="string">&quot;testJob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@XxlJob(value = &quot;hello&quot;)</span></span><br><span class="line">    <span class="meta">@XxlRegister(cron = &quot;0 0 0 * * ? *&quot;,</span></span><br><span class="line"><span class="meta">            triggerStatus = 1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;hello this is shark-chili&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后新增如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增配置项，必须项</span></span><br><span class="line"><span class="comment"># admin用户名</span></span><br><span class="line"><span class="string">xxl.job.admin.username=admin</span></span><br><span class="line"><span class="comment"># admin 密码</span></span><br><span class="line"><span class="string">xxl.job.admin.password=123456</span></span><br><span class="line"><span class="comment"># 执行器名称</span></span><br><span class="line"><span class="string">xxl.job.executor.title=shark-chili</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增配置项，可选项</span></span><br><span class="line"><span class="comment"># 执行器地址类型：0=自动注册、1=手动录入，默认为0</span></span><br><span class="line"><span class="string">xxl.job.executor.addressType=0</span></span><br><span class="line"><span class="comment"># 在上面为1的情况下，手动录入执行器地址列表，多地址逗号分隔</span></span><br><span class="line"><span class="string">xxl.job.executor.addressList=http://127.0.0.1:9999</span></span><br></pre></td></tr></table></figure><p>最后将xxl-job-admin和xxl-job启动，打开xxl-job的管理页面，可以看到我们的任务都注册进来了。</p><p><img src="https://qiniuyun.sharkchili.com/img202304211256178.png" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xxl-job-的概念&quot;&gt;&lt;a href=&quot;#xxl-job-的概念&quot; class=&quot;headerlink&quot; title=&quot;xxl-job 的概念&quot;&gt;&lt;/a&gt;xxl-job 的概念&lt;/h1&gt;&lt;h2 id=&quot;诞生背景&quot;&gt;&lt;a href=&quot;#诞生背景&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="xxl-job" scheme="https://palette-k.github.io/tags/xxl-job/"/>
    
  </entry>
  
  <entry>
    <title>异步动态导出功能设计</title>
    <link href="https://palette-k.github.io/2024/02/06/%E5%BC%82%E6%AD%A5%E5%8A%A8%E6%80%81%E5%AF%BC%E5%87%BA%E8%AE%BE%E8%AE%A1/"/>
    <id>https://palette-k.github.io/2024/02/06/%E5%BC%82%E6%AD%A5%E5%8A%A8%E6%80%81%E5%AF%BC%E5%87%BA%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-02-06T10:22:15.000Z</published>
    <updated>2024-06-24T05:35:41.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h1><p>想实现一个导出功能，可以很简单，也可以很复杂。简单做法，无脑用 EasyExcel + 注解，实现起来简便快捷。</p><p>easyexcel能大大减少占用内存的主要原因是：在解析Excel时没有将文件数据<code>一次性全部加载到内存中</code>，而是从磁盘上一行行读取数据，逐个解析。</p><p>但是如果想要指定导出字段呢？如果要一次性导出上百万条数据呢？</p><p>那可能会面临下面的问题：</p><ol><li>如果同步导数据，接口很容易超时。</li><li>如果把所有数据一次性装载到内存，很容易引起OOM。</li><li>数据量太大sql语句必定很慢。</li><li>相同商品编号的数据要放到一起。</li><li>如果走异步，如何通知用户导出结果？</li><li>如果excel文件太大，目标用户打不开怎么办？</li></ol><h1 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h1><p>要把导出这一功能异步，意味着需要有一张异步任务表来存储这些导出任务。</p><p>导入导出任务表如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `excel_import_process` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键id&#x27;</span>,</span><br><span class="line">  `import_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;导出名称&#x27;</span>,</span><br><span class="line">  `import_detail` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;导出详情&#x27;</span>,</span><br><span class="line">  `import_status` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;导出状态 1-处理中 2-处理完成 3-处理失败&#x27;</span>,</span><br><span class="line">  `error_file_url` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;错误文件链接&#x27;</span>,</span><br><span class="line">  `source_url` <span class="type">varchar</span>(<span class="number">1000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;源文件地址&#x27;</span>,</span><br><span class="line">  `import_total` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;导出成功数量&#x27;</span>,</span><br><span class="line">  `task_type` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;任务类型（1：导入 2：导出）&#x27;</span>,</span><br><span class="line">  `import_type` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;导入类型&#x27;</span>,</span><br><span class="line">  `status` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;数据状态 1-启用 2-停用&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;租户id&#x27;</span>,</span><br><span class="line">  `create_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建者&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新者&#x27;</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`) <span class="keyword">USING</span> BTREE COMMENT <span class="string">&#x27;租户ID&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;导出进度表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>一般来讲，导出接口会调用一个导出方法，简单的异步处理可以开启一个线程去实现导出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolManager.getInstance().execute(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">               export(fileName, exportParams, <span class="literal">null</span>, <span class="literal">null</span>, exportFieldList, <span class="literal">null</span>, importType, sysUser.getId(), sysUser.getTenantId(), excelImportProcess, getPayrollDetailsMap);</span><br><span class="line">           &#125;));</span><br></pre></td></tr></table></figure><p>完整的异步导出代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态字段，无法直接依赖注入</span></span><br><span class="line">        ExcelExportUtil.sysDictDataService = applicationContext.getBean(ISysDictDataService.class);</span><br><span class="line">        ExcelExportUtil.contextAwareExecutor = applicationContext.getBean(<span class="string">&quot;contextAwareExecutor&quot;</span>, ThreadPoolTaskExecutor.class);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exportDynamicExcel</span><span class="params">(List&lt;ExcelExportEntity&gt; exportFieldList, Class&lt;?&gt; serviceImpl, Method method, Object dto, String fileName, Integer importType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollUtil.isEmpty(exportFieldList)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;请选择需要导出的字段&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SysUser</span> <span class="variable">sysUser</span> <span class="operator">=</span> UserCacheUtils.getSysUser();</span><br><span class="line">        Class&lt;?&gt; exportClass = getMethodType(method);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; fieldNames = Arrays.stream(FieldUtils.getAllFields(exportClass)).map(Field::getName).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">for</span> (ExcelExportEntity excelExportEntity : exportFieldList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!fieldNames.contains((String) excelExportEntity.getKey())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;需要导出的字段不存在: &quot;</span> + (String) excelExportEntity.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExportParams</span> <span class="variable">exportParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportParams</span>();</span><br><span class="line">        <span class="type">ExportParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportParams</span>(fileName, fileName, ExcelType.XSSF);</span><br><span class="line"></span><br><span class="line">        contextAwareExecutor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="type">ExcelImportProcess</span> <span class="variable">excelImportProcess</span> <span class="operator">=</span> createExcelImportProcess(exportParams.getTitle(), sysUser.getTenantId(), importType, sysUser.getId());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cacheDict(exportClass);</span><br><span class="line">                export(fileName, exportParams, serviceImpl, dto, exportFieldList, method, importType, sysUser.getId(), sysUser.getTenantId(), excelImportProcess, <span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="type">String</span> <span class="variable">fullStackTrace</span> <span class="operator">=</span> ExceptionUtils.getFullStackTrace(e);</span><br><span class="line">                excelImportProcess.setImportStatus(ExcelProcessStatusEnum.PROCESS_FAILED.getCode());</span><br><span class="line">                excelImportProcess.setImportDetail(fullStackTrace.substring(<span class="number">0</span>, <span class="number">150</span>));</span><br><span class="line">                excelImportProcess.updateById();</span><br><span class="line">                log.error(<span class="string">&quot;导出发生错误: &#123;&#125;&quot;</span>, fullStackTrace);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p>我们调用的导出方法示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">export</span><span class="params">(String fileName, ExportParams exportParams, Class&lt;?&gt; excelExportTaskImpl, Object queryParams,</span></span><br><span class="line"><span class="params">                              List&lt;ExcelExportEntity&gt; excelExportEntityList, Method method, Integer importType, Integer userId,</span></span><br><span class="line"><span class="params">                              Long tenantId, ExcelImportProcess excelImportProcess, List&lt;Map&lt;String, Object&gt;&gt; dataMap)</span> &#123;</span><br><span class="line">       <span class="type">Field</span> <span class="variable">tenantIdField</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (!Objects.isNull(queryParams)) &#123;</span><br><span class="line">           tenantIdField = ReflectionUtils.findField(queryParams.getClass(), <span class="string">&quot;tenantId&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!Objects.isNull(tenantIdField)) &#123;</span><br><span class="line">           tenantIdField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">           ReflectionUtils.setField(tenantIdField, queryParams, tenantId);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Workbook workbook;</span><br><span class="line">       <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           stopWatch.start();</span><br><span class="line">           log.info(<span class="string">&quot;---开始执行excel导出---&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (Objects.isNull(dataMap)) &#123;</span><br><span class="line">               <span class="type">Object</span> <span class="variable">excelExportTask</span> <span class="operator">=</span> SpringUtils.getBean(excelExportTaskImpl);</span><br><span class="line">               workbook = cn.afterturn.easypoi.excel.ExcelExportUtil.exportBigExcel(exportParams, excelExportEntityList, (queryParam, page) -&gt; dataList(excelExportTask, method, excelImportProcess, queryParam, page), queryParams);  <span class="comment">// 导出-分页查询</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               excelImportProcess.setImportTotal(dataMap.size());</span><br><span class="line">               <span class="type">ExportParams</span> <span class="variable">exportParams2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportParams</span>(<span class="literal">null</span>, fileName);</span><br><span class="line">               exportParams2.setType(ExcelType.XSSF);</span><br><span class="line">               workbook = cn.afterturn.easypoi.excel.ExcelExportUtil.exportExcel(exportParams2, excelExportEntityList, dataMap);</span><br><span class="line">           &#125;</span><br><span class="line">           downloadExcel(fileName, workbook, excelImportProcess);</span><br><span class="line">           stopWatch.stop();</span><br><span class="line">           log.info(<span class="string">&quot;---excel导出结束---, 成功导出:&#123;&#125;行, 总共耗时:&#123;&#125;秒, 导出记录id: &#123;&#125;&quot;</span>, excelImportProcess.getImportDetail(), stopWatch.getTotalTimeSeconds(), excelImportProcess.getId());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">fullStackTrace</span> <span class="operator">=</span> ExceptionUtils.getFullStackTrace(e);</span><br><span class="line">           excelImportProcess.setImportStatus(ExcelProcessStatusEnum.PROCESS_FAILED.getCode());</span><br><span class="line">           excelImportProcess.setImportDetail(fullStackTrace.substring(<span class="number">0</span>, <span class="number">150</span>));</span><br><span class="line">           excelImportProcess.updateById();</span><br><span class="line">           log.error(<span class="string">&quot;导出发生错误: &#123;&#125;&quot;</span>, fullStackTrace);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到，exportBigExcel 方法可以指定表头，只需要传入excelExportEntityList即可，其中的dataList方法为分页方法，在这里指定了分页和总数信息，通过反射+动态代理查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">dataList</span><span class="params">(Object excelExportTask, Method method, ExcelImportProcess excelImportProcess, Object queryParam, <span class="type">int</span> page)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(queryParam <span class="keyword">instanceof</span> PageParam)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;参数不是PageParam类型&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 设置分页和租户id信息</span></span><br><span class="line">      ((PageParam) queryParam).setPageNum(page);</span><br><span class="line">      ((PageParam) queryParam).setPageSize(sliceSize); <span class="comment">// 默认为 20000 条</span></span><br><span class="line">      log.info(<span class="string">&quot;pageNum: &#123;&#125;&quot;</span>, page);</span><br><span class="line">      List&lt;Object&gt; data = (List&lt;Object&gt;) ReflectionUtils.invokeMethod(method, excelExportTask, queryParam);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!Objects.isNull(data)) &#123;</span><br><span class="line">          data = serializeDataList(data);</span><br><span class="line">          <span class="type">Integer</span> <span class="variable">importTotal</span> <span class="operator">=</span> excelImportProcess.getImportTotal();</span><br><span class="line">          <span class="keyword">if</span> (Objects.isNull(importTotal)) &#123;</span><br><span class="line">              importTotal = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          excelImportProcess.setImportTotal(importTotal + data.size());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>exportBigExcel的遍历分页代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Workbook <span class="title function_">exportBigExcel</span><span class="params">(IExcelExportServer server, Object queryParams)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       List&lt;Object&gt; list = server</span><br><span class="line">               .selectListForExcelExport(queryParams, page++);</span><br><span class="line">       <span class="keyword">while</span> (list != <span class="literal">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           write(list);</span><br><span class="line">           list = server.selectListForExcelExport(queryParams, page++);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看到这里你肯定会有个疑问，都支持导出百万级数据了，这样随便把查询条件放到 while 里去循环查询，数据量越大，偏移量越多，不会有深分页问题吗？</p><p>但是再仔细看看，这个方法只传了个页数，实际上，它不关心你怎么分页的。深分页这个问题其实是需要自己在业务代码里解决，easypoi只负责我们告诉分页以后的数据。</p><h1 id="多个-sheet"><a href="#多个-sheet" class="headerlink" title="多个 sheet"></a>多个 sheet</h1><p>我们知道，excel对一个sheet存放的最大数据量，是有做限制的，一个sheet最多可以保存<code>1048576</code>行数据。否则在保存数据时会直接报错：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">invalid</span> <span class="string">row</span> <span class="string">number</span> <span class="string">(1048576)</span> <span class="string">outside</span> <span class="string">allowable</span> <span class="string">range</span> <span class="string">(0..1048575)</span></span><br></pre></td></tr></table></figure><p>如果你想导出一百万以上的数据，excel的一个sheet肯定是存放不下的，因此我们需要把数据保存到多个sheet中。</p><p>之前说过，我们一般是通过<code>limit</code>语句来实现分页查询功能的，其中的pagetStart参数，是通过pageNo和pageSize动态计算出来的。如果只有一个sheet可以这么玩，但如果有多个sheet就会有问题。因此，我们需要重新计算<code>limit</code>的起始位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExcelWriter</span> <span class="variable">excelWriter</span> <span class="operator">=</span> EasyExcelFactory.write(out).build();</span><br><span class="line"><span class="type">int</span> <span class="variable">totalPage</span> <span class="operator">=</span> searchUserTotalPage(searchModel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(totalPage &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   Page&lt;User&gt; page = Page.create(searchModel);</span><br><span class="line">   <span class="type">int</span> <span class="variable">sheet</span> <span class="operator">=</span> (totalPage % maxSheetCount == <span class="number">0</span>) ? totalPage / maxSheetCount: (totalPage / maxSheetCount) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sheet;i++) &#123;</span><br><span class="line">      <span class="type">WriterSheet</span> <span class="variable">writeSheet</span> <span class="operator">=</span> buildSheet(i,<span class="string">&quot;sheet&quot;</span>+i);</span><br><span class="line">      <span class="type">int</span> <span class="variable">startPageNo</span> <span class="operator">=</span> i*(maxSheetCount/pageSize)+<span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">endPageNo</span> <span class="operator">=</span> (i+<span class="number">1</span>)*(maxSheetCount/pageSize);</span><br><span class="line">      <span class="keyword">while</span>(page.getPageNo()&gt;=startPageNo &amp;&amp; page.getPageNo()&lt;=endPageNo) &#123;</span><br><span class="line">        page = searchUser(searchModel);</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isEmpty(page.getList())) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        excelWriter.write(page.getList(),writeSheet);</span><br><span class="line">        page.setPageNo(page.getPageNo()+<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="流式查询"><a href="#流式查询" class="headerlink" title="流式查询"></a>流式查询</h1><p>可以使用MapReduce思想并利用流式API来处理</p><p>mybatis有提供cursor流式接口，然后就不用数据的join和order by那些耗性能的操作了，流式1 条条的取出数据在内存中去关联和排序，最终组合数据写到一个文档里面</p><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>由于现在我们导出excel数据的方案改成了<code>异步</code>，所以没法直接将excel文件，同步返回给用户。</p><p>因此我们需要先将excel文件存放到一个地方，当用户有需要时，可以访问到。</p><p>这时，我们可以直接将文件上传到<code>COS</code>文件服务器上。</p><p>所以你会发现，我们在异步任务表的设计上添加上了文件链接地址（细节！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">downloadExcel</span><span class="params">(String fileName, Workbook workbook, ExcelImportProcess excelImportProcess)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    workbook.write(outputStream);</span><br><span class="line">    fileName = fileName + ToolUtil.serialNumber();</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> FileUploadUtil.upload(outputStream.toByteArray(), fileName + <span class="string">&quot;.xlsx&quot;</span>, FileUploadConstant.EXPORT);  <span class="comment">// 上传到 cos</span></span><br><span class="line">    excelImportProcess.setSourceUrl(url);</span><br><span class="line"></span><br><span class="line">    excelImportProcess.setImportName(fileName);</span><br><span class="line">    excelImportProcess.setImportDetail(<span class="string">&quot;成功导出&quot;</span> + excelImportProcess.getImportTotal() + <span class="string">&quot;条&quot;</span>);</span><br><span class="line">    excelImportProcess.setImportStatus(ExcelProcessStatusEnum.PROCESS_COMPLETE.getCode());</span><br><span class="line">    excelImportProcess.updateById();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="功能优化"><a href="#功能优化" class="headerlink" title="功能优化"></a>功能优化</h1><p>写过一些 crud 代码就清楚，导出方法一般和查询的接口一样，需要在导出前调用查询的方法把 List 查出来，然后再进行后续的导出操作，把文件输出流传给前端。</p><p>但是如果需要导出一些带有字典值的字段呢？查询接口一般都是把表里的枚举值查出来，前端再通过查询字典表把这些枚举值替换成对应的中文字段。但是导出就没办法通过前端来转换了，这种转换字典的操作只能让后端做。</p><p>但是更加高级的做法可以使用注解，只需要在返回的VO里给某些需要转换的字段上加一个注解，就可以省去繁琐的替换操作了。优雅，太优雅了。</p><p>导出时检测字典类型的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cacheDict</span><span class="params">(Class&lt;?&gt; exportClass)</span> &#123;</span><br><span class="line">       List&lt;String&gt; dictTypeList = Lists.newArrayList();</span><br><span class="line">       <span class="keyword">for</span> (Field field : FieldUtils.getAllFields(exportClass)) &#123;</span><br><span class="line">           <span class="type">DictCode</span> <span class="variable">dictCode</span> <span class="operator">=</span> field.getAnnotation(DictCode.class);</span><br><span class="line">           <span class="keyword">if</span> (ToolUtil.isNotEmpty(dictCode)) &#123;</span><br><span class="line">               <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> dictCode.type();</span><br><span class="line">               <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> dictCode.value();</span><br><span class="line">               <span class="keyword">if</span> (ToolUtil.isNotEmpty(value) &amp;&amp; <span class="string">&quot;dict&quot;</span>.equals(type)) &#123;</span><br><span class="line">                   dictTypeList.add(value);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Map&lt;String, Map&lt;String, String&gt;&gt; dictMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (ToolUtil.isNotEmpty(dictTypeList)) &#123;</span><br><span class="line">           dictMap = sysDictDataService.selectEmpDictData(dictTypeList);</span><br><span class="line">       &#125;</span><br><span class="line">       RedisUtil.hmSet(<span class="string">&quot;sys:dict:&quot;</span>, dictMap);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过查询字典表，替换掉字典键值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Map&lt;String, Map&lt;String, String&gt;&gt; <span class="title function_">selectEmpDictData</span><span class="params">(List&lt;String&gt; dictTypeList)</span> &#123;</span><br><span class="line">       <span class="type">Long</span> <span class="variable">tenantId</span> <span class="operator">=</span> UserCacheUtils.getByTenantId();</span><br><span class="line">       List&lt;SysDictDataVO&gt; list = dictDataMapper.selectEmpDictData(dictTypeList, tenantId);</span><br><span class="line">       <span class="keyword">return</span> list.stream().collect(Collectors.groupingBy(SysDictDataVO::getDictType, TreeMap::<span class="keyword">new</span>, Collectors.toMap(SysDictDataVO::getDictValue, SysDictDataVO::getDictLabel, (existing, replacement) -&gt; existing, <span class="comment">// 如果遇到相同的键，保留现有的</span></span><br><span class="line">               LinkedHashMap::<span class="keyword">new</span>)));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需求背景&quot; class=&quot;headerlink&quot; title=&quot;需求背景&quot;&gt;&lt;/a&gt;需求背景&lt;/h1&gt;&lt;p&gt;想实现一个导出功能，可以很简单，也可以很复杂。简单做法，无脑用 EasyExcel + 注解，实现起来简便快捷。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="场景设计" scheme="https://palette-k.github.io/tags/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security的使用</title>
    <link href="https://palette-k.github.io/2024/01/25/SpringSecurity%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://palette-k.github.io/2024/01/25/SpringSecurity%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2024-01-25T09:23:54.000Z</published>
    <updated>2024-02-18T05:57:12.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>基本上，在所有的开发的系统中，都必须做认证(authentication)和授权(authorization)，以保证系统的安全性。</p><ul><li>认证是确认声明者的本身身份，其作为授权的上游衔接而存在</li><li>鉴权是对声明者所声明的真实性进行确认的过程，其作为授权的下游衔接而存在</li></ul><p>Spring Security 是一个功能强大且高度可定制的身份验证和访问控制框架。它是用于保护基于 Spring 的应用程序。</p><h1 id="认证链路"><a href="#认证链路" class="headerlink" title="认证链路"></a>认证链路</h1><p>1 用户名和密码被过滤器获取到，封装成<code>Authentication</code>,通常情况下是<code>UsernamePasswordAuthenticationToken</code>这个实现类。</p><p>2 <code>AuthenticationManager</code> 身份管理器负责验证这个<code>Authentication</code></p><p>3 认证成功后，<code>AuthenticationManager</code>身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）<code>Authentication</code>实例。</p><p>4 <code>SecurityContextHolder</code>安全上下文容器将第3步填充了信息的<code>Authentication</code>，通过SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。</p><p><img src="https://i0.hdslb.com/bfs/article/88a3aba0385efc8a25fbb26638fabc16171301454.png" alt="image-20240208155803862"></p><p><img src="http://kirito.iocoder.cn/2011121410543010.jpg" alt="http://kirito.iocoder.cn/2011121410543010.jpg"></p><h2 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h2><p>AuthenticationManager（接口）是认证相关的核心接口，也是发起认证的出发点。AuthenticationManager一般不直接认证，AuthenticationManager接口的常用实现类<code>ProviderManager</code> 内部会维护一个<code>List&lt;AuthenticationProvider&gt;</code>列表，存放多种认证方式，实际上这是委托者模式的应用（Delegate）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderManager</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationManager</span>, MessageSourceAware,</span><br><span class="line">InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护一个AuthenticationProvider列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AuthenticationProvider&gt; providers = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line">          <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">       Class&lt;? <span class="keyword">extends</span> <span class="title class_">Authentication</span>&gt; toTest = authentication.getClass();</span><br><span class="line">       <span class="type">AuthenticationException</span> <span class="variable">lastException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Authentication</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 依次认证</span></span><br><span class="line">       <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">             result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                copyDetails(authentication, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">             lastException = e;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果有Authentication信息，则直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">&amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">               <span class="comment">//移除密码</span></span><br><span class="line">((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">&#125;</span><br><span class="line">             <span class="comment">//发布登录成功事件</span></span><br><span class="line">eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">       <span class="comment">//执行到此，说明没有认证成功，包装异常信息</span></span><br><span class="line">       <span class="keyword">if</span> (lastException == <span class="literal">null</span>) &#123;</span><br><span class="line">          lastException = <span class="keyword">new</span> <span class="title class_">ProviderNotFoundException</span>(messages.getMessage(</span><br><span class="line">                <span class="string">&quot;ProviderManager.providerNotFound&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; toTest.getName() &#125;,</span><br><span class="line">                <span class="string">&quot;No AuthenticationProvider found for &#123;0&#125;&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       prepareException(lastException, authentication);</span><br><span class="line">       <span class="keyword">throw</span> lastException;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ProviderManager</code> 中的List，会依照次序去认证，认证成功则立即返回，若认证失败则返回null，下一个AuthenticationProvider会继续尝试认证，如果所有认证器都无法认证成功，则<code>ProviderManager</code> 会抛出一个ProviderNotFoundException异常。</p><p>DaoAuthenticationProvider：它获取用户提交的用户名和密码，比对其正确性，如果正确，返回一个数据库中的用户信息（假设用户信息被保存在数据库中）。</p><h1 id="核心配置解读"><a href="#核心配置解读" class="headerlink" title="核心配置解读"></a>核心配置解读</h1><h2 id="WebSecurityConfigurerAdapter"><a href="#WebSecurityConfigurerAdapter" class="headerlink" title="WebSecurityConfigurerAdapter"></a>WebSecurityConfigurerAdapter</h2><p>拿 ruoyi 的 SecurityConfig 举例，它继承了 WebSecurityConfigurerAdapter。</p><p>适配器模式在spring中被广泛的使用，在配置中使用Adapter的好处便是，我们可以选择性的配置想要修改的那一部分配置，而不用覆盖其他不相关的配置。WebSecurityConfigurerAdapter中我们可以选择自己想要修改的内容，来进行重写，而其提供了三个configure重载方法。</p><ul><li>configure(HttpSecurity)</li><li>configure(WebSecurity)</li><li>configure(AuthenticationManagerBuilder)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring security配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ruoyi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义用户认证逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证失败处理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationEntryPointImpl unauthorizedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退出处理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogoutSuccessHandlerImpl logoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * token认证过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationTokenFilter authenticationTokenFilter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跨域过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CorsFilter corsFilter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许匿名访问的地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PermitAllUrlProperties permitAllUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解决 无法直接注入 AuthenticationManager</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * anyRequest          |   匹配所有请求路径</span></span><br><span class="line"><span class="comment">     * access              |   SpringEl表达式结果为true时可以访问</span></span><br><span class="line"><span class="comment">     * anonymous           |   匿名可以访问</span></span><br><span class="line"><span class="comment">     * denyAll             |   用户不能访问</span></span><br><span class="line"><span class="comment">     * fullyAuthenticated  |   用户完全认证可以访问（非remember-me下自动登录）</span></span><br><span class="line"><span class="comment">     * hasAnyAuthority     |   如果有参数，参数表示权限，则其中任何一个权限可以访问</span></span><br><span class="line"><span class="comment">     * hasAnyRole          |   如果有参数，参数表示角色，则其中任何一个角色可以访问</span></span><br><span class="line"><span class="comment">     * hasAuthority        |   如果有参数，参数表示权限，则其权限可以访问</span></span><br><span class="line"><span class="comment">     * hasIpAddress        |   如果有参数，参数表示IP地址，如果用户IP和参数匹配，则可以访问</span></span><br><span class="line"><span class="comment">     * hasRole             |   如果有参数，参数表示角色，则其角色可以访问</span></span><br><span class="line"><span class="comment">     * permitAll           |   用户可以任意访问</span></span><br><span class="line"><span class="comment">     * rememberMe          |   允许通过remember-me登录的用户访问</span></span><br><span class="line"><span class="comment">     * authenticated       |   用户登录后可访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity httpSecurity)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注解标记允许匿名访问的url</span></span><br><span class="line">        ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.<span class="type">ExpressionInterceptUrlRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> httpSecurity.authorizeRequests();</span><br><span class="line">        permitAllUrl.getUrls().forEach(url -&gt; registry.antMatchers(url).permitAll());</span><br><span class="line"></span><br><span class="line">        httpSecurity</span><br><span class="line">                <span class="comment">// CSRF禁用，因为不使用session</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">// 禁用HTTP响应标头</span></span><br><span class="line">                .headers().cacheControl().disable().and()</span><br><span class="line">                <span class="comment">// 认证失败处理类</span></span><br><span class="line">                .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and()</span><br><span class="line">                <span class="comment">// 基于token，所以不需要session</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                <span class="comment">// 过滤请求</span></span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 对于登录login 注册register 验证码captchaImage 允许匿名访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/captchaImage&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 静态资源，可匿名访问</span></span><br><span class="line">                .antMatchers(HttpMethod.GET, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;/*.html&quot;</span>, <span class="string">&quot;/**/*.html&quot;</span>, <span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>, <span class="string">&quot;/profile/**&quot;</span>).permitAll()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/swagger-ui.html&quot;</span>, <span class="string">&quot;/swagger-resources/**&quot;</span>, <span class="string">&quot;/webjars/**&quot;</span>, <span class="string">&quot;/*/api-docs&quot;</span>, <span class="string">&quot;/druid/**&quot;</span>).permitAll()</span><br><span class="line">.antMatchers(<span class="string">&quot;/test/*&quot;</span>,<span class="string">&quot;/policy/*&quot;</span>,<span class="string">&quot;/type/*&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .headers().frameOptions().disable();</span><br><span class="line">        <span class="comment">// 添加Logout filter</span></span><br><span class="line">        httpSecurity.logout().logoutUrl(<span class="string">&quot;/logout&quot;</span>).logoutSuccessHandler(logoutSuccessHandler);</span><br><span class="line">        <span class="comment">// 添加JWT filter</span></span><br><span class="line">        httpSecurity.addFilterBefore(authenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        <span class="comment">// 添加CORS filter</span></span><br><span class="line">        httpSecurity.addFilterBefore(corsFilter, JwtAuthenticationTokenFilter.class);</span><br><span class="line">        httpSecurity.addFilterBefore(corsFilter, LogoutFilter.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 强散列哈希加密实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">bCryptPasswordEncoder</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份认证接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HttpSecurity常用配置"><a href="#HttpSecurity常用配置" class="headerlink" title="HttpSecurity常用配置"></a>HttpSecurity常用配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomWebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/resources/**&quot;</span>, <span class="string">&quot;/signup&quot;</span>, <span class="string">&quot;/about&quot;</span>).permitAll()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/db/**&quot;</span>).access(<span class="string">&quot;hasRole(&#x27;ADMIN&#x27;) and hasRole(&#x27;DBA&#x27;)&quot;</span>)</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">                .usernameParameter(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .failureForwardUrl(<span class="string">&quot;/login?error&quot;</span>)</span><br><span class="line">                .loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">            .logout()</span><br><span class="line">                .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">                .logoutSuccessUrl(<span class="string">&quot;/index&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">            .httpBasic()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是一个使用Java Configuration配置HttpSecurity的典型配置，其中http作为根开始配置，每一个and()对应了一个模块的配置（等同于xml配置中的结束标签），并且and()返回了HttpSecurity本身，于是可以连续进行配置。他们配置的含义也非常容易通过变量本身来推测，</p><ul><li>authorizeRequests()配置路径拦截，表明路径访问所对应的权限，角色，认证信息。</li><li>formLogin()对应表单认证相关的配置</li><li>logout()对应了注销相关的配置</li><li>httpBasic()可以配置basic登录</li><li>etc</li></ul><h3 id="WebSecurity常用配置"><a href="#WebSecurity常用配置" class="headerlink" title="WebSecurity常用配置"></a>WebSecurity常用配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        web</span><br><span class="line">            .ignoring()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/resources/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AuthenticationManagerBuilder"><a href="#AuthenticationManagerBuilder" class="headerlink" title="AuthenticationManagerBuilder"></a>AuthenticationManagerBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth</span><br><span class="line">            .inMemoryAuthentication()</span><br><span class="line">            .withUser(<span class="string">&quot;admin&quot;</span>).password(<span class="string">&quot;admin&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在WebSecurityConfigurerAdapter中进行认证相关的配置，可以使用configure(AuthenticationManagerBuilder auth)暴露一个AuthenticationManager的建造器：AuthenticationManagerBuilder 。如上所示，我们便完成了内存中用户的配置。</p><p>除了以上的示例代码，还有另外一种配置方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureGlobal</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth</span><br><span class="line">            .inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="string">&quot;admin&quot;</span>).password(<span class="string">&quot;admin&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的应用只有唯一一个WebSecurityConfigurerAdapter，那么他们之间的差距可以被忽略，从方法名可以看出两者的区别：</p><ul><li>使用@Autowired注入的AuthenticationManagerBuilder是全局的身份认证器，作用域可以跨越多个WebSecurityConfigurerAdapter，以及影响到基于Method的安全控制；</li><li>而 <code>protected configure()</code>的方式则类似于一个匿名内部类，它的作用域局限于一个WebSecurityConfigurerAdapter内部。</li></ul><h1 id="授权链路"><a href="#授权链路" class="headerlink" title="授权链路"></a>授权链路</h1><p><img src="https://i0.hdslb.com/bfs/article/4a5465473ec1db95c8fd8cc85ecf18a2171301454.png" alt="image-20240208154120807"></p><h2 id="UsernamePasswordAuthenticationFilter"><a href="#UsernamePasswordAuthenticationFilter" class="headerlink" title="UsernamePasswordAuthenticationFilter"></a>UsernamePasswordAuthenticationFilter</h2><p>整个调用流程是，先调用其父类 AbstractAuthenticationProcessingFilter.doFilter() 方法，然后再执行 UsernamePasswordAuthenticationFilter.attemptAuthentication() 方法进行验证；</p><p>AbstractAuthenticationProcessingFilter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line"><span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line">#<span class="number">1.</span>判断当前的filter是否可以处理当前请求，不可以的话则交给下一个filter处理</span><br><span class="line"><span class="keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Request is to process authentication&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Authentication authResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">#<span class="number">2.</span>抽象方法由子类UsernamePasswordAuthenticationFilter实现</span><br><span class="line">authResult = attemptAuthentication(request, response);</span><br><span class="line"><span class="keyword">if</span> (authResult == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// return immediately as subclass has indicated that it hasn&#x27;t completed</span></span><br><span class="line"><span class="comment">// authentication</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">2.</span>认证成功后，处理一些与session相关的方法 </span><br><span class="line">sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">logger.error(</span><br><span class="line"><span class="string">&quot;An internal error occurred while trying to authenticate the user.&quot;</span>,</span><br><span class="line">failed);</span><br><span class="line">#<span class="number">3.</span>认证失败后的的一些操作</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AuthenticationException failed) &#123;</span><br><span class="line"><span class="comment">// Authentication failed</span></span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Authentication success</span></span><br><span class="line"><span class="keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">3.</span> 认证成功后的相关回调方法 主要将当前的认证放到SecurityContextHolder中</span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个程序的执行流程如下:</p><ol><li>判断filter是否可以处理当前的请求，如果不可以则放行交给下一个filter</li><li>调用抽象方法<code>attemptAuthentication</code>进行验证，该方法由子类<code>UsernamePasswordAuthenticationFilter</code>实现</li><li>认证成功以后，回调一些与 session 相关的方法；</li><li>认证成功以后，认证成功后的相关回调方法；认证成功以后，认证成功后的相关回调方法；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">successfulAuthentication</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Authentication success. Updating SecurityContextHolder to contain: &quot;</span></span><br><span class="line">+ authResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line"></span><br><span class="line">rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fire event</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.eventPublisher != <span class="literal">null</span>) &#123;</span><br><span class="line">eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">InteractiveAuthenticationSuccessEvent</span>(</span><br><span class="line">authResult, <span class="built_in">this</span>.getClass()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将当前认证成功的 Authentication 放置到 SecurityContextHolder 中；</li><li>调用其它可扩展的 handlers 继续处理该认证成功以后的回调事件；（实现<code>AuthenticationSuccessHandler</code>接口即可）</li></ol><p>UsernamePasswordAuthenticationFilter: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">#<span class="number">1.</span>判断请求的方法必须为POST请求</span><br><span class="line"><span class="keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationServiceException</span>(</span><br><span class="line"><span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">2.</span>从request中获取username和password</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> obtainUsername(request);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> obtainPassword(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (username == <span class="literal">null</span>) &#123;</span><br><span class="line">username = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (password == <span class="literal">null</span>) &#123;</span><br><span class="line">password = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">username = username.trim();</span><br><span class="line">#<span class="number">3.</span>构建UsernamePasswordAuthenticationToken（两个参数的构造方法setAuthenticated(<span class="literal">false</span>)）</span><br><span class="line"><span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(</span><br><span class="line">username, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow subclasses to set the &quot;details&quot; property</span></span><br><span class="line">setDetails(request, authRequest);</span><br><span class="line">#<span class="number">4.</span> 调用 AuthenticationManager 进行验证（子类ProviderManager遍历所有的AuthenticationProvider认证）</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>认证请求的方法必须为<code>POST</code></li><li>从request中获取 username 和 password</li><li>封装<code>Authenticaiton</code>的实现类<code>UsernamePasswordAuthenticationToken</code>，（<code>UsernamePasswordAuthenticationToken</code>调用两个参数的构造方法setAuthenticated(false)）</li><li>调用 <code>AuthenticationManager</code> 的 <code>authenticate</code> 方法进行验证；可参考<a href="https://longfeizheng.github.io/2018/01/02/Spring-Security%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80-Spring-Security%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/#providermanager-1">ProviderManager</a>部分</li></ol><h2 id="AnonymousAuthenticationFilter"><a href="#AnonymousAuthenticationFilter" class="headerlink" title="AnonymousAuthenticationFilter"></a>AnonymousAuthenticationFilter</h2><p>从上图中过滤器的执行顺序图中可以看出<code>AnonymousAuthenticationFilter</code>过滤器是在<code>UsernamePasswordAuthenticationFilter</code>等过滤器之后，如果它前面的过滤器都没有认证成功，<code>Spring Security</code>则为当前的<code>SecurityContextHolder</code>中添加一个<code>Authenticaiton</code> 的匿名实现类<code>AnonymousAuthenticationToken</code>;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">#<span class="number">1.</span>如果前面的过滤器都没认证通过，则SecurityContextHolder中Authentication为空</span><br><span class="line"><span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">#<span class="number">2.</span>为当前的SecurityContextHolder中添加一个匿名的AnonymousAuthenticationToken</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(</span><br><span class="line">createAuthentication((HttpServletRequest) req));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Populated SecurityContextHolder with anonymous token: &#x27;&quot;</span></span><br><span class="line">+ SecurityContextHolder.getContext().getAuthentication() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;SecurityContextHolder not populated with anonymous token, as it already contained: &#x27;&quot;</span></span><br><span class="line">+ SecurityContextHolder.getContext().getAuthentication() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chain.doFilter(req, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span>创建匿名的AnonymousAuthenticationToken</span><br><span class="line"><span class="keyword">protected</span> Authentication <span class="title function_">createAuthentication</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line"><span class="type">AnonymousAuthenticationToken</span> <span class="variable">auth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnonymousAuthenticationToken</span>(key,</span><br><span class="line">principal, authorities);</span><br><span class="line">auth.setDetails(authenticationDetailsSource.buildDetails(request));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> auth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a filter with a principal named &quot;anonymousUser&quot; and the single authority</span></span><br><span class="line"><span class="comment"> * &quot;ROLE_ANONYMOUS&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key to identify tokens created by this filter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> #.创建一个用户名为anonymousUser 授权为ROLE_ANONYMOUS</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnonymousAuthenticationFilter</span><span class="params">(String key)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(key, <span class="string">&quot;anonymousUser&quot;</span>, AuthorityUtils.createAuthorityList(<span class="string">&quot;ROLE_ANONYMOUS&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>判断<code>SecurityContextHolder中Authentication</code>为否为空；</li><li>如果空则为当前的<code>SecurityContextHolder</code>中添加一个匿名的<code>AnonymousAuthenticationToken</code>（用户名为 anonymousUser 的<code>AnonymousAuthenticationToken</code>）</li></ol><h2 id="ExceptionTranslationFilter"><a href="#ExceptionTranslationFilter" class="headerlink" title="ExceptionTranslationFilter"></a>ExceptionTranslationFilter</h2><p>异常处理过滤器,该过滤器用来处理在系统认证授权过程中抛出的异常（也就是下一个过滤器<code>FilterSecurityInterceptor</code>）,主要是 处理 <code>AuthenticationException</code> 和 <code>AccessDeniedException</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line"><span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&quot;Chain processed normally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="comment">// Try to extract a SpringSecurityException from the stacktrace</span></span><br><span class="line">#.判断是不是AuthenticationException</span><br><span class="line">Throwable[] causeChain = throwableAnalyzer.determineCauseChain(ex);</span><br><span class="line"><span class="type">RuntimeException</span> <span class="variable">ase</span> <span class="operator">=</span> (AuthenticationException) throwableAnalyzer</span><br><span class="line">.getFirstThrowableOfType(AuthenticationException.class, causeChain);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ase == <span class="literal">null</span>) &#123;</span><br><span class="line">#. 判断是不是<span class="type">AccessDeniedException</span></span><br><span class="line"><span class="variable">ase</span> <span class="operator">=</span> (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType(</span><br><span class="line">AccessDeniedException.class, causeChain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ase != <span class="literal">null</span>) &#123;</span><br><span class="line">handleSpringSecurityException(request, response, chain, ase);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Rethrow ServletExceptions and RuntimeExceptions as-is</span></span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> ServletException) &#123;</span><br><span class="line"><span class="keyword">throw</span> (ServletException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line"><span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrap other Exceptions. This shouldn&#x27;t actually happen</span></span><br><span class="line"><span class="comment">// as we&#x27;ve already covered all the possibilities for doFilter</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FilterSecurityInterceptor"><a href="#FilterSecurityInterceptor" class="headerlink" title="FilterSecurityInterceptor"></a>FilterSecurityInterceptor</h2><p>此过滤器为认证授权过滤器链中最后一个过滤器，该过滤器之后就是请求真正的<code>/persons</code> 服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="type">FilterInvocation</span> <span class="variable">fi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterInvocation</span>(request, response, chain);</span><br><span class="line">invoke(fi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(FilterInvocation fi)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="keyword">if</span> ((fi.getRequest() != <span class="literal">null</span>)</span><br><span class="line">&amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) != <span class="literal">null</span>)</span><br><span class="line">&amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line"><span class="comment">// filter already applied to this request and user wants us to observe</span></span><br><span class="line"><span class="comment">// once-per-request handling, so don&#x27;t re-do security checking</span></span><br><span class="line">fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// first time this request being called, so perform security checking</span></span><br><span class="line"><span class="keyword">if</span> (fi.getRequest() != <span class="literal">null</span>) &#123;</span><br><span class="line">fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">1.</span> before invocation重要</span><br><span class="line"><span class="type">InterceptorStatusToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">super</span>.beforeInvocation(fi);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">#<span class="number">2.</span> 可以理解开始请求真正的 /persons 服务</span><br><span class="line">fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.finallyInvocation(token);</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">3.</span> after Invocation</span><br><span class="line"><span class="built_in">super</span>.afterInvocation(token, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>before invocation重要</li><li>请求真正的 &#x2F;persons 服务</li><li>after Invocation</li></ol><p>三个部分中，最重要的是 #1，该过程中会调用 <code>AccessDecisionManager</code> 来验证当前已认证成功的用户是否有权限访问该资源；</p><h3 id="before-invocation-AccessDecisionManager"><a href="#before-invocation-AccessDecisionManager" class="headerlink" title="before invocation: AccessDecisionManager"></a>before invocation: AccessDecisionManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> InterceptorStatusToken <span class="title function_">beforeInvocation</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Collection&lt;ConfigAttribute&gt; attributes = <span class="built_in">this</span>.obtainSecurityMetadataSource()</span><br><span class="line">.getAttributes(object);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="type">Authentication</span> <span class="variable">authenticated</span> <span class="operator">=</span> authenticateIfRequired();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attempt authorization</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">#<span class="number">1.</span>重点</span><br><span class="line"><span class="built_in">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">publishEvent(<span class="keyword">new</span> <span class="title class_">AuthorizationFailureEvent</span>(object, attributes, authenticated,accessDeniedException));</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>authenticated</code>就是当前认证的<code>Authentication</code>，<code>object</code>为当前请求的 <code>url:/persons</code>, getAttributes方法就是使用当前的访问资源路径去<code>匹配</code>我们自己定义的匹配规则。</p><blockquote><p>AccessDecisionManager 是如何授权的？</p></blockquote><p><code>Spring Security</code>默认使用<code>AffirmativeBased</code>实现<code>AccessDecisionManager</code> 的 <code>decide</code> 方法来实现授权</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decide</span><span class="params">(Authentication authentication, Object object,</span></span><br><span class="line"><span class="params">Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">deny</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">#<span class="number">1.</span>调用AccessDecisionVoter 进行vote(投票)</span><br><span class="line"><span class="keyword">for</span> (AccessDecisionVoter voter : getDecisionVoters()) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> voter.vote(authentication, object, configAttributes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Voter: &quot;</span> + voter + <span class="string">&quot;, returned: &quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (result) &#123;</span><br><span class="line">#<span class="number">1.1</span>只要有voter投票为ACCESS_GRANTED，则通过 直接返回</span><br><span class="line"><span class="keyword">case</span> AccessDecisionVoter.ACCESS_GRANTED:<span class="comment">//1</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">@#<span class="number">1.2</span>只要有voter投票为ACCESS_DENIED，则记录一下</span><br><span class="line"><span class="keyword">case</span> AccessDecisionVoter.ACCESS_DENIED:<span class="comment">//-1</span></span><br><span class="line">deny++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (deny &gt; <span class="number">0</span>) &#123;</span><br><span class="line">#<span class="number">2.</span>如果有一个及以上AccessDecisionVoter(姑且称之为投票者吧)都投ACCESS_DENIED，则直接就不通过了</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(messages.getMessage(</span><br><span class="line"><span class="string">&quot;AbstractAccessDecisionManager.accessDenied&quot;</span>, <span class="string">&quot;Access is denied&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// To get this far, every AccessDecisionVoter abstained</span></span><br><span class="line">checkAllowIfAllAbstainDecisions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用AccessDecisionVoter 进行vote(投票)</li><li>只要有投通过（ACCESS_GRANTED）票，则直接判为通过。</li><li>如果没有投通过则 <code>deny++</code> ,最后判断<code>if（deny&gt;0</code> 抛出<code>AccessDeniedException</code>（未授权）</li></ol><h1 id="SpringSecurityFilterChain过滤器加载流程"><a href="#SpringSecurityFilterChain过滤器加载流程" class="headerlink" title="SpringSecurityFilterChain过滤器加载流程"></a>SpringSecurityFilterChain过滤器加载流程</h1><h2 id="DelegatingFilterProxy"><a href="#DelegatingFilterProxy" class="headerlink" title="DelegatingFilterProxy"></a>DelegatingFilterProxy</h2><p>它的包结构：org.springframework.web.filter，它本身是 Spring Web 包中的类，并不是 SpringSecurity 中的类。因为 Spring 考虑到了多种使用场景，自然希望将侵入性降到最低，所以使用了这个委托代理类来代理真正的 SpringSecurityFilterChain。</p><p>DelegatingFilterProxy 实现了 javax.servlet.Filter 接口，使得它可以作为一个 java web 的标准过滤器，其职责也很简单，只负责调用真正的 SpringSecurityFilterChain。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegatingFilterProxy</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> WebApplicationContext webApplicationContext;</span><br><span class="line">   <span class="comment">// springSecurityFilterChain</span></span><br><span class="line">   <span class="keyword">private</span> String targetBeanName;</span><br><span class="line">   <span class="comment">// &lt;1&gt; 关键点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> Filter delegate;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">delegateMonitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">DelegatingFilterProxy</span><span class="params">(String targetBeanName, WebApplicationContext wac)</span> &#123;</span><br><span class="line">      Assert.hasText(targetBeanName, <span class="string">&quot;Target Filter bean name must not be null or empty&quot;</span>);</span><br><span class="line">      <span class="built_in">this</span>.setTargetBeanName(targetBeanName);</span><br><span class="line">      <span class="built_in">this</span>.webApplicationContext = wac;</span><br><span class="line">      <span class="keyword">if</span> (wac != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="built_in">this</span>.setEnvironment(wac.getEnvironment());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.delegateMonitor) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">this</span>.delegate == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.targetBeanName == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="built_in">this</span>.targetBeanName = getFilterName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Fetch Spring root application context and initialize the delegate early,</span></span><br><span class="line">            <span class="comment">// if possible. If the root application context will be started after this</span></span><br><span class="line">            <span class="comment">// filter proxy, we&#x27;ll have to resort to lazy initialization.</span></span><br><span class="line">            <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> findWebApplicationContext();</span><br><span class="line">            <span class="keyword">if</span> (wac != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="built_in">this</span>.delegate = initDelegate(wac);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><br><span class="line">         <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 过滤器代理支持懒加载</span></span><br><span class="line">      <span class="type">Filter</span> <span class="variable">delegateToUse</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">      <span class="keyword">if</span> (delegateToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="built_in">this</span>.delegateMonitor) &#123;</span><br><span class="line">            delegateToUse = <span class="built_in">this</span>.delegate;</span><br><span class="line">            <span class="keyword">if</span> (delegateToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> findWebApplicationContext();</span><br><span class="line">               delegateToUse = initDelegate(wac);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.delegate = delegateToUse;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 让代理过滤器执行实际的过滤行为</span></span><br><span class="line">      invokeDelegate(delegateToUse, request, response, filterChain);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化过滤器代理</span></span><br><span class="line">   <span class="comment">// &lt;2&gt;</span></span><br><span class="line">   <span class="keyword">protected</span> Filter <span class="title function_">initDelegate</span><span class="params">(WebApplicationContext wac)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">      <span class="type">Filter</span> <span class="variable">delegate</span> <span class="operator">=</span> wac.getBean(getTargetBeanName(), Filter.class);</span><br><span class="line">      <span class="keyword">if</span> (isTargetFilterLifecycle()) &#123;</span><br><span class="line">         delegate.init(getFilterConfig());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> delegate;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用代理过滤器</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeDelegate</span><span class="params">(</span></span><br><span class="line"><span class="params">         Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><br><span class="line">         <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">      delegate.doFilter(request, response, filterChain);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;1&gt; 可以发现整个 DelegatingFilterProxy 的逻辑就是为了调用 <code>private volatile Filter delegate;</code></p><p>&lt;2&gt; 可以看到，DelegatingFilterProxy 尝试去容器中获取名为 targetBeanName 的类，而 targetBeanName 的默认值便是 Filter 的名称，也就是 springSecurityFilterChain</p><p>DelegatingFilterProxy 只是名称和 targetBeanName 叫 springSecurityFilterChain，真正容器中的 Bean(name&#x3D;”springSecurityFilterChain”) 其实另有其人——通过 debug，我们发现了真正的 springSecurityFilterChain — FilterChainProxy。</p><blockquote><p>SpringSecurityFilterChain 是什么时候被放进去的？</p></blockquote><p>这就得说到老朋友 WebSecurity 了，还记得一般我们都会选择使用 @EnableWebSecurity 和 WebSecurityConfigurerAdapter 来进行 web 安全配置吗，来到 WebSecurity 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WebSecurity</span> <span class="keyword">extends</span></span><br><span class="line">      <span class="title class_">AbstractConfiguredSecurityBuilder</span>&lt;Filter, WebSecurity&gt; <span class="keyword">implements</span></span><br><span class="line">      <span class="title class_">SecurityBuilder</span>&lt;Filter&gt;, ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Filter <span class="title function_">performBuild</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">chainSize</span> <span class="operator">=</span> ignoredRequests.size() + securityFilterChainBuilders.size();</span><br><span class="line">List&lt;SecurityFilterChain&gt; securityFilterChains = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SecurityFilterChain&gt;(</span><br><span class="line">chainSize);</span><br><span class="line"><span class="keyword">for</span> (RequestMatcher ignoredRequest : ignoredRequests) &#123;</span><br><span class="line">securityFilterChains.add(<span class="keyword">new</span> <span class="title class_">DefaultSecurityFilterChain</span>(ignoredRequest));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (SecurityBuilder&lt;? <span class="keyword">extends</span> <span class="title class_">SecurityFilterChain</span>&gt; securityFilterChainBuilder : securityFilterChainBuilders) &#123;</span><br><span class="line">securityFilterChains.add(securityFilterChainBuilder.build());</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// &lt;1&gt; FilterChainProxy 由 WebSecurity 构建</span></span><br><span class="line"><span class="type">FilterChainProxy</span> <span class="variable">filterChainProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterChainProxy</span>(securityFilterChains);</span><br><span class="line"><span class="keyword">if</span> (httpFirewall != <span class="literal">null</span>) &#123;</span><br><span class="line">filterChainProxy.setFirewall(httpFirewall);</span><br><span class="line">&#125;</span><br><span class="line">filterChainProxy.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line"><span class="type">Filter</span> <span class="variable">result</span> <span class="operator">=</span> filterChainProxy;</span><br><span class="line">postBuildAction.run();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;1&gt; 最终定位到 WebSecurity 的 performBuild 方法，我们之前配置了一堆参数的 WebSecurity 最终帮助我们构建了 FilterChainProxy。</p><p>并且，最终在 <code>org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration</code>中被注册为默认名称为 SpringSecurityFilterChain。</p><h2 id="FilterChainProxy"><a href="#FilterChainProxy" class="headerlink" title="FilterChainProxy"></a>FilterChainProxy</h2><p>它才是真正的 springSecurityFilterChain，我们来看看它的源码（有删减，不影响理解）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterChainProxy</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line">   <span class="comment">// &lt;1&gt; 包含了多个SecurityFilterChain</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;SecurityFilterChain&gt; filterChains;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">FilterChainProxy</span><span class="params">(SecurityFilterChain chain)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>(Arrays.asList(chain));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">FilterChainProxy</span><span class="params">(List&lt;SecurityFilterChain&gt; filterChains)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.filterChains = filterChains;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">      filterChainValidator.validate(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">         FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">         doFilterInternal(request, response, chain);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">         FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">FirewalledRequest</span> <span class="variable">fwRequest</span> <span class="operator">=</span> firewall</span><br><span class="line">            .getFirewalledRequest((HttpServletRequest) request);</span><br><span class="line">      <span class="type">HttpServletResponse</span> <span class="variable">fwResponse</span> <span class="operator">=</span> firewall</span><br><span class="line">            .getFirewalledResponse((HttpServletResponse) response);</span><br><span class="line">  <span class="comment">// &lt;1&gt;</span></span><br><span class="line">      List&lt;Filter&gt; filters = getFilters(fwRequest);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (filters == <span class="literal">null</span> || filters.size() == <span class="number">0</span>) &#123;</span><br><span class="line">         fwRequest.reset();</span><br><span class="line">         chain.doFilter(fwRequest, fwResponse);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">VirtualFilterChain</span> <span class="variable">vfc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualFilterChain</span>(fwRequest, chain, filters);</span><br><span class="line">      vfc.doFilter(fwRequest, fwResponse);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &lt;1&gt; 可能会有多个过滤器链，返回第一个和请求URL匹配的过滤器链</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;Filter&gt; <span class="title function_">getFilters</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (SecurityFilterChain chain : filterChains) &#123;</span><br><span class="line">         <span class="keyword">if</span> (chain.matches(request)) &#123;</span><br><span class="line">            <span class="keyword">return</span> chain.getFilters();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看 FilterChainProxy 的名字就可以发现，它依旧不是真正实施过滤的类，它内部维护了一个 SecurityFilterChain，这个过滤器链才是请求真正对应的过滤器链，并且同一个 Spring 环境下，可能同时存在多个安全过滤器链，如 private List filterChains 所示，需要经过 chain.matches(request) 判断到底哪个过滤器链匹配成功，每个 request 最多只会经过一个 SecurityFilterChain。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;基本上，在所有的开发的系统中，都必须做认证(authentication)和授权(authorization)，以保证系统的</summary>
      
    
    
    
    
    <category term="Spring Security" scheme="https://palette-k.github.io/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>加签和验签</title>
    <link href="https://palette-k.github.io/2024/01/23/%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/"/>
    <id>https://palette-k.github.io/2024/01/23/%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/</id>
    <published>2024-01-23T10:25:02.000Z</published>
    <updated>2024-01-24T09:46:38.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学概念"><a href="#密码学概念" class="headerlink" title="密码学概念"></a>密码学概念</h1><h2 id="明文、密文、密钥、加密、解密"><a href="#明文、密文、密钥、加密、解密" class="headerlink" title="明文、密文、密钥、加密、解密"></a>明文、密文、密钥、加密、解密</h2><ul><li>明文：指没有经过加密的信息&#x2F;数据。</li><li>密文：明文被加密算法加密之后，会变成密文，以确保数据安全。</li><li>密钥：是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。</li><li>加密：将明文变成密文的过程。</li><li>解密：将密文还原为明文的过程。</li></ul><h2 id="对称加密、非对称加密"><a href="#对称加密、非对称加密" class="headerlink" title="对称加密、非对称加密"></a>对称加密、非对称加密</h2><ul><li>对称加密：加密和解密使用相同密钥的加密算法。</li><li>非对称加密：非对称加密算法需要两个密钥（公开密钥和私有密钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。</li></ul><h2 id="什么是公钥私钥？"><a href="#什么是公钥私钥？" class="headerlink" title="什么是公钥私钥？"></a>什么是公钥私钥？</h2><ul><li>公钥与私钥是成对存在的密钥，如果用公钥对数据进行加密，只有用对应的私钥才能解密。</li><li>其实，公钥就是公开的秘钥，私钥就是要你私自保存好的秘钥。</li><li>非对称加密算法需要有一对公私钥~</li></ul><h1 id="加签验签概念"><a href="#加签验签概念" class="headerlink" title="加签验签概念"></a>加签验签概念</h1><p><strong>「加签」</strong>：用Hash函数把原始报文生成报文摘要，然后用私钥对这个摘要进行加密，就得到这个报文对应的数字签名。通常来说呢，请求方会把<strong>「数字签名和报文原文」</strong>一并发送给接收方。</p><p><img src="https://i0.hdslb.com/bfs/article/3afa1614473420ae859db75b5844ebfb171301454.png" alt="image-20240123194037932"></p><p><strong>「验签」</strong>：接收方拿到原始报文和数字签名后，用<strong>「同一个Hash函数」</strong>从报文中生成摘要A。另外，用对方提供的公钥对数字签名进行解密，得到摘要B，对比A和B是否相同，就可以得知报文有没有被篡改过。</p><p><img src="https://i0.hdslb.com/bfs/article/d5e65c2f233576edd445aafe8ad2c148171301454.png" alt="image-20240123194253661"></p><h2 id="为什么需要加签和验签"><a href="#为什么需要加签和验签" class="headerlink" title="为什么需要加签和验签"></a>为什么需要加签和验签</h2><blockquote><p>为什么需要加签和验签呢？我们不是用<strong>「公钥加密，私钥解密」</strong>就好了嘛？</p></blockquote><p><img src="https://i0.hdslb.com/bfs/article/c01f928b38175b2862215b74d1717d1d171301454.png" alt="image-20240123194922845"></p><p>假设现在有A公司，要接入C公司的转账系统。</p><p>在一开始，C公司把自己的公钥寄给A公司，自己收藏好私钥。</p><p>A公司这边的商户，发起转账时，A公司先用C公司的公钥，对请求报文加密，加密报文到达C公司的转账系统时，C公司就用自己的私钥把报文解开。</p><p>假设在加密的报文在传输过程中，被入侵者获取了，他也郁闷，因为他没有私钥，本来想修改报文，给自己账号转一个亿的，哈哈。这个实现方式看起来是天衣无缝，稳得一匹的。</p><p>但是呢，如果一开始，C公司把公钥发给公司A的时候，就被入侵者获取到呢？</p><p>入侵者截取了C的公钥，他把自己的公钥发给了A公司，A误以为这就是C公司的公钥。A在发起转账时，用入侵者的公钥，对请求报文加密，加密报文到在传输过程，入侵者又截取了，这时候，他用自己的私钥解密，然后修改了报文（给自己转一个亿），再用C的公钥加密，发给C公司，C公司收到报文后，继续用自己的私钥解密。最后是不是A公司的转账账户损失了一个亿呢~</p><p><img src="https://i0.hdslb.com/bfs/article/c4e21e133c29eaaec66f0fb0153887c2171301454.png" alt="image-20240123195714790"></p><p>C公司是怎么区分报文是不是来自A呢，还是被入侵者修改过呢？为了表明身份和报文真实性，这就需要<strong>「加签验签」</strong>啦！</p><p>A公司把自己的公钥也发送给C公司，私钥自己保留着。在发起转账时，先用自己的私钥对请求报文加签，于是得到自己的数字签名。再把数字签名和请求报文一起发送给C公司。C公司收到报文后，拿A的公钥进行验签，如果原始报文和数字签名的摘要内容不一致，那就是报文被篡改啦~</p><p><img src="https://i0.hdslb.com/bfs/article/78eb7169a6300b247e60765ce5483e1a171301454.png" alt="image-20240123200041173"></p><p>假设A在发自己的公钥给C公司的时候，也被入侵者截取了呢？</p><p>假设入侵者截取到A的公钥后，随后也截取了到A发往C的报文。他截取到报文后，第一件想做的事肯定是修改报文内容。但是如果单单修改原始报文是不可以的，因为发过去C公司肯定验签不过啦。但是呢，数字签名似乎解不开，因为消息摘要算法（hash算法）无法逆向解开的，只起验证的作用呢….</p><p>所以呢，公钥与私钥是用来加密与解密的，<strong>「加签与验签是用来证明身份」</strong>，以免被篡改的。</p><h2 id="消息摘要算法"><a href="#消息摘要算法" class="headerlink" title="消息摘要算法"></a>消息摘要算法</h2><ul><li>相同的明文数据经过相同的消息摘要算法会得到相同的密文结果值。</li><li>数据经过消息摘要算法处理，得到的摘要结果值，是无法还原为处理前的数据的。</li><li>数据摘要算法也被称为哈希（Hash）算法或散列算法。</li><li>消息摘要算法一般用于签名验签。</li></ul><p>消息摘要算法主要分三类：MD（Message Digest，消息摘要算法）、SHA（Secure Hash Algorithm，安全散列算法）和MAC（Message Authentication Code，消息认证码算法）。</p><h3 id="MD家族算法"><a href="#MD家族算法" class="headerlink" title="MD家族算法"></a>MD家族算法</h3><p>MD（Message Digest，消息摘要算法）家族，包括MD2，MD4，MD5。</p><ul><li>MD2，MD4，MD5 计算的结果都是是一个128位（即16字节）的散列值，用于确保信息传输完整一致。</li><li>MD2的算法较慢但相对安全，MD4速度很快，但安全性下降，MD5则比MD4更安全、速度更快。</li><li>MD5被广泛应用于数据完整性校验、数据（消息）摘要、数据加密等。</li><li>MD5，可以被破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞攻击，因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。</li></ul><p><strong>MD5破解方式：</strong>把常用的密码先MD5处理，并将数据存储起来，然后跟需要查询的MD5结果匹配，这时就有可能通过匹配的MD5得到明文，所以有些简单的MD5码是反查到加密前原文的。</p><p>为了让MD5码更加安全，涌现了很多其他方法，如加盐。 盐要足够长足够乱，得到的MD5码就很难查到。</p><blockquote><p>MD5 算加密算法吗？</p></blockquote><p>MD5 算法和加密算法都可以将信息转换为另外一种内容，但是，<strong>MD5 算法对比 加密算法缺少了解密过程。</strong></p><p>使用 <strong>加密算法</strong> 加密后的消息是完整的，并且基于解密算法后，可以恢复原始数据。而 <strong>MD5 算法</strong> 得到的消息是不完整的，并且通过摘要的数据也无法得到原始数据。</p><p>所以严格意义上来讲，<strong>MD5 称为摘要&#x2F;散列算法更合适，而不是加密算法</strong>！</p><h3 id="SHA家族算法"><a href="#SHA家族算法" class="headerlink" title="SHA家族算法"></a>SHA家族算法</h3><p>SHA（Secure Hash Algorithm，安全散列算法，它是在MD算法基础上实现的，与MD算法区别在于<strong>「摘要长度」</strong>，SHA 算法的摘要<strong>「长度更长，安全性更高」</strong>。</p><h3 id="MAC算法家族"><a href="#MAC算法家族" class="headerlink" title="MAC算法家族"></a>MAC算法家族</h3><p>MAC算法 MAC（Message Authentication Code，消息认证码算法），是带密钥的Hash函数。输入密钥和消息，输出一个消息摘要。它集合了MD和SHA两大系列消息摘要算法。</p><h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>加密和解密使用<strong>「相同密钥」</strong>的加密算法就是对称加密算法。常见的对称加密算法有AES、3DES、DES、RC5、RC6等。</p><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p>数据加密标准（英语：Data Encryption Standard，缩写为 DES）是一种对称密钥加密块密码算法。DES算法的入口参数有三个：Key、Data、Mode。</p><ul><li>Key: 7个字节共56位，是DES算法的工作密钥；</li><li>Data: 8个字节64位，是要被加密或被解密的数据；</li><li>Mode: 加密或解密。</li></ul><h3 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h3><p>三重数据加密算法（英语：Triple Data Encryption Algorithm，又称3DES（Triple DES），是一种对称密钥加密块密码，相当于是对每个数据块应用三次数据加密标准（DES）算法。</p><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>AES，高级加密标准（英语：Advanced Encryption Standard），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。</p><ul><li>采用对称分组密码体制，密钥长度为 128 位、 192 位、256 位，分组长度128位</li><li>相对于DES ，AES具有更好的 安全性、效率 和 灵活性。</li></ul><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><p>非对称加密算法需要两个密钥：公钥和私钥。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有用对应的私钥才能解密。主要的非对称加密算法有：RSA、Elgamal、DSA、D-H、ECC。</p><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><ul><li>RSA加密算法是一种非对称加密算法,广泛应用于加密和<strong>数字签名</strong></li><li>RSA算法原理：两个大素数的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</li><li>RSA是被研究得最广泛的公钥算法，从提出到现在，经历了各种攻击的考验，普遍认为是目前最优秀的公钥方案之一。</li></ul><h3 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h3><ul><li>DSA(Digital Signature Algorithm,数字签名算法),也是一种非对称加密算法。</li><li>DSA和RSA区别在，DSA仅用于数字签名，不能用于数据加密解密。其安全性和RSA相当，但其性能要比RSA好。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学概念&quot;&gt;&lt;a href=&quot;#密码学概念&quot; class=&quot;headerlink&quot; title=&quot;密码学概念&quot;&gt;&lt;/a&gt;密码学概念&lt;/h1&gt;&lt;h2 id=&quot;明文、密文、密钥、加密、解密&quot;&gt;&lt;a href=&quot;#明文、密文、密钥、加密、解密&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="密码" scheme="https://palette-k.github.io/tags/%E5%AF%86%E7%A0%81/"/>
    
    <category term="算法" scheme="https://palette-k.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="验签" scheme="https://palette-k.github.io/tags/%E9%AA%8C%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>Maven入门到实战</title>
    <link href="https://palette-k.github.io/2024/01/18/Maven%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"/>
    <id>https://palette-k.github.io/2024/01/18/Maven%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</id>
    <published>2024-01-18T01:34:41.000Z</published>
    <updated>2024-01-22T10:39:57.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven-的安装与配置"><a href="#Maven-的安装与配置" class="headerlink" title="Maven 的安装与配置"></a>Maven 的安装与配置</h1><p>下载地址：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>使用 <code>win + r</code> 打开运行框，输入<code>control system</code>，回车进入设置界面后，创建一个环境变量<code>MAVEN_HOME</code>（maven的安装地址）。</p><p>创建好后，找到系统变量中的<code>path</code>，将<code>MAVEN_HOME</code>这个变量配置进去：%MAVEN_HOME%\bin</p><p>打开<code>cmd</code>命令行输入<code>mvn -v</code>，打印出版本号表示安装成功。</p><h2 id="修改-settings-xml"><a href="#修改-settings-xml" class="headerlink" title="修改 settings.xml"></a>修改 settings.xml</h2><p>修改 conf 下的 settings.xml，将 localRepository 替换成本地的 maven 仓库地址。</p><p>至此，maven 就能正常使用了！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">Licensed to the Apache Software Foundation (ASF) under one</span></span><br><span class="line"><span class="comment">or more contributor license agreements.  See the NOTICE file</span></span><br><span class="line"><span class="comment">distributed with this work for additional information</span></span><br><span class="line"><span class="comment">regarding copyright ownership.  The ASF licenses this file</span></span><br><span class="line"><span class="comment">to you under the Apache License, Version 2.0 (the</span></span><br><span class="line"><span class="comment">&quot;License&quot;); you may not use this file except in compliance</span></span><br><span class="line"><span class="comment">with the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Unless required by applicable law or agreed to in writing,</span></span><br><span class="line"><span class="comment">software distributed under the License is distributed on an</span></span><br><span class="line"><span class="comment">&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span></span><br><span class="line"><span class="comment">KIND, either express or implied.  See the License for the</span></span><br><span class="line"><span class="comment">specific language governing permissions and limitations</span></span><br><span class="line"><span class="comment">under the License.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> | This is the configuration file for Maven. It can be specified at two levels:</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |  1. User Level. This settings.xml file provides configuration for a single user,</span></span><br><span class="line"><span class="comment"> |                 and is normally provided in $&#123;user.home&#125;/.m2/settings.xml.</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 <span class="doctag">NOTE:</span> This location can be overridden with the CLI option:</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 -s /path/to/user/settings.xml</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |  2. Global Level. This settings.xml file provides configuration for all Maven</span></span><br><span class="line"><span class="comment"> |                 users on a machine (assuming they&#x27;re all using the same Maven</span></span><br><span class="line"><span class="comment"> |                 installation). It&#x27;s normally provided in</span></span><br><span class="line"><span class="comment"> |                 $&#123;maven.conf&#125;/settings.xml.</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 <span class="doctag">NOTE:</span> This location can be overridden with the CLI option:</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 -gs /path/to/global/settings.xml</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> | The sections in this sample file are intended to give you a running start at</span></span><br><span class="line"><span class="comment"> | getting the most out of your Maven installation. Where appropriate, the default</span></span><br><span class="line"><span class="comment"> | values (values used when the setting is not specified) are provided.</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">   | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\mvnrepository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- interactiveMode</span></span><br><span class="line"><span class="comment">   | This will determine whether maven prompts you when it needs input. If set to false,</span></span><br><span class="line"><span class="comment">   | maven will use a sensible default value, perhaps based on some other setting, for</span></span><br><span class="line"><span class="comment">   | the parameter in question.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: true</span></span><br><span class="line"><span class="comment">  &lt;interactiveMode&gt;true&lt;/interactiveMode&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- offline</span></span><br><span class="line"><span class="comment">   | Determines whether maven should attempt to connect to the network when executing a build.</span></span><br><span class="line"><span class="comment">   | This will have an effect on artifact downloads, artifact deployment, and others.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: false</span></span><br><span class="line"><span class="comment">  &lt;offline&gt;false&lt;/offline&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- pluginGroups</span></span><br><span class="line"><span class="comment">   | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.</span></span><br><span class="line"><span class="comment">   | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers</span></span><br><span class="line"><span class="comment">   | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- pluginGroup</span></span><br><span class="line"><span class="comment">     | Specifies a further group identifier to use for plugin lookup.</span></span><br><span class="line"><span class="comment">    &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- proxies</span></span><br><span class="line"><span class="comment">   | This is a list of proxies which can be used on this machine to connect to the network.</span></span><br><span class="line"><span class="comment">   | Unless otherwise specified (by system property or command-line switch), the first proxy</span></span><br><span class="line"><span class="comment">   | specification in this list marked as active will be used.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- proxy</span></span><br><span class="line"><span class="comment">     | Specification for one proxy, to be used in connecting to the network.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;proxy&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;optional&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;active&gt;true&lt;/active&gt;</span></span><br><span class="line"><span class="comment">      &lt;protocol&gt;http&lt;/protocol&gt;</span></span><br><span class="line"><span class="comment">      &lt;username&gt;proxyuser&lt;/username&gt;</span></span><br><span class="line"><span class="comment">      &lt;password&gt;proxypass&lt;/password&gt;</span></span><br><span class="line"><span class="comment">      &lt;host&gt;proxy.host.net&lt;/host&gt;</span></span><br><span class="line"><span class="comment">      &lt;port&gt;80&lt;/port&gt;</span></span><br><span class="line"><span class="comment">      &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;</span></span><br><span class="line"><span class="comment">    &lt;/proxy&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- servers</span></span><br><span class="line"><span class="comment">   | This is a list of authentication profiles, keyed by the server-id used within the system.</span></span><br><span class="line"><span class="comment">   | Authentication profiles can be used whenever maven must make a connection to a remote server.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- server</span></span><br><span class="line"><span class="comment">     | Specifies the authentication information to use when connecting to a particular server, identified by</span></span><br><span class="line"><span class="comment">     | a unique name within the system (referred to by the &#x27;id&#x27; attribute below).</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | <span class="doctag">NOTE:</span> You should either specify username/password OR privateKey/passphrase, since these pairings are</span></span><br><span class="line"><span class="comment">     |       used together.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;server&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;deploymentRepo&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;username&gt;repouser&lt;/username&gt;</span></span><br><span class="line"><span class="comment">      &lt;password&gt;repopwd&lt;/password&gt;</span></span><br><span class="line"><span class="comment">    &lt;/server&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Another sample, using keys to authenticate.</span></span><br><span class="line"><span class="comment">    &lt;server&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;siteServer&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt;</span></span><br><span class="line"><span class="comment">      &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt;</span></span><br><span class="line"><span class="comment">    &lt;/server&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- mirrors</span></span><br><span class="line"><span class="comment">   | This is a list of mirrors to be used in downloading artifacts from remote repositories.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | It works like this: a POM may declare a repository to use in resolving certain artifacts.</span></span><br><span class="line"><span class="comment">   | However, this repository may have problems with heavy traffic at times, so people have mirrored</span></span><br><span class="line"><span class="comment">   | it to several places.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | That repository definition will have a unique id, so we can create a mirror reference for that</span></span><br><span class="line"><span class="comment">   | repository, to be used as an alternate download site. The mirror site will be the preferred</span></span><br><span class="line"><span class="comment">   | server for that repository.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- mirror</span></span><br><span class="line"><span class="comment">&lt;mirrors&gt;</span></span><br><span class="line"><span class="comment">     | Specifies a repository mirror site to use instead of a given repository. The repository that</span></span><br><span class="line"><span class="comment">     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span></span><br><span class="line"><span class="comment">     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;mirrorId&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span></span><br><span class="line"><span class="comment">      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;</span></span><br><span class="line"><span class="comment">    &lt;/mirror&gt;</span></span><br><span class="line"><span class="comment"> &lt;/mirrors&gt;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 阿里云仓库 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">&lt;id&gt;nexus-aliyun&lt;/id&gt;</span></span><br><span class="line"><span class="comment">&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">&lt;name&gt;Nexus aliyun&lt;/name&gt;</span></span><br><span class="line"><span class="comment">&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span></span><br><span class="line"><span class="comment">&lt;/mirror&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- profiles</span></span><br><span class="line"><span class="comment">   | This is a list of profiles which can be activated in a variety of ways, and which can modify</span></span><br><span class="line"><span class="comment">   | the build process. Profiles provided in the settings.xml are intended to provide local machine-</span></span><br><span class="line"><span class="comment">   | specific paths and repository locations which allow the build to work in the local environment.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | For example, if you have an integration testing plugin - like cactus - that needs to know where</span></span><br><span class="line"><span class="comment">   | your Tomcat instance is installed, you can provide a variable here such that the variable is</span></span><br><span class="line"><span class="comment">   | dereferenced during the build process to configure the cactus plugin.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles</span></span><br><span class="line"><span class="comment">   | section of this document (settings.xml) - will be discussed later. Another way essentially</span></span><br><span class="line"><span class="comment">   | relies on the detection of a system property, either matching a particular value for the property,</span></span><br><span class="line"><span class="comment">   | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a</span></span><br><span class="line"><span class="comment">   | value of &#x27;1.4&#x27; might activate a profile when the build is executed on a JDK version of &#x27;1.4.2_07&#x27;.</span></span><br><span class="line"><span class="comment">   | Finally, the list of active profiles can be specified directly from the command line.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | <span class="doctag">NOTE:</span> For profiles defined in the settings.xml, you are restricted to specifying only artifact</span></span><br><span class="line"><span class="comment">   |       repositories, plugin repositories, and free-form properties to be used as configuration</span></span><br><span class="line"><span class="comment">   |       variables for plugins in the POM.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- profile</span></span><br><span class="line"><span class="comment">&lt;profiles&gt;</span></span><br><span class="line"><span class="comment">     | Specifies a set of introductions to the build process, to be activated using one or more of the</span></span><br><span class="line"><span class="comment">     | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt;</span></span><br><span class="line"><span class="comment">     | or the command line, profiles have to have an ID that is unique.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | An encouraged best practice for profile identification is to use a consistent naming convention</span></span><br><span class="line"><span class="comment">     | for profiles, such as &#x27;env-dev&#x27;, &#x27;env-test&#x27;, &#x27;env-production&#x27;, &#x27;user-jdcasey&#x27;, &#x27;user-brett&#x27;, etc.</span></span><br><span class="line"><span class="comment">     | This will make it more intuitive to understand what the set of introduced profiles is attempting</span></span><br><span class="line"><span class="comment">     | to accomplish, particularly when you only have a list of profile id&#x27;s for debug.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo.</span></span><br><span class="line"><span class="comment">    &lt;profile&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;jdk-1.4&lt;/id&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;activation&gt;</span></span><br><span class="line"><span class="comment">        &lt;jdk&gt;1.4&lt;/jdk&gt;</span></span><br><span class="line"><span class="comment">      &lt;/activation&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;repositories&gt;</span></span><br><span class="line"><span class="comment">        &lt;repository&gt;</span></span><br><span class="line"><span class="comment">          &lt;id&gt;jdk14&lt;/id&gt;</span></span><br><span class="line"><span class="comment">          &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt;</span></span><br><span class="line"><span class="comment">          &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt;</span></span><br><span class="line"><span class="comment">          &lt;layout&gt;default&lt;/layout&gt;</span></span><br><span class="line"><span class="comment">          &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt;</span></span><br><span class="line"><span class="comment">        &lt;/repository&gt;</span></span><br><span class="line"><span class="comment">      &lt;/repositories&gt;</span></span><br><span class="line"><span class="comment">    &lt;/profile&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     | Here is another profile, activated by the system property &#x27;target-env&#x27; with a value of &#x27;dev&#x27;,</span></span><br><span class="line"><span class="comment">     | which provides a specific path to the Tomcat instance. To use this, your plugin configuration</span></span><br><span class="line"><span class="comment">     | might hypothetically look like:</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | ...</span></span><br><span class="line"><span class="comment">     | &lt;plugin&gt;</span></span><br><span class="line"><span class="comment">     |   &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">     |   &lt;artifactId&gt;myplugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     |   &lt;configuration&gt;</span></span><br><span class="line"><span class="comment">     |     &lt;tomcatLocation&gt;$&#123;tomcatPath&#125;&lt;/tomcatLocation&gt;</span></span><br><span class="line"><span class="comment">     |   &lt;/configuration&gt;</span></span><br><span class="line"><span class="comment">     | &lt;/plugin&gt;</span></span><br><span class="line"><span class="comment">     | ...</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | <span class="doctag">NOTE:</span> If you just wanted to inject this configuration whenever someone set &#x27;target-env&#x27; to</span></span><br><span class="line"><span class="comment">     |       anything, you could just leave off the &lt;value/&gt; inside the activation-property.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;profile&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;env-dev&lt;/id&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;activation&gt;</span></span><br><span class="line"><span class="comment">        &lt;property&gt;</span></span><br><span class="line"><span class="comment">          &lt;name&gt;target-env&lt;/name&gt;</span></span><br><span class="line"><span class="comment">          &lt;value&gt;dev&lt;/value&gt;</span></span><br><span class="line"><span class="comment">        &lt;/property&gt;</span></span><br><span class="line"><span class="comment">      &lt;/activation&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;properties&gt;</span></span><br><span class="line"><span class="comment">        &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt;</span></span><br><span class="line"><span class="comment">      &lt;/properties&gt;</span></span><br><span class="line"><span class="comment">    &lt;/profile&gt;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- activeProfiles</span></span><br><span class="line"><span class="comment">   | List of profiles that are active for all builds.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">  &lt;activeProfiles&gt;</span></span><br><span class="line"><span class="comment">    &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt;</span></span><br><span class="line"><span class="comment">    &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;</span></span><br><span class="line"><span class="comment">  &lt;/activeProfiles&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Maven-配置详解"><a href="#Maven-配置详解" class="headerlink" title="Maven 配置详解"></a>Maven 配置详解</h1><p>pom.xml 的基本结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ls.mavendemo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-world<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hello-world<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先看一下各个标签的含义：</p><p><project> ：POM 的根元素，定义了一些POM相关的规范。<br><modelVersion>: POM版本号，我们用的是 Maven3 这里只能是4.0.0<br><groupId> <artifactId> <version>：项目的坐标，用于确定一个唯一的项目</p><ul><li><code>&lt;groupId&gt;</code>：指的是当前构建隶属的实际项目，一般是 公司的网址倒序 + 项目名</li><li><code>&lt;artifactId&gt;</code>：一般是指的当前项目中的其中一个模块</li><li><code>&lt;version&gt;</code>：当前项目的版本号</li></ul><p>Maven 的版本号规则实际上也是业界的通过规则，它的定义方式如下：</p><p><code>&#123;主版本号&#125;.&#123;次版本号&#125;.&#123;增量版本号&#125;-&#123;里程碑版本&#125;</code><br><strong>主版本号：</strong>一般是指的当前的项目有了重大的架构变动，版本之间几乎完全不兼容，例如：最近出的 SpringBoot3 就已经放弃了Java8，如果不升级 JDK的话，还是只能使用SpringBoot2<br><strong>次版本号：</strong>一般是指的项目的迭代版本，这种版本会修复大量的bug，带来一些小的新特性等，但是没有什么架构上的重大变化。<br><strong>增量版本号：</strong>一般是用于修复一些紧急bug，改动量很小时，可以使用增量版本号。<br><strong>里程碑版本：</strong>就是项目的当前版本处于一个什么样的阶段了，常见的里程碑版本有 SNAPSHOT，alpha，beta，release，GA 等。</p><ul><li>SNAPSHOT：开发版，此时会存在大量的代码变动</li><li>alpha和beta分别对应的是内测版与公测版，属于不稳定版本，使用的时候非常容易踩坑，所以一般只用于demo体验，在正式环境中不能使用。</li><li>release和GA都属于是稳定的正式版本，可以在正式环境中使用。</li></ul><p><name>：当前项目的名称<br><dependencies>：当前项目引入的依赖<br><dependency>：单个需要引入的具体的依赖包<br><scope>：依赖的范围，常见的有 compile 和 test，不同的范围起到包隔离的作用</p><h2 id="Maven-的依赖"><a href="#Maven-的依赖" class="headerlink" title="Maven 的依赖"></a>Maven 的依赖</h2><p>来看一下完整的依赖配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--type 指的的当前引入的构件类型，默认为 jar --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span><span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span><span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>通过<code>pom.xml</code> 分别描述 A、B 构建的依赖关系：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A 依赖 B --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ls.mavendemo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- B 依赖 C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ls.mavendemo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，A 可以使用 C 里面打包的代码。</p><p>在上面的依赖配置基础上，如果我们不想将 C 传递给 A，则可以在 B 引入 C 的时候，将其设置为可选依赖：</p><p>引入的依赖如果标记为 <code>optional</code> 则不再向上传递，此时 A 不能再直接使用 C中的代码，可以选依赖在 <code>pom.xml</code> 中表示为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- B 依赖 C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ls.mavendemo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>为什么会需要禁止依赖传递？</p></blockquote><p>举个简单的开发例子，我们在一个 WEB 项目的开发中，将 service 层与 dao 分别拆成了两个构件，service 包依赖 dao 包，但是 service 中只需要使用我们写的主代码，而不需要使用例如数据库驱动、JDBC、ORM框架等依赖，我们就可以在 dao 中使用<optional>禁止这些持久化相关的包向上传递到service。</p><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>依赖范围在 pom.xml 中使用 <scope></scope> 来表示，有5种选项：</p><ul><li>compile：默认选项，也是最常用的选项，在编译、运行、测试的classpath中有引入；依赖范围在向上传递的时候，间接依赖于直接依赖的范围一致</li><li>provided：只在编译、测试引入，运行时不引入，例如：lombok；依赖范围不会向上传递</li><li>runtime：只在运行、测试引入，编译期不引入，例如：mysql-connector-java；依赖范围可向上传递，直接依赖为<code>compile</code>时，间接依赖的范围依然是<code>runtime</code></li><li>test：只在测试中有效，例如：JUnit；依赖范围不会向上传递</li><li>system：与provided相同，但是需要手动指定依赖文件路径（system会破坏可移植性，不推荐使用）</li></ul><h3 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h3><p><strong>直接依赖：</strong>在同一个 pom.xml 下，后声明的依赖会覆盖先声明的依赖。</p><p><strong>间接依赖：</strong>在不同的 pom.xml 下，依赖路径最短的那个依赖会生效，也就是<strong>就近原则</strong>。</p><p>有时候我们需要手动的排除一部分传递性的依赖，然后再定义我们需要的依赖，举个简单的例子：</p><p>我们在 spring-boot 的项目中使用 redis，首先需要引入一个 starter，这个 starter 中又依赖了 <code>lettuce</code> 这个客户端，此时，我们不想使用这个客户端，想切换成 <code>jedis</code>，那么我们就可以使用<code>exclusions</code> 将 <code>lettuce</code> 排除掉。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注：这里的exclusion 中不需要使用版本号。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后再引入 <code>jedis</code> 的依赖就可以了。</p><h1 id="Maven-的继承与聚合"><a href="#Maven-的继承与聚合" class="headerlink" title="Maven 的继承与聚合"></a>Maven 的继承与聚合</h1><h2 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h2><p>所有的 pom.xml 文件都会默认继承 super pom，在 super pom 中定义了这么几个配置：</p><ul><li><p>构件与插件仓库的地址</p></li><li><p>源码、测试代码以及资源文件resources的默认路径</p></li><li><p>编译及打包后的文件路径</p></li></ul><p>这也是为什么我们创建一个Maven项目之后，只要在 Maven 约定好的路径中编写我们的代码，其他的几乎什么都不用配置，就可以直接进行构建，也是一种约定优于配置的思想体现。</p><p>super pom 的位置在Maven主目录的lib文件夹下面，找到一个叫maven-model-builder.jar 的文件，在这个 jar 包的\org\apache\maven\model\pom-4.0.0.xml 路径下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>never<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/test-classes<span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/scripts<span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/test/java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/test/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="手动引入自定义父POM"><a href="#手动引入自定义父POM" class="headerlink" title="手动引入自定义父POM"></a>手动引入自定义父POM</h3><p>父 <code>pom</code> 的引入语法很简单，在<code>parent</code>标签中添加构件坐标即可，类似于<code>dependency</code>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- relativePath 指的是父 pom.xml 所在的相对路径，默认值是 ../pom.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span><span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子模块会优先从上级目录中查找<code>pom.xml</code>，如果查不到则到<strong>本地仓库</strong>中查找，如果还是查不到则会从远程仓库中查找。</p><h2 id="模块的聚合"><a href="#模块的聚合" class="headerlink" title="模块的聚合"></a>模块的聚合</h2><p>demo-a 依赖 demo-b， demo-b 依赖 demo-c , 在这种情况下，我们需要先 install c ，再 install b ，最后再构建 a，执行起来非常麻烦，为了处理这个问题，Maven 引入了聚合机制，可以将这三个模块聚合在一起，一次性完成构建。</p><p>聚合的语法也非常简单，只需要在父目录的 <code>pom.xml</code> 中添加 <code>&lt;modules&gt;</code> 即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-a<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-b<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-c<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;module&gt;</code> 中填写的并不是 <code>artifactId</code>，而是需要被聚合的模块的名称。</p><h3 id="反应堆-reactor"><a href="#反应堆-reactor" class="headerlink" title="反应堆(reactor)"></a>反应堆(reactor)</h3><p>Maven 的反应堆是将多个模块的项目按照一定的顺序进行构建。</p><p>当我们执行install或package语句时，maven先构建的是配置了聚合关系的<strong>聚合模块</strong>，然后才是子模块。子模块构建的时候会按照被依赖的顺序，由底层向上层进行构建。因此，我们的模块之间不能出现循环依赖的情况，假如在<code>demo-c</code>中引入<code>demo-a</code>的依赖，此时构建就会报错。</p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>Maven配置会把子模块中使用到的<strong>依赖</strong>以及<strong>版本号</strong>等，抽取到父模块中由子模块直接继承。</p><p>父pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql-connector-java.verison</span>&gt;</span>8.0.29<span class="tag">&lt;/<span class="name">mysql-connector-java.verison</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector-java.verison&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子pom.xml可不声明依赖版本，直接继承父pom.xml的版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Maven-的生命周期"><a href="#Maven-的生命周期" class="headerlink" title="Maven 的生命周期"></a>Maven 的生命周期</h1><p>Maven 的生命周期有三个，分别是<code>clean</code>、<code>default</code>、<code>site</code>。</p><ul><li>clean：默认是清除target目录中的所有文件，避免将历史版本打到新的包中造成一些不在预期中的问题</li><li>process-resources：将资源文件src&#x2F;main&#x2F;resources下的文件复制到target&#x2F;classes目录中。</li><li>compile：将src&#x2F;main&#x2F;java下的代码编译成 class 文件，也放到target&#x2F;classes目录中。</li><li>process-test-resources：将资源文件src&#x2F;test&#x2F;resources下的文件复制到target&#x2F;test-classes目录中。</li><li>test-compile：将src&#x2F;test&#x2F;java下的代码编译成 class 文件，也放到target&#x2F;test-classes目录中。</li><li>test：运行单元测试并在target&#x2F;surefire-reports中生成测试报告。</li><li>package：将资源文件、class文件、pom文件打包成一个jar包。</li><li>install：将生成的jar包推送到本地仓库中。</li><li>deploy：将生成的jar包推送到远程仓库中。</li></ul><p>执行构建时，会按照<strong>阶段</strong>顺序从上到下的执行，但只有绑定了<strong>插件目标</strong>的<strong>阶段</strong>才会执行</p><p>可以在通过<code>&lt;plugin&gt;</code>标签引入插件，通过<code>&lt;excutions&gt;</code>来定义执行计划，通过<code>&lt;phase&gt;</code>与<code>&lt;goal&gt;</code>绑定<strong>阶段</strong>与<strong>插件模板</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--源码插件引入--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--执行计划--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--在哪个生命周期阶段执行--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--执行别名--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>build-source<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件目标--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Maven-私服"><a href="#Maven-私服" class="headerlink" title="Maven 私服"></a>Maven 私服</h1><p>Maven 的仓库只有两种类型：<strong>本地仓库</strong>、<strong>远程仓库</strong>。</p><p>对于 远程仓库 来说，有几种特殊的子类型，最特殊的就是 Maven 的 中央仓库，这个是 Maven 提供的官方仓库，我们可以在里面找到市面上的几乎任何一个开源构件。除了中央仓库之前，还有其他的公共仓库，例如：JBoss的仓库，阿里云、腾讯云的镜像仓库等。</p><p>另外一种就是我们接下来要讲到的私服了，私服是假设在局域网中的仓库服务，也可以看作是对公用远程仓库的代理。</p><h2 id="私服-Nexus"><a href="#私服-Nexus" class="headerlink" title="私服 Nexus"></a>私服 Nexus</h2><p>本地的开发电脑在引入某个依赖的时候，可以<strong>先从私服查找</strong>，如果私服没有找到再去<strong>公用仓库</strong>下载，同时，也允许我们将开发好的某些构件上传到私服中，供其他的开发者下载使用。</p><p>私服有以下优势：</p><ul><li>节省带宽，增加构件的下载速度，同时也增加了仓库的稳定性。<br>在同一个局域网中，只要有一个开发者引入了某个构件，触发了私服从公用仓库中下载构件后，私服就会将这构件缓存到私服所在的服务器中。此时，再有其他的开发者要使用这个构件，就能够直接从局域网下载了，局域网相对于公网，更快更稳定。</li><li>可以上传公共仓库中没有的构件，与同一局域网中的其他开发者共享。</li></ul><h2 id="Docker-安装私服"><a href="#Docker-安装私服" class="headerlink" title="Docker 安装私服"></a>Docker 安装私服</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>在 docker-desktop 中找到 sonatype&#x2F;nexus3 这个镜像，拉取一个版本下来。</p><p>打开 powershell，执行以下命令启动：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker volume create <span class="literal">--name</span> nexus<span class="literal">-data</span></span><br><span class="line"><span class="comment"># 将容器的8081端口映射到宿主机的8082端口</span></span><br><span class="line">docker run <span class="literal">-dp</span> <span class="number">8082</span>:<span class="number">8081</span> <span class="literal">--name</span> nexus <span class="literal">-v</span> nexus<span class="literal">-data</span>:/nexus<span class="literal">-data</span> sonatype/nexus3</span><br></pre></td></tr></table></figure><p>打开 nexus 管理台</p><p><img src="https://i0.hdslb.com/bfs/article/4dd60622c59e64e007a2075e55c20cfe171301454.png" alt="image-20240119094827382"></p><p>进入到 nexus 容器里，进入<code>sonatype-work/nexus3</code>文件夹，找到 admin.password，里面保存着初始密码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec <span class="literal">-it</span> nexus bash</span><br></pre></td></tr></table></figure><p>获取到密码之后，回到网页上，点击右上角的 sign in ，使用 admin 登录，接下来会进入一个引导流程，会做下面两个配置：</p><p>修改密码：这里直接改成admin123<br>配置是否允许匿名登录：即后面使用Maven连接私服的时候是否需要使用密码<br>安全的配置一般都是不允许使用匿名登录的，这里我们选择Disable anonymous access。</p><h3 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h3><p>登录成功之后，我们需要在私服中配置国内的公用仓库作为私服下载构件的下载源，在这之前，我们先看一下默认的仓库配置。打开<code>Server administration and configuration</code>进行配置，也就是标题栏上面那个齿轮，然后打开<code>Repositores</code>：</p><p><img src="https://i0.hdslb.com/bfs/article/c8dd78d0ecd1cfbca8df0f18771a397d171301454.png" alt="image-20240119105708923"></p><p><strong>Type:</strong></p><ul><li>proxy：代理仓库，用来代理中央仓库或其他的远程公用仓库。</li><li>hosted：用来保存我们在局域网中发布的构件，也就是私有仓库。</li><li>group：仓库分组，里面可以配置多个仓库，并指定仓库访问的优先级。</li></ul><p><strong>Name:</strong></p><ul><li>maven-release：存放非SNAPSHOT的构件。</li><li>maven-snapshots：用于存放里程碑版本为SNAPSHOT的构件。</li><li>maven-central：代理Maven中央仓库，这里会缓存从中央仓库下载的构件。</li><li>maven-public：是仓库的分组，这个仓库中配置了上面三个仓库的访问顺序。</li></ul><p>回到仓库列表页面，点击左上角的<code>Create repository</code>，然后选择&#96;maven2(proxy)</p><p><img src="https://i0.hdslb.com/bfs/article/5406b6aa45b35982e0ea5db44dc3a7b6171301454.png" alt="image-20240119111324927"></p><p>ali_repo 配置如下：</p><p><img src="https://i0.hdslb.com/bfs/article/baa1125bb3ca91494e5186f3dabbd3c6171301454.png" alt="image-20240119111757956"></p><p>然后打开<code>maven_public</code>，将<code>ali_repo</code>配置上去：</p><p><img src="https://i0.hdslb.com/bfs/article/b51abb55934afd94a004482f6740e411171301454.png" alt="image-20240119112013042"></p><p>将ali_repo放到 <code>snapshots</code> 与 <code>maven-central</code> 之间</p><p><img src="https://i0.hdslb.com/bfs/article/671f04680c99606e665a25f9884b86c5171301454.png" alt="image-20240119151424667"></p><p>如果是正式环境使用的话，还需要对新建角色<code>role</code>，并针对每一个开发者都创建一个用户<code>user</code></p><h3 id="私服的使用"><a href="#私服的使用" class="headerlink" title="私服的使用"></a>私服的使用</h3><h4 id="修改Maven配置"><a href="#修改Maven配置" class="headerlink" title="修改Maven配置"></a>修改Maven配置</h4><p>先修改<code>setting.xml</code>的两个配置，让Maven可以连接上私服</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后是镜像配置，这里的<code>url</code>配置成上面所说的<code>maven-public</code>地址：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8082/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：两个配置中的<code>id</code>需要保持一致</p><h4 id="从私服中下载构件"><a href="#从私服中下载构件" class="headerlink" title="从私服中下载构件"></a>从私服中下载构件</h4><p>尝试引入一个<code>spring-core</code>的jar包（一定本地仓库中没有的，不然不会触发从私服中拉取），去查看私服中是否进行了下载：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以在私服上成功看到下载下来的依赖</p><p><img src="https://i0.hdslb.com/bfs/article/5c06d75e2d708a28cc854c893a4dd827171301454.png" alt="image-20240119151253203"></p><h4 id="推送构件到私服"><a href="#推送构件到私服" class="headerlink" title="推送构件到私服"></a>推送构件到私服</h4><p>如果要把自定义的构件发布到仓库中，需要使用以下两个指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发布到本地仓库</span></span><br><span class="line">mvn clean install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发布到远程仓库</span></span><br><span class="line">mvn clean deploy</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要忽略<span class="built_in">test</span></span> </span><br><span class="line">mvn clean deploy -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>在 pom.xml 中配置将构件推送到哪个仓库中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8082/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8082/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>成功在私服上看到我们自定义的构件</p><p><img src="https://i0.hdslb.com/bfs/article/22a28009beb63ae94afd773eaf10e214171301454.png" alt="image-20240119153656855"></p><h4 id="打包源码"><a href="#打包源码" class="headerlink" title="打包源码"></a>打包源码</h4><p>在开发协作中，有时候还需要将源码发布到私服中以便其他开发者下载，源码中包含了注释和接口说明，更有利于协作，例如：api包、封装的工具包、基础架构包等。</p><p>但是Maven的默认生命周期中没有加入打包源码的插件，所以需要我们自行引入，在<code>plugins</code>标签中加入插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--源码插件引入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--执行计划--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--在生命周期的哪个阶段执行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新打包完成之后，查看Maven仓库会发现里面多了一个<code>xxx-sources.jar</code>的源码包。</p><p><img src="https://i0.hdslb.com/bfs/article/143c582bccfda3d50cceeff505067e95171301454.png" alt="image-20240119154543318"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Maven-的安装与配置&quot;&gt;&lt;a href=&quot;#Maven-的安装与配置&quot; class=&quot;headerlink&quot; title=&quot;Maven 的安装与配置&quot;&gt;&lt;/a&gt;Maven 的安装与配置&lt;/h1&gt;&lt;p&gt;下载地址：&lt;a href=&quot;https://maven.ap</summary>
      
    
    
    
    
    <category term="maven" scheme="https://palette-k.github.io/tags/maven/"/>
    
    <category term="docker" scheme="https://palette-k.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>SSO单点登录</title>
    <link href="https://palette-k.github.io/2024/01/03/SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>https://palette-k.github.io/2024/01/03/SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</id>
    <published>2024-01-03T03:52:17.000Z</published>
    <updated>2024-02-07T06:49:48.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是SSO"><a href="#什么是SSO" class="headerlink" title="什么是SSO"></a>什么是SSO</h1><p>SSO( Single Sign On)，即单点登录。是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分。</p><p>简单来说，在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录；用户只需注销一次，各个系统即可感知该用户已经注销。</p><h1 id="单系统登录"><a href="#单系统登录" class="headerlink" title="单系统登录"></a>单系统登录</h1><p>众所周知，HTTP是<strong>无状态</strong>的协议，这意味着<strong>服务器无法确认用户的信息</strong>。于是乎，W3C就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是<strong>Cookie</strong>。</p><p>如果说Cookie是检查用户身上的”通行证“来确认用户的身份，那么Session就是通过检查服务器上的”客户明细表“来确认用户的身份的。<strong>Session相当于在服务器中建立了一份“客户明细表”</strong>。</p><p>HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一个用户。于是乎：服务器向用户浏览器发送了一个名为JESSIONID的Cookie，它的值是Session的id值。<strong>其实Session是依据Cookie来识别是否是同一个用户</strong>。</p><blockquote><p>虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？</p></blockquote><p>单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie</p><p>既然这样，为什么不将web应用群中所有子系统的域名统一在一个顶级域名下，例如“*.baidu.com”，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。</p><p>共享cookie的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间；第三，cookie本身不安全。</p><h1 id="多系统登录的问题和解决方式"><a href="#多系统登录的问题和解决方式" class="headerlink" title="多系统登录的问题和解决方式"></a>多系统登录的问题和解决方式</h1><h2 id="Session-不共享问题"><a href="#Session-不共享问题" class="headerlink" title="Session 不共享问题"></a>Session 不共享问题</h2><p>单系统登录功能主要是用Session保存用户信息来实现的，但我们清楚的是：多系统即可能有多个Tomcat，而Session是依赖当前系统的Tomcat，所以系统A的Session和系统B的Session是<strong>不共享</strong>的。</p><p>解决系统之间Session不共享问题有一下几种方案：</p><ul><li>Tomcat集群Session全局复制（集群内每个tomcat的session完全同步）【会影响集群的性能呢，不建议】</li><li>根据请求的IP进行<strong>Hash映射</strong>到对应的机器上（这就相当于请求的IP一直会访问同一个服务器）【如果服务器宕机了，会丢失了一大部分Session的数据，不建议】</li><li>把Session数据放在Redis中（使用Redis模拟Session）【<strong>建议</strong>】</li></ul><h2 id="Cookie-跨域问题"><a href="#Cookie-跨域问题" class="headerlink" title="Cookie 跨域问题"></a>Cookie 跨域问题</h2><p>我们请求<code>&lt;https://www.google.com/&gt;</code>时，浏览器会自动把<code>google.com</code>的Cookie带过去给<code>google</code>的服务器，而不会把<code>&lt;https://www.baidu.com/&gt;</code>的Cookie带过去给<code>google</code>的服务器。</p><p>这就意味着，<strong>由于域名不同</strong>，用户向系统A登录后，系统A返回给浏览器的Cookie，用户再请求系统B的时候不会将系统A的Cookie带过去。</p><p>针对Cookie存在跨域问题，有几种解决方案：</p><ol><li>服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析出来，此后请求都把这个Token带上就行了</li><li>多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。</li><li>将Token保存在SessionStroage中（不依赖Cookie就没有跨域的问题了）</li></ol><h2 id="SSO-CAS"><a href="#SSO-CAS" class="headerlink" title="SSO-CAS"></a>SSO-CAS</h2><p>CAS （Central Authentication Service）</p><p>sso认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立<strong>全局会话（生成一份Token，写到Cookie中，保存在浏览器上）</strong>。随后，认证中心<strong>重定向回系统A</strong>，并把Token携带过去给系统A。</p><p>接着，系统A去sso认证中心验证这个Token是否正确，如果正确，则系统A和用户建立局部会话（<strong>创建Session</strong>）。到此，系统A和用户已经是登录状态了。</p><p>此时，用户想要访问系统B<code>www.java4y.com</code>受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统B<code>www.java4y.com</code>发现用户并没有登录，于是<strong>重定向到sso认证中心，并将自己的地址作为参数</strong>。</p><p>注意，因为之前用户与认证中心<code>www.sso.com</code>已经建立了全局会话（当时已经把Cookie保存到浏览器上了），所以这次系统B<strong>重定向</strong>到认证中心<code>www.sso.com</code>是可以带上Cookie的。</p><p>认证中心<strong>根据带过来的Cookie</strong>发现已经与用户建立了全局会话了，认证中心<strong>重定向回系统B</strong>，并把Token携带过去给系统B。</p><p>接着，系统B去sso认证中心验证这个Token是否正确，如果正确，则系统B和用户建立局部会话（<strong>创建Session</strong>）。到此，系统B和用户已经是登录状态了。</p><p>其实SSO认证中心就类似一个<strong>中转站</strong>。</p><p><img src="https://i0.hdslb.com/bfs/article/48fd7714fdcf677dd1f444901a96a874171301454.png" alt="image-20240207114043185"></p><h2 id="SSO-JWT"><a href="#SSO-JWT" class="headerlink" title="SSO-JWT"></a>SSO-JWT</h2><p>JWT（JSON Web Token）是一种轻量级的开放标准（RFC 7519），用于在各方之间安全地传输信息。在SSO系统中，JWT被广泛应用于认证和授权，可以实现基于令牌的单点登录（SSO）。</p><p>JWT是一种自包含的令牌，它由三部分组成：头部、载荷和签名。头部包含了JWT类型和使用的加密算法；载荷包含了JWT所包含的信息，如用户身份、角色、权限等；签名则用于验证JWT的真实性和完整性。</p><p>在SSO系统中，JWT通常用于跨域认证和授权，实现以下流程：</p><ol><li>用户在第一次登录时，SSO服务器会生成一个JWT令牌，并将该令牌发送给用户。</li><li>用户访问其他应用程序或系统时，将JWT令牌随请求一同发送给目标应用程序或系统。</li><li>目标应用程序或系统通过验证JWT令牌的签名，确认该令牌是由SSO服务器颁发的，并可以解析出JWT中的用户信息。</li><li>目标应用程序或系统可以根据JWT中的用户信息进行身份验证和授权，让用户在不同的应用程序或系统之间实现无缝切换。</li></ol><h2 id="SSO-企微认证"><a href="#SSO-企微认证" class="headerlink" title="SSO-企微认证"></a>SSO-企微认证</h2><p>PaaS企微认证SSO是根据企业微信提供了OAuth的<a href="https://developer.work.weixin.qq.com/document/path/91335">授权登录方式</a>，可以让从企业微信终端打开的网页获取成员的身份信息，从而免去登录的环节。企业应用中的URL链接（包括自定义菜单或者消息中的链接），均可通过OAuth2.0验证接口来获取成员的UserId身份信息。</p><p>企微SSO再根据UserId查询用户表数据找到企微userid对应的用户信息，根据用户信息颁发JWT-token.</p><h2 id="SSO-微信小程序认证"><a href="#SSO-微信小程序认证" class="headerlink" title="SSO-微信小程序认证"></a>SSO-微信小程序认证</h2><p>PaaS微信小程序认证是根据<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">微信小程序登录</a> 调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。<br>调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 、 用户在微信开放平台帐号下的唯一标识UnionID（若当前小程序已绑定到微信开放平台帐号） 和 会话密钥 session_key，根据OpenID和UnionID 生成登录凭证。</p><h2 id="SSO-OAuth-2-0"><a href="#SSO-OAuth-2-0" class="headerlink" title="SSO-OAuth 2.0"></a>SSO-OAuth 2.0</h2><p>系统对接SSO-OAuth2.0,通过sso单点登录获取授权码并跳转到自己的系统,用授权码code获取用户信息比对自己的系统用户数据,以确认登录成功。</p><h3 id="接入流程"><a href="#接入流程" class="headerlink" title="接入流程"></a>接入流程</h3><p><img src="https://i0.hdslb.com/bfs/article/e2a56f673631318ced90a2014b4b5ef9171301454.png" alt="image-20240122114748174"></p><ol><li>用户访问第三方服务，第三方服务通过构造OAuth2链接（参数包括当前第三方服务的身份ID，以及重定向URI），将用户引导到认证服务器的授权页</li><li>用户选择是否同意授权</li><li>若用户同意授权，则认证服务器将用户重定向到第一步指定的重定向URI，同时附上一个授权码。</li><li>第三方服务收到授权码，带上授权码来源的重定向URI，并向认证服务器申请凭证。</li><li>认证服务器检查授权码和重定向URI的有效性，通过后颁发AccessToken（调用凭证）,根据AccessToken和授权码可获得用户数据</li></ol><p>OAuth2.0协议支持多种授权模式，如授权码模式、隐式授权模式、密码凭证授权模式、客户端模式等，每种模式都有不同的应用场景和安全性。</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>授权码模式</td><td>第三方应用先申请一个授权码code，然后根据code获取令牌accessToken</td></tr><tr><td>隐式授权模式</td><td>有些web应用为纯前端应用，该模式允许直接向前端颁发令牌</td></tr><tr><td>密码凭证授权模式</td><td>如果你高度信任某个应用，RFC 6379也允许用户把用户名和密码直接告诉该应用</td></tr><tr><td>客户端凭证模式</td><td>指客户端以自己的名义，而不是以用户的名义，向“服务提供商”进行认证</td></tr></tbody></table><h3 id="OAuth2-0协议的优点"><a href="#OAuth2-0协议的优点" class="headerlink" title="OAuth2.0协议的优点"></a>OAuth2.0协议的优点</h3><ol><li>安全性：OAuth2.0协议通过授权码、访问令牌等机制，保证了用户的资源不会被未经授权的第三方应用程序访问。</li><li>可扩展性：OAuth2.0协议支持多种授权模式，可以适用于不同类型的应用程序和系统。</li><li>简单性：OAuth2.0协议是一种简单的授权协议，易于实现和使用。</li><li>可移植性：OAuth2.0协议可以在不同的平台和语言之间使用，可以提高系统的可移植性和互操作性。</li></ol><h2 id="SSO-OIDC"><a href="#SSO-OIDC" class="headerlink" title="SSO-OIDC"></a>SSO-OIDC</h2><p>英文全称为 OpenID Connect，缩写为 OIDC，是一个基于 OAuth2 协议的身份认证标准协议。它在 OAuth2 上构建了一个身份层，提供完善的身份认证功能。</p><p>OIDC的交互时序图如下：</p><p><img src="https://i0.hdslb.com/bfs/article/9823bb275a6674b61e6a5940fab05b8b171301454.png" alt="image-20240207144926930"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是SSO&quot;&gt;&lt;a href=&quot;#什么是SSO&quot; class=&quot;headerlink&quot; title=&quot;什么是SSO&quot;&gt;&lt;/a&gt;什么是SSO&lt;/h1&gt;&lt;p&gt;SSO( Single Sign On)，即单点登录。是指在多系统应用群中登录一个系统，便可在其他所有系统中</summary>
      
    
    
    
    
    <category term="SSO" scheme="https://palette-k.github.io/tags/SSO/"/>
    
    <category term="OAuth2" scheme="https://palette-k.github.io/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>SSE</title>
    <link href="https://palette-k.github.io/2024/01/02/SSE/"/>
    <id>https://palette-k.github.io/2024/01/02/SSE/</id>
    <published>2024-01-02T02:08:08.000Z</published>
    <updated>2024-01-11T12:13:34.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Server-Sent Events 服务器推送事件，简称 SSE，是一种服务端实时<strong>主动</strong>向浏览器推送消息的技术。</p><p>SSE运行在HTTP协议之上，它允许服务器以事件流（Event Stream）的形式将数据发送给客户端。客户端通过建立持久化的HTTP连接，并监听这个事件流，从而可以实时接收到服务器推送的数据。</p><h1 id="SSE用途"><a href="#SSE用途" class="headerlink" title="SSE用途"></a>SSE用途</h1><p>ChatGPT 是一个基于深度学习的大型语言模型，处理自然语言需要大量的计算资源和时间，响应速度肯定比普通的读数据库要慢的多，普通 http 接口等待时间过长，显然并不合适。对于这种单项对话场景，ChagtGPT 将先计算出的数据“推送”给用户，边计算边返回，避免用户因为等待时间过长关闭页面。而这，可以采用 SSE 技术。</p><p>SSE 可以在 Web 应用程序中实现诸如股票在线数据、日志推送、聊天室实时人数等即时数据推送功能。股票📈k线的实时变化，彩票趋势走向，以及工业数据实时监控（受限于页面的数据获取范围面）和日志推送和CI&#x2F;CD工作流进度的推送等相关单向推送需求的场景。</p><p>需要注意的是，SSE 并不是适用于所有的实时推送场景。在需要高并发、高吞吐量和低延迟的场景下，WebSockets 可能更加适合。而在需要更轻量级的推送场景下，SSE 可能更加适合。因此，在选择即时更新方案时，需要根据具体的需求和场景进行选择。</p><h1 id="SSE与-WebSocket-比较"><a href="#SSE与-WebSocket-比较" class="headerlink" title="SSE与 WebSocket 比较"></a>SSE与 WebSocket 比较</h1><table><thead><tr><th>WebSocket</th><th>SSE</th></tr></thead><tbody><tr><td>基于TCP长连接通讯</td><td>基于HTTP协议</td></tr><tr><td>全双工，可以同时发送和接收消息</td><td>单工，只能服务端单向发送信息</td></tr><tr><td>相对复杂</td><td>轻量级，使用简单</td></tr><tr><td>不在协议范围内，需手动实现</td><td>内置断线重连和消息追踪功能</td></tr><tr><td>类型广泛</td><td>文本或使用 Base64 编码和 gzip 压缩的二进制消息</td></tr><tr><td>不支持自定义事件类型</td><td>支持自定义事件类型</td></tr><tr><td>连接数无限制</td><td>连接数 HTTP&#x2F;1.1 6个，HTTP&#x2F;2 可协商（默认100）</td></tr></tbody></table><h1 id="SSE的实现原理"><a href="#SSE的实现原理" class="headerlink" title="SSE的实现原理"></a>SSE的实现原理</h1><p>以下是SSE（Server-Sent Events）的实现原理：</p><ul><li>连接建立：通常情况下，客户端（如浏览器）通过发送HTTP GET请求到服务器来请求建立一个SSE连接。</li><li>服务器响应：一旦服务器接收到请求，它将返回一个HTTP响应，该响应的状态码为200，内容类型（Content-Type）设置为”text&#x2F;event-stream”。</li><li>数据推送：服务器可以通过已经建立的连接向客户端推送数据。每次推送的数据被称作一个事件（Event）。每个事件由一个或多个以”\n\n”分隔的数据块组成。每个数据块都是一行文本，可能包含一个以”:”开头的注释行、以”data:”开头的数据行，或者以”id:”和”event:”开头的行来指定事件ID和事件类型。</li><li>客户端处理：当客户端接收到服务器推送的事件后，它会触发相应的JavaScript事件处理器来处理这些事件。</li><li>重连：如果连接断开，客户端会自动尝试重新连接。如果服务器在事件中指定了ID，那么在重新连接时，客户端会发送一个”Last-Event-ID”的HTTP头部信息到服务器，告诉服务器客户端接收到的最后一个事件的ID。根据这个信息，服务器可以决定从哪个事件开始重新发送数据。</li></ul><p>总结起来，SSE使用了基于文本和HTTP协议的简单机制，使得服务器能够实时地将数据推送到客户端，而无需客户端频繁地发起新的请求。</p><h1 id="使用SSE的注意事项"><a href="#使用SSE的注意事项" class="headerlink" title="使用SSE的注意事项"></a>使用SSE的注意事项</h1><p>以下是在使用SSE（Server-Sent Events）技术进行实时数据推送时需要注意的几个关键点：</p><ul><li>异步处理：由于SSE基于长连接的机制，因此数据推送过程可能会持续较长时间。为了防止服务器线程被阻塞，建议采用异步方式处理SSE请求。例如，可以在控制器方法中使用@Async注解或利用CompletableFuture等异步编程方式。</li><li>超时处理：SSE连接可能会因网络中断、客户端关闭等原因而超时。为了避免无效连接占据服务器资源，建议设置超时时间并处理超时情况。例如，可以利用SseEmitter对象的setTimeout()方法设定超时时间，并通过onTimeout()方法处理超时逻辑。</li><li>异常处理：在实际应用中，可能会遇到网络异常、数据推送失败等问题。这种情况下，可以使用SseEmitter对象的completeWithError()方法将异常信息发送给客户端，并在客户端通过eventSource.onerror事件进行处理。</li><li>内存管理：在使用SseEmitter时，需要特别注意内存管理问题，尤其是在大量并发连接的场景下。当客户端断开连接后，务必及时释放SseEmitter对象，以避免资源泄漏和内存溢出。</li><li>并发性能：SSE的并发连接数可能对服务器性能产生影响。如果需要处理大量并发连接，可以考虑使用线程池或其他异步处理方式，以最大化服务器资源利用。</li><li>客户端兼容性：虽然大多数现代浏览器都支持SSE，但一些旧版本的浏览器可能不支持。因此，在使用SSE时，需要确保目标客户端对其有良好的支持，或者提供备选的实时数据推送机制。</li></ul><h1 id="SpringBoot-集成-SSE"><a href="#SpringBoot-集成-SSE" class="headerlink" title="SpringBoot 集成 SSE"></a>SpringBoot 集成 SSE</h1><p>下面给出一个 SpringBoot 集成 SSE 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SseEmitter <span class="title function_">streamChatCompletions</span><span class="params">(ChatCompletionRequest completionRequest, String tenantToken)</span> &#123;</span><br><span class="line">        <span class="comment">// 发起OpenaiStream请求，并使用sse发送给客户端</span></span><br><span class="line">      List&lt;ChatCompletionChunk&gt; chunks = Lists.newArrayList();</span><br><span class="line">      Flowable&lt;ChatCompletionChunk&gt; flowable = service.streamChatCompletion(completionRequest);</span><br><span class="line">      <span class="type">SseEmitter</span> <span class="variable">sseEmitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SseEmitter</span>(<span class="number">120000L</span>);</span><br><span class="line">      <span class="type">AtomicBoolean</span> <span class="variable">isCompleted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">      <span class="comment">// CAS 处理超时情况，避免无效连接持续占据服务器资源</span></span><br><span class="line">      sseEmitter.onTimeout(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (isCompleted.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">              sseEmitter.complete();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">       <span class="comment">// 流数据处理</span></span><br><span class="line">      flowable.subscribe(chatCompletionChunk -&gt; &#123;</span><br><span class="line">          <span class="comment">// 监听数据流</span></span><br><span class="line">          <span class="keyword">if</span> (!Objects.isNull(chatCompletionChunk.getId())) &#123;</span><br><span class="line">              <span class="type">boolean</span> <span class="variable">isStop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">              <span class="keyword">if</span> (chatCompletionChunk != <span class="literal">null</span> &amp;&amp; chatCompletionChunk.getChoices() != <span class="literal">null</span>) &#123;</span><br><span class="line">                  isStop = chatCompletionChunk.getChoices().stream().anyMatch(choice -&gt; choice != <span class="literal">null</span> &amp;&amp; <span class="string">&quot;stop&quot;</span>.equals(choice.getFinishReason()));</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (isStop) &#123;</span><br><span class="line">                  <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> chunks.stream().map(item -&gt; item.getChoices().stream().map(choice -&gt; choice.getMessage().getContent()).filter(Objects::nonNull).collect(Collectors.joining())).collect(Collectors.joining());</span><br><span class="line">                  List&lt;ChatMessage&gt; messages = completionRequest.getMessages();</span><br><span class="line">              &#125;</span><br><span class="line">              chunks.add(chatCompletionChunk);</span><br><span class="line">              sseEmitter.send(chatCompletionChunk);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">100</span>);</span><br><span class="line">              sseEmitter.send(JROpenaiConstant.SSE_DONE);</span><br><span class="line">              <span class="keyword">if</span> (isCompleted.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">                  sseEmitter.complete();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,throwable -&gt; &#123;</span><br><span class="line">          <span class="comment">// 异常处理</span></span><br><span class="line">          <span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> OpenAiHttpException) &#123;</span><br><span class="line">               log.error(<span class="string">&quot;OpenAi异常&quot;</span>);</span><br><span class="line">               sseEmitter.send(Result.failed(throwable.getMessage()));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// other throwable error</span></span><br><span class="line">              log.error(throwable.getMessage(), throwable);</span><br><span class="line">              sseEmitter.send(Result.failed(throwable.getMessage()));</span><br><span class="line">          &#125;</span><br><span class="line">          Thread.sleep(<span class="number">100</span>);</span><br><span class="line">          sseEmitter.send(JROpenaiConstant.SSE_DONE);</span><br><span class="line">          <span class="keyword">if</span> (isCompleted.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">              sseEmitter.complete();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">       <span class="comment">// shutdown okhttp3.Dispatcher</span></span><br><span class="line">      service.shutdownExecutor();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> sseEmitter;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Server-Sent Events 服务器推送事件，简称 SSE，是一种服务端实时&lt;strong&gt;主动&lt;/strong&gt;向浏览器推送消息的</summary>
      
    
    
    
    
    <category term="SSE" scheme="https://palette-k.github.io/tags/SSE/"/>
    
  </entry>
  
  <entry>
    <title>logback的配置和使用</title>
    <link href="https://palette-k.github.io/2023/12/28/logback%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://palette-k.github.io/2023/12/28/logback%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</id>
    <published>2023-12-28T06:20:54.000Z</published>
    <updated>2023-12-29T05:35:26.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="logback-简介"><a href="#logback-简介" class="headerlink" title="logback 简介"></a>logback 简介</h1><blockquote><p>logback 官网：<a href="https://logback.qos.ch/">https://logback.qos.ch/</a></p></blockquote><p>logback 由三个模块组成：</p><ul><li>logback-core</li><li>logback-classic</li><li>logback-access</li></ul><p><code>logback-core</code> 是其它模块的基础设施，其它模块基于它构建，<code>logback-core</code> 提供了一些关键的通用机制。</p><p><code>logback-classic</code> 的地位和作用等同于 <code>Log4J</code>，它也被认为是 <code>Log4J</code> 的一个改进版，并且它实现了简单日志门面 <code>SLF4J</code>；</p><p><code>logback-access</code> 主要作为一个与 <code>Servlet</code> 容器交互的模块，比如说<code>tomcat</code>或者 <code>jetty</code>，提供一些与 <code>HTTP</code> 访问相关的功能。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>接下来会介绍关于 logback 配置文件的配置项。</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>整个 logback.xml 配置文件的结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;glmapper-name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;glmapper-demo&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>$&#123;glmapper-name&#125;<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span> </span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span>&gt;</span></span><br><span class="line">        //xxxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span>&gt;</span></span><br><span class="line">        //xxxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span>             </span><br><span class="line">       //xxxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br></pre></td></tr></table></figure><ul><li><p>scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</p></li><li><p>scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</p></li><li><p>debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</p></li></ul><h3 id="contextName"><a href="#contextName" class="headerlink" title="contextName"></a>contextName</h3><p>logger上下文，默认名称为 “default”。可以使用 contextName 标签设置成其他名字，用于区分不同应用程序。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">contextName</span>&gt;</span>xxl_job<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>用于定义变量标签，name 为变量的名称，value 的值是变量的值。可以用 “${name}” 来使用变量。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志记录器，日期滚动记录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;./logs/xxl-job-admin&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><p>用来设置某一个包或者具体的某一个类的日志打印级别以及指定<code>appender</code>。这里的 level 是向下兼容的，即 DEBUG 级别的也会包含 INFO 级别的日志。</p><p>name:用来指定受此<code>logger</code>约束的某一个包或者具体的某一个类。</p><p>level:用来设置打印级别（<code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>, <code>ALL</code> 和 <code>OFF</code>），还有一个值<code>INHERITED</code>或者同义词<code>NULL</code>，代表强制执行上级的级别。如果没有设置此属性，那么当前<code>logger</code>将会继承上级的级别。</p><p>addtivity:用来描述是否向上级<code>logger</code>传递打印信息。默认是<code>true</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.xxl.job.executor&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>根logger，也是一种logger，且只有一个level属性。根logger 用于控制 appender 配置的日志等级和输出权限。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 生产环境下，将此级别配置为适合的级别，以免日志文件太多或影响程序性能 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILEERROR&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILEWARN&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILEINFO&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILEALL&quot;</span> /&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 生产环境将请stdout,testfile去掉 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter其实是appender里面的子元素。它作为过滤器存在，执行一个过滤器会有返回DENY，NEUTRAL，ACCEPT三个枚举值中的一个。可以为<code>appender</code> 添加一个或多个过滤器，可以用任意条件对日志进行过滤。<code>appender</code> 有多个过滤器时，按照配置顺序执行。</p><ul><li>DENY：日志将立即被抛弃不再经过其他过滤器</li><li>NEUTRAL：有序列表里的下个过滤器过接着处理日志</li><li>ACCEPT：日志会被立即处理，不再经过剩余过滤器</li></ul><p>filter 还指定了一个 class，class有两个种类：</p><ul><li>ThresholdFilter：临界值过滤器，过滤掉低于临界值的日志。当日志级别等于或高于临界值，过滤器返回 NEUTRAL；当日志级别低于临界值时，日志会被拒绝。</li><li>LevelFilter：级别过滤器，根据日志级别进行过滤。如果日志级别等于配置级别，过滤器会根据 onMatch 和 onMismatch 接收或拒绝日志。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志记录器，日期滚动记录 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILEINFO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">     ......</span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- 此日志文件只记录info级别的 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">level</span>&gt;</span>info<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 如果命中就使用这条规则 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 如果没有命中就禁止这条日志 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="appender"><a href="#appender" class="headerlink" title="appender"></a>appender</h3><p><code>appender</code>是一个日志打印的组件，这里组件里面定义了打印过滤的条件、打印输出方式、滚动策略、编码方式、打印格式等等。但是它只是一个配置，这个配置的开关和打印级别由 logger 或者 root 的 appender-ref 指定某个具体的 appender 控制。</p><h4 id="appender-的种类"><a href="#appender-的种类" class="headerlink" title="appender 的种类"></a>appender 的种类</h4><p><code>appender</code> 有两个属性 <code>name</code>和<code>class</code>;<code>name</code>指定<code>appender</code>名称，<code>class</code>指定<code>appender</code>的全限定名。</p><ul><li>ConsoleAppender：把日志添加到控制台</li><li>FileAppender：把日志添加到文件</li><li>RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。它是FileAppender的子类</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;GLMAPPER-LOGGERONE&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="append-子标签"><a href="#append-子标签" class="headerlink" title="append 子标签"></a>append 子标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是 <code>true</code>，日志被追加到文件结尾，如果是<code>false</code>，清空现存文件，默认是<code>true</code>。</p><h4 id="file-子标签"><a href="#file-子标签" class="headerlink" title="file 子标签"></a>file 子标签</h4><p>file 标签用于指定被写入的文件名，可以是相对也可以是绝对路径，如果上级目录不存在会自动创建，没有默认值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">    $&#123;logging.path&#125;/glmapper-spring-boot/glmapper-loggerone.log</span><br><span class="line"><span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表示当前appender将会将日志写入到<code>$&#123;logging.path&#125;/glmapper-spring-boot/glmapper-loggerone.log</code>这个目录下。</p><h4 id="rollingPolicy-子标签"><a href="#rollingPolicy-子标签" class="headerlink" title="rollingPolicy 子标签"></a>rollingPolicy 子标签</h4><p>这个子标签用来描述滚动策略的。这个只有<code>appender</code>的<code>class</code>是<code>RollingFileAppender</code>时才需要配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 归档的日志文件的路径，例如今天是2013-12-21日志，当前写的日志文件路径为file节点指定，可以将此文件与file指定文件路径设置为不同路径，从而将当前日志文件或归档日志文件置不同的目录。</span></span><br><span class="line"><span class="comment">           而2013-12-21的日志文件在由fileNamePattern指定。%d&#123;yyyy-MM-dd&#125;指定日期格式，%i指定索引 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/all/log-all-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 除按日志记录之外，还配置了日志文件不能超过2M，若超过2M，日志文件会以索引0开始，</span></span><br><span class="line"><span class="comment">           命名日志文件，例如log-error-2013-12-21.0.log --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="TimeBasedRollingPolicy"><a href="#TimeBasedRollingPolicy" class="headerlink" title="TimeBasedRollingPolicy"></a>TimeBasedRollingPolicy</h4><p>最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。这个下面又包括了两个属性：</p><ul><li>FileNamePattern</li><li>maxHistory</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rollingPolicy</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志文件输出的文件名:按天回滚 daily --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">        $&#123;logging.path&#125;/glmapper-spring-boot/glmapper-loggerone.log.%d&#123;yyyy-MM-dd&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的这段配置表明<strong>每天生成一个日志文件，保存30天的日志文件</strong></p><h4 id="FixedWindowRollingPolicy"><a href="#FixedWindowRollingPolicy" class="headerlink" title="FixedWindowRollingPolicy"></a>FixedWindowRollingPolicy</h4><p>根据固定窗口算法重命名文件的滚动策略。</p><h4 id="encoder-子标签"><a href="#encoder-子标签" class="headerlink" title="encoder 子标签"></a>encoder 子标签</h4><p>对记录事件进行格式化。它干了两件事：</p><ul><li>把日志信息转换成字节数组</li><li>把字节数组写入到输出流</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125;</span><br><span class="line">    - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前<code>encoder</code>只有<code>PatternLayoutEncoder</code>一种类型。</p><h1 id="不同日志隔离级别打印"><a href="#不同日志隔离级别打印" class="headerlink" title="不同日志隔离级别打印"></a>不同日志隔离级别打印</h1><h2 id="根据包、类隔离"><a href="#根据包、类隔离" class="headerlink" title="根据包、类隔离"></a>根据包、类隔离</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--此logger约束将.service包下的日志输出到GLMAPPER-SERVICE，错误日志输出到GERROR-APPENDE；GERROR-APPENDE见上面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.glmapper.spring.boot.service&quot;</span> <span class="attr">level</span>=<span class="string">&quot;$&#123;logging.level&#125;&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;GLMAPPER-SERVICE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;GERROR-APPENDER&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--这里指定到了具体的某一个类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.glmapper.spring.boot.task.TestLogTask&quot;</span> <span class="attr">level</span>=<span class="string">&quot;$&#123;logging.level&#125;&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;SCHEDULERTASKLOCK-APPENDER&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ERROR-APPENDER&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="根据环境隔离"><a href="#根据环境隔离" class="headerlink" title="根据环境隔离"></a>根据环境隔离</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;appender-ref ref=&quot;sendErrorMsgAppender&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;sit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;appender-ref ref=&quot;sendErrorMsgAppender&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;uat&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;appender-ref ref=&quot;sendErrorMsgAppender&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;sendErrorMsgAppender&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="logback小实战"><a href="#logback小实战" class="headerlink" title="logback小实战"></a>logback小实战</h1><p>使用 logback 配置将日志定义到自定义输出源，可以拿SpringBoot 整合 logback 发送企微通知作为例子。</p><p>要实现error级别异常日志异常报警，就是要捕获所有的error级别的日志，然后解析出异常数据，调用企业微信接口发送消息即可。</p><p>Logback中的<code>Appender</code>类用来表示日志的输出的目的地。所以我们只需要自定义一个 <code>Appeder</code>，然后在Logback的配置文件中的所有的<code>Logger</code>配置中(或者是所有Error级别的 <code>Logger</code>配置)增加这个自定义的<code>Appeder</code>就可以以拦截所有的(异常)日志。</p><p>首先定义一个企微发送消息的Appender。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendErrorMsgAppender</span> <span class="keyword">extends</span> <span class="title class_">UnsynchronizedAppenderBase</span>&lt;LoggingEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pattern;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PatternLayout layout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Level</span> <span class="variable">nowLevel</span> <span class="operator">=</span> Level.ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(LoggingEvent eventObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventObject == <span class="literal">null</span> || !eventObject.getLevel().isGreaterOrEqual(nowLevel)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>, userAccount = <span class="string">&quot;&quot;</span>, bodyString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (requestAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> requestAttributes.getRequest();</span><br><span class="line"></span><br><span class="line">                url = request.getRequestURI();</span><br><span class="line">                userAccount = getUserinfo(request);</span><br><span class="line">                bodyString = ServletUtil.getBody(request);</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotBlank(bodyString)) &#123;</span><br><span class="line">                    bodyString = JSON.toJSONString(JSON.parse(bodyString));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                logger.info(<span class="string">&quot;url:&#123;&#125;&quot;</span>, url);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.isBlank(eventObject.getFormattedMessage())) &#123;</span><br><span class="line">                <span class="comment">// 没有地址的错误日志不发送直接存储到日志文件即可,避免企业微信页面展示过多的错误信息</span></span><br><span class="line">                logger.info(<span class="string">&quot;lockKey:&#123;&#125;&quot;</span>, eventObject.getLoggerName());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Environment</span> <span class="variable">bean</span> <span class="operator">=</span> SpringUtil.getBean(Environment.class);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">active</span> <span class="operator">=</span> bean.getProperty(<span class="string">&quot;spring.profiles.active&quot;</span>);</span><br><span class="line">            <span class="comment">// dev本地调试异常错误不推送企微</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;prod&quot;</span>.equals(active)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">serverName</span> <span class="operator">=</span> <span class="string">&quot;jr-ai-open-api&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">errorMessage</span> <span class="operator">=</span> layout.doLayout(eventObject);</span><br><span class="line">            <span class="type">String</span> <span class="variable">webHook</span> <span class="operator">=</span> bean.getProperty(<span class="string">&quot;qyWeChat.webHook&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(webHook)) &#123;</span><br><span class="line">                toWechat(webHook, serverName, active, url, userAccount, bodyString, errorMessage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PatternLayout</span> <span class="variable">patternLayout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PatternLayout</span>();</span><br><span class="line">        patternLayout.setContext(context);</span><br><span class="line">        patternLayout.setPattern(getPattern());</span><br><span class="line">        patternLayout.start();</span><br><span class="line">        <span class="built_in">this</span>.layout = patternLayout;</span><br><span class="line">        <span class="built_in">super</span>.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toWechat</span><span class="params">(String robotUrl, String projectName, String environment, String requestUrl, String requestAccount, String requestBody, String errorLog)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">markdownContent</span> <span class="operator">=</span> buildMarkdownContent(projectName, environment, requestUrl, requestAccount, requestBody, errorLog);</span><br><span class="line">        <span class="type">String</span> <span class="variable">markdownMsg</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;msgtype\&quot;: \&quot;markdown\&quot;, \&quot;markdown\&quot;: &#123;\&quot;content\&quot;: &quot;</span> + JSON.toJSONString(markdownContent) + <span class="string">&quot;&#125;&#125;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">CloseableHttpClient</span> <span class="variable">httpclient</span> <span class="operator">=</span> HttpClients.createDefault()) &#123;</span><br><span class="line">            <span class="type">HttpPost</span> <span class="variable">httppost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(robotUrl);</span><br><span class="line">            httppost.addHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line">            httppost.setEntity(<span class="keyword">new</span> <span class="title class_">StringEntity</span>(markdownMsg, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            httpclient.execute(httppost);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">buildMarkdownContent</span><span class="params">(String projectName, String environment, String requestUrl, String requestAccount, String requestBody, String errorLog)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;font color=\&quot;red\&quot;&gt; 【ERROR 通知】  &lt;/font&gt; \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 触发项目：&lt;/font&gt; &lt;font color=\&quot;info\&quot;&gt; &quot;</span> + projectName + <span class="string">&quot;&lt;/font&gt; \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 触发环境：&lt;/font&gt; &lt;font color=\&quot;info\&quot;&gt; &quot;</span> + environment + <span class="string">&quot;&lt;/font&gt; \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 触发时间：&lt;/font&gt; &quot;</span> + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)) + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 请求URL：&lt;/font&gt; &quot;</span> + requestUrl + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 请求账号：&lt;/font&gt; &quot;</span> + requestAccount + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 请求Body：&lt;/font&gt; \n```json\n&quot;</span> + requestBody + <span class="string">&quot;\n```\n\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;font color=&#x27;red&#x27;&gt;【Exception 详情】&lt;/font&gt; \n```json\n&quot;</span> + errorLog + <span class="string">&quot;\n```\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPattern</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pattern = pattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PatternLayout <span class="title function_">getLayout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> layout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLayout</span><span class="params">(PatternLayout layout)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.layout = layout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Level <span class="title function_">getNowLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nowLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNowLevel</span><span class="params">(Level nowLevel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nowLevel = nowLevel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 logback.xml 中定义 SendErrorMsgAppender 的输出源，并指定在生产环境下才输出日志。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;sendErrorMsgAppender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.junrunrenli.proxy.exception.SendErrorMsgAppender&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] [%X&#123;traceId&#125;] [%X&#123;loginName&#125;] %-5level %logger&#123;50&#125; [line:%L]: %ex&#123;10&#125; -%msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.filter.EvaluatorFilter&quot;</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 过滤指定类型日志 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">evaluator</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">expression</span>&gt;</span>return message.contains(&quot;Broken pipe&quot;);<span class="tag">&lt;/<span class="name">expression</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">evaluator</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">OnMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">OnMatch</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">OnMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">OnMismatch</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">OnMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">OnMatch</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">OnMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">OnMismatch</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;sendErrorMsgAppender&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样配置以后，项目中所有使用<code>log.error()</code>方法打印的日志(即error级别日志)都会通过企业微信发出消息报警。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;logback-简介&quot;&gt;&lt;a href=&quot;#logback-简介&quot; class=&quot;headerlink&quot; title=&quot;logback 简介&quot;&gt;&lt;/a&gt;logback 简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;logback 官网：&lt;a href=&quot;https</summary>
      
    
    
    
    
    <category term="logback，日志" scheme="https://palette-k.github.io/tags/logback%EF%BC%8C%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>一致性哈希</title>
    <link href="https://palette-k.github.io/2023/12/27/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    <id>https://palette-k.github.io/2023/12/27/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</id>
    <published>2023-12-27T10:47:26.000Z</published>
    <updated>2023-12-29T09:54:40.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><p>对于经常使用的数据，我们一般会使用 Redis 作为缓存机制，为了实现高可用，使用了3台Redis（没有设置集群，集群至少要6台）。</p><p>使用hash算法，存储的时候根据公式 h &#x3D; hash(key)%机器节点数，h 为 Redis 对应的编号，取数据的时候也根据相同的公式取，因此一定可以从存储的机器中拿到想要的数据。但是使用这种策略可能会存在以下问题：</p><ul><li>假设有一台 Redis 服务器宕机了，此时每个 key 就要按照 h &#x3D; hash(key)%(机器节点数-1) 重新计算</li><li>假设要新增一台 Redis 服务器，此时每个 key 就要按照 h &#x3D; hash(key)%(机器节点数+1) 重新计算</li></ul><p>也就是说，如果服务节点有变更，会导致缓存失效，大量的 key 需要重新计算，在这期间如果有请求进来，就会直接打到数据库上，导致缓存雪崩。</p><h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><p>一致性哈希是讲整个哈希空间组织成一个虚拟的圆环，假设哈希函数 H 的值空间为 [0,2^32-1]（哈希值是32位无符号整形）。</p><p>把服务器按照 IP 或者主机名作为关键字进行哈希，确定服务器在哈希环中的位置。</p><p>再使用哈希函数把数据对象映射到环上，数据从顺时针方向找，遇到的第一个服务器就是它定位到的服务器。</p><p><img src="https://i0.hdslb.com/bfs/article/a41c409530fc27e7ebb2d744f585e22a171301454.png" alt="image-20231228103401543"></p><p>结论：数据1、2存储服务器B上，数据3存储在服务器C上，数据4存储在服务器A上</p><h2 id="容错性和可扩展性"><a href="#容错性和可扩展性" class="headerlink" title="容错性和可扩展性"></a>容错性和可扩展性</h2><p>假如这时候有服务器C宕机了呢？那么只有原本在B和C之间的数据会失效，重新定位到服务器A，其他数据节点的服务器不会发生变化。</p><p><img src="https://i0.hdslb.com/bfs/article/33a772b9eb938f8d2a865da97731ee75171301454.png" alt="image-20231228103647790"></p><p>或者我们想新增一台服务器D呢？那么只有C和D之间的数据会失效，重新定位到服务器D，而其他的数据节点的存储服务器也不会发生任何变化。</p><p><img src="https://i0.hdslb.com/bfs/article/6cb533eae847346c14f72dc43343b8a0171301454.png" alt="image-20231228103831559"></p><p>可以看出，一致性哈希算法对于节点的增减只会有一部分数据需要重新定位，不会导致大量的缓存失效。</p><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>现实的业务场景中，节点不会分布得那么均匀，如果节点较少，可能会出现数据倾斜的情况。</p><p>观察下图，所有的数据全都定位到服务B上，无法实现负载均衡了。</p><p><img src="https://i0.hdslb.com/bfs/article/dc20a553ace0ca99611ae40d9774f23b171301454.png" alt="image-20231228104239560"></p><p>为了解决这种数据存储不平衡的问题，一致性哈希算法引入了虚拟节点机制，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点称为虚拟节点。</p><p><img src="https://i0.hdslb.com/bfs/article/046f08a7f3e7ec5f5a83beadf6c27054171301454.png" alt="image-20231228112641899"></p><p>增加了虚拟节点到实际节点的映射，这样就能解决服务节点少时数据不平均的问题了。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p><h1 id="手撕源码"><a href="#手撕源码" class="headerlink" title="手撕源码"></a>手撕源码</h1><p>介绍完一致性哈希算法的概念和规则，接下来我们从源码的角度分析一致性哈希算法是怎么实现的。</p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>首先确定项目中要使用的哈希算法，其中服务器和数据的映射都依赖哈希算法。</p><p>非加密算法：MurMurHash算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  MurMurHash算法，是非加密HASH算法，性能很高，</span></span><br><span class="line"><span class="comment"> *  比传统的CRC32,MD5，SHA-1（这两个算法都是加密HASH算法，复杂度本身就很高，带来的性能上的损害也不可避免）</span></span><br><span class="line"><span class="comment"> *  等HASH算法要快很多，而且据说这个算法的碰撞率很低.</span></span><br><span class="line"><span class="comment"> *  http://murmurhash.googlepages.com/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">hash</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(key.getBytes());</span><br><span class="line">    <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="number">0x1234ABCD</span>;</span><br><span class="line">    <span class="type">ByteOrder</span> <span class="variable">byteOrder</span> <span class="operator">=</span> buf.order();</span><br><span class="line">    buf.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">    <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0xc6a4a7935bd1e995L</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">h</span> <span class="operator">=</span> seed ^ (buf.remaining() * m);</span><br><span class="line">    <span class="type">long</span> k;</span><br><span class="line">    <span class="keyword">while</span> (buf.remaining() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">        k = buf.getLong();</span><br><span class="line">        k *= m;</span><br><span class="line">        k ^= k &gt;&gt;&gt; r;</span><br><span class="line">        k *= m;</span><br><span class="line">        h ^= k;</span><br><span class="line">        h *= m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buf.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">finish</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>).order(</span><br><span class="line">                ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        <span class="comment">// for big-endian version, do this first:</span></span><br><span class="line">        <span class="comment">// finish.position(8-buf.remaining());</span></span><br><span class="line">        finish.put(buf).rewind();</span><br><span class="line">        h ^= finish.getLong();</span><br><span class="line">        h *= m;</span><br><span class="line">    &#125;</span><br><span class="line">    h ^= h &gt;&gt;&gt; r;</span><br><span class="line">    h *= m;</span><br><span class="line">    h ^= h &gt;&gt;&gt; r;</span><br><span class="line">    buf.order(byteOrder);</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密算法：md5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get hash code on 2^32 ring (md5散列的方式计算hash值)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> long</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">hash2</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// md5 byte</span></span><br><span class="line">    MessageDigest md5;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;MD5 not supported&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    md5.reset();</span><br><span class="line">    <span class="type">byte</span>[] keyBytes = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        keyBytes = key.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown string :&quot;</span> + key, e);</span><br><span class="line">    &#125;</span><br><span class="line">    md5.update(keyBytes);</span><br><span class="line">    <span class="type">byte</span>[] digest = md5.digest();</span><br><span class="line">    <span class="comment">// hash code, Truncate to 32-bits</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> ((<span class="type">long</span>) (digest[<span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">            | ((<span class="type">long</span>) (digest[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">            | ((<span class="type">long</span>) (digest[<span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">            | (digest[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">truncateHashCode</span> <span class="operator">=</span> hashCode &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">    <span class="keyword">return</span> truncateHashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节点映射"><a href="#节点映射" class="headerlink" title="节点映射"></a>节点映射</h2><p>以有序 Map 的形式在内存中缓存每个节点的 Hash 值对应的物理节点信息，所以引入了 TreeMap 进行存储。</p><p>为了增加一致性哈希算法中的虚拟节点，在初始化节点映射的过程中，将计算出 实际节点*虚拟节点 的hash值，以 Hash 值为 key，以物理节点标识为 value，以有序 Map 的形式在内存中缓存，作为后续计算数据对象对应的物理节点时的查询数据。代码如下，virtualHash2RealNode 中缓存着所有虚拟节点 Hash 值对应的物理节点信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚拟节点数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NODE_NUM</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 映射到哈希环上的 虚拟节点+真实节点 (使用 红黑树 排序)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> TreeMap&lt;Long, String&gt; virtualHash2RealNode = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化节点（引入虚拟节点）</span></span><br><span class="line"><span class="comment"> * init consistency hash ring, put virtual node on the 2^64 ring</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initVirtual2RealRing</span><span class="params">(List&lt;String&gt; shards)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.shardNodes = shards;</span><br><span class="line">    <span class="keyword">for</span> (String node : shardNodes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NODE_NUM; i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> hash(<span class="string">&quot;SHARD-&quot;</span> + node + <span class="string">&quot;-NODE-&quot;</span> + i);</span><br><span class="line">            virtualHash2RealNode.put(hashCode, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据定位节点"><a href="#数据定位节点" class="headerlink" title="数据定位节点"></a>数据定位节点</h2><p>已知 virtualHash2RealNode 中存放着物理节点的信息，使用 tailMap() 方法寻找到比该数据大的范围内的所有物理节点，返回第一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找数据所对应节点</span></span><br><span class="line"><span class="comment"> * 从顺时针遇到的第一个节点</span></span><br><span class="line"><span class="comment"> * get real node by key&#x27;s hash on the 2^64</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getShardInfo</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    SortedMap&lt;Long, String&gt; tailMap = virtualHash2RealNode.tailMap(hashCode);</span><br><span class="line">    <span class="keyword">if</span> (tailMap.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> virtualHash2RealNode.get(virtualHash2RealNode.firstKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> virtualHash2RealNode.get(tailMap.firstKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><p>一般在项目中，会把一致性哈希算法包装成工具类使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistencyHashUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; shardNodes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储节点数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NODE_NUM</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 映射到哈希环上的 虚拟节点+真实节点 (使用 红黑树 排序)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;Long, String&gt; virtualHash2RealNode = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, String&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化节点（引入虚拟节点）</span></span><br><span class="line"><span class="comment">     * init consistency hash ring, put virtual node on the 2^64 ring</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initVirtual2RealRing</span><span class="params">(List&lt;String&gt; shards)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.shardNodes = shards;</span><br><span class="line">        <span class="keyword">for</span> (String node : shardNodes) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NODE_NUM; i++)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> hash(<span class="string">&quot;SHARD-&quot;</span> + node + <span class="string">&quot;-NODE-&quot;</span> + i);</span><br><span class="line">                virtualHash2RealNode.put(hashCode, node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 寻找数据所对应节点</span></span><br><span class="line"><span class="comment">     * 从顺时针遇到的第一个节点</span></span><br><span class="line"><span class="comment">     * get real node by key&#x27;s hash on the 2^64</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShardInfo</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        SortedMap&lt;Long, String&gt; tailMap = virtualHash2RealNode.tailMap(hashCode);</span><br><span class="line">        <span class="keyword">if</span> (tailMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> virtualHash2RealNode.get(virtualHash2RealNode.firstKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualHash2RealNode.get(tailMap.firstKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印节点</span></span><br><span class="line"><span class="comment">     * prinf ring virtual node info</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMap</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(virtualHash2RealNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  MurMurHash算法，是非加密HASH算法，性能很高，</span></span><br><span class="line"><span class="comment">     *  比传统的CRC32,MD5，SHA-1（这两个算法都是加密HASH算法，复杂度本身就很高，带来的性能上的损害也不可避免）</span></span><br><span class="line"><span class="comment">     *  等HASH算法要快很多，而且据说这个算法的碰撞率很低.</span></span><br><span class="line"><span class="comment">     *  http://murmurhash.googlepages.com/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">hash</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(key.getBytes());</span><br><span class="line">        <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="number">0x1234ABCD</span>;</span><br><span class="line">        <span class="type">ByteOrder</span> <span class="variable">byteOrder</span> <span class="operator">=</span> buf.order();</span><br><span class="line">        buf.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0xc6a4a7935bd1e995L</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">h</span> <span class="operator">=</span> seed ^ (buf.remaining() * m);</span><br><span class="line">        <span class="type">long</span> k;</span><br><span class="line">        <span class="keyword">while</span> (buf.remaining() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            k = buf.getLong();</span><br><span class="line">            k *= m;</span><br><span class="line">            k ^= k &gt;&gt;&gt; r;</span><br><span class="line">            k *= m;</span><br><span class="line">            h ^= k;</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buf.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">finish</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>).order(</span><br><span class="line">                    ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">            <span class="comment">// for big-endian version, do this first:</span></span><br><span class="line">            <span class="comment">// finish.position(8-buf.remaining());</span></span><br><span class="line">            finish.put(buf).rewind();</span><br><span class="line">            h ^= finish.getLong();</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line">        h *= m;</span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line">        buf.order(byteOrder);</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get hash code on 2^32 ring (md5散列的方式计算hash值)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">hash2</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// md5 byte</span></span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;MD5 not supported&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.reset();</span><br><span class="line">        <span class="type">byte</span>[] keyBytes = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            keyBytes = key.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown string :&quot;</span> + key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.update(keyBytes);</span><br><span class="line">        <span class="type">byte</span>[] digest = md5.digest();</span><br><span class="line">        <span class="comment">// hash code, Truncate to 32-bits</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> ((<span class="type">long</span>) (digest[<span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (digest[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">truncateHashCode</span> <span class="operator">=</span> hashCode &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">        <span class="keyword">return</span> truncateHashCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; shards = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        shards.add(<span class="string">&quot;consumer-uuid-2&quot;</span>);</span><br><span class="line">        shards.add(<span class="string">&quot;consumer-uuid-1&quot;</span>);</span><br><span class="line">        <span class="type">ConsistencyHashUtil</span> <span class="variable">sh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsistencyHashUtil</span>();</span><br><span class="line">        sh.initVirtual2RealRing(shards);</span><br><span class="line">        sh.printMap();</span><br><span class="line">        <span class="type">int</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;consumer&quot;</span> + i;</span><br><span class="line">            System.out.println(hash(key) + <span class="string">&quot;:&quot;</span> + sh.getShardInfo(key));</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;consumer-uuid-1&quot;</span>.equals(sh.getShardInfo(key))) &#123;</span><br><span class="line">                consumer1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;consumer-uuid-2&quot;</span>.equals(sh.getShardInfo(key))) &#123;</span><br><span class="line">                consumer2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;consumer1:&quot;</span> + consumer1);</span><br><span class="line">        System.out.println(<span class="string">&quot;consumer2:&quot;</span> + consumer2);</span><br><span class="line">        <span class="comment">/*long start = System.currentTimeMillis();</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 1000 * 1000 * 1000; i++) &#123;</span></span><br><span class="line"><span class="comment">            if (i % (100 * 1000 * 1000) == 0) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(i + &quot;:&quot; + hash(&quot;key1&quot; + i));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        long end = System.currentTimeMillis();</span></span><br><span class="line"><span class="comment">        System.out.println(end - start);*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hutool 工具包也有封装好一致性哈希算法的工具类，只需要传入复制的节点个数和节点对象就能初始化节点映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一致性Hash算法</span></span><br><span class="line"><span class="comment"> * 算法详解：http://blog.csdn.net/sparkliang/article/details/5279393</span></span><br><span class="line"><span class="comment"> * 算法实现：https://weblogs.java.net/blog/2007/11/27/consistent-hashing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoleilu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;节点类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistentHash</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Hash计算对象，用于自定义hash算法 */</span></span><br><span class="line">Hash32&lt;Object&gt; hashFunc;</span><br><span class="line"><span class="comment">/** 复制的节点个数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> numberOfReplicas;</span><br><span class="line"><span class="comment">/** 一致性Hash环 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Integer, T&gt; circle = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造，使用Java默认的Hash算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numberOfReplicas 复制的节点个数，增加每个节点的复制节点有利于负载均衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodes 节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConsistentHash</span><span class="params">(<span class="type">int</span> numberOfReplicas, Collection&lt;T&gt; nodes)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.numberOfReplicas = numberOfReplicas;</span><br><span class="line"><span class="built_in">this</span>.hashFunc = key -&gt; &#123;</span><br><span class="line"><span class="comment">//默认使用FNV1hash算法</span></span><br><span class="line"><span class="keyword">return</span> HashUtil.fnvHash(key.toString());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//初始化节点</span></span><br><span class="line"><span class="keyword">for</span> (T node : nodes) &#123;</span><br><span class="line">add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hashFunc hash算法对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numberOfReplicas 复制的节点个数，增加每个节点的复制节点有利于负载均衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodes 节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConsistentHash</span><span class="params">(Hash32&lt;Object&gt; hashFunc, <span class="type">int</span> numberOfReplicas, Collection&lt;T&gt; nodes)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.numberOfReplicas = numberOfReplicas;</span><br><span class="line"><span class="built_in">this</span>.hashFunc = hashFunc;</span><br><span class="line"><span class="comment">//初始化节点</span></span><br><span class="line"><span class="keyword">for</span> (T node : nodes) &#123;</span><br><span class="line">add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加节点&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 每增加一个节点，就会在闭环上增加给定复制节点数&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 例如复制节点数是2，则每调用此方法一次，增加两个虚拟节点，这两个节点指向同一Node</span></span><br><span class="line"><span class="comment"> * 由于hash算法会调用node的toString方法，故按照toString去重</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T node)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfReplicas; i++) &#123;</span><br><span class="line">circle.put(hashFunc.hash32(node.toString() + i), node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除节点的同时移除相应的虚拟节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(T node)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfReplicas; i++) &#123;</span><br><span class="line">circle.remove(hashFunc.hash32(node.toString() + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得一个最近的顺时针节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 为给定键取Hash，取得顺时针方向上最近的一个虚拟节点对应的实际节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (circle.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hashFunc.hash32(key);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span> == circle.containsKey(hash)) &#123;</span><br><span class="line">SortedMap&lt;Integer, T&gt; tailMap = circle.tailMap(hash);<span class="comment">//返回此映射的部分视图，其键大于等于 hash</span></span><br><span class="line">hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正好命中</span></span><br><span class="line"><span class="keyword">return</span> circle.get(hash);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入复制的节点个数和实际物理节点信息，实现一致性哈希。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ConsistentHash&lt;Node&gt; <span class="title function_">makeProxyPool</span><span class="params">(List&lt;OpenaiProxy&gt; openaiProxies)</span> &#123;</span><br><span class="line">        List&lt;Node&gt; realNodes = openaiProxies.stream().map(item -&gt; <span class="keyword">new</span> <span class="title class_">Node</span>(item.getHost(), item.getToken())).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConsistentHash</span>&lt;&gt;(<span class="number">500</span>, realNodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式缓存&quot;&gt;&lt;a href=&quot;#分布式缓存&quot; class=&quot;headerlink&quot; title=&quot;分布式缓存&quot;&gt;&lt;/a&gt;分布式缓存&lt;/h1&gt;&lt;p&gt;对于经常使用的数据，我们一般会使用 Redis 作为缓存机制，为了实现高可用，使用了3台Redis（没有设置集群，集</summary>
      
    
    
    
    
    <category term="算法，一致性哈希" scheme="https://palette-k.github.io/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Spring AOP</title>
    <link href="https://palette-k.github.io/2023/12/21/AOP/"/>
    <id>https://palette-k.github.io/2023/12/21/AOP/</id>
    <published>2023-12-21T11:28:26.000Z</published>
    <updated>2023-12-27T10:35:25.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对AOP的理解"><a href="#对AOP的理解" class="headerlink" title="对AOP的理解"></a>对AOP的理解</h1><p><code>AOP(Aspect-Oriented Programming:面向切面编程)</code>，它实际做的就是将业务和一些非业务进行拆解，降低彼此业务模块与非业务模块的耦合度，便于后续的扩展维护。例如<code>权限校验</code>、<code>日志管理</code>、<code>事务处理</code>等都可以使用<code>AOP</code>实现。而<code>Spring</code>就是基于动态代理实现<code>AOP</code>的。如果被代理的类有实现接口的话，就会基于<code>JDK Proxy</code>完成代理的创建。反之就是通过<code>Cglib</code>完成代理创建。</p><p><img src="https://qiniuyun.sharkchili.com/img202304071136659.png"></p><blockquote><p>Spring AOP和AspectJ AOP的区别知道吗？</p></blockquote><p><strong>答:</strong> 其实<code>Spring AOP</code>属于运行时增强，基于<code>代理(Proxying)</code>实现的。而<code>AspectJ AOP</code>属于编译时增强，基于<code>字节码操作(Bytecode Manipulation)</code>实现的。相比之下后者比前者更成熟、更强大一些。如果在切面不多的情况下，两者差异是不大的，如果切面非常多的话，后者性能会比强者好很多。</p><p><code>AOP</code>中有很多核心术语，分别是:</p><ol><li><p><code>目标(Target)</code>: 这就被代理的对象，例如我们希望对<code>UserService</code>每个方法进行<code>增强(在不动它的代码情况下增加一些非业务的动作)</code>，那么这个<code>UserService</code>就是目标。</p></li><li><p><code>代理(Proxy)</code>: 就是给你被代理后的对象的厂商，例如我们上面说过希望对<code>UserService</code>每个方法进行增强，那么给用户返回增强后的对象的类就是<code>代理类</code>。</p></li><li><p><code>连接点(JoinPoint)</code>:目标对象，每一个可能可以被增强的方法都可以称为连接点，尽管它最后可能不会被增强。</p></li><li><p><code>切入点(Pointcut)</code>: 连接点中确确实实被做增强操作的方法就叫切入点。</p></li><li><p><code>通知(Advice)</code>: 不要被表面的语义误导，通知并不是告知某人的意思，通知的意思是拦截对象后，做的增强操作。</p></li><li><p><code>切面(Aspect)</code>: 切入点<code>(Pointcut)</code>+通知<code>(Advice)</code></p></li><li><p><code>织入(Weaving)</code>：把通知的动作融入到对象中，生成代理对象的过程就叫做织入</p></li></ol><blockquote><p>AspectJ 通知类型有哪些？</p></blockquote><p><strong>答:</strong> 有很多，分别是：</p><ol><li><code>Before（前置通知）</code>: 目标对象方法调用前触发增强。</li><li><code>After （后置通知）</code>:目标对象方法调用后进行增强。</li><li><code>AfterReturning（返回通知）</code>:目标对象方法执行结束，返回值时进行增强。</li><li><code>AfterThrowing（异常通知）</code>:目标对象方法执行报错并抛出时做的增强。</li><li><code>Around(环绕通知）</code>:这个比较常用了，目标对象方法调用前后我们可以做各种增强操作,甚至不调用对象的方法都能做到。</li></ol><h1 id="动态代理实现"><a href="#动态代理实现" class="headerlink" title="动态代理实现"></a>动态代理实现</h1><h2 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h2><p>使用 Spring 实现 JDK 动态代理，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDKProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          *  1 创建原始对象</span></span><br><span class="line"><span class="comment">          *  JDK1.8 以前，内部类访问外部类的对象， 原始对象需声明成 final</span></span><br><span class="line"><span class="comment">          *  final UserService userService = new UserServiceImpl();</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    </span><br><span class="line">          <span class="comment">// 2 JDK 创建动态代理</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>()&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作用：书写额外功能，运行原始方法，执行前、后 抛出异常</span></span><br><span class="line"><span class="comment">     * 参数：Proxy 代理对象</span></span><br><span class="line"><span class="comment">            Method 额外功能，增加给原始方法</span></span><br><span class="line"><span class="comment">            Object[] 原始方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;------proxy log ------&quot;</span>);</span><br><span class="line">       <span class="comment">// 原始方法运行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(userService,args);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1. 需要ClassLoader创建代理类的Class对象，可以借一个，借用的类加载器没有限制 TestJDKProxy UserServiceImpl</span></span><br><span class="line"><span class="comment">    * 2. 代理对象和原始对象实现相同的接口，取原始对象实现的接口</span></span><br><span class="line"><span class="comment">    * 3. 重写 InvocationHandler 的 invoke 方法，实现额外功能</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userServiceProxy</span> <span class="operator">=</span> (UserService)Proxy.newProxyInstance(TestJDKProxy.class.getClassLoader(),userService.getClass().getInterfaces(),handler);</span><br><span class="line">    </span><br><span class="line">    userService.login(<span class="string">&quot;suns&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    userServiceProxy.register(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cglib-动态代理"><a href="#Cglib-动态代理" class="headerlink" title="Cglib 动态代理"></a>Cglib 动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCglib</span>  &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">           *  1 创建原始对象</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">         <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">         </span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2 通过Cglib方式创建动态代理</span></span><br><span class="line"><span class="comment">         * Enhancer 通过继承父类创建代理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">         </span><br><span class="line">         enhancer.setClassLoader(TestCglib.class.getClassLoader());</span><br><span class="line">         enhancer.setSuperClass(userService.getClass());</span><br><span class="line">         </span><br><span class="line">     </span><br><span class="line">         <span class="type">MethodInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>()&#123;</span><br><span class="line">     </span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等同于 InvocationHandler --- invoke</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;------cglib log ------&quot;</span>);</span><br><span class="line">       <span class="comment">// 原始方法运行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(userService,args);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">         enhancer.setCallback(interceptor);</span><br><span class="line">         <span class="type">UserService</span> <span class="variable">userServiceProxy</span> <span class="operator">=</span> (UserService)enhancer.create();</span><br><span class="line">         </span><br><span class="line">         userServiceProxy.login(<span class="string">&quot;suns&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">         userServiceProxy.register(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于 @EnableAspectJAutoProxy 注解，在AopAutoConfiguration这个类里可以看到相关定义。</p><p>Cglib代理：@EnableAspectJAutoProxy(proxyTargetClass &#x3D; true) </p><p>JDK代理：@EnableAspectJAutoProxy(proxyTargetClass &#x3D; false) </p><p><strong>Spring AOP 代理默认实现 JDK，SpringBoot AOP 代理默认实现 Cglib。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(Advice.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AspectJAutoProxyingConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JdkDynamicAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CglibAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AOP源码"><a href="#AOP源码" class="headerlink" title="AOP源码"></a>AOP源码</h1><p>注解切面类名为:<code>AnnotationAwareAspectJAutoProxyCreator</code></p><p><img src="https://qiniuyun.sharkchili.com/img202304071136639.png"></p><p>从类图中我们可以看到它继承了<code>BeanPostProcessor</code>以及<code>BeanFactoryAware</code>这就意味着这个类在<code>bean</code>工厂加载期间以及<code>bean</code>初始化前后会对<code>bean</code>做一些手脚。 而且我们看到这个类继承了<code>AbstractAutoProxyCreator</code>，这就意味它的抽象类一定为当前类做了某些方法的模板，即<strong>模板方法模式</strong>。 笔者贴出了<code>bean</code>初始化前置处理器的<code>postProcessBeforeInstantiation</code>的核心逻辑，可以看到<code>AbstractAutoProxyCreator</code>里面会判断当前传入的<code>bean</code>是否是<code>AOP</code>类，如果是则将其生成通知器类然后放入缓存<code>advisedBeans</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="comment">//判断是否是AOP类，或者是否需要跳过?</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line"><span class="comment">//放到增强其的缓存中</span></span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否是<code>AOP</code>类的逻辑方法如下所示，<code>isInfrastructureClass</code>就是判断这个类是否属于通知或者切点或者通知器<code>Advisor</code>类，如果是就返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> &#123;</span><br><span class="line"><span class="comment">//判断这个类是否是切点、增强器或者需要被代理的类</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">retVal</span> <span class="operator">=</span> Advice.class.isAssignableFrom(beanClass) ||</span><br><span class="line">Pointcut.class.isAssignableFrom(beanClass) ||</span><br><span class="line">Advisor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">AopInfrastructureBean.class.isAssignableFrom(beanClass);</span><br><span class="line"><span class="keyword">if</span> (retVal &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Did not attempt to auto-proxy infrastructure class [&quot;</span> + beanClass.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否跳过的逻辑也很简单，如下所示，找到所有的通知器，判断当前这个<code>bean</code>是否这里面某个通知器名字一样，如果一样就返回<code>true</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"><span class="comment">// 这步就会找到并生成通知器类，然后和当前bean比对，如果这个bean属于通知器类则返回true</span></span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line"><span class="keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line"><span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;</span><br><span class="line">((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;</span><br><span class="line"><span class="comment">//如果和当前bean名字一样则返回true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不妨看看<code>findCandidateAdvisors</code>的逻辑，可以看到它又会调用一个<code>findCandidateAdvisors</code>查找通知器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findCandidateAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 查找通知器然后返回</span></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="built_in">super</span>.findCandidateAdvisors();</span><br><span class="line"><span class="comment">//然后创建生成通知器</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.aspectJAdvisorsBuilder != <span class="literal">null</span>) &#123;</span><br><span class="line">advisors.addAll(<span class="built_in">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑来了<code>buildAspectJAdvisors</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title function_">buildAspectJAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">List&lt;String&gt; aspectNames = <span class="built_in">this</span>.aspectBeanNames;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">aspectNames = <span class="built_in">this</span>.aspectBeanNames;</span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//将这个bean封装成factory </span></span><br><span class="line"><span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">BeanFactoryAspectInstanceFactory</span>(<span class="built_in">this</span>.beanFactory, beanName);</span><br><span class="line">Class&lt;?&gt; beanType = <span class="built_in">this</span>.beanFactory.getType(beanName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果当前这个bean类型是切面类则调用getAdvisors然后返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">List&lt;Advisor&gt; classAdvisors = <span class="built_in">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="comment">//存放到缓存中，后续调用时会用到</span></span><br><span class="line"><span class="built_in">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们不断步进就会看到，通过上述的<code>factory</code>各种参数信息找到这个<code>bean</code>的切点，切点表达式，方法名，切面名称构成一个增强器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Advisor <span class="title function_">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span><br><span class="line"><span class="params"><span class="type">int</span> declarationOrderInAspect, String aspectName)</span> &#123;</span><br><span class="line"></span><br><span class="line">validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"></span><br><span class="line"><span class="type">AspectJExpressionPointcut</span> <span class="variable">expressionPointcut</span> <span class="operator">=</span> getPointcut(</span><br><span class="line">candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"><span class="keyword">if</span> (expressionPointcut == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个增强器</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InstantiationModelAwarePointcutAdvisorImpl</span>(expressionPointcut, candidateAdviceMethod,</span><br><span class="line"><span class="built_in">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装成增强器后，如何将其他类变成代理类？-重点"><a href="#封装成增强器后，如何将其他类变成代理类？-重点" class="headerlink" title="封装成增强器后，如何将其他类变成代理类？(重点)"></a>封装成增强器后，如何将其他类变成代理类？(重点)</h2><p><strong>答:</strong> 这就到<code>bean</code>初始化后置操作了，如下代码所示，从缓存中获取这个<code>bean</code>，如果这个<code>bean</code>不在<code>earlyProxyReferences</code>中，则调用<code>wrapIfNecessary</code>，这个方法会在必要情况下根据策略决定用<code>cglib</code>或者jdk代理完成某些需要被代理的类的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="comment">// 如果这个bean不在代理缓存中，则进行增强</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="那你知道他们在bean生命周期的那个阶段实现的呢？"><a href="#那你知道他们在bean生命周期的那个阶段实现的呢？" class="headerlink" title="那你知道他们在bean生命周期的那个阶段实现的呢？"></a>那你知道他们在bean生命周期的那个阶段实现的呢？</h2><p><strong>答:</strong> 上面的类图已经写的非常清楚了，在<code>bean初始化前后</code>也就我们常说的<code>BPP阶段</code>完成<code>AOP</code>类的缓存以及通知器创建。在<code>bean</code>初始化后，根据需要结合通知器完成代理类的改造。</p><h2 id="代理的创建过程是什么呢？"><a href="#代理的创建过程是什么呢？" class="headerlink" title="代理的创建过程是什么呢？"></a>代理的创建过程是什么呢？</h2><p><strong>答:</strong> AOP提供了一个默认工厂根据类是否有继承接口或者是否就是目标类决定创建的策略。然后根据不同的策略决定代理类的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line"><span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下便是<code>jdk</code>代理的创建策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">.........</span><br><span class="line"><span class="comment">//获取被代理的类的接口</span></span><br><span class="line">Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised, <span class="literal">true</span>);</span><br><span class="line">findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成代理对象并返回</span></span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下便是<code>cglib</code>的创建策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">.......</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">.......</span><br><span class="line">将当前类信息通过enhancer 生成代理对象</span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> createEnhancer();</span><br><span class="line"><span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">enhancer.setClassLoader(classLoader);</span><br><span class="line"><span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised));</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> <span class="title class_">ClassLoaderAwareGeneratorStrategy</span>(classLoader));</span><br><span class="line"></span><br><span class="line">Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">Class&lt;?&gt;[] types = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[callbacks.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">types[x] = callbacks[x].getClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回最终生成的代理对象</span></span><br><span class="line"><span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">&#125;</span><br><span class="line">........</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="手写事务-AOP实现"><a href="#手写事务-AOP实现" class="headerlink" title="手写事务-AOP实现"></a>手写事务-AOP实现</h1><p>基于以上对 AOP 的理解，我们可以自己实现AOP，就以事务的实现为例。</p><p>首先列出建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `user_test`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_test` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `balance` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">9</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `user_test` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `user_test` <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="自定义事务注解"><a href="#自定义事务注解" class="headerlink" title="自定义事务注解"></a>自定义事务注解</h2><p>对于声明式的事务，我们可以自定义注解实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTransaction &#123;</span><br><span class="line">    Propagation <span class="title function_">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务的传播属性可以在枚举类中定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Propagation</span> &#123;</span><br><span class="line"></span><br><span class="line">    REQUIRED(<span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    REQUIRES_NEW(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    Propagation(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据库连接资源管理"><a href="#数据库连接资源管理" class="headerlink" title="数据库连接资源管理"></a>数据库连接资源管理</h2><p>数据库的连接是由 ThreadLocal 控制的，ThreadLocal 存储的类型是一个 Map<br>Map 中的 key 是 DataSource，value 是 Connection（为了应对多数据源的情况，所以是一个 Map）<br>用了 ThreadLocal 保证了同一个线程获取一个 Connection 对象，从而保证一次事务的所有操作需要在同一个数据库连接上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ConnectionHolder&gt; CONNECTION_THREAD_LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Connection curConnection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  上一个方法的</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">private</span> ConnectionHolder lastConnectionHolder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unbindResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">lastConnectionHolder</span> <span class="operator">=</span> CONNECTION_THREAD_LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (lastConnectionHolder == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置当前连接为上一个方法的连接</span></span><br><span class="line">        <span class="comment">// 第一个ConnectionHolder的lastConnectionHolder属性为null，间接释放资源</span></span><br><span class="line">        CONNECTION_THREAD_LOCAL.set(lastConnectionHolder.getLastConnectionHolder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  获取资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConnectionHolder <span class="title function_">getResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CONNECTION_THREAD_LOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  绑定(set)资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bindResource</span><span class="params">(ConnectionHolder connectionHolder)</span> &#123;</span><br><span class="line">        CONNECTION_THREAD_LOCAL.set(connectionHolder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getCurConnectionStatic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">connectionHolder</span> <span class="operator">=</span> ConnectionHolder.getResource();</span><br><span class="line">        <span class="keyword">return</span> connectionHolder != <span class="literal">null</span> ? connectionHolder.getCurConnection() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getCurConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> curConnection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurConnection</span><span class="params">(Connection curConnection)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.curConnection = curConnection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConnectionHolder <span class="title function_">getLastConnectionHolder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastConnectionHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastConnectionHolder</span><span class="params">(ConnectionHolder lastConnectionHolder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lastConnectionHolder = lastConnectionHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p>自定义事务管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TransactionManager</span><span class="params">(ObjectProvider&lt;DataSource&gt; dataSourceProvider)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSourceProvider.getIfAvailable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TransactionInfo <span class="title function_">createTransactionIfNecessary</span><span class="params">(MyTransaction miniTransactional)</span> &#123;</span><br><span class="line">        <span class="type">TransactionInfo</span> <span class="variable">transactionInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionInfo</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">needNew</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (miniTransactional != <span class="literal">null</span> &amp;&amp; miniTransactional.propagation() == Propagation.REQUIRES_NEW) &#123;</span><br><span class="line">            needNew = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取连接（可能会调用setAutoCommit）</span></span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">curConnectionHolder</span> <span class="operator">=</span> transactionInfo.createConnectionIfNecessary(<span class="built_in">this</span>.dataSource, needNew);</span><br><span class="line">        transactionInfo.setConnection(curConnectionHolder.getCurConnection());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定ThreadLocal</span></span><br><span class="line">        ConnectionHolder.bindResource(curConnectionHolder);</span><br><span class="line">        <span class="keyword">return</span> transactionInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rollBack</span><span class="params">(TransactionInfo transactionInfo)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (transactionInfo.isNewTransaction()) &#123;</span><br><span class="line">                <span class="comment">// 执行回滚事务</span></span><br><span class="line">                transactionInfo.getConnection().rollback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理资源</span></span><br><span class="line">            TransactionManager.cleanupAfterCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionInfo transactionInfo)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (transactionInfo.isNewTransaction()) &#123;</span><br><span class="line">                <span class="comment">// 执行提交事务</span></span><br><span class="line">                transactionInfo.getConnection().commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理资源</span></span><br><span class="line">            TransactionManager.cleanupAfterCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cleanupAfterCompletion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 先将当前连接还回连接池</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">curConnection</span> <span class="operator">=</span> ConnectionHolder.getCurConnectionStatic();</span><br><span class="line">        <span class="keyword">if</span>(curConnection!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curConnection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再重置当前连接为上一个方法的连接</span></span><br><span class="line">        ConnectionHolder.unbindResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 transactionInfo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前connection是否为事务创建者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">newTransaction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConnectionHolder <span class="title function_">createConnectionIfNecessary</span><span class="params">(DataSource dataSource, <span class="type">boolean</span> needNew)</span> &#123;</span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">curConnectionHolder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">lastConnectionHolder</span> <span class="operator">=</span> ConnectionHolder.getResource();</span><br><span class="line">        <span class="keyword">if</span> (lastConnectionHolder == <span class="literal">null</span> || needNew) &#123;</span><br><span class="line">            curConnectionHolder = newOneConnectionHolder(dataSource, lastConnectionHolder);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!needNew) &#123;</span><br><span class="line">            curConnectionHolder = lastConnectionHolder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curConnectionHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConnectionHolder <span class="title function_">newOneConnectionHolder</span><span class="params">(DataSource dataSource, ConnectionHolder lastConnectionHolder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.newTransaction = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">connectionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionHolder</span>();</span><br><span class="line">        connectionHolder.setLastConnectionHolder(lastConnectionHolder);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">newConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newConnection = dataSource.getConnection();</span><br><span class="line">            <span class="comment">// fixme 关闭自动提交，间接开启事务</span></span><br><span class="line">            newConnection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        connectionHolder.setCurConnection(newConnection);</span><br><span class="line">        <span class="keyword">return</span> connectionHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConnection</span><span class="params">(Connection connection)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connection = connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNewTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newTransaction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNewTransaction</span><span class="params">(<span class="type">boolean</span> newTransaction)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.newTransaction = newTransaction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AOP实现事务逻辑"><a href="#AOP实现事务逻辑" class="headerlink" title="AOP实现事务逻辑"></a>AOP实现事务逻辑</h2><p>使用@Aspect实现AOP，定义切入点和真正实现AOP的切面方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">TransactionAspect</span><span class="params">(TransactionManager transactionManager)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.transactionManager = transactionManager;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Pointcut(value = &quot;@within(com.jrrl.transaction.aop.MyTransaction)&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">point</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around(&quot;point()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">MyTransaction</span> <span class="variable">myTransaction</span> <span class="operator">=</span> ((MethodSignature) joinPoint.getSignature()).getMethod().getAnnotation(MyTransaction.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化 transactionInfo</span></span><br><span class="line">        <span class="type">TransactionInfo</span> <span class="variable">transactionInfo</span> <span class="operator">=</span> transactionManager.createTransactionIfNecessary(myTransaction);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用目标方法</span></span><br><span class="line">            res = joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 回滚事务</span></span><br><span class="line">            transactionManager.rollBack(transactionInfo);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        transactionManager.commit(transactionInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务的传播属性"><a href="#事务的传播属性" class="headerlink" title="事务的传播属性"></a>事务的传播属性</h2><table><thead><tr><th>传播属性</th><th>概念</th><th>建议</th></tr></thead><tbody><tr><td><strong><code>PROPAGATION_REQUIRED</code></strong></td><td>（默认传播属性）如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</td><td>增删改操作@Transactional(rollbackFor &#x3D; Exception.class)</td></tr><tr><td><strong><code>PROPAGATION_SUPPORTS</code></strong></td><td>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</td><td>查询操作@Transactional(propagation&#x3D;Propagation.SUPPORTS, readOnly &#x3D; true)</td></tr><tr><td><strong><code>PROPAGATION_REQUIRES_NEW</code></strong></td><td>创建一个新的事务，如果当前存在事务，则把当前事务挂起。</td><td></td></tr><tr><td><strong><code>PROPAGATION_NESTED</code></strong></td><td>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</td><td></td></tr><tr><td><strong><code>PROPAGATION_MANDATORY</code></strong></td><td>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</td><td></td></tr></tbody></table><blockquote><p>需要注意的是，在同一个类中非事务方法调用事务方法，事务失效问题</p></blockquote><p><strong>原因：</strong></p><p>spring 在扫描bean的时候会扫描方法上是否包含@Transactional注解，如果包含，spring会为这个bean动态地生成一个子类（即代理类，proxy），代理类是继承原来那个bean的。此时，当这个有注解的方法被调用的时候，实际上是由代理类来调用的，代理类在调用之前就会启动transaction。</p><p>然而，如果这个有注解的方法是被同一个类中的其他方法调用的，那么该方法的调用并没有通过代理类，而是直接通过原来的那个bean，所以就不会启动transaction，我们看到的现象就是@Transactional注解无效。</p><p>解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">noneTransactionMethod</span><span class="params">()</span>&#123; <span class="comment">//非事务方法</span></span><br><span class="line">    <span class="type">xxxServiceImpl</span> <span class="variable">bean</span> <span class="operator">=</span> SpringUtils.getBean(xxxServiceImpl.class);</span><br><span class="line">    bean.transactionMethod();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionMethod</span><span class="params">()</span>&#123; <span class="comment">// 事务方法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对AOP的理解&quot;&gt;&lt;a href=&quot;#对AOP的理解&quot; class=&quot;headerlink&quot; title=&quot;对AOP的理解&quot;&gt;&lt;/a&gt;对AOP的理解&lt;/h1&gt;&lt;p&gt;&lt;code&gt;AOP(Aspect-Oriented Programming:面向切面编程)&lt;/cod</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://palette-k.github.io/tags/Spring/"/>
    
    <category term="AOP" scheme="https://palette-k.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis源码</title>
    <link href="https://palette-k.github.io/2023/12/20/MyBatis%E6%BA%90%E7%A0%81/"/>
    <id>https://palette-k.github.io/2023/12/20/MyBatis%E6%BA%90%E7%A0%81/</id>
    <published>2023-12-20T10:24:15.000Z</published>
    <updated>2024-01-25T08:46:49.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis-执行流程"><a href="#MyBatis-执行流程" class="headerlink" title="MyBatis 执行流程"></a>MyBatis 执行流程</h1><p>首先回顾一下jdbc的执行流程。</p><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MyBatis/jdbc.png"></p><p>MyBatis的执行流程也包含jdbc的执行流程，但是会做一些前置处理。</p><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MyBatis/MyBatis.png"></p><h2 id="方法代理-MapperMethod"><a href="#方法代理-MapperMethod" class="headerlink" title="方法代理(MapperMethod)"></a>方法代理(MapperMethod)</h2><p>使用动态代理调用，可以看到非常熟悉的 invoke 方法，这个invoke方法就是动态代理的逻辑，method.invoke()方法就是实现代理类对原始方法的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6424540398559729838L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="built_in">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="built_in">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="会话-SqlSession"><a href="#会话-SqlSession" class="headerlink" title="会话(SqlSession)"></a>会话(SqlSession)</h2><p>SqlSession 是myBatis的门面(采用门面模式设计)，核心作用是为用户提供API。API包括增、删、改、查以及提交、关闭等。其自身是没有能力处理这些请求的，所以内部会包含一个唯一的执行器 Executor，所有请求都会交给执行器来处理。</p><p>SqlSession 是SqlSessionFactory会话工厂创建出来的一个会话的对象，这个SqlSession对象用于执行具体的SQL语句并返回给用户请求的结果。</p><h2 id="执行器-Executor"><a href="#执行器-Executor" class="headerlink" title="执行器(Executor)"></a>执行器(Executor)</h2><p>Executor是一个大管家，核心功能包括：缓存维护、获取动态SQL、获取连接、以及最终的JDBC调用等。在图中所有蓝色节点全部都是在Executor中完成。</p><p>这么多事情无法全部亲力亲为，就需要把任务分派下去。所以Executor内部还会包含若干个组件：</p><ul><li>缓存维护：cache</li><li>获取连接：Transaction</li><li>获取动态sql：SqlSource</li><li>调用jdbc：StatementHandler</li></ul><p>上述组件中前三个和Executor是1对1关系，只有StatementHandler是1对多。每执行一次SQL 就会构造一个新的StatementHandler。StatementHandler的作用就是专门和JDBC打交道，执行SQL的。</p><h3 id="SQL处理器-StatementHandler"><a href="#SQL处理器-StatementHandler" class="headerlink" title="SQL处理器(StatementHandler)"></a>SQL处理器(StatementHandler)</h3><p>在JDBC中执行一次sql的步骤包括。预编译SQL、设置参数然后执行。StatementHandler就是用来处理这三步。</p><p>用于获取预处理器，共有三种类型。通过statementType&#x3D;<code>&quot;STATEMENT|PREPARED|CALLABLE&quot;</code> 可分别进行指定。</p><ul><li>PreparedStatementHandler：带预处理的执行器</li><li>CallableStatementHandler：存储过程执行器</li><li>SimpleStatementHandler：基于Sql执行器</li></ul><p>同样它也需要两个助手分别是：</p><ul><li>设置参数：ParameterHandler</li><li>读取结果：ResultSetHandler，可在SqlSession中查询时自行定义ResultSetHandler</li></ul><p>另外的执行是由它自己完成。</p><h1 id="主键生成"><a href="#主键生成" class="headerlink" title="主键生成"></a>主键生成</h1><p>在平时开发的时候经常会有这样的需求，插入数据返回主键，或者插入数据之前需要获取主键，这样的需求在 mybatis 中也是支持的。只需要在 xml 里配置 useGenerateKey &#x3D; true 就好了。</p><p>其中主要的逻辑部分就在 KeyGenerator 中，其接口方法如下：</p><p>processBefore 是在生成 StatementHandler 的时候执行，processAfter 则是在完成插入返回结果之前执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">KeyGenerator</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">processBefore</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">processAfter</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所见 KeyGenerator 非常的简单，主要是通过两个拦截方法实现的：</p><ul><li>Jdbc3KeyGenerator：主要基于 java.sql.Statement.getGeneratedKeys 的主键返回接口实现的，所以他不需要 processBefore 方法，只需要在获取到结果后使用 processAfter 拦截，然后用反射将主键设置到参数中即可；</li><li>SelectKeyGenerator：主要是通过 XML 配置或者注解设置 <strong>selectKey</strong> ，然后单独发出查询语句，在返回拦截方法中使用反射设置主键，其中两个拦截方法只能使用其一，在 <strong>selectKey.order</strong> 属性中设置 <code>AFTER|BEFORE</code> 来确定；</li></ul><h1 id="MyBatis-缓存"><a href="#MyBatis-缓存" class="headerlink" title="MyBatis 缓存"></a>MyBatis 缓存</h1><p>myBatis中存在两个缓存，一级缓存和二级缓存。</p><ul><li>一级缓存：也叫做会话级缓存，生命周期仅存在于当前会话，不可以直接关关闭。但可以通过flushCache和localCacheScope对其做相应控制。</li><li>二级缓存：也叫应用级性缓存，缓存对象存在于整个应用周期，而且可以跨线程使用。</li></ul><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><h3 id="一级缓存的命中场景"><a href="#一级缓存的命中场景" class="headerlink" title="一级缓存的命中场景"></a>一级缓存的命中场景</h3><p>关于一级缓存的命中可大致分为两个场景，满足特定命中参数，第二不触发清空方法。</p><h4 id="缓存命中参数："><a href="#缓存命中参数：" class="headerlink" title="缓存命中参数："></a>缓存命中参数：</h4><ol><li>SQL与参数相同：</li><li>同一个会话：</li><li>相同的MapperStatement ID：</li><li>RowBounds行范围相同：</li></ol><h4 id="触发清空缓存"><a href="#触发清空缓存" class="headerlink" title="触发清空缓存"></a>触发清空缓存</h4><ol><li>手动调用clearCache</li><li>执行提交回滚</li><li>执行update</li><li>配置flushCache&#x3D;true</li><li>缓存作用域为Statement</li></ol><h3 id="一级缓存源码解析"><a href="#一级缓存源码解析" class="headerlink" title="一级缓存源码解析"></a>一级缓存源码解析</h3><p>一级缓存逻辑就存在于 BaseExecutor (基础执行器)里面。当会话接收到查询请求之后，会交给执行器的Query方法，在这里会通过 Sql、参数、分页条件等参数创建一个缓存key，在基于这个key去 PerpetualCache中查找对应的缓存值，如果有命中直接返回。没有就会查询数据库，然后在填充缓存。最终缓存的实现非常简单，就是一个HashMap。</p><h4 id="一级缓存的清空"><a href="#一级缓存的清空" class="headerlink" title="一级缓存的清空"></a>一级缓存的清空</h4><p>缓存的清空对应BaseExecutor中的 clearLocalCache.方法。只要找到调用该方法地方，就知道哪些场景中会清空缓存了。</p><ul><li>update: 执行任意增删改</li><li>select：查询又分为两种情况清空，一前置清空，即配置了flushCache&#x3D;true。二后置清空，配置了缓存作用域为statement 查询结束合会清空缓存。</li><li>commit：提交前清空</li><li>Rolback：回滚前清空</li></ul><blockquote><p>注意：clearLocalCache 不是清空某条具体数据，而清当前会话下所有一级缓存数据。</p></blockquote><h3 id="MyBatis集成Spring后一级缓存失效的问题？"><a href="#MyBatis集成Spring后一级缓存失效的问题？" class="headerlink" title="MyBatis集成Spring后一级缓存失效的问题？"></a>MyBatis集成Spring后一级缓存失效的问题？</h3><p>很多人发现，集成一级缓存后会话失效了，以为是spring Bug ，真正原因是Spring 对SqlSession进行了封装，通过SqlSessionTemplae ，使得每次调用Sql，都会重新构建一个SqlSession，具体参见SqlSessionInterceptor。而根据前面所学，一级缓存必须是同一会话才能命中,所以在这些场景当中不能命中。</p><p>怎么解决呢？给Spring 添加事物 即可。添加事物之后，SqlSessionInterceptor(会话拦截器)就会去判断两次请求是否在同一事物当中，如果是就会共用同一个SqlSession会话来解决。</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>二级缓存也称作是应用级缓存，与一级缓存不同的，是它的作用范围是整个应用，而且可以跨线程使用。所以二级缓存有更高的命中率，适合缓存一些修改较少的数据。在流程上是先访问二级缓存，再访问一级缓存。</p><p>MyBatis抽象出Cache接口，其只定义了缓存中最基本的功能方法：</p><ul><li>设置缓存</li><li>获取缓存</li><li>清除缓存</li><li>获取缓存数量</li></ul><p>然后上述中每一个功能都会对应一个组件类，并基于装饰者加责任链的模式，将各个组件进行串联。在执行缓存的基本功能时，其它的缓存逻辑会沿着这个责任链依次往下传递。</p><p>这样设计有以下优点：</p><ol><li>职责单一：各个节点只负责自己的逻辑，不需要关心其它节点。</li><li>扩展性强：可根据需要扩展节点、删除节点，还可以调换顺序保证灵活性。</li><li>松耦合：各节点之间不没强制依赖其它节点。而是通过顶层的Cache接口进行间接依赖。</li></ol><h3 id="缓存空间声明"><a href="#缓存空间声明" class="headerlink" title="缓存空间声明"></a>缓存空间声明</h3><p>二级默认缓存默认是不开启的，需要为其声明缓存空间才可以使用，通过@CacheNamespace 或 为指定的MappedStatement声明。声明之后该缓存为该Mapper所独有，其它Mapper不能访问。如需要多个Mapper共享一个缓存空间可通过@CacheNamespaceRef 或进行引用同一个缓存空间。</p><h3 id="二级缓存的命中条件"><a href="#二级缓存的命中条件" class="headerlink" title="二级缓存的命中条件"></a>二级缓存的命中条件</h3><p>二级缓存的命中场景与一级缓存类似，不同在于二级可以跨会放使用，还有就是二级缓存的更新，为了保证数据一至性，二级缓存必须是会话提交之才会真正填充，包括对缓存的清空，也必须是会话正常提交之后才生效。</p><h3 id="二级缓存结构"><a href="#二级缓存结构" class="headerlink" title="二级缓存结构"></a>二级缓存结构</h3><p>为了实现会话提交之后才变更二级缓存，MyBatis为每个会话设立了若干个暂存区，当前会话对指定缓存空间的变更，都存放在对应的暂存区，当会话提交之后才会提交到每个暂存区对应的缓存空间。为了统一管理这些暂存区，每个会话都一个唯一的事物缓存管理器。所以这里暂存区也可叫做事物缓存。</p><h3 id="二级缓存的执行流程"><a href="#二级缓存的执行流程" class="headerlink" title="二级缓存的执行流程"></a>二级缓存的执行流程</h3><p>原本会话是通过Executor实现SQL调用，这里基于装饰器模式使用CachingExecutor对SQL调用逻辑进行拦截。以嵌入二级缓存相关逻辑。</p><h4 id="查询操作query"><a href="#查询操作query" class="headerlink" title="查询操作query"></a>查询操作query</h4><p>当会话调用query() 时，会基于查询语句、参数等数据组成缓存Key，然后尝试从二级缓存中读取数据。读到就直接返回，没有就调用被装饰的Executor去查询数据库，然后在填充至对应的暂存区。</p><blockquote><p>请注意，这里的查询是实时从缓存空间读取的，而变更，只会记录在暂存区</p></blockquote><h4 id="更新操作update"><a href="#更新操作update" class="headerlink" title="更新操作update"></a>更新操作update</h4><p>当执行update操作时，同样会基于查询的语句和参数组成缓存KEY，然后在执行update之前清空缓存。这里清空只针对暂存区，同时记录清空的标记，以便当会话提交之时，依据该标记去清空二级缓存空间。</p><blockquote><p>如果在查询操作中配置了flushCache&#x3D;true ，也会执行相同的操作。</p></blockquote><h4 id="提交操作commit"><a href="#提交操作commit" class="headerlink" title="提交操作commit"></a>提交操作commit</h4><p>当会话执行commit操作后，会将该会话下所有暂存区的变更，更新到对应二级缓存空间去。</p><h1 id="Hibernate和MyBatis的区别"><a href="#Hibernate和MyBatis的区别" class="headerlink" title="Hibernate和MyBatis的区别"></a>Hibernate和MyBatis的区别</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。</p><p>其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。Hibernate和MyBatis都支持 JDBC 和 JTA 事务处理。</p><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h3 id="hibernate是全自动，而mybatis是半自动"><a href="#hibernate是全自动，而mybatis是半自动" class="headerlink" title="hibernate是全自动，而mybatis是半自动"></a>hibernate是全自动，而mybatis是半自动</h3><p>hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p><h3 id="hibernate数据库移植性远大于mybatis"><a href="#hibernate数据库移植性远大于mybatis" class="headerlink" title="hibernate数据库移植性远大于mybatis"></a>hibernate数据库移植性远大于mybatis</h3><p>hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（Oracle、MySQL等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于程序员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。</p><h3 id="hibernate拥有完整的日志系统"><a href="#hibernate拥有完整的日志系统" class="headerlink" title="hibernate拥有完整的日志系统"></a>hibernate拥有完整的日志系统</h3><p>hibernate日志系统非常健全，涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等；而mybatis则除了基本记录功能外，功能薄弱很多。</p><h3 id="mybatis相比hibernate需要关心很多细节"><a href="#mybatis相比hibernate需要关心很多细节" class="headerlink" title="mybatis相比hibernate需要关心很多细节"></a>mybatis相比hibernate需要关心很多细节</h3><p>hibernate配置要比mybatis复杂的多，学习成本也比mybatis高。但也正因为mybatis使用简单，才导致它要比hibernate关心很多技术细节。mybatis由于不用考虑很多细节，开发模式上与传统jdbc区别很小，因此很容易上手并开发项目，但忽略细节会导致项目前期bug较多，因而开发出相对稳定的软件很慢，而开发出软件却很快。hibernate则正好与之相反。但是如果使用hibernate很熟练的话，实际上开发效率丝毫不差于甚至超越mybatis。</p><h3 id="sql直接优化上，mybatis要比hibernate方便很多"><a href="#sql直接优化上，mybatis要比hibernate方便很多" class="headerlink" title="sql直接优化上，mybatis要比hibernate方便很多"></a>sql直接优化上，mybatis要比hibernate方便很多</h3><p>由于mybatis的sql都是写在xml里，因此优化sql比hibernate方便很多。而hibernate的sql很多都是自动生成的，无法直接维护sql；虽有hql，但功能还是不及sql强大，见到报表等变态需求时，hql也歇菜，也就是说hql是有局限的；hibernate虽然也支持原生sql，但开发模式上却与orm不同，需要转换思维，因此使用上不是非常方便。总之写sql的灵活度上hibernate不及mybatis。</p><h3 id="缓存机制上，hibernate要比mybatis更好一些"><a href="#缓存机制上，hibernate要比mybatis更好一些" class="headerlink" title="缓存机制上，hibernate要比mybatis更好一些"></a>缓存机制上，hibernate要比mybatis更好一些</h3><p>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p><p>而Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MyBatis-执行流程&quot;&gt;&lt;a href=&quot;#MyBatis-执行流程&quot; class=&quot;headerlink&quot; title=&quot;MyBatis 执行流程&quot;&gt;&lt;/a&gt;MyBatis 执行流程&lt;/h1&gt;&lt;p&gt;首先回顾一下jdbc的执行流程。&lt;/p&gt;
&lt;p&gt;&lt;img s</summary>
      
    
    
    
    
    <category term="原理" scheme="https://palette-k.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
    <category term="MyBatis" scheme="https://palette-k.github.io/tags/MyBatis/"/>
    
    <category term="源码" scheme="https://palette-k.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jdbc的演变</title>
    <link href="https://palette-k.github.io/2023/12/20/jdbc%E7%9A%84%E6%BC%94%E5%8F%98/"/>
    <id>https://palette-k.github.io/2023/12/20/jdbc%E7%9A%84%E6%BC%94%E5%8F%98/</id>
    <published>2023-12-20T02:05:22.000Z</published>
    <updated>2023-12-20T11:04:57.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jdbc流程"><a href="#jdbc流程" class="headerlink" title="jdbc流程"></a>jdbc流程</h1><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MyBatis/jdbc.png"></p><h1 id="jdbc操作"><a href="#jdbc操作" class="headerlink" title="jdbc操作"></a>jdbc操作</h1><h2 id="jdbc连接"><a href="#jdbc连接" class="headerlink" title="jdbc连接"></a>jdbc连接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//1.加载配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span></span><br><span class="line">ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pros.load(is);</span><br><span class="line"><span class="comment">//2.读取配置信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"><span class="comment">//3.加载驱动</span></span><br><span class="line">Class.forName(driverClass);</span><br><span class="line"><span class="comment">//4.获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password);</span><br><span class="line">System.out.println(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><h2 id="使用PreparedStatement实现增删改操作"><a href="#使用PreparedStatement实现增删改操作" class="headerlink" title="使用PreparedStatement实现增删改操作"></a>使用PreparedStatement实现增删改操作</h2><p>可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p><h3 id="PreparedStatement-vs-Statement"><a href="#PreparedStatement-vs-Statement" class="headerlink" title="PreparedStatement vs Statement"></a>PreparedStatement vs Statement</h3><ul><li><p>代码的可读性和可维护性。 </p></li><li><p>PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的 编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) </p></li><li><p>PreparedStatement 可以防止 SQL 注入</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String sql,Object ... args)</span>&#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1.获取数据库的连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">//2.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">//3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.执行sql语句</span></span><br><span class="line">ps.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//5.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用PreparedStatement实现查询操作"><a href="#使用PreparedStatement实现查询操作" class="headerlink" title="使用PreparedStatement实现查询操作"></a>使用PreparedStatement实现查询操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getInstance</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取数据库连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">// 2.预编译sql语句，得到PreparedStatement对象</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4.执行executeQuery(),得到结果集：ResultSet</span></span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="comment">// 5.得到结果集的元数据：ResultSetMetaData</span></span><br><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"><span class="comment">// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnCount; i++) &#123;<span class="comment">// 遍历每一个列</span></span><br><span class="line"><span class="comment">// 获取列值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">columnVal</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 获取列的别名:列的别名，使用类的属性名充当</span></span><br><span class="line"><span class="type">String</span> <span class="variable">columnLabel</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 6.2使用反射，给对象的相应属性赋值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnLabel);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 7.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jdbc事务处理"><a href="#jdbc事务处理" class="headerlink" title="jdbc事务处理"></a>jdbc事务处理</h2><ul><li><p>调用 Connection 对象的 setAutoCommit(false); </p></li><li><p>以取消自动提交事务在所有的 SQL 语句都成功执行后，调用 commit(); </p></li><li><p>方法提交事务在出现异常时，调用 rollback(); 方法回滚事务</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJDBCTransaction</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取数据库连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">// 2.开启事务</span></span><br><span class="line">conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 3.进行数据库操作</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance - 100 where user = ?&quot;</span>;</span><br><span class="line">update(conn, sql1, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line"><span class="comment">// 模拟网络异常</span></span><br><span class="line"><span class="comment">//System.out.println(10 / 0);</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance + 100 where user = ?&quot;</span>;</span><br><span class="line">update(conn, sql2, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"><span class="comment">// 4.若没有异常，则提交事务</span></span><br><span class="line">conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">// 5.若有异常，则回滚事务</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//6.恢复每次DML操作的自动提交功能</span></span><br><span class="line">conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7.关闭连接</span></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到的 update 方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Connection conn ,String sql, Object... args)</span> &#123;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 2.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.执行sql语句</span></span><br><span class="line">ps.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 4.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(<span class="literal">null</span>, ps);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Druid数据库连接池"><a href="#Druid数据库连接池" class="headerlink" title="Druid数据库连接池"></a>Druid数据库连接池</h1><p>如果使用传统的jdbc连接方式，可能会出现以下问题：</p><ul><li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求 一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用</strong>。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严 重的甚至会造成服务器的崩溃。 </li><li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统 中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？） </li><li><strong>这种开发不能控制被创建的连接对象数，</strong>系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内 存泄漏，服务器崩溃。</li></ul><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 </p><p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 </p><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了 日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDruid</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">    System.out.println(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【druid.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">20</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">filters</span>=<span class="string">wall</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jdbc流程&quot;&gt;&lt;a href=&quot;#jdbc流程&quot; class=&quot;headerlink&quot; title=&quot;jdbc流程&quot;&gt;&lt;/a&gt;jdbc流程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ashleyblog.oss-cn-shenzhen.aliyuncs.</summary>
      
    
    
    
    
    <category term="jdbc" scheme="https://palette-k.github.io/tags/jdbc/"/>
    
    <category term="Druid" scheme="https://palette-k.github.io/tags/Druid/"/>
    
  </entry>
  
</feed>
