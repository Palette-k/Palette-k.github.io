<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MAT案例整理</title>
      <link href="/2025/09/24/MAT%E6%A1%88%E4%BE%8B%E6%95%B4%E7%90%86/"/>
      <url>/2025/09/24/MAT%E6%A1%88%E4%BE%8B%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="开启Dump文件自动转储"><a href="#开启Dump文件自动转储" class="headerlink" title="开启Dump文件自动转储"></a>开启Dump文件自动转储</h1><p>一般来说，线上运行的系统都会加上下面的 JVM 参数，以便如果线上出现 OOM 问题的时候，自动将事故现场保留下来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 当程序出现OutofMemory时，将会在相应的目录下生成一份dump文件，如果不指定选项HeapDumpPath则在当前目录下生成dump文件</span></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:ErrorFile=/logs/oom_dump/xxx.log -XX:HeapDumpPath=/logs/oom_dump/xxx.hprof</span><br></pre></td></tr></table></figure><p>但是有某种情况下，pod会被k8s的某种保护机制下自动kill掉，那么dump文件没办法保存下来。此时也可以联系运维给这个服务加上EFS （Amazon 文件系统）等待下次出现能抓住这个问题。</p><p>EFS 是 <strong>Amazon 提供的完全托管的弹性网络文件系统</strong>，主要用于在 AWS 上运行的多台 EC2 实例之间 <strong>共享存储</strong>。它可以实现多个容器等实例同时挂载同一个 EFS 文件系统。</p><p>如果程序出现 OOM 之后，就是有代码存在内存泄漏的风险，这个时候即使能对外提供服务，其实也是有风险的，可能造成更多的请求有问题，所以该参数非常有必要，可以让 K8S 快速的再拉起来一个实例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+ExitOnOutOfMemoryError</span><br></pre></td></tr></table></figure><p>也有比较原始的方式获取到dump文件，通过 <code>jmap</code> 工具生成可以生成任意Java进程的dump文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先找到PID</span></span><br><span class="line">ps -ef | grep java</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">jmap 转存快照</span></span><br><span class="line">jmap -dump:format=b,file=/opt/dump/test.dump &#123;PID&#125;</span><br></pre></td></tr></table></figure><p>无法在生产环境上使用<code>jstack</code>、<code>jmap</code>等命令直接查错的原因：</p><ol><li><strong>需要和 JVM 进程交互</strong></li></ol><ul><li><ul><li>jstack、jmap 等工具会通过 <strong>Attach API</strong> 去连接目标 Java 进程。</li></ul></li><li><ul><li>连接过程中 JVM 可能会有短暂停顿，尤其是在生成 <strong>堆转储（heap dump）</strong> 时，会触发 <strong>STW（Stop-The-World）</strong>。</li></ul></li></ul><ol><li><strong>堆转储会消耗大量资源</strong></li></ol><ul><li><ul><li>jmap -dump 会把整个堆内存写到磁盘，如果堆是几十 GB，磁盘 IO 和 CPU 会瞬间飙升。</li></ul></li><li><ul><li>在高并发的生产环境里，这可能导致应用延迟飙升，甚至直接 OOM &#x2F; 崩溃。</li></ul></li></ul><ol><li><strong>阻塞风险</strong></li></ol><ul><li><ul><li>某些 JVM bug 或特定版本下，jstack、jmap 执行时可能卡住，甚至把目标进程挂死。</li></ul></li><li><ul><li>这在大规模线上系统中是 <strong>不可接受的风险</strong>。</li></ul></li></ul><p>而使用-XX:+HeapDumpOnOutOfMemoryError这个参数，只在 JVM 已经抛出 OutOfMemoryError、进程无法继续正常工作时才触发 dump。HeapDumpOnOutOfMemoryError 的触发时刻，进程已经 <strong>内存耗尽，服务功能基本不可用</strong>，此时再做 dump 不会额外带来业务中断风险，反而能保留关键现场用于问题分析。</p><p>从安全性维度上讲，运维不会允许研发随时在生产上执行 jmap，因为这是“人为操作”，风险可控但不可预测。而使用JVM 参数 -XX:+HeapDumpOnOutOfMemoryError 是 <strong>只读配置</strong>，行为固定、无人工干预，且只在最坏情况下触发，<strong>可控且可预期</strong>。</p><h1 id="MAT工具参数调整"><a href="#MAT工具参数调整" class="headerlink" title="MAT工具参数调整"></a>MAT工具参数调整</h1><h2 id="MAT需要JDK11才能运行"><a href="#MAT需要JDK11才能运行" class="headerlink" title="MAT需要JDK11才能运行"></a>MAT需要JDK11才能运行</h2><p>解决办法是，打开MAT的安装目录，有一个配置文件MemoryAnalyzer.ini。打开这个文件，在文件中指定JDK版本即可。新增两行配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-vm D:/jdkPath/bin/javaw.exe</span><br></pre></td></tr></table></figure><p>在使用jvisualvm分析大的dump文件时，堆查器使用的内存不足</p><p>修改JAVA_HOME&#x2F;lib&#x2F;visualvm&#x2F;etc&#x2F;visualvm.conf文件中 visualvm_default_options&#x3D;”-J-client -J-Xms24 -J-Xmx256m”，然后重启jvisualVM即可</p><h2 id="MAT修改内存空间"><a href="#MAT修改内存空间" class="headerlink" title="MAT修改内存空间"></a>MAT修改内存空间</h2><p>分析堆转储文件需要消耗很多的堆空间，为了保证分析的效率和性能，在有条件的情况下，建议分配给 MAT 尽可能多的内存资源。两种方式分配内存资源给 MAT：<br>1）修改启动参数 MemoryAnalyzer.exe -vmargs -Xmx4g<br>2）编辑文件 MemoryAnalyzer.ini 添加 -vmargs – Xmx4g</p><h1 id="案例一：查询条件未做限制全表扫描"><a href="#案例一：查询条件未做限制全表扫描" class="headerlink" title="案例一：查询条件未做限制全表扫描"></a>案例一：查询条件未做限制全表扫描</h1><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>线上某个服务有接口非常慢，通过监控链路查看发现，中间的 GAP 时间非常大，实际接口并没有消耗很多时间，并且在那段时间里有很多这样的请求。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/693a19a64dd945e8bbd4baee1ee76e15~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="null"></p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>先从监控链路分析了一波，发现请求是已经打到服务上了，处理之前不知道为什么等了 3s，猜测是不是机器当时负载太大了，通过 QPS 监控查看发现，在接口慢的时候 CPU 突然增高，同时也频繁的 GC ，并且时间很长，但是请求量并不大，并且这台机器很快就因为 Heap满了而被下掉了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7de13c219964feb9f2d00cad9e0552f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="null"></p><p>dump 出来的文件足有 4.8G，话不多说祭出 jvisualvm 进行分析，分析工具都被这个dump文件给搞挂了也报了个<code>java.lang.OutOfMemoryError: Java heap space</code>，加载成功之后就给出了导致OOM的线程。</p><p>找到<code>class</code>按照大小排序，占用最多的是一个 byte 数组，有 1.07G，char 数组也有1.03G，byte 数组都是数字，直接查看 char 数组吧，点进去查看具体内容，果然是那条count语句，一条 SQL 1.03G 难以想象。。。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b4d6894ebf045d9bdd175e9a1fb880e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="null"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0be4c3f444c4d8e8e92c29a940cb9a9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="null"></p><p>这个<code>userId</code>的数据完全是外部传过来的，并没有做什么操作，从监控上看，这个入参有 64M，马上联系对应系统排查为啥会传这么多用户过来查询，经过一番排查确认他们有个<code>bug</code>，会把所有用户都发过来查询。。。到此问题排查清楚。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>对方系统控制传入<code>userId</code>的数量，我们自己的系统也对<code>userId</code>做一个限制，问题排查过程比较困难，修改方案总是那么的简单。</p><p>对于 SQL 语句，如果监测到没有<code>where</code>条件的全表查询应该默认增加一个合适的<code>limit</code>作为限制，防止这种问题拖垮整个系统。</p><h1 id="案例二：文件删除导致内存泄漏"><a href="#案例二：文件删除导致内存泄漏" class="headerlink" title="案例二：文件删除导致内存泄漏"></a>案例二：文件删除导致内存泄漏</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天下午，正酣畅淋漓的搬砖，突然运维同事在群里通知，核心服务某个节点内存异常，服务假死。神经一下子紧张起来，赶紧跑到运维那边观察现象。</p><p>观察的结果是服务内存溢出，该服务是核心服务，分配了5G内存。运维在转存快照后，立刻重启服务后正常。在接下来的一段时间里，另一台服务节点也发生了同样的情况。</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>进入到<code>Dominator Tree</code>视图, 列出当前存活的对象的内存大小，这看起来像是我需要关注的重点。然后查了下这个类 <code>java.io.DeleteOnExitHook</code> 与 内存泄露的相关问题。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/639dc7ba1a0e7a00d97eb65737e5a58e19056ef1.png" alt="img"></p><p>在删除文件使用 <code>File.deleteOnExit()</code> 方法时，并不是立刻删除文件，而是将该文件路径维护在类DeleteOnExit的一个LinkedHashSet中，最后在JVM关闭的时候，才会去删除这里面的文件，这个方法不能用于长时间运行的服务。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>问题定位于<code>File.deleteOnExit()</code>方法的调用，导致内存泄漏。调用该方法只会将需要删除文件的路径，维护在类<code>DeleteOnExit</code>的一个LinkedHashSet中，在JVM关闭时，才会去真正执行删除文件操作。这样导致<code>DeleteOnExitHook</code>这个对象越来越大，最终内存溢出。</p><p><code>File.delete()</code>与 <code>File.deleteOnExit()</code> 的区别：<br>当调用delete()方法时，直接删除文件，不管该文件是否存在，一经调用立即执行<br>当调用deleteOnExit()方法时，只是相当于对deleteOnExit()作一个声明，当程序运行结束，JVM终止时才真正调用deleteOnExit()方法实现删除操作。</p><p>我写了下面这个测试方法，对比 <code>delete()</code>和<code>deleteOnExit()</code>的区别，现象会比较明显。使用<code>deleteOnExit</code>时是在文件全部创建，JVM关闭的时候，才一个个删除文件，<code>delete</code>会立刻删除文件。(所以这个方法的使用场景是怎样的，我就不太清楚了)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loopTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">root</span> <span class="operator">=</span> <span class="string">&quot;D:\\C_Temp\\files\\&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(root);</span><br><span class="line">    <span class="keyword">if</span> (!path.exists()) &#123;</span><br><span class="line">        path.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">40000</span>) &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path, <span class="string">&quot;Hello-&quot;</span> + i + <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">        file.createNewFile();</span><br><span class="line">        file.delete();</span><br><span class="line"><span class="comment">//            file.deleteOnExit();</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="案例三：JVM启动参数有误"><a href="#案例三：JVM启动参数有误" class="headerlink" title="案例三：JVM启动参数有误"></a>案例三：JVM启动参数有误</h1><h2 id="事故背景"><a href="#事故背景" class="headerlink" title="事故背景"></a>事故背景</h2><p>2023年3月10日14时19分，C公司开发人员向A公司开发人员反映某开放接口从2023年3月10日14时许开始无法访问和使用。该系统为某基础数据接口服务，基于 HTTP 协议进行通信。按照惯例，首先排查网络是否异常，经运维人员检查，证明网络连通性没有问题。A公司开发组于2023年3月10日14时30分通知运维人员重启应用服务，期间短暂恢复正常。但是，很快，十分钟后，电话再次响起，告知服务又出现异常，无法访问。为了避免影响进一步扩大，A公司决定将程序<strong>紧急回滚至上一稳定版本</strong>。回滚后，系统业务功能恢复正常。短暂松一口气后，开始排查问题。</p><h2 id="事故分析"><a href="#事故分析" class="headerlink" title="事故分析"></a>事故分析</h2><p>根据前面的故障现象，初步猜测是内存问题。堆转储文件出来后，用*MAT(Memory Analyzer Tool)*工具打开转储文件，原以为会发现某个类型对象占用大量的内存，结果出乎意料，Histogram（直方图）中显示活跃对象居然只有100多M！尝试 Calculate Precise Retained Size（计算精确大小），计算结果与前面相差不大。检查 Outgoing References （追踪引用对象）和 Incoming References（追踪被引用对象）也未见明显异常，令人头大。</p><p>日志已经明确提示我们<code>java.lang.OutOfMemoryError: Java heap space</code>，首先肯定这是一个堆内存空间引起的问题，可能的原因有：</p><ul><li><p>内存加载数据量过大例如不受行数限制的数据库查询语句，或者不限制字节数的文件读取等，事故系统显然没有这些情况；</p></li><li><p>内存泄漏（资源未关闭&#x2F;无法回收）当系统存在大量未关闭的 IO 资源，或者错误使用<code>ThreadLocal</code>等场景时也会发生<code>OOM</code>，经排查，也不存在这种情况；</p></li><li><p>系统内存不足系统内存不足以支撑当前业务场景所需要的内存，过小的机器内存或者不合理的<em>JVM</em>内存参数。</p></li></ul><p>如果排除所有合理选项，最不合理那个会不会就是答案呢？遂开始检查机器的内存，根据运维的说法，机器内存为16GB，<code>top</code>命令查看<code>java</code>进程占用内存约为7.8GB，看起来似乎没毛病。</p><p>但是随后另一个同事注意到了一个事情，最后一次系统升级的时候，改动过应用启停脚本，对比旧版本的脚本，发现差异部分就是内存参数：</p><p>旧版本原为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms8g -Xmx8g -Xmn3g</span><br></pre></td></tr></table></figure><p>新版本改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms8g -Xmx8g -Xmn8g</span><br></pre></td></tr></table></figure><h2 id="事故原因"><a href="#事故原因" class="headerlink" title="事故原因"></a>事故原因</h2><p><strong>-Xms</strong>：初始堆大小，通常和 -Xmx 设置一样大，避免堆在运行中动态扩容，减少 GC 和内存分配的开销。</p><p><strong>-Xmx</strong>：最大堆大小，和物理机&#x2F;容器内存要匹配，不能随意大于系统可用内存</p><p><strong>-Xmn</strong>：年轻代大小，年轻代太大，意味着老年代空间变小，Full GC 更容易触发；但太小的话 Minor GC 会频繁发生。</p><p>为什么<code>-Xmn</code>参数设置成与<code>-Xmx</code>参数一样的大小会导致<code>OOM</code>呢？该项目使用的<em>JDK</em>版本为1.8，看看<em>JDK 8</em>的内存模型：</p><p><img src="https://img2023.cnblogs.com/blog/1925794/202304/1925794-20230407022218419-543043266.png" alt="null"></p><p>不难发现，<code>Heap Space Size = Young Space Size + Old Space Size</code>，而<code>-Xmn</code>参数控制的正是 Young 区的大小，当堆区被 Young Gen 完全挤占，又有对象想要升代到 Old Gen 时，发现 Old 区空间不足，于是触发 Full GC，触发 Full GC 以后呢，通常又会面临两种情况：</p><ul><li><p>Young 区又刚好腾出来一点空间，对象又不用放到 Old 区里面了，皆大欢喜</p></li><li><p>Young 区空间还是不够，对象还是得放到 Old 区，Old 区空间不够，卒，喜提<code>OOM</code></p></li><li><p>诶，就是奔着 Old 区去的，管你 Young 不 Young，Old 区空间不够，卒，喜提<code>OOM</code></p></li></ul><p>这个就解释了为什么系统刚刚启动时，会有一个短时间正常工作的现象，随后，当某段程序触发 Old Gen 升代时，就会发生随机的<code>OOM</code>错误。那么什么时候对象会进入老年代呢？这里也很有意思，不妨结合日志里面出现<code>OOM</code>的地方，对号入座：</p><ul><li><p>经历足够多次数 GC 依然存活的对象</p></li><li><p>申请一个大对象（比如超过 Eden 区一半大小）</p></li><li><p>GC 后 Eden 区对象大小超过 S 区之和</p></li><li><p>Eden 区 + S0 区 GC 后，S1 区放不下</p></li></ul><p>换言之，正常情况下，<code>-Xmn</code>参数总是应当小于<code>-Xmx</code>参数，否则就会触发<code>OOM</code>错误。触发 GC 的前后，Old 区几乎都没有空间，仅有的一点点还是<em>JDK</em>强行分配的（在启动<em>JVM</em>时强制覆写了我们的<code>-Xmn</code>参数）</p><h2 id="事故复盘"><a href="#事故复盘" class="headerlink" title="事故复盘"></a>事故复盘</h2><p>这是一场典型的”人祸“，来源于某个同事的”调优“，比起追究责任，更重要的是带给我们的启发：</p><ul><li><p>即使是应用启停脚本，也应该作为程序的一部分，纳入测试验证流程和上线检查清单，禁止随意变更；</p></li><li><p>很多时候，默认的就是最好的，矫枉则常常过正。</p></li></ul><h2 id="事故影响"><a href="#事故影响" class="headerlink" title="事故影响"></a>事故影响</h2><p>造成C公司关键业务停摆半小时，生产系统紧急回滚一次。A公司相关负责人连夜编写事故报告一份。</p><h1 id="案例四：YGC耗时过长"><a href="#案例四：YGC耗时过长" class="headerlink" title="案例四：YGC耗时过长"></a>案例四：YGC耗时过长</h1><h2 id="事故背景-1"><a href="#事故背景-1" class="headerlink" title="事故背景"></a>事故背景</h2><p>今年4月份，我们的广告服务在新版本上线后，收到了大量的服务超时告警，通过下面的监控图可以看到：超时量突然大面积增加，1分钟内甚至达到了上千次接口超时。下面详细介绍下该问题的排查过程。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/5423da7c0b241096b32b7b20bfe0bd9372217824.png" alt="image-20251009151826385"></p><h2 id="事故分析-1"><a href="#事故分析-1" class="headerlink" title="事故分析"></a>事故分析</h2><h3 id="检查监控"><a href="#检查监控" class="headerlink" title="检查监控"></a>检查监控</h3><p>收到告警后，我们第一时间查看了监控系统，立马发现了YoungGC耗时过长的异常。我们的程序大概在21点50左右上线，通过下图可以看出：在上线之前，YGC基本几十毫秒内完成，而上线后YGC耗时明显变长，最长甚至达到了3秒多。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/0dd60a1953718b85aca5fa43fb62cb5d3d3c64a5.png" alt="image-20251009151840777"></p><p>由于YGC期间程序会Stop The World，而我们上游系统设置的服务超时时间都在几百毫秒，因此推断：是因为YGC耗时过长引发了服务大面积超时。<br>按照GC问题的常规排查流程，我们立刻摘掉了一个节点，然后通过以下命令dump了堆内存文件用来保留现场。<br>jmap -dump:format&#x3D;b,file&#x3D;heap pid<br>最后对线上服务做了回滚处理，回滚后服务立马恢复了正常，接下来就是长达1天的问题排查和修复过程。</p><h3 id="确认JVM配置"><a href="#确认JVM配置" class="headerlink" title="确认JVM配置"></a>确认JVM配置</h3><p>用下面的命令，我们再次检查了JVM的参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep &quot;applicationName=adsearch&quot;</span><br><span class="line">-Xms4g -Xmx4g -Xmn2g -Xss1024K </span><br><span class="line">-XX:ParallelGCThreads=5 </span><br><span class="line">-XX:+UseConcMarkSweepGC </span><br><span class="line">-XX:+UseParNewGC </span><br><span class="line">-XX:+UseCMSCompactAtFullCollection </span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=80</span><br></pre></td></tr></table></figure><p>可以看到堆内存为4G，新生代和老年代均为2G，新生代采用ParNew收集器。<br>再通过命令 <strong>jmap -heap pid</strong> 查到：新生代的Eden区为1.6G，S0和S1区均为0.2G。<br>本次上线并未修改JVM相关的任何参数，同时我们服务的请求量基本和往常持平。因此猜测：此问题大概率和上线的代码相关。</p><h3 id="检查代码"><a href="#检查代码" class="headerlink" title="检查代码"></a>检查代码</h3><p>再回到YGC的原理来思考这个问题，一次YGC的过程主要包括以下两个步骤：</p><p>1、从GC Root扫描对象，对存活对象进行标注<br>2、将存活对象复制到S1区或者晋升到Old区</p><p>根据下面的监控图可以看出：正常情况下，Survivor区的使用率一直维持在很低的水平（大概30M左右），但是上线后，Survivor区的使用率开始波动，最多的时候快占满0.2G了。而且，YGC耗时和Survivor区的使用率基本成正相关。因此，我们推测：应该是长生命周期的对象越来越多，导致标注和复制过程的耗时增加。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/687ecf4776dda049497eaf723cebc9eefec4b215.png" alt="image-20251009151910165"></p><p>再回到服务的整体表现：上游流量并没有出现明显变化，正常情况下，核心接口的响应时间也基本在200ms以内，YGC的频率大概每8秒进行1次。</p><p>很显然，对于局部变量来说，在每次YGC后就能够马上被回收了。那为什么还会有如此多的对象在YGC后存活下来呢？</p><p>我们进一步将怀疑对象锁定在：程序的全局变量或者类静态变量上。但是diff了本次上线的代码，我们并未发现代码中有引入此类变量。</p><h3 id="对dump的堆内存文件进行分析"><a href="#对dump的堆内存文件进行分析" class="headerlink" title="对dump的堆内存文件进行分析"></a>对dump的堆内存文件进行分析</h3><p>代码排查没有进展后，我们开始从堆内存文件中寻找线索，使用MAT工具导入了第1步dump出来的堆文件后，然后通过Dominator Tree视图查看到了当前堆中的所有大对象。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/43a137057fc71d67df1e4a638d0ab82cd30136e3.png" alt="image-20251009151921350"></p><p>立马发现NewOldMappingService这个类所占的空间很大，通过代码定位到：这个类位于第三方的client包中，由我们公司的商品团队提供，用于实现新旧类目转换（最近商品团队在对类目体系进行改造，为了兼容旧业务，需要进行新旧类目映射）。</p><p>进一步查看代码，发现这个类中存在大量的静态HashMap，用于缓存新旧类目转换时需要用到的各种数据，以减少RPC调用，提高转换性能。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/c6cd37b626eb699c56d7e52c5a79c0559250ee1e.png" alt="image-20251009151932001"></p><p>原本以为，非常接近问题的真相了，但是深入排查发现：这个类的所有静态变量全部在类加载时就初始化完数据了，虽然会占到100多M的内存，但是之后基本不会再新增数据。并且，这个类早在3月份就上线使用了，client包的版本也一直没变过。</p><p>经过上面种种分析，这个类的静态HashMap会一直存活，经过多轮YGC后，最终晋升到老年代中，它不应该是YGC持续耗时过长的原因。因此，我们暂时排除了这个可疑点。</p><h3 id="分析YGC处理Reference的耗时"><a href="#分析YGC处理Reference的耗时" class="headerlink" title="分析YGC处理Reference的耗时"></a>分析YGC处理Reference的耗时</h3><p>团队对于YGC问题的排查经验很少，不知道再往下该如何分析了。基本扫光了网上可查到的所有案例，发现原因集中在这两类上：</p><p>1、对存活对象标注时间过长：比如重载了Object类的Finalize方法，导致标注Final Reference耗时过长；或者String.intern方法使用不当，导致YGC扫描StringTable时间过长。<br>2、长周期对象积累过多：比如本地缓存使用不当，积累了太多存活对象；或者锁竞争严重导致线程阻塞，局部变量的生命周期变长。</p><p>针对第1类问题，可以通过以下参数显示GC处理Reference的耗时-XX:+PrintReferenceGC。添加此参数后，可以看到不同类型的 reference 处理耗时都很短，因此又排除了此项因素。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/9ecf81f51d2ab44de2776ea56de9fae4d0f4db2c.png" alt="image-20251009151943216"></p><h3 id="再回到长周期对象进行分析"><a href="#再回到长周期对象进行分析" class="headerlink" title="再回到长周期对象进行分析"></a>再回到长周期对象进行分析</h3><p>再往后，我们添加了各种GC参数试图寻找线索都没有结果，似乎要黔驴技穷，没有思路了。综合监控和种种分析来看：应该只有长周期对象才会引发我们这个问题。<br>折腾了好几个小时，最终峰回路转，一个小伙伴重新从MAT堆内存中找到了第二个怀疑点。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/2be25637c40c5b2fbab1bd51249092bb63991778.png" alt="image-20251009152000836"></p><p>从上面的截图可以看到：大对象中排在第3位的ConfigService类进入了我们的视野，该类的一个ArrayList变量中竟然包含了270W个对象，而且大部分都是相同的元素。<br>ConfigService这个类在第三方Apollo的包中，不过源代码被公司架构部进行了二次改造，通过代码可以看出：<strong>问题出在了第11行，每次调用getConfig方法时都会往List中添加元素，并且未做去重处理</strong>。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/5ca57283ab1e5257efdaf64438737c6c0f863074.png" alt="image-20251009152011394"></p><p>我们的广告服务在apollo中存储了大量的广告策略配置，而且大部分请求都会调用ConfigService的getConfig方法来获取配置，因此会不断地往静态变量namespaces中添加新对象，从而引发此问题。</p><p>至此，整个问题终于水落石出了。这个BUG是因为架构部在对apollo client包进行定制化开发时不小心引入的，很显然没有经过仔细测试，并且刚好在我们上线前一天发布到了中央仓库中，而公司基础组件库的版本是通过super-pom方式统一维护的，业务无感知。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>为了快速验证YGC耗时过长是因为此问题导致的，我们在一台服务器上直接用旧版本的apollo client 包进行了替换，然后重启了服务，观察了将近20分钟，YGC恢复正常。<br>最后，我们通知架构部修复BUG，重新发布了super-pom，彻底解决了这个问题。<br>通过上面这个案例，可以看到YGC问题其实比较难排查。相比FGC或者OOM，YGC的日志很简单，只知道新生代内存的变化和耗时，同时dump出来的堆内存必须要仔细排查才行。</p><p>另外，如果不清楚YGC的流程，排查起来会更加困难。这里，我对YGC相关的知识点再做下梳理，方便大家更全面的理解YGC。</p><h2 id="YGC的相关知识点总结"><a href="#YGC的相关知识点总结" class="headerlink" title="YGC的相关知识点总结"></a>YGC的相关知识点总结</h2><h3 id="5个问题重新认识新生代"><a href="#5个问题重新认识新生代" class="headerlink" title="5个问题重新认识新生代"></a>5个问题重新认识新生代</h3><p><img src="https://i0.hdslb.com/bfs/openplatform/0646869f14e1952bcb7886e95fca3833227e7098.png" alt="image-20251009152021669"></p><p>YGC 在新生代中进行，首先要清楚新生代的堆结构划分。新生代分为Eden区和两个Survivor区，其中Eden:from:to &#x3D; 8:1:1 (比例可以通过参数 –XX:SurvivorRatio 来设定 )，这是最基本的认识。</p><p><strong>为什么会有新生代？</strong></p><p>如果不分代，所有对象全部在一个区域，每次GC都需要对全堆进行扫描，存在效率问题。分代后，可分别控制回收频率，并采用不同的回收算法，确保GC性能全局最优。</p><p><strong>为什么新生代会采用复制算法？</strong></p><p>新生代的对象朝生夕死，大约90%的新建对象可以被很快回收，复制算法成本低，同时还能保证空间没有碎片。虽然标记整理算法也可以保证没有碎片，但是由于新生代要清理的对象数量很大，将存活的对象整理到待清理对象之前，需要大量的移动操作，时间复杂度比复制算法高。</p><p><strong>为什么新生代需要两个Survivor区？</strong></p><p>为了节省空间考虑，如果采用传统的复制算法，只有一个Survivor区，则Survivor区大小需要等于Eden区大小，此时空间消耗是8 * 2，而两块Survivor可以保持新对象始终在Eden区创建，存活对象在Survivor之间转移即可，空间消耗是8+1+1，明显后者的空间利用率更高。</p><p><strong>新生代的实际可用空间是多少？</strong></p><p>YGC后，总有一块Survivor区是空闲的，因此新生代的可用内存空间是90%。在YGC的log中或者通过 jmap -heap pid 命令查看新生代的空间时，如果发现capacity只有90%，不要觉得奇怪。</p><p><strong>Eden区是如何加速内存分配的？</strong></p><p>HotSpot虚拟机使用了两种技术来加快内存分配。分别是bump-the-pointer和TLAB（Thread Local Allocation Buffers）。</p><p>由于Eden区是连续的，因此bump-the-pointer在对象创建时，只需要检查最后一个对象后面是否有足够的内存即可，从而加快内存分配速度。</p><p>TLAB技术是对于多线程而言的，基于 CAS 的独享线程（Mutator Threads）可以优先将对象分配在 Eden 中的一块内存，因为是 Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个 TLAB 都是一个线程独享的。</p><h3 id="新生代的4种回收器"><a href="#新生代的4种回收器" class="headerlink" title="新生代的4种回收器"></a>新生代的4种回收器</h3><p><img src="https://i0.hdslb.com/bfs/openplatform/74c0af883d201ea5c29522a83964f1b8f87c4ac9.png" alt="image-20251009152033492"></p><p>SerialGC（串行回收器），最古老的一种，单线程执行，适合单CPU场景。</p><p>ParNew（并行回收器），将串行回收器多线程化，适合多CPU场景，需要搭配老年代CMS回收器一起使用。</p><p>ParallelGC（并行回收器），和ParNew不同点在于它关注吞吐量，可设置期望的停顿时间，它在工作时会自动调整堆大小和其他参数。</p><p>G1（Garage-First回收器），JDK 9及以后版本的默认回收器，兼顾新生代和老年代，将堆拆成一系列Region，不要求内存块连续，新生代仍然是并行收集。</p><p>上述回收器均采用复制算法，都是独占式的，执行期间都会Stop The World.</p><h3 id="YGC的触发时机"><a href="#YGC的触发时机" class="headerlink" title="YGC的触发时机"></a>YGC的触发时机</h3><p>当Eden区空间不足时，就会触发YGC。结合新生代对象的内存分配看下详细过程：</p><p>1、新对象会先尝试在栈上分配，如果不行则尝试在TLAB分配，否则再看是否满足大对象条件要在老年代分配，最后才考虑在Eden区申请空间。</p><p>2、如果Eden区没有合适的空间，则触发YGC。</p><p>3、YGC时，对Eden区和From Survivor区的存活对象进行处理，如果满足动态年龄判断的条件或者To Survivor区空间不够则直接进入老年代，如果老年代空间也不够了，则会发生promotion failed，触发老年代的回收。否则将存活对象复制到To Survivor区。</p><p>4、此时Eden区和From Survivor区的剩余对象均为垃圾对象，可直接抹掉回收。</p><p>此外，老年代如果采用的是CMS回收器，为了减少CMS Remark阶段的耗时，也有可能会触发一次YGC，这里不作展开。</p><h3 id="YGC的执行过程"><a href="#YGC的执行过程" class="headerlink" title="YGC的执行过程"></a>YGC的执行过程</h3><p>YGC采用的复制算法，主要分成以下两个步骤：</p><p>1、查找GC Roots，将其引用的对象拷贝到S1区<br>2、递归遍历第1步的对象，拷贝其引用的对象到S1区或者晋升到Old区</p><p>上述整个过程都是需要暂停业务线程的（STW），不过ParNew等新生代回收器可以多线程并行执行，提高处理效率。<br>YGC通过可达性分析算法，从GC Root（可达对象的起点）开始向下搜索，标记出当前存活的对象，那么剩下未被标记的对象就是需要回收的对象。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/c8f660c88c58d76eb43d82946901eca39951e029.png" alt="image-20251009152043568"></p><p>可作为YGC时GC Root的对象包括以下几种：</p><p>1、虚拟机栈中引用的对象<br>2、方法区中静态属性、常量引用的对象<br>3、本地方法栈中引用的对象<br>4、被Synchronized锁持有的对象<br>5、记录当前被加载类的SystemDictionary<br>6、记录字符串常量引用的StringTable<br>7、存在跨代引用的对象<br>8、和GC Root处于同一CardTable的对象</p><p>其中1-3是大家容易想到的，而4-8很容易被忽视，却极有可能是分析YGC问题时的线索入口。</p><p>另外需要注意的是，针对下图中跨代引用的情况，老年代的对象A也必须作为GC Root的一部分，但是如果每次YGC时都去扫描老年代，肯定存在效率问题。在HotSpot JVM，引入卡表（Card Table）来对跨代引用的标记进行加速。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/c9c2eca238cf6ee5b0136ccbbf7a44463d701a57.png" alt="image-20251009152100016"></p><p>Card Table，简单理解是一种空间换时间的思路，因为存在跨代引用的对象大概占比不到1%，因此可将堆空间划分成大小为512字节的卡页，如果卡页中有一个对象存在跨代引用，则可以用1个字节来标识该卡页是dirty状态，卡页状态进一步通过写屏障技术进行维护。</p><p>遍历完GC Roots后，便能够找出第一批存活的对象，然后将其拷贝到S1区。接下来，就是一个递归查找和拷贝存活对象的过程。</p><p>S1区为了方便维护内存区域，引入了两个指针变量：_saved_mark_word和_top，其中_saved_mark_word表示当前遍历对象的位置，_top表示当前可分配内存的位置，很显然，_saved_mark_word到_top之间的对象都是已拷贝但未扫描的对象。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/fda76ace4388f57324a1cbdad9646a62cbddb096.png" alt="image-20251009152108967"></p><p>贝到S1区，_top也会往前移动，直到_saved_mark_word追上_top，说明S1区所有对象都已经遍历完成。</p><p>有一个细节点需要注意的是：拷贝对象的目标空间不一定是S1区，也可能是老年代。如果一个对象的年龄（经历的YGC次数）满足动态年龄判定条件便直接晋升到老年代中。对象的年龄保存在Java对象头的mark word数据结构中（如果大家对Java并发锁熟悉，肯定了解这个数据结构，不熟悉的建议查阅资料了解下，这里不做展开）。</p><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>这篇文章通过线上案例分析并结合原理讲解，详细介绍了YGC的相关知识。从YGC实战角度出发，再简单总结一下：<br>1、首先要清楚YGC的执行原理，比如年轻代的堆内存结构、Eden区的内存分配机制、GC Roots扫描、对象拷贝过程等。<br>2、YGC的核心步骤是标注和复制，绝部分YGC问题都集中在这两步，因此可以结合YGC日志和堆内存变化情况逐一排查，同时dump的堆内存文件需要仔细分析。</p><h1 id="案例五：动态对象年龄判定机制引起STW"><a href="#案例五：动态对象年龄判定机制引起STW" class="headerlink" title="案例五：动态对象年龄判定机制引起STW"></a>案例五：动态对象年龄判定机制引起STW</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>公司某规则引擎系统，在每次发版启动会手动预热，预热完成当流量切进来之后会偶发的出现一次长达1-2秒的Young GC（流量并不大，并且LB下的每个节点都会出现该情况）</p><p>在这次长暂停之后，每一次的年轻代GC暂停时间又都恢复在20-100ms以内</p><p>2秒虽然看起来不算长吧，但规则引擎每次执行也才几毫秒，这谁能忍？而且这玩意一旦超时，出单可能也跟着超时失败！</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在分析该系统GC日志后发现，2s暂停发生在Young GC阶段，而且每次发生长暂停的Young GC都会伴随着新生代对象的晋升(Promotion)</p><p><strong>启动后第一次年轻代GC日志</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023-04-23T16:28:31.108</span><span class="string">+0800:</span> [<span class="string">GC2023-04-23T16:28:31.108+0800:</span> [<span class="string">ParNew2023-04-23T16:28:31.229+0800:</span> [<span class="string">SoftReference</span>, <span class="number">0</span> <span class="string">refs</span>, <span class="number">0.0000950</span> <span class="string">secs</span>]<span class="number">2023-04-23T16:28:31.229</span><span class="string">+0800:</span> [<span class="string">WeakReference</span>, <span class="number">1156 </span><span class="string">refs</span>, <span class="number">0.0001040</span> <span class="string">secs</span>]<span class="number">2023-04-23T16:28:31.229</span><span class="string">+0800:</span> [<span class="string">FinalReference</span>, <span class="number">10410</span> <span class="string">refs</span>, <span class="number">0.0103720</span> <span class="string">secs</span>]<span class="number">2023-04-23T16:28:31.240</span><span class="string">+0800:</span> [<span class="string">PhantomReference</span>, <span class="number">286</span> <span class="string">refs</span>, <span class="number">2</span> <span class="string">refs</span>, <span class="number">0.0129420</span> <span class="string">secs</span>]<span class="number">2023-04-23T16:28:31.253</span><span class="string">+0800:</span> [<span class="string">JNI</span> <span class="string">Weak</span> <span class="string">Reference</span>, <span class="number">0.0000000</span> <span class="string">secs</span>]</span><br><span class="line"><span class="string">Desired</span> <span class="string">survivor</span> <span class="string">size</span> <span class="number">214728704</span> <span class="string">bytes</span>, <span class="string">new</span> <span class="string">threshold</span> <span class="number">1</span> <span class="string">(max</span> <span class="number">15</span><span class="string">)</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">age   1:</span>  <span class="number">315529928</span> <span class="string">bytes</span>,  <span class="number">315529928</span> <span class="string">total</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">age   2:</span>   <span class="number">40956656</span> <span class="string">bytes</span>,  <span class="number">356486584</span> <span class="string">total</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">age   3:</span>    <span class="number">8408040</span> <span class="string">bytes</span>,  <span class="number">364894624</span> <span class="string">total</span></span><br><span class="line"><span class="string">:</span> <span class="string">3544342K-&gt;374555K(3774912K)</span>, <span class="number">0.1444710</span> <span class="string">secs</span>] <span class="string">3544342K-&gt;374555K(10066368K)</span>, <span class="number">0.1446290</span> <span class="string">secs</span>] [<span class="attr">Times:</span> <span class="string">user=1.46</span> <span class="string">sys=0.09</span>, <span class="string">real=0.15</span> <span class="string">secs</span>] </span><br></pre></td></tr></table></figure><p><strong>长暂停年轻代GC日志</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023-04-23T17:18:28.514</span><span class="string">+0800:</span> [<span class="string">GC2023-04-23T17:18:28.514+0800:</span> [<span class="string">ParNew2023-04-23T17:18:29.975+0800:</span> [<span class="string">SoftReference</span>, <span class="number">0</span> <span class="string">refs</span>, <span class="number">0.0000660</span> <span class="string">secs</span>]<span class="number">2023-04-23T17:18:29.975</span><span class="string">+0800:</span> [<span class="string">WeakReference</span>, <span class="number">1224 </span><span class="string">refs</span>, <span class="number">0.0001400</span> <span class="string">secs</span>]<span class="number">2023-04-23T17:18:29.975</span><span class="string">+0800:</span> [<span class="string">FinalReference</span>, <span class="number">8898 </span><span class="string">refs</span>, <span class="number">0.0149670</span> <span class="string">secs</span>]<span class="number">2023-04-23T17:18:29.990</span><span class="string">+0800:</span> [<span class="string">PhantomReference</span>, <span class="number">600</span> <span class="string">refs</span>, <span class="number">1</span> <span class="string">refs</span>, <span class="number">0.0344300</span> <span class="string">secs</span>]<span class="number">2023-04-23T17:18:30.025</span><span class="string">+0800:</span> [<span class="string">JNI</span> <span class="string">Weak</span> <span class="string">Reference</span>, <span class="number">0.0000210</span> <span class="string">secs</span>]</span><br><span class="line"><span class="string">Desired</span> <span class="string">survivor</span> <span class="string">size</span> <span class="number">214728704</span> <span class="string">bytes</span>, <span class="string">new</span> <span class="string">threshold</span> <span class="number">15</span> <span class="string">(max</span> <span class="number">15</span><span class="string">)</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">age   1:</span>   <span class="number">79203576</span> <span class="string">bytes</span>,   <span class="number">79203576</span> <span class="string">total</span></span><br><span class="line"><span class="string">:</span> <span class="string">3730075K-&gt;304371K(3774912K)</span>, <span class="number">1.5114000</span> <span class="string">secs</span>] <span class="string">3730075K-&gt;676858K(10066368K)</span>, <span class="number">1.5114870</span> <span class="string">secs</span>] [<span class="attr">Times:</span> <span class="string">user=6.32</span> <span class="string">sys=0.58</span>, <span class="string">real=1.51</span> <span class="string">secs</span>] </span><br></pre></td></tr></table></figure><p><strong>从这个长暂停的GC日志来看，是发生了晋升的，在Young GC后，有363M+的对象晋升到了老年代，这个晋升操作因该就是耗时原因（ps: 检查过safepoint原因，不存在异常）</strong></p><p>由于日志参数中没有配置<code>-XX:+PrintHeapAtGC</code>参数，这里是手动计算的晋升大小：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">年轻代年轻变化</span> <span class="bullet">-</span> <span class="string">全堆容量变化</span> <span class="string">=</span> <span class="string">晋升大小</span></span><br><span class="line"><span class="string">(304371K</span> <span class="bullet">-</span> <span class="string">3730075K)</span> <span class="bullet">-</span> <span class="string">(676858K</span> <span class="bullet">-</span> <span class="string">3730075K)</span> <span class="string">=</span> <span class="string">372487K(363M)</span></span><br></pre></td></tr></table></figure><p><strong>下一次年轻代GC日志</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023-04-23T17:23:39.749</span><span class="string">+0800:</span> [<span class="string">GC2023-04-23T17:23:39.749+0800:</span> [<span class="string">ParNew2023-04-23T17:23:39.774+0800:</span> [<span class="string">SoftReference</span>, <span class="number">0</span> <span class="string">refs</span>, <span class="number">0.0000500</span> <span class="string">secs</span>]<span class="number">2023-04-23T17:23:39.774</span><span class="string">+0800:</span> [<span class="string">WeakReference</span>, <span class="number">3165 </span><span class="string">refs</span>, <span class="number">0.0002720</span> <span class="string">secs</span>]<span class="number">2023-04-23T17:23:39.774</span><span class="string">+0800:</span> [<span class="string">FinalReference</span>, <span class="number">3520 </span><span class="string">refs</span>, <span class="number">0.0021520</span> <span class="string">secs</span>]<span class="number">2023-04-23T17:23:39.776</span><span class="string">+0800:</span> [<span class="string">PhantomReference</span>, <span class="number">150</span> <span class="string">refs</span>, <span class="number">1</span> <span class="string">refs</span>, <span class="number">0.0051910</span> <span class="string">secs</span>]<span class="number">2023-04-23T17:23:39.782</span><span class="string">+0800:</span> [<span class="string">JNI</span> <span class="string">Weak</span> <span class="string">Reference</span>, <span class="number">0.0000100</span> <span class="string">secs</span>]</span><br><span class="line"><span class="string">Desired</span> <span class="string">survivor</span> <span class="string">size</span> <span class="number">214728704</span> <span class="string">bytes</span>, <span class="string">new</span> <span class="string">threshold</span> <span class="number">15</span> <span class="string">(max</span> <span class="number">15</span><span class="string">)</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">age   1:</span>   <span class="number">17076040</span> <span class="string">bytes</span>,   <span class="number">17076040</span> <span class="string">total</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">age   2:</span>   <span class="number">40832336</span> <span class="string">bytes</span>,   <span class="number">57908376</span> <span class="string">total</span></span><br><span class="line"><span class="string">:</span> <span class="string">3659891K-&gt;90428K(3774912K)</span>, <span class="number">0.0321300</span> <span class="string">secs</span>] <span class="string">4032378K-&gt;462914K(10066368K)</span>, <span class="number">0.0322210</span> <span class="string">secs</span>] [<span class="attr">Times:</span> <span class="string">user=0.30</span> <span class="string">sys=0.00</span>, <span class="string">real=0.03</span> <span class="string">secs</span>] </span><br></pre></td></tr></table></figure><p>乍一看好像没什么问题，仔细想想还是发现了不对劲，为什么程序刚启动第二次gc就发生了晋升？</p><p>推测这里应该是动态年龄判定导致的，GC中晋升年龄阈值并不是固定的15，而是jvm每次gc后动态计算的</p><h3 id="年轻代晋升机制"><a href="#年轻代晋升机制" class="headerlink" title="年轻代晋升机制"></a>年轻代晋升机制</h3><p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</p><p>《深入理解Java虚拟机》一书中提到，对象晋升年龄的阈值是动态判定的。</p><p>不过经查阅其他资料和验证后，发现此处和《深入理解Java虚拟机》解释的有些出入</p><p><strong>其实就是按年龄给对象分组，取total（累加值，小于等与当前年龄的对象总大小）最大的年龄分组，如果该分组的total大于survivor的一半，就将晋升年龄阈值更新为该分组的年龄</strong></p><p><strong>注意：不是是超过survivor一半就晋升，超过survivor一半只会重新设置晋升阈值（threshold），在下一次GC才会使用该新阈值</strong></p><p>从上面第一次的GC日志也可以证明这个结论，在这次GC中全堆的内存变化和年轻代内存变化是相等的，所以并没有发生对象的晋升</p><p>就像上面的日志中，第一次GC只是将threshold设置为1，因为此时survivor一半为214728704 bytes，而年龄为1的对象总和有315529928 bytes，超过了Desired survivor size，所以在本次GC后将threshold设置为年龄为1的对象年龄1</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">这里更新了对象晋升年龄阈值为1</span></span><br><span class="line"><span class="string">Desired</span> <span class="string">survivor</span> <span class="string">size</span> <span class="number">214728704</span> <span class="string">bytes,</span> <span class="string">new</span> <span class="string">threshold</span> <span class="number">1</span> <span class="string">(max</span> <span class="number">15</span><span class="string">)</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">age   1:</span>  <span class="number">315529928</span> <span class="string">bytes,</span>  <span class="number">315529928</span> <span class="string">total</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">age   2:</span>   <span class="number">40956656</span> <span class="string">bytes,</span>  <span class="number">356486584</span> <span class="string">total</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">age   3:</span>    <span class="number">8408040</span> <span class="string">bytes,</span>  <span class="number">364894624</span> <span class="string">total</span></span><br></pre></td></tr></table></figure><p>这里顺便解释下这个年龄分布的输出内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">age   1:</span>  <span class="number">315529928</span> <span class="string">bytes,</span>  <span class="number">315529928</span> <span class="string">total</span> </span><br></pre></td></tr></table></figure><p><code>- age 1</code>表示年龄为1的对象分组，<code>315529928 bytes</code>表示年龄为1的对象占用内存大小</p><p><code>315529928 total</code>这个是一个累加值，表示小于等于当前分组年龄的对象总大小。先把对象按年龄分组，age 1的分组total为age 1总大小（前面的xxx bytes），age 2的分组total为<code>age 1 + age 2</code>总大小，age n的分组total为<code>age 1 + age 2 + ... +age n</code>的总大小，累加规则如下图所示</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d4920d4bcfd40bb9b11289af232c2b1~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.avis#?w=1916&h=632&s=75385&e=png&b=fdfdfd" alt="null"></p><p>当total最大的分组的total值超过了survivor&#x2F;2时，就会更新晋升阈值</p><p>在第二次年轻代GC“长暂停年轻代GC日志”中，由于新的晋升年龄阈值为1，所以那些经历了一次GC并存活并且现在仍然可达（reachable）的对象们就会发生晋升了</p><p><strong>由于此次GC发生了363M的对象晋升，所以导致了长暂停</strong></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>JVM中这个“动态对象年龄判定”真的合理吗？</p><p>个人认为机制是好的，可以更好的适应不同程序的内存状况，但不是任何场景都适合，比如在本文中这个刚启动不就GC的场景下就会有问题</p><p>因为在程序刚启动时，大多数对象年龄都是0或者1，很容易出现年龄为1的大量存活对象；在这个“动态对象年龄判定”机制下，就会导致新的晋升阈值被设置为1，导致这些不该晋升的对象发生了晋升</p><p>比如程序在初始化，正在加载各种资源时发生了Young GC，加载逻辑还在执行中，很多新建的对象年龄在这次GC时还是可达的（reachable）</p><p>经历了这次GC后，这些对象年龄更新为1，但是由于“动态对象年龄判定”机制的影响，晋升年龄阈值更新为了“最大的对象年龄分组”的年龄，也就是这批刚经历了一次GC的对象们</p><p>在这次GC之后不久，资源初始化完成了，涉及的相关对象有很可能不可达了，但是由于刚才晋升年龄阈值被更新为了1，在下一次正常的Young GC这批年龄为1的对象会直接发生晋升，提前或者说错误的发生了晋升</p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><p>经查阅文档、资料，发现“动态年龄判定”这个机制并不能禁用，所以如果想解决这个问题，只有靠“绕过”这个计算规则了</p><p>动态年龄的判定，是根据Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半来判定的，那么根据这个机制解决也很简单</p><p>由于我们足够了解自己的系统，清楚的知道加载资源所需的大概内存，完全可以设定一个大于这些暂时可达的对象总和的数值来作为survivor的容量</p><p><strong>比如上面的日志中，第一次GC后年龄为1的对象有315529928 Bytes(300M)，Desired survivor size为（survivor size &#x2F;2）214728704 bytes(204M)，那么survivor就可以设置为600M以上。</strong></p><p><strong>不过为了稳妥，还是将survivor调到800M，这样desired survivor size就是400M左右，在第一次Young GC后，就不会因年龄为1的对象总和超过了desired survivor size而导致晋升年龄阈值的更新了，从而也就不会有提前&#x2F;错误晋升而导致的GC长暂停问题</strong></p><p>survivor不可以直接指定大小，不过可以通过-XX:SurvivorRatio这种调节比例的方式来调节survivor大小</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">-XX:SurvivorRatio=8</span></span><br></pre></td></tr></table></figure><p>表示两个Survivor和Edgen区的比，8表示两个Survivor:Eden&#x3D;2:8，即一个Survivor占新生代的1&#x2F;10。</p><p>好了，现在直接通过比例，强行给 Survivor 调大</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">-XX:SurvivorRatio=3</span></span><br></pre></td></tr></table></figure><p>调整之后，Survivor 总占比为 40%，大小为 1717829632 Bytes，单个 S0&#x2F;S1的一半也有 10% - 429457408 Bytes，远超 age&#x3D;1 的分组总大小 315529928 Bytes。</p><p>这样一来， Young GC 后复制到 Survivor 的对象（最大年龄分组）占总比例的大小就不会到 50% 了，也就不会把 MaxTenuringThreshold 更新为 1 ，自然就解决了这个“乱晋升”的问题</p><p>改完收工，再次发版手动预热后，再也没有切量后长暂停的问题了，Young GC稳定在 30-100ms，成功解决！</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> MAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转AI应用</title>
      <link href="/2025/09/22/%E7%8E%A9%E8%BD%ACAI%E5%BA%94%E7%94%A8/"/>
      <url>/2025/09/22/%E7%8E%A9%E8%BD%ACAI%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="大模型"><a href="#大模型" class="headerlink" title="大模型"></a>大模型</h1><p>以下是一些常用大模型的特性以及区别：</p><table><thead><tr><th>厂商&#x2F;系列</th><th>代表模型</th><th>核心特点</th><th>典型应用场景</th><th>开源&#x2F;闭源</th><th>大致成本</th></tr></thead><tbody><tr><td><strong>OpenAI</strong></td><td>GPT-3.5</td><td>成本（计算／资源）较低；能做一般写作、代码辅助、总结、翻译等任务；</td><td>对话式任务，对一般任务（写作、聊天、翻译、简单问题）非常合适</td><td>闭源</td><td>输入$0.5&#x2F;百万tokens，输出$1.5&#x2F;百万tokens</td></tr><tr><td></td><td>GPT-4o &#x2F; GPT-4.1-series</td><td>通用性强，多模态（文本、图像、音频），生态整合好，引入更大的上下文支持</td><td>内容创作、复杂推理、代码生成、多模态分析</td><td>闭源</td><td>GPT-4.1 API: 输入$2&#x2F;百万tokens, 输出$8&#x2F;百万tokens</td></tr><tr><td></td><td>GPT-5</td><td><strong>上下文长度</strong>：API 上输入 + 输出合起来可以 ~400K tokens 或更多，更好地处理非常长对话、文档、或混合任务（例如图像＋文本长内容）；<strong>逻辑推理</strong>：在推理深度、多步逻辑、工具调用／agent 工作流中是目前顶尖版本；被设计为“知道什么时候 fast 回答、什么时候 think 更久”的。<strong>多模态感知能力</strong>：多模态能力更成熟；不仅处理图像 + 文本，也能够把这些模态的信息整合进工具调用、推理等任务中。<strong>工具使用</strong>：GPT-5 在 Agent &#x2F;复杂任务自动化 &#x2F;工具链调用 &#x2F;长流程任务中被设计为更可靠的支持者。</td><td>企业／团队使用／复杂 agent &#x2F; 多工具调用流程</td><td>闭源</td><td>GPT-5 是最新旗舰，默认模型；Plus／Pro／Enterprise 等订阅得到不同等级访问；API 用户也可以调用多个变体；有“thinking 模式”等可选设定以匹配任务需求。</td></tr><tr><td><strong>Anthropic</strong></td><td>Claude 3.5 (Sonnet)</td><td>在多数普通任务／生成任务／基础编程任务中表现稳定。能较好处理图像 + 文本，写作、摘要、对话类任务表现不错。支持的上下文窗口已经很大（在 Claude 平台／Bedrock 等为 200,000 tokens 的默认窗口）对文档 &#x2F;对话历史处理不错。</td><td>简单写作／对话／摘要／内容生成，不需要特别复杂的逻辑链／大量上下文</td><td>闭源</td><td>输入$3&#x2F;百万tokens, 输出$15&#x2F;百万tokens</td></tr><tr><td></td><td>Claude 3.7 (Sonnet)</td><td><strong>安全稳健</strong>，<strong>超长上下文</strong>（200K tokens），<strong>混合推理模式</strong>（快思慢想），代码能力强。对复杂推理任务、中间解释 (“step-by-step thinking”) 更强；对指令的遵守 (“follow instructions”) 在多数情况下提升；写作／创造性任务中语境构建更丰富。</td><td>企业级应用、长文档处理、安全敏感型任务</td><td>闭源</td><td>输入$3&#x2F;百万tokens, 输出$15&#x2F;百万tokens</td></tr><tr><td></td><td>Claude 4</td><td>在 agent 工作流 &#x2F;自动化任务中表现更强；在复杂编码任务、长链推理任务（需要多个步骤／需要处理大量上下文／计划任务等）中优势明显。Sonnet 4 最新版本（及 Opus 4）支持 <strong>1,000,000 tokens（即百万 token）</strong> 的上下文窗口（至少 Sonnet 4 有 preview &#x2F;扩展支持）。</td><td>高复杂／长期项目／大型代码库／需要工具调用／代理操作／大型文件 &#x2F; 上下文／精准度高／安全性要求高</td><td>闭源</td><td>输入$3&#x2F;百万tokens, 输出$15&#x2F;百万tokens</td></tr><tr><td><strong>DeepSeek (开源)</strong></td><td>DeepSeek-R1 (系列)</td><td><strong>逻辑推理专家</strong>，专为数学证明、代码生成、金融分析等复杂任务优化。它基于强化学习（RL）训练，能展示“思维链”（Chain-of-Thought），让推理过程更透明。</td><td><strong>科研与数学</strong>（解数学题、公式推导）、<strong>金融分析</strong>（生成复杂SQL查询、策略优化）、<strong>算法开发</strong>（优化代码逻辑、调试）、<strong>教育辅助</strong>（分步讲解解题思路）</td><td>部分开源</td><td>较小模型可本地免费部署；671B通过API调用</td></tr><tr><td></td><td>DeepSeek-V3 (系列)</td><td><strong>全能型选手</strong>，擅长<a href="https://cloud.tencent.com/product/nlp?from=20067&from_column=20067">自然语言处理</a>（NLP）任务，如文本生成、多语言翻译、智能客服等。计算效率极高，适合大规模应用。</td><td><strong>内容创作</strong>（写文章、报告、广告文案）、<strong>智能客服</strong>（快速响应、多轮对话）、<strong>多语言翻译</strong>（支持高质量中英互译）、<strong>代码辅助</strong>（补全、注释生成）</td><td>闭源</td><td>API成本低（输入$0.14&#x2F;百万tokens），适合企业大规模部署。</td></tr></tbody></table><blockquote><p>小模型与大模型的区别在哪？为什么现在AI大模型这么流行？</p></blockquote><p>小模型／专门模型：通常训练／设计是为某一类任务或某一个业务场景（比如推荐系统、CTR预测、分类、标签预测）。当任务变了或者场景变复杂，这些模型可能性能下降严重。而且小模型往往依赖有限特征（用户行为、特定历史、有限长度的输入／窗口），不能处理非常长对话／非常多上下文。</p><p>大模型（LLMs）：LLMs 可以处理大上下文、对话历史、复杂提示（prompt）／prompt engineering，可以做推理链、中间思考、解释性输出。甚至可以去做RAG（外部知识库检索增强）、MCP（连接外部工具使用），因为现在都是基于Agent去做的，也可以直接通过写提示词的方式用自然语言去调优。</p><h1 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a>RAG</h1><p>RAG<strong>（Retrieval Augmented Generation，检索增强生成）</strong>, 其核心在于将 LLMs 与外部知识库（如维基百科或企业内部文档）连接，使得模型在生成响应前，能够先从这些知识库中检索并使用最相关的信息。这项使开发者能够在无需为每个特定任务重新训练或微调大模型的情况下，通过连接外部知识库和文档，为模型注入额外的非参数化知识，从而显著提升其在专业领域的能力和回答精度。</p><p>RAG 系统的搭建与运维，需依托于一套复杂的检索机制，该机制依赖向量搜索及嵌入技术，以确保 LLM 能够高效获取最为契合的信息资源。</p><p>RAG是一种将信息检索与生成模型相结合的混合架构。首先，检索器从外部知识库或文档集中获取与用户查询相关的内容片段；然后，生成器基于这些检索到的内容生成自然语言输出，确保生成的内容既信息丰富，又具备高度的相关性和准确性。</p><p>一张图看下RAG的基础原理：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/3c53071211311c4f98dabdf7faac64f1f86e7dcb.png"></p><h2 id="RAG-标准技术流程"><a href="#RAG-标准技术流程" class="headerlink" title="RAG 标准技术流程"></a>RAG 标准技术流程</h2><p>首先看下这张来自于极客时间实战专栏：RAG 快速开发实战中的分享：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/175ece8ae90127050ad7c5c523bb508406af5e48.png" alt="image-20250922135345984"></p><p>RAG 标准流程由索引（Indexing）、检索（Retriever）和生成（Generation）三个核心阶段组成。</p><p><strong>索引阶段</strong>，通过处理多种来源多种格式的文档提取其中文本，将其切分为标准长度的文本块（chunk），并进行嵌入向量化（embedding），向量存储在向量数据库（vector database）中。</p><p><strong>检索阶段</strong>，用户输入的查询（query）被转化为向量表示，通过相似度匹配从向量数据库中检索出最相关的文本块</p><p><strong>最后生成阶段</strong>，检索到的相关文本与原始查询共同构成提示词（Prompt），输入大语言模型（LLM），生成精确且具备上下文关联的回答。通过这一流程，RAG实现了检索与生成的有机结合，显著提升了 LLM 在领域任务中的准确性和实时性。</p><p>再来看看向量的概念和语义搜索。</p><p>比如说你有两个水果，我们可以把2个水果通过不同的维度计算出来一个向量的值，形成一个向量的数组，例如：</p><p>苹果：[红色: 0.92, 甜度: 0.83, 圆形: 0.78]</p><p>草莓：[红色: 0.85, 甜度: 0.75, 圆形: 0.62]</p><p>虽然苹果和草莓是不同的水果，但它们的向量很接近。这表明它们有相似的特性，比如颜色和甜度。但如果你把“老虎”表示成向量，则和苹果的向量就不接近。通过比较向量的“距离”，计算机能快速判断哪些事物是相关的。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/2b30a18a157ba09bd690bb4f47bab1c9fc6f38b1.png" alt="image-20250922135546319"></p><p>理解了向量后，我们也许要知道在RAG中，一个重要的搜索方法就是基于向量的语义相似性搜索：</p><p>语义检索是通过向量距离，计算用户问题与知识库内容的距离，从而得出“相似度”，当然这并不是语文上的相似度，而是数学上的。</p><h2 id="RAG-优化手段"><a href="#RAG-优化手段" class="headerlink" title="RAG 优化手段"></a>RAG 优化手段</h2><h3 id="知识采集"><a href="#知识采集" class="headerlink" title="知识采集"></a>知识采集</h3><p>RAG的使用有一个关键起点，就是知识库的搭建。而知识库搭建又涉及到一个最原始最通用的方式：数据导入。在企业实际场景中，数据导入的形式五花八门，远不止网页内容。我们需要将各种<strong>结构化数据</strong>和<strong>非结构化数据</strong>导入到 AI 的知识库中，才能为后续问答系统提供高质量的“知识地基”。</p><blockquote><p>什么是结构化数据与非结构化数据？</p></blockquote><p><strong>非结构化数据</strong>：指那些没有固定格式、不可按行列直接组织的数据，例如：</p><ul><li><p>PDF、Word、PPT 等文档</p></li><li><p>云文档</p></li><li><p>图片</p></li><li><p>网页内容等</p></li></ul><p><strong>结构化数据</strong>：指按预定义结构组织的数据，通常以行和列构成，例如：</p><ul><li>数据库中的表格数据</li></ul><p>因此，企业在构建 AI 系统时，还需要掌握从不同来源导入数据的能力，包括文本、表格、图片、网页等内容，为 RAG 系统提供多样、真实的数据支撑。</p><p>一个PDF转Markdown的软件：MinerU，这个软件已经在很多公司的生产环境使用。</p><p>企业中除了数据库的知识数据外，还有大量的企业对外的产品文档、帮助手册，而这些文件也需要存储到AI的知识库中。MinurU能够非常较大程度的解析各种PDF文件为Markdown格式，同时识别里面的各种元素。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/ffa3692c081c4ab33add66320b2aede0e5f1c79e.png" alt="image-20250922140535592"></p><h3 id="内容分块"><a href="#内容分块" class="headerlink" title="内容分块"></a>内容分块</h3><p>在 RAG 系统中，文档是需要分割成文本块再进行向量嵌入的。分块太大，可能包含太多不相关的信息，从而降低了检索的准确性。相反，分块太小可能会丢失必要的上下文信息，导致生成的回应缺乏连贯性或深度。</p><p>分块方式的选择：</p><ul><li><strong>固定大小的分块</strong>：直接设定块中的字数，并选择块之间是否重复内容。通常我们会保持块之间的一些重叠，以确保语义上下文不会在块之间丢失。</li><li><strong>内容分块</strong>：根据文档具体内容分块，例如根据标点符号（如句号）分割。或者直接使用更高级的NLTK或者spaCy库提供的句子分割功能。</li><li><strong>递归分块</strong>：在大多数情况下推荐的方法。其通过重复地应用分块规则来递归地分解文本。例如在langchain中会先通过段落换行符（<code>\n\n</code>）进行分割。然后检查这些块地大小。如果大小不超过一定阈值，则该块被保留。对于大小超过标准的块，使用单换行符（<code>\n</code>）再次分割。以此类推，不断根据块更新更小的分块规则（如空格、句号）。这种方法可以灵活地调整块的大小。例如，对于文本中的密集信息部分，可能需要更细的分割来捕捉细节；而对于信息较少的部分，则可以使用更大的块。而它的挑战在于，需要制定精细的规则来决定何时和如何分割文本。</li><li><strong>从小到大分块</strong>：更直接的解决方案是把同一文档进行从大到小所有尺寸的分割，然后把不同大小的分块全部存进向量数据库，并保存每个分块的上下级关系，进行递归搜索。但是可想而知，我们需要存储大量重复内容，这种方案的缺点就是需要更大的储存空间。</li><li><strong>特殊结构分块</strong>：针对特定结构化内容的专门分割器。这些分割器特别设计来处理这些类型的文档，以确保正确保留和理解其结构。langchain提供的特殊分割器包括：Markdown文件，Latex文件，以及各种主流代码语言分割器。</li></ul><blockquote><p>上述方法中无一例外最终都需要设定一个参数——块的大小，那么我们应该如何选择呢？</p></blockquote><p>首先不同的嵌入模型有其最佳输入大小。比如openai和text-embedding-ada-002模型在256或512大小的块上效果更好。其次，文档的类型和用户查询的长度及复杂性也是决定分块大小的重要因素。处理长篇文章或书籍时，较大分块有助于保留更多的上下文和主题连贯性；而对于社交媒体帖子，较小的分块更适合捕捉每个帖子的精确语义。实际场景中，可能需要不断实验调整，在一些测试中，128大小的分块往往是最佳选择，在无从下手时，可以从这个大小作为起点进行测试。</p><h3 id="嵌入模型"><a href="#嵌入模型" class="headerlink" title="嵌入模型"></a>嵌入模型</h3><p>嵌入模型可以帮我们把文本转换成向量，显然不同的嵌入模型带来的效果也不尽相同。比如Word2Vec模型有一些局限性，其生成的词向量是静态的。一旦模型训练完成，每个词的向量就是固定不变的，但如果存在一词多义的情况，可能就会导致问题。相比之下，引入自注意力机制的模型，比如BERT，能够根据上下文动态地调整词义，使得同一个词在不同语境下有不同的向量表示。</p><p>在这种情况下，我们推荐参考Hugging Face推出的嵌入模型排行榜MTEB（<a href="https://huggingface.co/spaces/mteb/leaderboard">huggingface.co</a>），同时要注意并非所有的嵌入模型都支持中文，因此在选择时应查阅模型说明。</p><h3 id="重排模型"><a href="#重排模型" class="headerlink" title="重排模型"></a>重排模型</h3><p>重排模型通过对初始检索结果进行更深入的相关性评估排序，确保最终展示给用户的结果更加符合其查询意图。这一过程通常由深度学习模型实现，如Cohere模型。这些模型会考虑更多的特征，比如查询意图、词汇的多重语义、用户的历史行为和上下文信息等。</p><p>在实践中，使用RAG构建系统时都应考虑重排方法，以评估其是否能够提高系统性能。</p><h3 id="指代消解"><a href="#指代消解" class="headerlink" title="指代消解"></a>指代消解</h3><blockquote><p><strong>什么是指代消解？</strong></p></blockquote><p>简单来说，<strong>指代消解</strong>就是让机器学会理解“它”“他”“这里”这种模糊代词到底指的是什么。在我们日常的对话中，代词就像个调皮的小孩，躲在句子里不肯说出“我是谁”，而机器如果不能正确理解这些代词，就很容易答非所问。</p><p>尤其是在 RAG（Retrieval Augmented Generation）系统中，能否精准“还原”代词背后的真实含义，直接影响到知识的检索效果和准确率。</p><p>在RAG系统中，信息的准确检索和生成依赖于对上下文的深刻理解。如果系统不能正确解析指代关系，就会出现信息混淆，降低召回率和准确性。例如，在检索知识库时，错误地理解“它”可能导致系统返回与用户真正意图不匹配的答案。因此，指代消解有助于：</p><ol><li>提升信息检索的精确度</li><li>增强生成回答的逻辑连贯性</li><li>改善用户体验</li></ol><p>指代消解在处理含有复杂指代关系的文本时尤为关键。常见应用场景包括：</p><ol><li>自然语言问答系统</li><li>对话机器人</li><li>机器翻译</li><li>信息抽取与文本摘要</li></ol><p>当文本中出现多次代词指向同一对象或者含糊不清的指代时，指代消解的作用就显得格外重要。</p><p>指代消解的实现通常涉及以下几个步骤：</p><ol><li><strong>候选实体识别</strong>：梳理用户可能常见的问题，并识别出文本中所有可能的指代对象。</li><li><strong>特征提取</strong>：利用上下文历史聊天记录信息、语义关系等提取有助于判断指代关系的特征。</li><li><strong>模型判定</strong>：基于AI大模型，根据当前用户问题和历史聊天记录，从而确定最佳的指代关系。</li><li><strong>后处理与评估</strong>：持续的对返回结果结果进行优化和校正，确保整体准确性。</li></ol><h3 id="查询重写"><a href="#查询重写" class="headerlink" title="查询重写"></a>查询重写</h3><blockquote><p><strong>什么是查询重写？</strong></p></blockquote><p><strong>查询重写</strong>（Query Rewriting），是将用户原始的提问，转换为一个更能表达其真实意图的查询方式。它的目标是重新表述问题，以更高的匹配度找到相关文档。</p><p>这个能力在面对模糊、歧义或用户表达方式与知识库中的文档术语不一致的情况下，尤其重要。比如用户问：“它开放吗？”如果能自动重写为“长城这个景点现在开放吗，可以去参观吗？”那么检索结果的范围和语义就丰富了，返回的结果显然就更准确了。</p><blockquote><p><strong>为什么需要查询重写</strong></p></blockquote><p>• 用户的提问通常比较口语化，直接用问题检索效果不佳</p><p>• 减少查询和文档之间的语义差异</p><p>• 多轮对话中的检索，需要指代消解</p><p>查询重写策略：</p><ul><li><strong>子问题查询</strong>，生成相关子问题，补充query的细节：利用LLM的分析能力，识别出需要解答哪些子问题才能全面回答主问题。将这些子问题同时发送到检索系统（如向量数据库或搜索引擎）中，寻找与每个子问题最相关的文档片段。将检索到的所有与子问题相关的信息提供给LLM，指令它基于这些证据进行梳理、整合，最终生成一个连贯、全面的答案。</li><li><strong>假设文档（HyDE）</strong>：向LLM发送指令，如“请生成一个能回答以下问题的段落：[用户查询]”。LLM会输出一段虚构但合理的文本。将这个生成的“假设文档”转换为向量（Embedding），然后在向量数据库中进行相似度搜索。找到与“假设文档”最相似的真实文档片段，并将其作为最终检索结果返回给用户或用于后续的答案生成。</li><li><strong>回溯提示（STEP-BACK Prompting）</strong>：引导LLM基于原始问题，提出一个关于基本概念、通用原则或更广泛背景的问题。先检索并获取这个回溯问题的答案。将检索到的通用知识与原始的具体问题相结合，进行演绎推理，最终得出答案。</li><li><strong>查询扩展</strong>，伪相关反馈提供领域知识补充：使用用户的原始查询进行初步检索，得到一组初始文档。从排名前K的文档中，通过算法（如TF-IDF, BM25, 或Embedding）提取出与原始查询最相关且信息量最大的术语。将原始查询与提取出的新术语组合在一起，形成一个新的、更丰富的查询。使用扩展后的新查询进行最终检索，得到更准确、更全面的结果。</li></ul><h1 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h1><p>模型上下文协议（MCP）是一种 开放协议，用于实现 LLM 应用 与 外部数据源和工具 之间的无缝集成。无论你是在构建 AI 驱动的 IDE，优化 聊天界面，还是创建自定义 AI 工作流，MCP 提供了一种 标准化方式，让 LLM 能够访问所需的上下文信息。</p><p>MCP（ModelContext Protocol）就像是AI世界的USB-C接口，统一了各种工具的连接方式，也就是说通过这个“扩展坞”，AI就可以轻松地与世界上的各种工具协作，变得更聪明、更高效。有了这个，在企业开发中就会通过MCP更容易地接入业务系统，从而实现通过自然语言来操作业务系统。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/67912d55b60e090cd2e644f06d906393e84b6f33.png" alt="image-20250922144712395"></p><p>目前已经有非常多的MCP Server可以让大家使用，网址如下：</p><ul><li><p>Smithery：<a href="https://smithery.ai/">https://smithery.ai/</a></p></li><li><p>MCP导航：<a href="https://mcp.so/">https://mcp.so/</a></p></li><li><p>阿里云百炼：<a href="https://bailian.console.aliyun.com/?tab=mcp">https://bailian.console.aliyun.com/?tab=mcp</a></p></li><li><p>MCP官方服务器合集：<a href="https://github.com/modelcontextprotocol/servers">https://github.com/modelcontextprotocol/servers</a></p></li><li><p>MCP Github热门导航：<a href="https://github.com/punkpeye/awesome-mcp-servers">https://github.com/punkpeye/awesome-mcp-servers</a></p></li></ul><p>MCP刚发布的时候不温不火，直到今年Agent大爆发才被广泛关注。而在今年2月，Cursor正式宣布加入MCP功能支持，一举将MCP推到了全体开发人员面前。从本质上来说，MCP是一种技术协议，一种智能体Agent开发过程中共同约定的一种规范。这就好比秦始皇的“<strong>书同文、车同轨</strong>”，在统一的规范下，大家的<strong>协作效率就能大幅提高</strong>，最终<strong>提升智能体Agent的开发效率</strong>。</p><p>总的来说，MCP解决的最大痛点，就是Agent开发中调用外部工具的技术门槛过高的问题。</p><h2 id="MCP工作原理"><a href="#MCP工作原理" class="headerlink" title="MCP工作原理"></a>MCP工作原理</h2><p>下面这张图展示了MCP的工作原理：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/1de07bb9f1590e01cf839d5a5619b6c880f0eaab.png" alt="image-20250922145126975"></p><h3 id="MCP通信数据结构"><a href="#MCP通信数据结构" class="headerlink" title="MCP通信数据结构"></a>MCP通信数据结构</h3><p>在MCP开发过程中，我们会涉及到客户端的开发、服务端的开发，在使用中，客户端AI程序必须通过MCP客服端与MCP服务端进行数据通信，而在通信过程中，通常我们会约定一个说话的格式，这个说话的格式通常称为：协议。</p><p>MCP的通信过程中，采用的协议是JSON-RPC，JSON-RPC 就是一个在MCP业务场景中的“说话的格式”。</p><p>MCP 强制使用 JSON-RPC 2.0，通过这种标准的约定格式，完成业务流程的通信。这种协议简单轻量，消息格式简单。基于 JSON，几乎所有编程语言都支持。它传输层无关：可在 HTTP、WebSocket、TCP 等多种传输协议上使用。</p><p>比如一个JSON-RPC的请求结构如下所示：</p><p>请求体：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;subtract&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">42</span><span class="punctuation">,</span> <span class="number">23</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回体：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="number">19</span><span class="punctuation">,</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>针对请求体的结构说明如下：</p><p>jsonrpc : 必须为 “2.0”。</p><p>method: 调用的方法名（字符串）。</p><p>params: 参数（可省略），支持对象（命名参数）或数组（位置参数）。</p><p>id: 请求标识符。</p><p>请求体这种东西就像你给外卖小哥发消息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;buy&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;item&quot;</span><span class="punctuation">:</span> <span class="string">&quot;coffee&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>method：我要干啥，比如“buy”。</p><p>params：我要的细节，比如“2杯咖啡”。</p><p>id：这是我给这单起的编号，方便等下对上结果。</p><p>然后再响应阶段：外卖小哥给你回消息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ok&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这时候你就能根据 id 知道：哦，这是我刚才点的咖啡的结果。</p><p>要是出错了，对方会这么回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">-32601</span><span class="punctuation">,</span> <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Method not found&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>意思就是“你点的这个菜菜单里没有”。</p><h2 id="MCP通信协议"><a href="#MCP通信协议" class="headerlink" title="MCP通信协议"></a>MCP通信协议</h2><p><strong>MCP 协议基于 SSE 的完整生命周期</strong>：从“握手建联”，到“初始化确认”，再到“发工具清单、调用工具”，中间还有“心跳保活”，最后“优雅断开”。</p><p>1️⃣ 连接建立</p><ol><li>客户端：我先 GET &#x2F;sse，想开个 SSE 通道。</li><li>服务端：好，给你一个 SSE 管道（Emitter），还顺手建了个会话（Session）。</li><li>双方：通道打通啦，可以传消息了。</li></ol><p>2️⃣ 会话初始化</p><ol><li>客户端：我发个初始化请求（InitializeRequest），告诉你我是谁、怎么工作。</li><li>服务端：收到！找到对应的会话，回你一个 InitializeResponse。</li><li>双方：好，身份确认，咱们对接上了。</li></ol><p>3️⃣ ToolList请求（工具清单）</p><ol><li>客户端：你有哪些工具能用？我来调用。</li><li>服务端：等下，我调调工具管理器，整理出工具清单。</li><li>服务端推送：这是工具列表，拿去用吧。</li></ol><p>4️⃣ 连接维持（心跳）</p><ol><li>客户端：ping~ 还活着吗？</li><li>服务端：pong~ 我在呢，同时更新一下心跳时间。</li><li>双方：OK，确认连接不中断。</li></ol><p>5️⃣ 工具调用</p><ol><li>客户端：我现在要用某个工具（POST tools&#x2F;call），给你参数。</li><li>服务端：收到，我去找对应的工具处理器执行一下。</li><li>服务端：执行完了，把结果推给你（SSE）。</li><li>双方：一次完整的调用结束。</li></ol><p>6️⃣ 连接关闭</p><ol><li>客户端：事情办完了，我要断开啦。</li><li>服务端：好，那我把你的会话和 SSE 管道都清掉。</li><li>双方：优雅收尾，拜拜。</li></ol><h1 id="AI编排设计模式分享"><a href="#AI编排设计模式分享" class="headerlink" title="AI编排设计模式分享"></a>AI编排设计模式分享</h1><h2 id="设计模式之一：链式工作流"><a href="#设计模式之一：链式工作流" class="headerlink" title="设计模式之一：链式工作流"></a>设计模式之一：链式工作流</h2><p>这个模式就像工厂流水线——把复杂任务拆成一个个小工序，前一道工序的结果自动传给下一道。技术实现上用了”责任链”设计模式，支持随时增加新的处理环节。</p><p>使用场景：</p><p>这个实现展示了几个关键原则：</p><ol><li>需要分步骤完成的复杂任务（比如先查天气再规划行程最后生成攻略）</li><li>宁愿多花点时间也要保证准确率（像重要文件的多级审批）</li><li>后一步依赖前一步的结果（就像做菜必须按洗菜→切菜→炒菜的顺序）</li></ol><p><img src="https://i0.hdslb.com/bfs/openplatform/a2383d98c3c4c765d007a2180ae97444e7a75057.png" alt="image-20250922153332913"></p><h2 id="设计模式之二：并行化工作流"><a href="#设计模式之二：并行化工作流" class="headerlink" title="设计模式之二：并行化工作流"></a>设计模式之二：并行化工作流</h2><p>这个模式就像开了多个窗口同时干活——让多个大模型同时处理任务，最后把结果汇总起来。主要有两种方式：</p><ol><li><strong>分片处理</strong>：把大任务拆成小任务，分给不同的大模型同时处理（类似分工作业）</li><li><strong>投票机制</strong>：让多个大模型同时处理同一个任务，最后投票选出最佳结果（像开会讨论）</li></ol><p>使用场景：</p><p>并行化工作流模式展示了对多个大语言模型操作的高效并发处理。这种模式对于需要并行执行大语言模型调用并自动聚合输出的场景特别有用。</p><ol><li>要处理一堆相似但互不干扰的任务（比如同时分析多个用户群体的数据）</li><li>需要多个任务独立运行（像工厂里的流水线作业）</li><li>任务能快速拆解且可以并行执行（比如同时生成多个产品描述）</li></ol><p><img src="https://i0.hdslb.com/bfs/openplatform/a812fd2c6ec53a5b0a88c7979a109eba35abaec3.png" alt="image-20250922153404486"></p><h2 id="设计模式之三：路由工作流"><a href="#设计模式之三：路由工作流" class="headerlink" title="设计模式之三：路由工作流"></a>设计模式之三：路由工作流</h2><p>路由模式实现了智能任务分配，能够针对不同类型的输入进行专门处理，这种模式专为复杂任务设计，不同类型的输入由专门的流程处理会更好。</p><p>这个模式就像智能分诊台——能自动识别问题类型，转给最专业的处理流程。技术实现上相当于给大模型装了个智能路由器，不同的问题自动走专用通道。</p><p>使用场景：</p><p>它使用大语言模型分析输入内容，并将其路由到最合适的专门提示或处理程序。</p><ol><li>要处理五花八门的问题类型（比如客服系统同时接咨询、投诉、技术问题）</li><li>不同问题需要不同专家处理（像医院分内科&#x2F;外科&#x2F;急诊）</li><li>需要精准分类输入内容（像快递自动分拣系统）</li></ol><p><img src="https://i0.hdslb.com/bfs/openplatform/21d64ac100bdd9a4b0736c57a1afe00cf6e6de58.png" alt="image-20250922153437157"></p><h2 id="设计模式之四：协调者-执行者"><a href="#设计模式之四：协调者-执行者" class="headerlink" title="设计模式之四：协调者-执行者"></a>设计模式之四：协调者-执行者</h2><p>这个模式就像电影拍摄现场——导演（协调者）负责分镜头，各工种（执行者）专注自己的专业领域。技术实现上采用”中央指挥部+特种部队”的架构，既保持灵活又确保可控。</p><p>使用场景：</p><p>当你的任务像建造摩天大楼需要多方协作时：</p><ol><li>任务复杂到无法提前拆解（像应对突发事件的应急小组）</li><li>需要不同专业视角（像建筑设计需要结构&#x2F;水电&#x2F;装修多方配合）</li><li>解决方案需要动态调整（像军事行动中的实时战术变化）</li></ol><p><img src="https://i0.hdslb.com/bfs/openplatform/a90bee98019fc81e130757642f432fb4a2daa1ea.png" alt="image-20250922153500040"></p><h2 id="设计模式之五：生成者-评估者"><a href="#设计模式之五：生成者-评估者" class="headerlink" title="设计模式之五：生成者-评估者"></a>设计模式之五：生成者-评估者</h2><p>这个模式就像作家与编辑的协作——写手（生成者）负责创作初稿，编辑（评估者）逐字推敲提出修改意见。技术实现上采用”创作-反馈”循环机制，直到作品达到出版标准。</p><ol><li><strong>生成者大语言模型</strong>：生成初始响应并根据反馈进行改进。</li><li><strong>评估者大语言模型</strong>：分析响应并提供详细的改进反馈。</li></ol><p>使用场景</p><p>评估者 - 优化者模式适用于需要多轮迭代以提高质量的任务。</p><ol><li>有明确的品质标准（像学术论文需要同行评审）</li><li>迭代改进能显著提升价值（像广告文案的AB测试）</li><li>追求完美输出（像电影剧本的多次修订）</li></ol><p><img src="https://i0.hdslb.com/bfs/openplatform/789dc061f610565f1baf1e40bc652196ed359a3e.png" alt="image-20250922153802595"></p><p>这种模式我觉得和反思模式应该是同一个。反思（Reflection），是一种重要的AIAgent工作范式。</p><p>反思模式对于那些<strong>一次执行难以成功</strong>的任务特别有用。具体来说，AI首先针对任务生成一个初始输出，然后对这个输出进行审视，检查其准确性、完整性和逻辑性，识别出潜在的问题和改进空间。</p><p>这种模式的核心在于赋予AI自我评估和自我修正的能力。它不再是一个简单的输出生成器，而是一个能够不断学习、进步的智能体。通过反思，AI可以从自己的错误中吸取教训，积累经验，逐步提升解决问题的能力。</p><p>反思模式的应用：第一个模型处理完成后，第2个模型进行评审，然后让第1个模型处理节点在进行反思性的处理。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/0ae05b10520ce3c039fe815767e4a5775b24ef69.png" alt="image-20250922155732340"></p><h2 id="设计模式之六：工具使用模式"><a href="#设计模式之六：工具使用模式" class="headerlink" title="设计模式之六：工具使用模式"></a>设计模式之六：工具使用模式</h2><p>模型可调用外部 API 或工具获取信息或执行操作，适用于实时数据查询、智能控制等。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/823494fc956bc51d7e84042c76d72e10ab993481.png" alt="image-20250922153915900"></p><p>在AI会话节点中集成了MCP工具服务，也算是这种模式的应用了。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何设计一个秒杀系统</title>
      <link href="/2025/09/12/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/09/12/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="不同场景下的不同架构案例"><a href="#不同场景下的不同架构案例" class="headerlink" title="不同场景下的不同架构案例"></a>不同场景下的不同架构案例</h1><p>如果你想快速搭建一个简单的秒杀系统，只需要把你的商品购买页面增加一个“定时上架”功能，仅在秒杀开始时才让用户看到购买按钮，当商品的库存卖完了也就结束了。这就是当时第一个版本的秒杀系统实现方式。</p><p>但随着请求量的加大（比如从1w&#x2F;s到了10w&#x2F;s的量级），这个简单的架构很快就遇到了瓶颈，因此需要做架构改造来提升系统性能。这些架构改造包括：</p><ol><li>把秒杀系统独立出来单独打造一个系统，这样可以有针对性地做优化，例如这个独立出来的系统就减少了店铺装修的功能，减少了页面的复杂度；</li><li>在系统部署上也独立做一个机器集群，这样秒杀的大流量就不会影响到正常的商品购买集群的机器负载；</li><li>将热点数据（如库存数据）单独放到一个缓存系统中，以提高“读性能”；</li><li>增加秒杀答题，防止有秒杀器抢单。</li></ol><p><img src="https://i0.hdslb.com/bfs/openplatform/5d227f416eecc2b7d5d67fc81dadaef7c026170f.png" alt="image-20250912114800915"></p><p>然而这个架构仍然支持不了超过100w&#x2F;s的请求量，所以为了进一步提升秒杀系统的性能，我们又对架构做进一步升级，比如：</p><ol><li>对页面进行彻底的动静分离，使得用户秒杀时不需要刷新整个页面，而只需要点击抢宝按钮，借此把页面刷新的数据降到最少；</li><li>在服务端对秒杀商品进行本地缓存，不需要再调用依赖系统的后台服务获取数据，甚至不需要去公共的缓存集群中查询数据，这样不仅可以减少系统调用，而且能够避免压垮公共缓存集群。</li><li>增加系统限流保护，防止最坏情况发生。</li></ol><p>我们对页面进行了进一步的静态化，秒杀过程中不需要刷新整个页面，而只需要向服务端请求很少的动态数据。而且，最关键的详情和交易系统都增加了本地缓存，来提前缓存秒杀商品的信息，热点数据库也做了独立部署，等等。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/2b3360a22d998a4d3fc49221fb41aa34da2f7626.png" alt="image-20250912114836701"></p><h1 id="动静分离方案"><a href="#动静分离方案" class="headerlink" title="动静分离方案"></a>动静分离方案</h1><h2 id="何为动静数据"><a href="#何为动静数据" class="headerlink" title="何为动静数据"></a>何为动静数据</h2><p>简单来说，<strong>“动态数据”和“静态数据”的主要区别就是看页面中输出的数据是否和URL、浏览者、时间、地域相关，以及是否含有Cookie等私密数据</strong>。比如说：</p><ol><li>很多媒体类的网站，某一篇文章的内容不管是你访问还是我访问，它都是一样的。所以它就是一个典型的静态数据，但是它是个动态页面。</li><li>我们如果现在访问淘宝的首页，每个人看到的页面可能都是不一样的，淘宝首页中包含了很多根据访问者特征推荐的信息，而这些个性化的数据就可以理解为动态数据了。</li></ol><p>那么，怎样对静态数据做缓存呢？我在这里总结了几个重点。</p><p><strong>第一，你应该把静态数据缓存到离用户最近的地方</strong>。静态数据就是那些相对不会变化的数据，因此我们可以把它们缓存起来。缓存到哪里呢？常见的就三种，用户浏览器里、CDN上或者在服务端的Cache中。你应该根据情况，把它们尽量缓存到离用户最近的地方。</p><p><strong>第二，静态化改造就是要直接缓存HTTP连接</strong>。相较于普通的数据缓存而言，你肯定还听过系统的静态化改造。静态化改造是直接缓存HTTP连接而不是仅仅缓存数据，如下图所示，Web代理服务器根据请求URL，直接取出对应的HTTP响应头和响应体然后直接返回，这个响应过程简单得连HTTP协议都不用重新组装，甚至连HTTP请求头也不需要解析。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/d6b55cefca40b52b2b7b753c5138fbde48a805bc.png" alt="image-20250912115240035"></p><p>第三，让谁来缓存静态数据也很重要。不同语言写的Cache软件处理缓存数据的效率也各不相同。以Java为例，因为Java系统本身也有其弱点（比如不擅长处理大量连接请求，每个连接消耗的内存较多，Servlet容器解析HTTP协议较慢），所以你可以不在Java层做缓存，而是直接在Web服务器层上做，这样你就可以屏蔽Java语言层面的一些弱点；而相比起来，Web服务器（如Nginx、Apache、Varnish）也更擅长处理大并发的静态文件请求。</p><h2 id="如何做动静分离的改造"><a href="#如何做动静分离的改造" class="headerlink" title="如何做动静分离的改造"></a>如何做动静分离的改造</h2><p>下面，我以典型的商品详情系统为例来详细介绍。这里，你可以先打开京东或者淘宝的商品详情页，看看这个页面里都有哪些动静数据。我们从以下5个方面来分离出动态内容。</p><ol><li><strong>URL唯一化</strong>。商品详情系统天然地就可以做到URL唯一化，比如每个商品都由ID来标识，那么<a href="http://item.xxx.com/item.htm?id=xxxx%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E5%94%AF%E4%B8%80%E7%9A%84URL%E6%A0%87%E8%AF%86%E3%80%82%E4%B8%BA%E5%95%A5%E8%A6%81URL%E5%94%AF%E4%B8%80%E5%91%A2%EF%BC%9F%E5%89%8D%E9%9D%A2%E8%AF%B4%E4%BA%86%E6%88%91%E4%BB%AC%E6%98%AF%E8%A6%81%E7%BC%93%E5%AD%98%E6%95%B4%E4%B8%AAHTTP%E8%BF%9E%E6%8E%A5%EF%BC%8C%E9%82%A3%E4%B9%88%E4%BB%A5%E4%BB%80%E4%B9%88%E4%BD%9C%E4%B8%BAKey%E5%91%A2%EF%BC%9F%E5%B0%B1%E4%BB%A5URL%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84Key%EF%BC%8C%E4%BE%8B%E5%A6%82%E4%BB%A5id=xxx%E8%BF%99%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86%E3%80%82">http://item.xxx.com/item.htm?id=xxxx就可以作为唯一的URL标识。为啥要URL唯一呢？前面说了我们是要缓存整个HTTP连接，那么以什么作为Key呢？就以URL作为缓存的Key，例如以id=xxx这个格式进行区分。</a></li><li><strong>分离浏览者相关的因素</strong>。浏览者相关的因素包括是否已登录，以及登录身份等，这些相关因素我们可以单独拆分出来，通过动态请求来获取。</li><li><strong>分离时间因素</strong>。服务端输出的时间也通过动态请求获取。</li><li><strong>异步化地域因素</strong>。详情页面上与地域相关的因素做成异步方式获取，当然你也可以通过动态请求方式获取，只是这里通过异步获取更合适。</li><li><strong>去掉Cookie</strong>。服务端输出的页面包含的Cookie可以通过代码软件来删除，如Web服务器Varnish可以通过unset req.http.cookie 命令去掉Cookie。注意，这里说的去掉Cookie并不是用户端收到的页面就不含Cookie了，而是说，在缓存的静态数据中不含有Cookie。</li></ol><p>分离出动态内容之后，如何组织这些内容页就变得非常关键了。这里我要提醒你一点，因为这其中很多动态内容都会被页面中的其他模块用到，如判断该用户是否已登录、用户ID是否匹配等，所以这个时候我们应该将这些信息JSON化（用JSON格式组织这些数据），以方便前端获取。</p><p>前面我们介绍里用缓存的方式来处理静态数据。而动态内容的处理通常有两种方案：ESI（Edge Side Includes）方案和CSI（Client Side Include）方案。</p><ol><li><strong>ESI方案（或者SSI）</strong>：即在Web代理服务器上做动态内容请求，并将请求插入到静态页面中，当用户拿到页面时已经是一个完整的页面了。这种方式对服务端性能有些影响，但是用户体验较好。</li><li><strong>CSI方案</strong>。即单独发起一个异步JavaScript 请求，以向服务端获取动态内容。这种方式服务端性能更佳，但是用户端页面可能会延时，体验稍差。</li></ol><h2 id="动静分离的几种架构方案"><a href="#动静分离的几种架构方案" class="headerlink" title="动静分离的几种架构方案"></a>动静分离的几种架构方案</h2><p>前面我们通过改造把静态数据和动态数据做了分离，那么如何在系统架构上进一步对这些动态和静态数据重新组合，再完整地输出给用户呢？</p><p>这就涉及对用户请求路径进行合理的架构了。根据架构上的复杂度，有3种方案可选：</p><ol><li>实体机单机部署；</li><li>统一Cache层；</li><li>上CDN。</li></ol><h3 id="方案1：实体机单机部署"><a href="#方案1：实体机单机部署" class="headerlink" title="方案1：实体机单机部署"></a>方案1：实体机单机部署</h3><p>这种方案是将虚拟机改为实体机，以增大Cache的容量，并且采用了一致性Hash分组的方式来提升命中率。这里将Cache分成若干组，是希望能达到命中率和访问热点的平衡。Hash分组越少，缓存的命中率肯定就会越高，但短板是也会使单个商品集中在一个分组中，容易导致Cache被击穿，所以我们应该适当增加多个相同的分组，来平衡访问热点和命中率的问题。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/986972ae2092227affa74c5b03bbcf3ca3f6db57.png" alt="image-20250912115638023"></p><p>实体机单机部署有以下几个优点：</p><ol><li>没有网络瓶颈，而且能使用大内存；</li><li>既能提升命中率，又能减少Gzip压缩；</li><li>减少Cache失效压力，因为采用定时失效方式，例如只缓存3秒钟，过期即自动失效。</li></ol><p>这个方案中，虽然把通常只需要虚拟机或者容器运行的Java应用换成实体机，优势很明显，它会增加单机的内存容量，但是一定程度上也造成了CPU的浪费，因为单个的Java进程很难用完整个实体机的CPU。</p><p>另外就是，一个实体机上部署了Java应用又作为Cache来使用，这造成了运维上的高复杂度，所以这是一个折中的方案。如果你的公司里，没有更多的系统有类似需求，那么这样做也比较合适，如果你们有多个业务系统都有静态化改造的需求，那还是建议把Cache层单独抽出来公用比较合理，如下面的方案2所示。</p><h3 id="方案2：统一Cache层"><a href="#方案2：统一Cache层" class="headerlink" title="方案2：统一Cache层"></a>方案2：统一Cache层</h3><p>所谓统一Cache层，就是将单机的Cache统一分离出来，形成一个单独的Cache集群。统一Cache层是个更理想的可推广方案，该方案的结构图如下：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/e8594ffc6609e96746a9cc8c8eef50a4ac0c22cc.png" alt="image-20250912115702515"></p><p>将Cache层单独拿出来统一管理可以减少运维成本，同时也方便接入其他静态化系统。此外，它还有一些优点。</p><ol><li>单独一个Cache层，可以减少多个应用接入时使用Cache的成本。这样接入的应用只要维护自己的Java系统就好，不需要单独维护Cache，而只关心如何使用即可。</li><li>统一Cache的方案更易于维护，如后面加强监控、配置的自动化，只需要一套解决方案就行，统一起来维护升级也比较方便。</li><li>可以共享内存，最大化利用内存，不同系统之间的内存可以动态切换，从而能够有效应对各种攻击。</li></ol><p>这种方案虽然维护上更方便了，但是也带来了其他一些问题，比如缓存更加集中，导致：</p><ol><li>Cache层内部交换网络成为瓶颈；</li><li>缓存服务器的网卡也会是瓶颈；</li><li>机器少风险较大，挂掉一台就会影响很大一部分缓存数据。</li></ol><p>要解决上面这些问题，可以再对Cache做Hash分组，即一组Cache缓存的内容相同，这样能够避免热点数据过度集中导致新的瓶颈产生。</p><blockquote><p>一个商品数据存储在多个Cache实例中，如何保证数据一致性呢？</p></blockquote><p>这个专栏中提的Hash分组都是基于Nginx+Varnish实现的，Nginx把请求的URL中的商品ID进行Hash并路由到一个upstream中，这个upstream挂载一个Varnish分组（如下图所示）。这样，一个相同的商品就可以随机访问一个分组的任意一台Varnish机器了。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/743f34318cce13b91dcdeb6c671a1325e8f07ed2.png" alt="image-20250912162900348"></p><p>有Cache的地方就必然存在失效问题。为啥要失效？因为要保证数据的一致性。所以要用到Cache必然会问如何保证Cache和DB的数据一致性，如果Cache有分组的话，还要保证一个分组中多个实例之间数据的一致性，就像保证MySQL的主从一致一样。</p><p>其实，失效有主动失效和被动失效两种方式。</p><ul><li>被动失效，主要处理如模板变更和一些对时效性不太敏感数据的失效，采用设置一定时间长度（如只缓存3秒钟）这种自动失效的方式。当然，你也要开发一个后台管理界面，以便能够在紧急情况下手工失效某些Cache。</li><li>主动失效，一般有Cache失效中心监控数据库表变化发送失效请求、系统发布也需要清空Cache数据等几种场景。其中失效中心承担了主要的失效功能，这个失效中心的逻辑图如下：</li></ul><p><img src="https://i0.hdslb.com/bfs/openplatform/8b53486d63156810d687cbe61fcc36941c34793d.png" alt="image-20250912163041092"></p><p>失效中心会监控关键数据表的变更（有个中间件来解析MySQL的binglog，然后发现有Insert、Update、Delete等操作时，会把变更前的数据以及要变更的数据转成一个消息发送给订阅方），通过这种方式来发送失效请求给Cache，从而清除Cache数据。如果Cache数据放在CDN上，那么也可以采用类似的方式来设计级联的失效结构，采用主动发请求给Cache软件失效的方式，如下图所示：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/3607b38a11073d67a13333ea184a8ed537b481c2.png" alt="image-20250912163117755"></p><p>这种失效有失效中心将失效请求发送给每个CDN节点上的Console机，然后Console机来发送失效请求给每台Cache机器。</p><h3 id="方案3：上CDN"><a href="#方案3：上CDN" class="headerlink" title="方案3：上CDN"></a>方案3：上CDN</h3><p>在将整个系统做动静分离后，我们自然会想到更进一步的方案，就是将Cache进一步前移到CDN上，因为CDN离用户最近，效果会更好。</p><p>但是要想这么做，有以下几个问题需要解决。</p><ol><li><strong>失效问题</strong>。前面我们也有提到过缓存时效的问题，不知道你有没有理解，我再来解释一下。谈到静态数据时，我说过一个关键词叫“相对不变”，它的言外之意是“可能会变化”。比如一篇文章，现在不变，但如果你发现个错别字，是不是就会变化了？如果你的缓存时效很长，那用户端在很长一段时间内看到的都是错的。所以，这个方案中也是，我们需要保证CDN可以在秒级时间内，让分布在全国各地的Cache同时失效，这对CDN的失效系统要求很高。</li><li><strong>命中率问题</strong>。Cache最重要的一个衡量指标就是“高命中率”，不然Cache的存在就失去了意义。同样，如果将数据全部放到全国的CDN上，必然导致Cache分散，而Cache分散又会导致访问请求命中同一个Cache的可能性降低，那么命中率就成为一个问题。</li><li><strong>发布更新问题</strong>。如果一个业务系统每周都有日常业务需要发布，那么发布系统必须足够简洁高效，而且你还要考虑有问题时快速回滚和排查问题的简便性。</li></ol><p>从前面的分析来看，将商品详情系统放到全国的所有CDN节点上是不太现实的，因为存在失效问题、命中率问题以及系统的发布更新问题。那么是否可以选择若干个节点来尝试实施呢？答案是“可以”，但是这样的节点需要满足几个条件：</p><ol><li>靠近访问量比较集中的地区；</li><li>离主站相对较远；</li><li>节点到主站间的网络比较好，而且稳定；</li><li>节点容量比较大，不会占用其他CDN太多的资源。</li></ol><p>最后，还有一点也很重要，那就是：节点不要太多。</p><p>基于上面几个因素，选择CDN的二级Cache比较合适，因为二级Cache数量偏少，容量也更大，让用户的请求先回源的CDN的二级Cache中，如果没命中再回源站获取数据，部署方式如下图所示：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/871f14b3e51d04c89e03e5af239796b4e6237def.png" alt="image-20250912115722599"></p><p>使用CDN的二级Cache作为缓存，可以达到和当前服务端静态化Cache类似的命中率，因为节点数不多，Cache不是很分散，访问量也比较集中，这样也就解决了命中率问题，同时能够给用户最好的访问体验，是当前比较理想的一种CDN化方案。</p><p>除此之外，CDN化部署方案还有以下几个特点：</p><ol><li>把整个页面缓存在用户浏览器中；</li><li>如果强制刷新整个页面，也会请求CDN；</li><li>实际有效请求，只是用户对“刷新抢宝”按钮的点击。</li></ol><p>这样就把90%的静态数据缓存在了用户端或者CDN上，当真正秒杀时，用户只需要点击特殊的“刷新抢宝”按钮，而不需要刷新整个页面。这样一来，系统只是向服务端请求很少的有效数据，而不需要重复请求大量的静态数据。</p><p>秒杀的动态数据和普通详情页面的动态数据相比更少，性能也提升了3倍以上。所以“抢宝”这种设计思路，让我们不用刷新页面就能够很好地请求到服务端最新的动态数据。</p><h1 id="二八原则：有针对性地处理好系统的“热点数据”"><a href="#二八原则：有针对性地处理好系统的“热点数据”" class="headerlink" title="二八原则：有针对性地处理好系统的“热点数据”"></a>二八原则：有针对性地处理好系统的“热点数据”</h1><h2 id="发现热点数据"><a href="#发现热点数据" class="headerlink" title="发现热点数据"></a>发现热点数据</h2><h3 id="发现静态热点数据"><a href="#发现静态热点数据" class="headerlink" title="发现静态热点数据"></a>发现静态热点数据</h3><p>如前面讲的，静态热点数据可以通过商业手段，例如强制让卖家通过报名参加的方式提前把热点商品筛选出来，实现方式是通过一个运营系统，把参加活动的商品数据进行打标，然后通过一个后台系统对这些热点商品进行预处理，如提前进行缓存。但是这种通过报名提前筛选的方式也会带来新的问题，即增加卖家的使用成本，而且实时性较差，也不太灵活。</p><p>不过，除了提前报名筛选这种方式，你还可以通过技术手段提前预测，例如对买家每天访问的商品进行大数据计算，然后统计出TOP N的商品，我们可以认为这些TOP N的商品就是热点商品。</p><h3 id="发现动态热点数据"><a href="#发现动态热点数据" class="headerlink" title="发现动态热点数据"></a>发现动态热点数据</h3><p>我们可以通过卖家报名或者大数据预测这些手段来提前预测静态热点数据，但这其中有一个痛点，就是实时性较差，如果我们的系统能在秒级内自动发现热点商品那就完美了。</p><p>能够动态地实时发现热点不仅对秒杀商品，对其他热卖商品也同样有价值，所以我们需要想办法实现热点的动态发现功能。</p><p>这里我给出一个动态热点发现系统的具体实现。</p><ol><li>构建一个异步的系统，它可以收集交易链路上各个环节中的中间件产品的热点Key，如Nginx、缓存、RPC服务框架等这些中间件（一些中间件产品本身已经有热点统计模块）。</li><li>建立一个热点上报和可以按照需求订阅的热点服务的下发规范，主要目的是通过交易链路上各个系统（包括详情、购物车、交易、优惠、库存、物流等）访问的时间差，把上游已经发现的热点透传给下游系统，提前做好保护。比如，对于大促高峰期，详情系统是最早知道的，在统一接入层上Nginx模块统计的热点URL。</li><li>将上游系统收集的热点数据发送到热点服务台，然后下游系统（如交易系统）就会知道哪些商品会被频繁调用，然后做热点保护。</li></ol><p>这里我给出了一个图，其中用户访问商品时经过的路径有很多，我们主要是依赖前面的导购页面（包括首页、搜索页面、商品详情、购物车等）提前识别哪些商品的访问量高，通过这些系统中的中间件来收集热点数据，并记录到日志中。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/83dcc8c0d1a9284b05c9d5fa8b63e4f61a7b3ce0.png" alt="image-20250912120422769"></p><h2 id="处理热点数据"><a href="#处理热点数据" class="headerlink" title="处理热点数据"></a>处理热点数据</h2><p><strong>处理热点数据通常有几种思路：一是优化，二是限制，三是隔离</strong>。</p><p>先来说说优化。优化热点数据最有效的办法就是缓存热点数据，如果热点数据做了动静分离，那么可以长期缓存静态数据。但是，缓存热点数据更多的是“临时”缓存，即不管是静态数据还是动态数据，都用一个队列短暂地缓存数秒钟，由于队列长度有限，可以采用LRU淘汰算法替换。</p><p>再来说说限制。限制更多的是一种保护机制，限制的办法也有很多，例如对被访问商品的ID做一致性Hash，然后根据Hash做分桶，每个分桶设置一个处理队列，这样可以把热点商品限制在一个请求队列里，防止因某些热点商品占用太多的服务器资源，而使其他请求始终得不到服务器的处理资源。</p><p>最后介绍一下隔离。秒杀系统设计的第一个原则就是将这种热点数据隔离出来，不要让1%的请求影响到另外的99%，隔离出来后也更方便对这1%的请求做针对性的优化。</p><p>具体到“秒杀”业务，我们可以在以下几个层次实现隔离。</p><ol><li><strong>业务隔离</strong>。把秒杀做成一种营销活动，卖家要参加秒杀这种营销活动需要单独报名，从技术上来说，卖家报名后对我们来说就有了已知热点，因此可以提前做好预热。</li><li><strong>系统隔离</strong>。系统隔离更多的是运行时的隔离，可以通过分组部署的方式和另外99%分开。秒杀可以申请单独的域名，目的也是让请求落到不同的集群中。</li><li><strong>数据隔离</strong>。秒杀所调用的数据大部分都是热点数据，比如会启用单独的Cache集群或者MySQL数据库来放热点数据，目的也是不想0.01%的数据有机会影响99.99%数据。</li></ol><p>当然了，实现隔离有很多种办法。比如，你可以按照用户来区分，给不同的用户分配不同的Cookie，在接入层，路由到不同的服务接口中；再比如，你还可以在接入层针对URL中的不同Path来设置限流策略。服务层调用不同的服务接口，以及数据层通过给数据打标来区分等等这些措施，其目的都是把已经识别出来的热点请求和普通的请求区分开。</p><h1 id="流量削峰这事应该怎么做？"><a href="#流量削峰这事应该怎么做？" class="headerlink" title="流量削峰这事应该怎么做？"></a>流量削峰这事应该怎么做？</h1><h2 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h2><p>要对流量进行削峰，最容易想到的解决方案就是用消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。</p><p>但是，如果流量峰值持续一段时间达到了消息队列的处理上限，例如本机的消息积压达到了存储空间的上限，消息队列同样也会被压垮，这样虽然保护了下游的系统，但是和直接把请求丢弃也没多大的区别。就像遇到洪水爆发时，即使是有水库恐怕也无济于事。</p><p>除了消息队列，类似的排队方式还有很多，例如：</p><ol><li>利用线程池加锁等待也是一种常用的排队方式；</li><li>先进先出、先进后出等常用的内存排队算法的实现方式；</li><li>把请求序列化到文件中，然后再顺序地读文件（例如基于MySQL binlog的同步机制）来恢复请求等方式。</li></ol><h2 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h2><p>最早期的秒杀只是纯粹地刷新页面和点击购买按钮，它是后来才增加了答题功能的。那么，为什么要增加答题功能呢？</p><p>这主要是为了增加购买的复杂度，从而达到两个目的。</p><p>第一个目的是防止部分买家使用秒杀器在参加秒杀时作弊。2011年秒杀非常火的时候，秒杀器也比较猖獗，因而没有达到全民参与和营销的目的，所以系统增加了答题来限制秒杀器。增加答题后，下单的时间基本控制在2s后，秒杀器的下单比例也大大下降。</p><p>第二个目的其实就是延缓请求，起到对请求流量进行削峰的作用，从而让系统能够更好地支持瞬时的流量高峰。这个重要的功能就是把峰值的下单请求拉长，从以前的1s之内延长到2s~10s。这样一来，请求峰值基于时间分片了。这个时间的分片对服务端处理并发非常重要，会大大减轻压力。而且，由于请求具有先后顺序，靠后的请求到来时自然也就没有库存了，因此根本到不了最后的下单步骤，所以真正的并发写就非常有限了。这种设计思路目前用得非常普遍，如当年支付宝的“咻一咻”、微信的“摇一摇”都是类似的方式。</p><p>这里，我重点说一下秒杀答题的设计思路。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/013b09c6b0eae6269ad0742ee7059ea59a172628.png" alt="image-20250912155807956"></p><p>如上图所示，整个秒杀答题的逻辑主要分为3部分。</p><ol><li><strong>题库生成模块</strong>，这个部分主要就是生成一个个问题和答案，其实题目和答案本身并不需要很复杂，重要的是能够防止由机器来算出结果，即防止秒杀器来答题。</li><li><strong>题库的推送模块</strong>，用于在秒杀答题前，把题目提前推送给详情系统和交易系统。题库的推送主要是为了保证每次用户请求的题目是唯一的，目的也是防止答题作弊。</li><li><strong>题目的图片生成模块</strong>，用于把题目生成为图片格式，并且在图片里增加一些干扰因素。这也同样是为防止机器直接来答题，它要求只有人才能理解题目本身的含义。这里还要注意一点，由于答题时网络比较拥挤，我们应该把题目的图片提前推送到CDN上并且要进行预热，不然的话当用户真正请求题目时，图片可能加载比较慢，从而影响答题的体验。</li></ol><p>其实真正答题的逻辑比较简单，很好理解：当用户提交的答案和题目对应的答案做比较，如果通过了就继续进行下一步的下单逻辑，否则就失败。我们可以把问题和答案用下面这样的key来进行MD5加密：</p><ul><li>问题key：userId+itemId+question_Id+time+PK</li><li>答案key：userId+itemId+answer+PK</li></ul><p>验证的逻辑如下图所示：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/a984a6e0a560de3994f6c6448eeb307ee697840c.png" alt="image-20250912155917942"></p><p>注意，这里面的验证逻辑，除了验证问题的答案以外，还包括用户本身身份的验证，例如是否已经登录、用户的Cookie是否完整、用户是否重复频繁提交等。</p><p>除了做正确性验证，我们还可以对提交答案的时间做些限制，例如从开始答题到接受答案要超过1s，因为小于1s是人为操作的可能性很小，这样也能防止机器答题的情况。</p><h2 id="分层过滤"><a href="#分层过滤" class="headerlink" title="分层过滤"></a>分层过滤</h2><p>前面介绍的排队和答题要么是少发请求，要么对发出来的请求进行缓冲，而针对秒杀场景还有一种方法，就是对请求进行分层过滤，从而过滤掉一些无效的请求。分层过滤其实就是采用“漏斗”式设计来处理请求的，如下图所示。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/c7aa7c6890ffec67c74f2acea3924f7b06230cc7.png" alt="image-20250912160024914"></p><p>假如请求分别经过CDN、前台读系统（如商品详情系统）、后台系统（如交易系统）和数据库这几层，那么：</p><ul><li>大部分数据和流量在用户浏览器或者CDN上获取，这一层可以拦截大部分数据的读取；</li><li>经过第二层（即前台系统）时数据（包括强一致性的数据）尽量得走Cache，过滤一些无效的请求；</li><li>再到第三层后台系统，主要做数据的二次检验，对系统做好保护和限流，这样数据量和请求就进一步减少；</li><li>最后在数据层完成数据的强一致性校验。</li></ul><p>这样就像漏斗一样，尽量把数据量和请求量一层一层地过滤和减少了。</p><p><strong>分层过滤的核心思想是：在不同的层次尽可能地过滤掉无效请求，让“漏斗”最末端的才是有效请求</strong>。而要达到这种效果，我们就必须对数据做分层的校验。</p><p>分层校验的基本原则是：</p><ol><li>将动态请求的读数据缓存（Cache）在Web端，过滤掉无效的数据读；</li><li>对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题；</li><li>对写数据进行基于时间的合理分片，过滤掉过期的失效请求；</li><li>对写请求做限流保护，将超出系统承载能力的请求过滤掉；</li><li>对写数据进行强一致性校验，只保留最后有效的数据。</li></ol><h1 id="影响性能的因素有哪些？"><a href="#影响性能的因素有哪些？" class="headerlink" title="影响性能的因素有哪些？"></a>影响性能的因素有哪些？</h1><h2 id="影响性能的因素"><a href="#影响性能的因素" class="headerlink" title="影响性能的因素"></a>影响性能的因素</h2><p>我们讨论的主要是系统服务端性能，一般用QPS（Query Per Second，每秒请求数）来衡量，还有一个影响和QPS也息息相关，那就是响应时间（Response Time，RT），它可以理解为服务器处理响应的耗时。</p><p><strong>首先，我们先来看看响应时间和QPS有啥关系</strong>。</p><p>对于大部分的Web系统而言，响应时间一般都是由CPU执行时间和线程等待时间（比如RPC、IO等待、Sleep、Wait等）组成，即服务器在处理一个请求时，一部分是CPU本身在做运算，还有一部分是在各种等待。</p><p>理解了服务器处理请求的逻辑，估计你会说为什么我们不去减少这种等待时间。很遗憾，根据我们实际的测试发现，减少线程等待时间对提升性能的影响没有我们想象得那么大，它并不是线性的提升关系，这点在很多代理服务器（Proxy）上可以做验证。</p><p>如果代理服务器本身没有CPU消耗，我们在每次给代理服务器代理的请求加个延时，即增加响应时间，但是这对代理服务器本身的吞吐量并没有多大的影响，因为代理服务器本身的资源并没有被消耗，可以通过增加代理服务器的处理线程数，来弥补响应时间对代理服务器的QPS的影响。</p><p>其实，真正对性能有影响的是CPU的执行时间。这也很好理解，因为CPU的执行真正消耗了服务器的资源。经过实际的测试，如果减少CPU一半的执行时间，就可以增加一倍的QPS。</p><p>也就是说，我们应该致力于减少CPU的执行时间。</p><p><strong>其次，我们再来看看线程数对QPS的影响</strong>。</p><p>单看“总QPS”的计算公式，你会觉得线程数越多QPS也就会越高，但这会一直正确吗？显然不是，线程数不是越多越好，因为线程本身也消耗资源，也受到其他因素的制约。例如，线程越多系统的线程切换成本就会越高，而且每个线程也都会耗费一定内存。</p><p>那么，设置什么样的线程数最合理呢？其实<strong>很多多线程的场景都有一个默认配置，即“线程数 &#x3D; 2 * CPU核数 + 1”</strong>。除去这个配置，还有一个根据最佳实践得出来的公式：</p><blockquote><p>线程数 &#x3D; [(线程等待时间 + 线程CPU时间) &#x2F; 线程CPU时间] × CPU数量</p></blockquote><p>当然，最好的办法是通过性能测试来发现最佳的线程数。</p><p>换句话说，要提升性能我们就要减少CPU的执行时间，另外就是要设置一个合理的并发线程数，通过这两方面来显著提升服务器的性能。</p><h2 id="如何发现瓶颈"><a href="#如何发现瓶颈" class="headerlink" title="如何发现瓶颈"></a>如何发现瓶颈</h2><p>那么，如何发现CPU的瓶颈呢？其实有很多CPU诊断工具可以发现CPU的消耗，最常用的就是JProfiler和Yourkit这两个工具，它们可以列出整个请求中每个函数的CPU执行时间，可以发现哪个函数消耗的CPU时间最多，以便你有针对性地做优化。</p><p>当然还有一些办法也可以近似地统计CPU的耗时，例如通过jstack定时地打印调用栈，如果某些函数调用频繁或者耗时较多，那么那些函数就会多次出现在系统调用栈里，这样相当于采样的方式也能够发现耗时较多的函数。</p><h2 id="如何优化系统"><a href="#如何优化系统" class="headerlink" title="如何优化系统"></a>如何优化系统</h2><h3 id="减少编码"><a href="#减少编码" class="headerlink" title="减少编码"></a>减少编码</h3><p>Java的编码运行比较慢，这是Java的一大硬伤。在很多场景下，只要涉及字符串的操作（如输入输出操作、I&#x2F;O操作）都比较耗CPU资源，不管它是磁盘I&#x2F;O还是网络I&#x2F;O，因为都需要将字符转换成字节，而这个转换必须编码。</p><p>那么如何才能减少编码呢？例如，网页输出是可以直接进行流输出的，即用resp.getOutputStream()函数写数据，把一些静态的数据提前转化成字节，等到真正往外写的时候再直接用OutputStream()函数写，就可以减少静态数据的编码转换。</p><p>我在《深入分析Java Web技术内幕》一书中介绍的“Velocity优化实践”一章的内容，就是基于把静态的字符串提前编码成字节并缓存，然后直接输出字节内容到页面，从而大大减少编码的性能消耗的，网页输出的性能比没有提前进行字符到字节转换时提升了30%左右。</p><h3 id="减少序列化"><a href="#减少序列化" class="headerlink" title="减少序列化"></a>减少序列化</h3><p>序列化大部分是在RPC中发生的，因此避免或者减少RPC就可以减少序列化，当然当前的序列化协议也已经做了很多优化来提升性能。有一种新的方案，就是可以将多个关联性比较强的应用进行“合并部署”，而减少不同应用之间的RPC也可以减少序列化的消耗。</p><p>所谓“合并部署”，就是把两个原本在不同机器上的不同应用合并部署到一台机器上，当然不仅仅是部署在一台机器上，还要在同一个Tomcat容器中，且不能走本机的Socket，这样才能避免序列化的产生</p><h3 id="Java极致优化"><a href="#Java极致优化" class="headerlink" title="Java极致优化"></a>Java极致优化</h3><p>Java和通用的Web服务器（如Nginx或Apache服务器）相比，在处理大并发的HTTP请求时要弱一点，所以一般我们都会对大流量的Web系统做静态化改造，让大部分请求和数据直接在Nginx服务器或者Web代理服务器（如Varnish、Squid等）上直接返回（这样可以减少数据的序列化与反序列化），而Java层只需处理少量数据的动态请求。针对这些请求，我们可以使用以下手段进行优化：</p><ul><li>直接使用Servlet处理请求。避免使用传统的MVC框架，这样可以绕过一大堆复杂且用处不大的处理逻辑，节省1ms时间（具体取决于你对MVC框架的依赖程度）。</li><li>直接输出流数据。使用resp.getOutputStream()而不是resp.getWriter()函数，可以省掉一些不变字符数据的编码，从而提升性能；数据输出时推荐使用JSON而不是模板引擎（一般都是解释执行）来输出页面。</li></ul><h3 id="并发读优化"><a href="#并发读优化" class="headerlink" title="并发读优化"></a>并发读优化</h3><ul><li>像商品中的“标题”和“描述”这些本身不变的数据，会在秒杀开始之前全量推送到秒杀机器上，并一直缓存到秒杀结束；</li><li>像库存这类动态数据，会采用“被动失效”的方式缓存一定时间（一般是数秒），失效后再去缓存拉取最新的数据。</li></ul><p>你可能还会有疑问：像库存这种频繁更新的数据，一旦数据不一致，会不会导致超卖？</p><p>这就要用到前面介绍的读数据的分层校验原则了，读的场景可以允许一定的脏数据，因为这里的误判只会导致少量原本无库存的下单请求被误认为有库存，可以等到真正写数据时再保证最终的一致性，通过在数据的高可用性和一致性之间的平衡，来解决高并发的数据读取问题。</p><h1 id="秒杀系统“减库存”设计的核心逻辑"><a href="#秒杀系统“减库存”设计的核心逻辑" class="headerlink" title="秒杀系统“减库存”设计的核心逻辑"></a>秒杀系统“减库存”设计的核心逻辑</h1><p>如果要设计一套秒杀系统，那我想你的老板肯定会先对你说：千万不要超卖，这是大前提。</p><p>我们平常购物都是这样，看到喜欢的商品然后下单，但并不是每个下单请求你都最后付款了。你说系统是用户下单了就算这个商品卖出去了，还是等到用户真正付款了才算卖出了呢？这的确是个问题！</p><p>我们可以先根据减库存是发生在下单阶段还是付款阶段，把减库存做一下划分。</p><h2 id="减库存有哪几种方式"><a href="#减库存有哪几种方式" class="headerlink" title="减库存有哪几种方式"></a>减库存有哪几种方式</h2><p>总结来说，减库存操作一般有如下几个方式：</p><ul><li><strong>下单减库存</strong>，即当买家下单后，在商品的总库存中减去买家购买数量。下单减库存是最简单的减库存方式，也是控制最精确的一种，下单时直接通过数据库的事务机制控制商品库存，这样一定不会出现超卖的情况。但是你要知道，有些人下完单可能并不会付款。</li><li><strong>付款减库存</strong>，即买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。</li><li><strong>预扣库存</strong>，这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如10分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。</li></ul><h2 id="减库存可能存在的问题"><a href="#减库存可能存在的问题" class="headerlink" title="减库存可能存在的问题"></a>减库存可能存在的问题</h2><p>假如我们采用“下单减库存”的方式，即用户下单后就减去库存，正常情况下，买家下单后付款的概率会很高，所以不会有太大问题。但是有一种场景例外，就是当卖家参加某个活动时，此时活动的有效时间是商品的黄金售卖时间，如果有竞争对手通过恶意下单的方式将该卖家的商品全部下单，让这款商品的库存减为零，那么这款商品就不能正常售卖了。要知道，这些恶意下单的人是不会真正付款的，这正是“下单减库存”方式的不足之处。</p><p>“付款减库存”又会导致另外一个问题：库存超卖。假如有100件商品，就可能出现300人下单成功的情况，因为下单时不会减库存，所以也就可能出现下单成功数远远超过真正库存数的情况，这尤其会发生在做活动的热门商品上。这样一来，就会导致很多买家下单成功但是付不了款，买家的购物体验自然比较差。</p><p>那么，既然“下单减库存”和“付款减库存”都有缺点，我们能否把两者相结合，将两次操作进行前后关联起来，下单时先预扣，在规定时间内不付款再释放库存，即采用“预扣库存”这种方式呢？</p><p>这种方案确实可以在一定程度上缓解上面的问题。但是否就彻底解决了呢？其实没有！针对恶意下单这种情况，虽然把有效的付款时间设置为10分钟，但是恶意买家完全可以在10分钟后再次下单，或者采用一次下单很多件的方式把库存减完。针对这种情况，解决办法还是要结合安全和反作弊的措施来制止。</p><p>例如，给经常下单不付款的买家进行识别打标（可以在被打标的买家下单时不减库存）、给某些类目设置最大购买件数（例如，参加活动的商品一人最多只能买3件），以及对重复下单不付款的操作进行次数限制等。</p><p>针对“库存超卖”这种情况，在10分钟时间内下单的数量仍然有可能超过库存数量，遇到这种情况我们只能区别对待：对普通的商品下单数量超过库存数量的情况，可以通过补货来解决；但是有些卖家完全不允许库存为负数的情况，那只能在买家付款时提示库存不足。</p><h2 id="大型秒杀中如何减库存？"><a href="#大型秒杀中如何减库存？" class="headerlink" title="大型秒杀中如何减库存？"></a>大型秒杀中如何减库存？</h2><p>目前来看，业务系统中最常见的就是预扣库存方案，像你在买机票、买电影票时，下单后一般都有个“有效付款时间”，超过这个时间订单自动释放，这都是典型的预扣库存方案。而具体到秒杀这个场景，应该采用哪种方案比较好呢？</p><p>由于参加秒杀的商品，一般都是“抢到就是赚到”，所以成功下单后却不付款的情况比较少，再加上卖家对秒杀商品的库存有严格限制，所以秒杀商品采用“下单减库存”更加合理。另外，理论上由于“下单减库存”比“预扣库存”以及涉及第三方支付的“付款减库存”在逻辑上更为简单，所以性能上更占优势。</p><p>“下单减库存”在数据一致性上，主要就是保证大并发请求时库存数据不能为负数，也就是要保证数据库中的库存字段值不能为负数，一般我们有多种解决方案：一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行SQL语句来报错；再有一种就是使用CASE WHEN判断语句，例如这样的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> item <span class="keyword">SET</span> inventory <span class="operator">=</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> inventory <span class="operator">&gt;=</span> xxx <span class="keyword">THEN</span> inventory<span class="operator">-</span>xxx <span class="keyword">ELSE</span> inventory <span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="秒杀减库存的极致优化"><a href="#秒杀减库存的极致优化" class="headerlink" title="秒杀减库存的极致优化"></a>秒杀减库存的极致优化</h2><p>由于MySQL存储数据的特点，同一数据在数据库里肯定是一行存储（MySQL），因此会有大量线程来竞争InnoDB行锁，而并发度越高时等待线程会越多，TPS（Transaction Per Second，即每秒处理的消息数）会下降，响应时间（RT）会上升，数据库的吞吐量就会严重受影响。</p><p>这就可能引发一个问题，就是单个热点商品会影响整个数据库的性能， 导致0.01%的商品影响99.99%的商品的售卖，这是我们不愿意看到的情况。一个解决思路是遵循前面介绍的原则进行隔离，把热点商品放到单独的热点库中。但是这无疑会带来维护上的麻烦，比如要做热点数据的动态迁移以及单独的数据库等。</p><p>而分离热点商品到单独的数据库还是没有解决并发锁的问题，我们应该怎么办呢？要解决并发锁的问题，有两种办法：</p><ul><li><strong>应用层做排队</strong>。按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。</li><li><strong>数据库层做排队</strong>。应用层只能做到单机的排队，但是应用机器数本身很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做全局排队是最理想的。阿里的数据库团队开发了针对这种MySQL的InnoDB层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。</li></ul><p>你可能有疑问了，排队和锁竞争不都是要等待吗，有啥区别？</p><p>如果熟悉MySQL的话，你会知道InnoDB内部的死锁检测，以及MySQL Server和InnoDB的切换会比较消耗性能，淘宝的MySQL核心团队还做了很多其他方面的优化，如COMMIT_ON_SUCCESS和ROLLBACK_ON_FAIL的补丁程序，配合在SQL里面加提示（hint），在事务里不需要等待应用层提交（COMMIT），而在数据执行完最后一条SQL后，直接根据TARGET_AFFECT_ROW的结果进行提交或回滚，可以减少网络等待时间（平均约0.7ms）。据我所知，目前阿里MySQL团队已经将包含这些补丁程序的MySQL开源。</p><p>另外，数据更新问题除了前面介绍的热点隔离和排队处理之外，还有些场景（如对商品的lastmodifytime字段的）更新会非常频繁，在某些场景下这些多条SQL是可以合并的，一定时间内只要执行最后一条SQL就行了，以便减少对数据库的更新操作。</p><blockquote><p> 如果异步的请求失败了，怎么办？</p></blockquote><p>对秒杀来说，我觉得如果失败了直接丢弃就好了，最坏的结果就是这个人没有抢到而已。但是你非要纠结的话，就要做异步消息的持久化以及重试机制了，要保证异步请求的最终正确处理一般都要借助消息系统，即消息的最终可达，例如阿里的消息中间件是能承诺只要客户端消息发送成功，那么消息系统一定会保证消息最终被送到目的地，即消息不会丢。因为客户端只要成功发送一条消息，下游消费方就一定会消费这条消息，所以也就不存在消息发送失败的问题了。</p><h1 id="准备Plan-B：如何设计兜底方案"><a href="#准备Plan-B：如何设计兜底方案" class="headerlink" title="准备Plan B：如何设计兜底方案"></a>准备Plan B：如何设计兜底方案</h1><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>所谓“降级”，就是当系统的容量达到一定程度时，限制或者关闭系统的某些非核心功能，从而把有限的资源保留给更核心的业务。它是一个有目的、有计划的执行过程，所以对降级我们一般需要有一套预案来配合执行。如果我们把它系统化，就可以通过预案系统和开关系统来实现降级。</p><p>降级方案可以这样设计：当秒杀流量达到5w&#x2F;s时，把成交记录的获取从展示20条降级到只展示5条。“从20改到5”这个操作由一个开关来实现，也就是设置一个能够从开关系统动态获取的系统参数。</p><p>这里，我给出开关系统的示意图。它分为两部分，一部分是开关控制台，它保存了开关的具体配置信息，以及具体执行开关所对应的机器列表；另一部分是执行下发开关数据的Agent，主要任务就是保证开关被正确执行，即使系统重启后也会生效。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/1b7fe21e0720519aff27e1b7c9621e6d482473cb.png" alt="image-20250912161948237"></p><p>执行降级无疑是在系统性能和用户体验之间选择了前者，降级后肯定会影响一部分用户的体验，例如在双11零点时，如果优惠券系统扛不住，可能会临时降级商品详情的优惠信息展示，把有限的系统资源用在保障交易系统正确展示优惠信息上，即保障用户真正下单时的价格是正确的。所以降级的核心目标是牺牲次要的功能和用户体验来保证核心业务流程的稳定，是一个不得已而为之的举措。</p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>如果说降级是牺牲了一部分次要的功能和用户的体验效果，那么限流就是更极端的一种保护措施了。限流就是当系统容量达到瓶颈时，我们需要通过限制一部分流量来保护系统，并做到既可以人工执行开关，也支持自动化保护的措施。</p><p>这里，我同样给出了限流系统的示意图。总体来说，限流既可以是在客户端限流，也可以是在服务端限流。此外，限流的实现方式既要支持URL以及方法级别的限流，也要支持基于QPS和线程的限流。</p><p>首先，我以内部的系统调用为例，来分别说下客户端限流和服务端限流的优缺点。</p><ul><li><strong>客户端限流</strong>，好处可以限制请求的发出，通过减少发出无用请求从而减少对系统的消耗。缺点就是当客户端比较分散时，没法设置合理的限流阈值：如果阈值设的太小，会导致服务端没有达到瓶颈时客户端已经被限制；而如果设的太大，则起不到限制的作用。</li><li><strong>服务端限流</strong>，好处是可以根据服务端的性能设置合理的阈值，而缺点就是被限制的请求都是无效的请求，处理这些无效的请求本身也会消耗服务器资源。</li></ul><p>在限流的实现手段上来讲，基于QPS和线程数的限流应用最多，最大QPS很容易通过压测提前获取，例如我们的系统最高支持1w QPS时，可以设置8000来进行限流保护。线程数限流在客户端比较有效，例如在远程调用时我们设置连接池的线程数，超出这个并发线程请求，就将线程进行排队或者直接超时丢弃。</p><p>限流无疑会影响用户的正常请求，所以必然会导致一部分用户请求失败，因此在系统处理这种异常时一定要设置超时时间，防止因被限流的请求不能fast fail（快速失败）而拖垮系统。</p><h2 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h2><p>如果限流还不能解决问题，最后一招就是直接拒绝服务了。</p><p>当系统负载达到一定阈值时，例如CPU使用率达到90%或者系统load值达到2*CPU核数时，系统直接拒绝所有请求，这种方式是最暴力但也最有效的系统保护方式。例如秒杀系统，我们在如下几个环节设计过载保护：</p><blockquote><p>在最前端的Nginx上设置过载保护，当机器负载达到某个值时直接拒绝HTTP请求并返回503错误码，在Java层同样也可以设计过载保护。</p></blockquote><p>拒绝服务可以说是一种不得已的兜底方案，用以防止最坏情况发生，防止因把服务器压跨而长时间彻底无法提供服务。像这种系统过载保护虽然在过载时无法提供服务，但是系统仍然可以运作，当负载下降时又很容易恢复，所以每个系统和每个环节都应该设置这个兜底方案，对系统做最坏情况下的保护。</p>]]></content>
      
      
      <categories>
          
          <category> 场景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程实战</title>
      <link href="/2025/09/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
      <url>/2025/09/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="可见性、原子性和有序性问题：并发编程Bug的源头"><a href="#可见性、原子性和有序性问题：并发编程Bug的源头" class="headerlink" title="可见性、原子性和有序性问题：并发编程Bug的源头"></a>可见性、原子性和有序性问题：并发编程Bug的源头</h1><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>在单核时代，所有的线程都是在一颗CPU上执行，CPU缓存与内存的数据一致性容易解决。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/525e6b4dc17e61d2cb4da7e6f5f4c67ba68a3153.png" alt="image-20250908170705273"></p><p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为<strong>可见性</strong>。</p><p>多核时代，每颗CPU都有自己的缓存，这时CPU缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的CPU上执行时，这些线程操作的是不同的CPU缓存。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/39d83dc297f154950222d9a7551da57d130d8abb.png" alt="image-20250908170740063"></p><p>每执行一次add10K()方法，都会循环10000次count+&#x3D;1操作。在calc()方法中我们创建了两个线程，每个线程调用一次add10K()方法，循环10000次count+&#x3D;1操作如果改为循环1亿次，你会发现效果更明显，最终count的值接近1亿，而不是2亿。如果循环10000次，count的值接近20000，原因是两个线程不是同时启动的，有一个时差。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/abc22292dd8bfc85443ce291a89178383ce64afe.png" alt="image-20250908170851695"></p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>操作系统允许某个进程执行一小段时间，例如50毫秒，过了50毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个50毫秒称为“<strong>时间片</strong>”。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/9226bbf245fc08ebbd74c48bcfed9ef9be99e6a6.png" alt="image-20250908170951720"></p><p>在一个时间片内，如果一个进程进行一个IO操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让CPU的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得CPU的使用权了。</p><p>务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条CPU指令完成，例如上面代码中的<code>count += 1</code>，至少需要三条CPU指令。</p><ul><li>指令1：首先，需要把变量count从内存加载到CPU的寄存器；</li><li>指令2：之后，在寄存器中执行+1操作；</li><li>指令3：最后，将结果写入内存（缓存机制导致可能写入的是CPU缓存而不是内存）。</li></ul><p>操作系统做任务切换，可以发生在任何一条<strong>CPU指令</strong>执行完，是的，是CPU指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设count&#x3D;0，如果线程A在指令1执行完后做线程切换，线程A和线程B按照下图的序列执行，那么我们会发现两个线程都执行了count+&#x3D;1的操作，但是得到的结果不是我们期望的2，而是1。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/c702606869213089b3670d92e946f27e86248407.png" alt="image-20250908171038462"></p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>在Java领域一个经典的案例就是利用双重检查创建单例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有两个线程A、B同时调用getInstance()方法，他们会同时发现 <code>instance == null</code> ，于是同时对Singleton.class加锁，此时JVM保证只有一个线程能够加锁成功（假设是线程A），另外一个线程则会处于等待状态（假设是线程B）；线程A会创建一个Singleton实例，之后释放锁，锁释放后，线程B被唤醒，线程B再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程B检查 <code>instance == null</code> 时会发现，已经创建过Singleton实例了，所以线程B不会再创建一个Singleton实例。</p><p>这看上去一切都很完美，无懈可击，但实际上这个getInstance()方法并不完美。问题出在哪里呢？出在new操作上，我们以为的new操作应该是：</p><ol><li>分配一块内存M；</li><li>在内存M上初始化Singleton对象；</li><li>然后M的地址赋值给instance变量。</li></ol><p>但是实际上优化后的执行路径却是这样的：</p><ol><li>分配一块内存M；</li><li>将M的地址赋值给instance变量；</li><li>最后在内存M上初始化Singleton对象。</li></ol><p>优化后会导致什么问题呢？我们假设线程A先执行getInstance()方法，当执行完指令2时恰好发生了线程切换，切换到了线程B上；如果此时线程B也执行getInstance()方法，那么线程B在执行第一个判断时会发现 <code>instance != null</code> ，所以直接返回instance，而此时的instance是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/1df032b69cd1d24f984ed4966f34c1f78e2a7439.png" alt="image-20250908171208513"></p><h1 id="Java内存模型：看Java如何解决可见性和有序性问题"><a href="#Java内存模型：看Java如何解决可见性和有序性问题" class="headerlink" title="Java内存模型：看Java如何解决可见性和有序性问题"></a>Java内存模型：看Java如何解决可见性和有序性问题</h1><h2 id="什么是Java内存模型？"><a href="#什么是Java内存模型？" class="headerlink" title="什么是Java内存模型？"></a>什么是Java内存模型？</h2><p>Java 内存模型（JMM）是一组规范和规则，它定义了在多线程环境下，Java 程序中的变量（包括实例字段、静态字段和构成数组对象的元素）如何被写入内存以及如何从内存中读取。它的核心目标是解决在并发编程中由于可见性、原子性和有序性问题而导致的线程不安全问题</p><p>JMM 从逻辑上划分了这两种内存：</p><ul><li><strong>主内存</strong>：所有共享变量都存储在主内存中。它是所有线程共享的区域。</li><li><strong>工作内存</strong>：每个线程都有自己的工作内存，其中保存了该线程使用到的变量的<strong>主内存副本</strong>。线程对所有变量的操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。</li></ul><p><strong>交互流程</strong>：</p><ol><li>线程要读取一个共享变量时，会先从主内存<strong>复制</strong>一份到自己的工作内存。</li><li>然后线程就在自己的工作内存中操作这个副本。</li><li>操作完成后，在某个时间点再将工作内存中的副本<strong>刷新</strong>回主内存。</li></ol><h2 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a>Happens-Before 规则</h2><p>真正要表达的是：<strong>前面一个操作的结果对后续操作是可见的</strong>。</p><h3 id="程序的顺序性规则"><a href="#程序的顺序性规则" class="headerlink" title="程序的顺序性规则"></a>程序的顺序性规则</h3><p>这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。这还是比较容易理解的，比如刚才那段示例代码，按照程序的顺序，第6行代码 “x &#x3D; 42;” Happens-Before 于第7行代码 “v &#x3D; true;”，这就是规则1的内容，也比较符合单线程里面的思维：程序前面对某个变量的修改一定是对后续操作可见的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">v</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    x = <span class="number">42</span>;</span><br><span class="line">    v = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里x会是多少呢？</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h3><p>这条规则是指对一个volatile变量的写操作， Happens-Before 于后续对这个volatile变量的读操作。</p><h3 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h3><p>这条规则是指如果A Happens-Before B，且B Happens-Before C，那么A Happens-Before C。</p><p>我们将规则3的传递性应用到我们的例子中，会发生什么呢？可以看下面这幅图：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/2e84c7e0cd776461314d31731e24eaed02283e6e.png" alt="image-20250908171850247"></p><p>示例代码中的传递性规则</p><p>从图中，我们可以看到：</p><ol><li>“x&#x3D;42” Happens-Before 写变量 “v&#x3D;true” ，这是规则1的内容；</li><li>写变量“v&#x3D;true” Happens-Before 读变量 “v&#x3D;true”，这是规则2的内容 。</li></ol><p>如果线程B读到了“v&#x3D;true”，那么线程A设置的“x&#x3D;42”对线程B是可见的。也就是说，线程B能看到 “x &#x3D;&#x3D; 42”</p><h3 id="管程中锁的规则"><a href="#管程中锁的规则" class="headerlink" title="管程中锁的规则"></a>管程中锁的规则</h3><p>这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</p><p><strong>管程</strong>是一种通用的同步原语，在Java中指的就是synchronized，synchronized是Java里对管程的实现。</p><p>管程中的锁在Java里是隐式实现的，例如下面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">//此处自动加锁</span></span><br><span class="line">  <span class="comment">// x是共享变量,初始值=10</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.x &lt; <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">12</span>; </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; <span class="comment">//此处自动解锁</span></span><br></pre></td></tr></table></figure><p>假设x的初始值是10，线程A执行完代码块后x的值会变成12（执行完自动释放锁），线程B进入代码块时，能够看到线程A对x的写操作，也就是线程B能够看到x&#x3D;&#x3D;12。</p><h3 id="线程-start-规则"><a href="#线程-start-规则" class="headerlink" title="线程 start() 规则"></a>线程 start() 规则</h3><p>主线程A启动子线程B后，子线程B能够看到主线程在启动子线程B前的操作。</p><p>如果线程A调用线程B的 start() 方法（即在线程A中启动线程B），那么该start()操作 Happens-Before 于线程B中的任意操作。具体可参考下面示例代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">  <span class="comment">// 主线程调用B.start()之前</span></span><br><span class="line">  <span class="comment">// 所有对共享变量的修改，此处皆可见</span></span><br><span class="line">  <span class="comment">// 此例中，var==77</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 此处对共享变量var修改</span></span><br><span class="line"><span class="keyword">var</span> = <span class="number">77</span>;</span><br><span class="line"><span class="comment">// 主线程启动子线程</span></span><br><span class="line">B.start();</span><br></pre></td></tr></table></figure><h3 id="线程-join-规则"><a href="#线程-join-规则" class="headerlink" title="线程 join() 规则"></a>线程 join() 规则</h3><p>主线程A等待子线程B完成（主线程A通过调用子线程B的join()方法实现），当子线程B完成后（主线程A中join()方法返回），主线程能够看到子线程的操作。</p><p>换句话说就是，如果在线程A中，调用线程B的 join() 并成功返回，那么线程B中的任意操作Happens-Before 于该 join() 操作的返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">  <span class="comment">// 此处对共享变量var修改</span></span><br><span class="line">  <span class="keyword">var</span> = <span class="number">66</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 例如此处对共享变量修改，</span></span><br><span class="line"><span class="comment">// 则这个修改结果对线程B可见</span></span><br><span class="line"><span class="comment">// 主线程启动子线程</span></span><br><span class="line">B.start();</span><br><span class="line">B.join()</span><br><span class="line"><span class="comment">// 子线程所有对共享变量的修改</span></span><br><span class="line"><span class="comment">// 在主线程调用B.join()之后皆可见</span></span><br><span class="line"><span class="comment">// 此例中，var==66</span></span><br></pre></td></tr></table></figure><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ul><li><strong>原子性</strong>：通过互斥锁保证代码块的原子性。</li><li><strong>可见性</strong>：线程在进入 <code>synchronized</code> 块时，会清空工作内存，从主内存重新加载共享变量。在退出 <code>synchronized</code> 块时，会把工作内存中的修改刷新到主内存。</li></ul><p>sychronized 是一种互斥锁，一次只能允许一个线程进入被锁住的代码块。<br>sychronized 是 Java 的一个关键字，它能将代码块&#x2F;方法锁起来。<br>如果 sychronized 修饰的是实例方法，对应的锁则是对象实例。<br>如果 sychronized 修饰的是静态方法，对应的锁则是当前类的 Class 实例。<br>如果 sychronized 修饰的是代码块，对应的锁则是传入 synchronized 的对象实例。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过反编译发现，编译器会生成 ACC_SYNCHRONIZED 关键字来标识。<br>当修饰代码块的时候，会依赖 monitorenter 和 monitorexit 指令。<br>无论 sychronized 修饰的是方法还是代码块，对应的锁都是一个实例对象。</p><p>在内存中，对象一般由三部分组成，分别是对象头，对象实际数据和对齐填充。<br>重点在于对象头，对象头又由几部分组成，但是我们重点关注对象头 Mark Word 的信息就好。<br>Mark Word 会记录对象关于锁的信息。<br>又因为每个对象都会有一个与之对应的 monitor 对象，monitor 对象中存储着当前持有锁的线程和等待锁的线程队列。<br>了解 Mark Word 和 monitor 对象是理解 synchronized 原理的前提。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/ba882269a61a2af588f03893d2c73c498ea9ea7f.png" alt="image-20250910164612128"></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>在 JDK1.6 之前是重量级锁，线程进入同步代码块&#x2F;方法时，monitor 对象会把当前进入线程的 id 进行存储，设置 Mark Word 的 monitor 对象地址，并把阻塞的线程存储到 monitor 的等待线程队列中，它加锁是依赖底层操作系统的 mutex 相关指令实现，所以会有用户态和内核态之间的切换，性能损耗十分明显。</p><p>而 JDK1.6 以后引入偏向锁和轻量级锁在 JVM 层面实现加锁逻辑，不依赖底层操作系统，就没有切换的消耗。在使用 synchronized 加锁的时候，Java 并不会直接调用操作系统内核加锁，而是根据线程的竞争情况采用不同的策略逐渐升级锁，直至调用操作系统加锁。</p><p>锁的升级包含以下几个过程：</p><ul><li>调研发现，在大多数情况下，锁不仅不会存在竞争情况，而且通常会由同一个线程多次获取。在这种情况下，JVM 会将锁设置为偏向锁。偏向锁会在对象头中记录拥有偏向锁的线程的ID，并将锁标识位设置为偏向锁状态。这样，当同一个线程再次请求获取这个对象的锁时，不需要进行任何同步操作，可以直接获取到锁，提高了程序的性能。<ul><li>另一种情况是，当线程B尝试获取偏向锁时，如果此时拥有偏向锁的线程A已经执行完毕并释放了锁，JVM 会尝试撤销偏向锁，并进行锁的竞争。如果在撤销偏向锁的过程中，没有其他线程来竞争锁，JVM 会将锁的状态设置为偏向线程B，并更新对象头中记录的线程ID为线程B的ID。在这种情况下，并不会发生锁的升级。只有当线程B尝试获取锁时，线程A还没有执行完毕，即出现了竞争情况，才会发生锁的升级，进而转为轻量级锁或重量级锁。</li></ul></li><li>当系统线程出现多个线程竞争的情况时，synchronized 会从偏向锁升级为轻量级锁。需要注意的是，轻量级锁通常出现在竞争不激烈、任务执行时间短的情况下。当出现锁竞争时，例如线程A正在执行过程中，线程B开始尝试获取锁，此时synchronized会进行自旋等待。synchronized并不会立即升级为重量级锁，而是会尝试使用自适应自旋锁来获取锁。如果自旋一段时间后仍未获取到锁，synchronized会正式升级为重量级锁。</li></ul><p>整体 synchronized 的锁升级过程为：<strong>偏向锁 -&gt; 轻量级锁（自旋锁） -&gt; 重量级锁</strong>。</p><ul><li><strong>无锁状态</strong>：锁标志位为 <code>01</code>，此时不存在线程执行任务。</li><li><strong>偏向锁</strong>：系统会在 MarkWord 中记录一个<strong>线程</strong> <strong>id</strong>，当该线程再次获取锁的时候，无需再申请锁，直接获取以增加效率。</li><li><strong>轻量级锁</strong>：系统会将对象头中的锁标志位修正为”00”，加锁和解锁操作使用CAS指令来修改锁标志位。当出现锁竞争的情况时，JVM 会尝试进行一段短暂的自旋（也称为空闲自旋或忙等待），以等待锁的释放。这个自旋过程是为了避免线程进入阻塞状态，以提高锁竞争的效率。</li><li><strong>重量级锁</strong>：JVM 会尝试调用操作系统进行加锁，同时会将锁的标记位 CAS 修正为 “10” ，表示锁已经升级为重量级锁。没有抢占到锁的线程会被加入到系统内的等待队列中等待唤醒。</li></ul><p><strong>我们可以近似地理解，偏向锁和轻量级锁都是系统通过 CAS 修改对象头中的锁标记位来实现的，只有重量级锁才会调用操作系统内核进行加锁或者入队操作</strong>。一个是只需要修改点东西就能实现，一个是需要入队、阻塞、唤醒、出队等诸多步骤才能实现，谁快谁慢不言而喻！</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul><li><strong>可见性</strong>：保证对 <code>volatile</code> 变量的写操作会<strong>立即刷新</strong>到主内存，并且每次读操作都会从主内存重新读取，绕过工作内存。</li><li><strong>有序性</strong>：通过添加<strong>内存屏障</strong>来禁止指令重排序。</li><li><strong>注意</strong>：<code>volatile</code> <strong>不保证原子性</strong>（例如 <code>volatile int i; i++</code> 仍然不是原子操作）。</li></ul><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>只要在构造函数中正确初始化了 <code>final</code> 字段，并且没有“this”引用逸出，那么其他线程就能看到最终初始化后的值，无需同步。</p><p>“逸出”有点抽象，我们还是举个例子吧，在下面例子中，在构造函数里面将this赋值给了全局变量global.obj，这就是“逸出”，线程通过global.obj读取x是有可能读到0的。因此我们一定要避免“逸出”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line"><span class="comment">// 错误的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FinalFieldExample</span><span class="params">()</span> &#123; </span><br><span class="line">  x = <span class="number">3</span>;</span><br><span class="line">  y = <span class="number">4</span>;</span><br><span class="line">  <span class="comment">// 此处就是讲this逸出，</span></span><br><span class="line">  global.obj = <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何预防死锁"><a href="#如何预防死锁" class="headerlink" title="如何预防死锁"></a>如何预防死锁</h1><p>并发程序一旦死锁，一般没有特别好的方法，很多时候我们只能重启应用。因此，解决死锁问题最好的办法还是规避死锁。</p><p>只有以下这四个条件都发生时才会出现死锁：</p><ol><li>互斥，共享资源X和Y只能被一个线程占用；</li><li>占有且等待，线程T1已经取得共享资源X，在等待共享资源Y的时候，不释放共享资源X；</li><li>不可抢占，其他线程不能强行抢占线程T1占有的资源；</li><li>循环等待，线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，就是循环等待。</li></ol><p>反过来分析，<strong>也就是说只要我们破坏其中一个，就可以成功避免死锁的发生</strong>。</p><p>其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？</p><ol><li>对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</li><li>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li><li>对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li></ol><h1 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h1><p><strong>有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，这就是所谓的“活锁”</strong>。</p><p>以类比现实世界里的例子，路人甲从左手边出门，路人乙从右手边进门，两人为了不相撞，互相谦让，路人甲让路走右手边，路人乙也让路走左手边，结果是两人又相撞了。这种情况，基本上谦让几次就解决了，因为人会交流啊。可是如果这种情况发生在编程世界了，就有可能会一直没完没了地“谦让”下去，成为没有发生阻塞但依然执行不下去的“活锁”。</p><p>解决“<strong>活锁</strong>”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。</p><h1 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h1><p><strong>所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况</strong>。</p><p>如果线程优先级“不均”，在CPU繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。</p><p>解决“<strong>饥饿</strong>”问题的方案很简单，有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行。这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。</p><h1 id="用“等待-通知”机制优化循环等待"><a href="#用“等待-通知”机制优化循环等待" class="headerlink" title="用“等待-通知”机制优化循环等待"></a>用“等待-通知”机制优化循环等待</h1><p>在<strong>破坏占用且等待条件</strong>的时候，如果不能一次性申请到所有资源，就用死循环的方式来循环等待。如果apply()操作耗时非常短，而且并发冲突量也不大时，这个方案还挺不错的，但是如果apply()操作耗时长，或者并发冲突量大的时候，循环等待这种方案就不适用了，因为在这种场景下，可能要循环上万次才能获取到锁，太消耗CPU了。</p><h2 id="用synchronized实现等待-通知机制"><a href="#用synchronized实现等待-通知机制" class="headerlink" title="用synchronized实现等待-通知机制"></a>用synchronized实现等待-通知机制</h2><p>在Java语言里，等待-通知机制可以有多种实现方式，比如Java语言内置的synchronized配合wait()、notify()、notifyAll()这三个方法就能轻松实现。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/ad501ac0c02918d98708c918dd086fe19602731e.png" alt="image-20250908174313597"></p><p>在并发程序中，当一个线程进入临界区后，由于某些条件不满足，需要进入等待状态，Java对象的wait()方法就能够满足这种需求。如上图所示，当调用wait()方法后，当前线程就会被阻塞，并且进入到右边的等待队列中，<strong>这个等待队列也是互斥锁的等待队列</strong>。 线程在进入等待队列的同时，<strong>会释放持有的互斥锁</strong>，线程释放锁后，其他线程就有机会获得锁，并进入临界区了。</p><p>那线程要求的条件满足时，该怎么通知这个等待的线程呢？很简单，就是Java对象的notify()和notifyAll()方法。我在下面这个图里为你大致描述了这个过程，当条件满足时调用notify()，会通知等待队列（<strong>互斥锁的等待队列</strong>）中的线程，告诉它<strong>条件曾经满足过</strong>。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/986f66069e6becb1ea8874539f76215c071a5cfb.png" alt="image-20250908174338238"></p><p>为什么说是曾经满足过呢？因为<strong>notify()只能保证在通知时间点，条件是满足的</strong>。而被通知线程的<strong>执行时间点和通知的时间点</strong>基本上不会重合，所以当线程执行的时候，很可能条件已经不满足了（保不齐有其他线程插队）。这一点你需要格外注意。</p><p>除此之外，还有一个需要注意的点，被通知的线程要想重新执行，仍然需要获取到互斥锁（因为曾经获取的锁在调用wait()时已经释放了）。</p><p><strong>notify()是会随机地通知等待队列中的一个线程，而notifyAll()会通知等待队列中的所有线程</strong>。</p><p>假设我们有资源A、B、C、D，线程1申请到了AB，线程2申请到了CD，此时线程3申请AB，会进入等待队列（AB分配给线程1，线程3要求的条件不满足），线程4申请CD也会进入等待队列。我们再假设之后线程1归还了资源AB，如果使用notify()来通知等待队列中的线程，有可能被通知的是线程4，但线程4申请的是CD，所以此时线程4还是会继续等待，而真正该唤醒的线程3就再也没有机会被唤醒了。</p><h1 id="创建多少线程才是合适的"><a href="#创建多少线程才是合适的" class="headerlink" title="创建多少线程才是合适的"></a>创建多少线程才是合适的</h1><p><strong>在并发编程领域，提升性能本质上就是提升硬件的利用率，再具体点来说，就是提升I&#x2F;O的利用率和CPU的利用率</strong>。</p><p>如果只有一个线程，执行CPU计算的时候，I&#x2F;O设备空闲；执行I&#x2F;O操作的时候，CPU空闲，所以CPU的利用率和I&#x2F;O设备的利用率都是50%。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/9494c5be4b39fddb9a4d56bf8cf478250f851a8e.png" alt="image-20250909094950235"></p><p>如果有两个线程，如下图所示，当线程A执行CPU计算的时候，线程B执行I&#x2F;O操作；当线程A执行I&#x2F;O操作的时候，线程B执行CPU计算，这样CPU的利用率和I&#x2F;O设备的利用率就都达到了100%。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/b403f285ecd457ccead4c404e1dc8bf94e6c640b.png" alt="image-20250909095012687"></p><p>通过上面的图示，很容易看出：单位时间处理的请求数量翻了一番，也就是说吞吐量提高了1倍。</p><p>对于CPU密集型计算，多线程本质上是提升多核CPU的利用率，所以对于一个4核的CPU，每个核一个线程，理论上创建4个线程就可以了，再多创建线程也只是增加线程切换的成本。所以，<strong>对于CPU密集型的计算场景，理论上“线程的数量&#x3D;CPU核数”就是最合适的</strong>。不过在工程上，<strong>线程的数量一般会设置为“CPU核数+1”</strong>，这样的话，当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证CPU的利用率。</p><p>对于I&#x2F;O密集型的计算场景，比如前面我们的例子中，如果CPU计算和I&#x2F;O操作的耗时是1:1，那么2个线程是最合适的。如果CPU计算和I&#x2F;O操作的耗时是1:2，那多少个线程合适呢？是3个线程，如下图所示：CPU在A、B、C三个线程之间切换，对于线程A，当CPU从B、C切换回来时，线程A正好执行完I&#x2F;O操作。这样CPU和I&#x2F;O设备的利用率都达到了100%。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/8956e749062492cb16f162fd344cdbf10093526f.png" alt="image-20250909095149313"></p><p>通过上面这个例子，我们会发现，对于I&#x2F;O密集型计算场景，最佳的线程数是与程序中CPU计算和I&#x2F;O操作的耗时比相关的，我们可以总结出这样一个公式：</p><blockquote><p>最佳线程数&#x3D;1 +（I&#x2F;O耗时 &#x2F; CPU耗时）</p></blockquote><p>不过上面这个公式是针对单核CPU的，至于多核CPU，也很简单，只需要等比扩大就可以了，计算公式如下：</p><blockquote><p>最佳线程数&#x3D;CPU核数 * [ 1 +（I&#x2F;O耗时 &#x2F; CPU耗时）]</p></blockquote><p>最佳线程数最终还是靠压测来确定的，实际工作中大家面临的系统，“I&#x2F;O耗时 &#x2F; CPU耗时”往往都大于1，所以基本上都是在这个<strong>初始值的基础上增加</strong>。增加的过程中，应关注线程数是如何影响吞吐量和延迟的。</p><p>实际工作中，不同的I&#x2F;O模型对最佳线程数的影响非常大，例如大名鼎鼎的Nginx用的是非阻塞I&#x2F;O，采用的是多进程单线程结构，Nginx本来是一个I&#x2F;O密集型系统，但是最佳进程数设置的却是CPU的核数，完全参考的是CPU密集型的算法。所以，理论我们还是要活学活用。</p><h1 id="Semaphore：快速实现一个限流器"><a href="#Semaphore：快速实现一个限流器" class="headerlink" title="Semaphore：快速实现一个限流器"></a>Semaphore：快速实现一个限流器</h1><p><strong>Semaphore可以允许多个线程访问一个临界区</strong>。</p><p>比较常见的需求就是我们工作中遇到的各种池化资源，例如连接池、对象池、线程池等等。所谓对象池呢，指的是一次性创建出N个对象，之后所有的线程重复利用这N个对象，当然对象在被释放前，也是不允许其他线程使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjPool</span>&lt;T, R&gt; &#123;</span><br><span class="line">  <span class="keyword">final</span> List&lt;T&gt; pool;</span><br><span class="line">  <span class="comment">// 用信号量实现限流器</span></span><br><span class="line">  <span class="keyword">final</span> Semaphore sem;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  ObjPool(<span class="type">int</span> size, T t)&#123;</span><br><span class="line">    pool = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;T&gt;()&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">      pool.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    sem = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 利用对象池的对象，调用func</span></span><br><span class="line">  R <span class="title function_">exec</span><span class="params">(Function&lt;T,R&gt; func)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    sem.acquire();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      t = pool.remove(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> func.apply(t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      pool.add(t);</span><br><span class="line">      sem.release();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建对象池</span></span><br><span class="line">ObjPool&lt;Long, String&gt; pool = <span class="keyword">new</span> <span class="title class_">ObjPool</span>&lt;Long, String&gt;(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 通过对象池获取t，之后执行  </span></span><br><span class="line">pool.exec(t -&gt; &#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">    <span class="keyword">return</span> t.toString();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们用一个List来保存对象实例，用Semaphore实现限流器。关键的代码是ObjPool里面的exec()方法，这个方法里面实现了限流的功能。</p><p>在这个方法里面，我们首先调用acquire()方法（与之匹配的是在finally里面调用release()方法），假设对象池的大小是10，信号量的计数器初始化为10，那么前10个线程调用acquire()方法，都能继续执行，相当于通过了信号灯，而其他线程则会阻塞在acquire()方法上。对于通过信号灯的线程，我们为每个线程分配了一个对象 t（这个分配工作是通过pool.remove(0)实现的），分配完之后会执行一个回调函数func，而函数的参数正是前面分配的对象 t ；执行完回调函数之后，它们就会释放对象（这个释放工作是通过pool.add(t)实现的），同时调用release()方法来更新信号量的计数器。如果此时信号量里计数器的值小于等于0，那么说明有线程在等待，此时会自动唤醒等待的线程。</p><p>简言之，使用信号量，我们可以轻松地实现一个限流器。</p><h1 id="ReadWriteLock：快速实现一个完备的缓存"><a href="#ReadWriteLock：快速实现一个完备的缓存" class="headerlink" title="ReadWriteLock：快速实现一个完备的缓存"></a>ReadWriteLock：快速实现一个完备的缓存</h1><p>用ReadWriteLock快速实现一个通用的缓存工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span>&lt;K,V&gt; &#123;</span><br><span class="line">  <span class="keyword">final</span> Map&lt;K, V&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">  <span class="comment">// 读锁</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">  <span class="comment">// 写锁</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line">  <span class="comment">// 读缓存</span></span><br><span class="line">  V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.get(key); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写缓存</span></span><br><span class="line">  V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.put(key, v); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果源头数据的数据量不大，就可以采用一次性加载的方式，这种方式最简单（可参考下图），只需在应用启动的时候把源头数据查询出来，依次调用类似上面示例代码中的put()方法就可以了。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/9e2858eac1adea40a283eafbcb683eac52fbc9e4.png" alt="image-20250909104647306"></p><p>如果源头数据量非常大，那么就需要按需加载了，按需加载也叫懒加载，指的是只有当应用查询缓存，并且数据不在缓存里的时候，才触发加载源头相关数据进缓存的操作。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/79c545d9fac4aa013452c7aa0cff4a7ec9384a82.png" alt="image-20250909104709132"></p><p>下面你可以结合文中示意图看看如何利用ReadWriteLock 来实现缓存的按需加载。</p><p>如果缓存中没有缓存目标对象，那么就需要从数据库中加载，然后写入缓存，写缓存需要用到写锁，所以在代码中的⑤处，我们调用了 <code>w.lock()</code> 来获取写锁。</p><p>另外，还需要注意的是，在获取写锁之后，我们并没有直接去查询数据库，而是在代码⑥⑦处，重新验证了一次缓存中是否存在，再次验证如果还是不存在，我们才去查询数据库并更新本地缓存。为什么我们要再次验证呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span>&lt;K,V&gt; &#123;</span><br><span class="line">  <span class="keyword">final</span> Map&lt;K, V&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line"></span><br><span class="line">  V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//读缓存</span></span><br><span class="line">    r.lock();         ①</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      v = m.get(key); ②</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      r.unlock();     ③</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存中存在，返回</span></span><br><span class="line">    <span class="keyword">if</span>(v != <span class="literal">null</span>) &#123;   ④</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//缓存中不存在，查询数据库</span></span><br><span class="line">    w.lock();         ⑤</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//再次验证</span></span><br><span class="line">      <span class="comment">//其他线程可能已经查询过数据库</span></span><br><span class="line">      v = m.get(key); ⑥</span><br><span class="line">      <span class="keyword">if</span>(v == <span class="literal">null</span>)&#123;  ⑦</span><br><span class="line">        <span class="comment">//查询数据库</span></span><br><span class="line">        v=省略代码无数</span><br><span class="line">        m.put(key, v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是在高并发的场景下，有可能会有多线程竞争写锁。假设缓存是空的，没有缓存任何东西，如果此时有三个线程T1、T2和T3同时调用get()方法，并且参数key也是相同的。那么它们会同时执行到代码⑤处，但此时只有一个线程能够获得写锁，假设是线程T1，线程T1获取写锁之后查询数据库并更新缓存，最终释放写锁。此时线程T2和T3会再有一个线程能够获取写锁，假设是T2，如果不采用再次验证的方式，此时T2会再次查询数据库。T2释放写锁之后，T3也会再次查询一次数据库。而实际上线程T1已经把缓存的值设置好了，T2、T3完全没有必要再次查询数据库。所以，再次验证的方式，能够避免高并发场景下重复查询数据的问题。</p><h2 id="读写锁的升级与降级"><a href="#读写锁的升级与降级" class="headerlink" title="读写锁的升级与降级"></a>读写锁的升级与降级</h2><p>上面按需加载的示例代码中，在①处获取读锁，在③处释放读锁，那是否可以在②处的下面增加验证缓存并更新缓存的逻辑呢？详细的代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读缓存</span></span><br><span class="line">r.lock();         ①</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  v = m.get(key); ②</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//再次验证并更新缓存</span></span><br><span class="line">      <span class="comment">//省略详细代码</span></span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">  r.unlock();     ③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看上去好像是没有问题的，先是获取读锁，然后再升级为写锁，对此还有个专业的名字，叫<strong>锁的升级</strong>。可惜ReadWriteLock并不支持这种升级。在上面的代码示例中，读锁还没有释放，此时获取写锁，会导致写锁永久等待，最终导致相关线程都被阻塞，永远也没有机会被唤醒。锁的升级是不允许的，这个你一定要注意。</p><p>不过，虽然锁的升级是不允许的，但是锁的降级却是允许的。以下代码来源自ReentrantReadWriteLock的官方示例，略做了改动。你会发现在代码①处，获取读锁的时候线程还是持有写锁的，这种锁的降级是支持的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CachedData</span> &#123;</span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">  <span class="comment">// 读锁  </span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">  <span class="comment">//写锁</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">processCachedData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">      <span class="comment">// 释放读锁，因为不允许读锁的升级</span></span><br><span class="line">      r.unlock();</span><br><span class="line">      <span class="comment">// 获取写锁</span></span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 再次检查状态  </span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放写锁前，降级为读锁</span></span><br><span class="line">        <span class="comment">// 降级是可以的</span></span><br><span class="line">        r.lock(); ①</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放写锁</span></span><br><span class="line">        w.unlock(); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处仍然持有读锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;use(data);&#125; </span><br><span class="line">    <span class="keyword">finally</span> &#123;r.unlock();&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="StampedLock：读多写少性能最佳锁"><a href="#StampedLock：读多写少性能最佳锁" class="headerlink" title="StampedLock：读多写少性能最佳锁"></a>StampedLock：读多写少性能最佳锁</h1><h2 id="StampedLock支持的三种锁模式"><a href="#StampedLock支持的三种锁模式" class="headerlink" title="StampedLock支持的三种锁模式"></a>StampedLock支持的三种锁模式</h2><p>StampedLock支持三种模式，分别是：<strong>写锁</strong>、<strong>悲观读锁</strong>和<strong>乐观读</strong>。其中，写锁、悲观读锁的语义和ReadWriteLock的写锁、读锁的语义非常类似，允许多个线程同时获取悲观读锁，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的。不同的是：StampedLock里的写锁和悲观读锁加锁成功之后，都会返回一个stamp；然后解锁的时候，需要传入这个stamp。相关的示例代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取/释放悲观读锁示意代码</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.readLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//省略业务相关代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  sl.unlockRead(stamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取/释放写锁示意代码</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.writeLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//省略业务相关代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  sl.unlockWrite(stamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StampedLock的性能之所以比ReadWriteLock还要好，其关键是StampedLock支持乐观读的方式。ReadWriteLock支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；而StampedLock提供的乐观读，是允许一个线程获取写锁的，也就是说不是所有的写操作都被阻塞。</p><p><strong>乐观读这个操作是无锁的</strong>，所以相比较ReadWriteLock的读锁，乐观读的性能更好一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> x, y;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">  <span class="comment">//计算到原点的距离  </span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 乐观读</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.tryOptimisticRead();</span><br><span class="line">    <span class="comment">// 读入局部变量，</span></span><br><span class="line">    <span class="comment">// 读的过程数据可能被修改</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">curX</span> <span class="operator">=</span> x, curY = y;</span><br><span class="line">    <span class="comment">//判断执行读操作期间，是否存在写操作</span></span><br><span class="line">    <span class="comment">//如果存在，则sl.validate返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!sl.validate(stamp))&#123;</span><br><span class="line">      <span class="comment">// 升级为悲观读锁</span></span><br><span class="line">      stamp = sl.readLock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        curX = x;</span><br><span class="line">        curY = y;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放悲观读锁</span></span><br><span class="line">        sl.unlockRead(stamp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(</span><br><span class="line">      curX * curX + curY * curY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果执行乐观读操作的期间，存在写操作，会把乐观读升级为悲观读锁。这个做法挺合理的，否则你就需要在一个循环里反复执行乐观读，直到执行乐观读操作的期间没有写操作（只有这样才能保证x和y的正确性和一致性），而循环读会浪费大量的CPU。</p><p>StampedLock在命名上并没有增加Reentrant，<strong>StampedLock不支持重入</strong>。</p><p>还有一点需要特别注意，那就是：如果线程阻塞在StampedLock的readLock()或者writeLock()上时，此时调用该阻塞线程的interrupt()方法，会导致CPU飙升。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">inal <span class="type">StampedLock</span> <span class="variable">lock</span></span><br><span class="line">  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">T1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">  <span class="comment">// 获取写锁</span></span><br><span class="line">  lock.writeLock();</span><br><span class="line">  <span class="comment">// 永远阻塞在此处，不释放写锁</span></span><br><span class="line">  LockSupport.park();</span><br><span class="line">&#125;);</span><br><span class="line">T1.start();</span><br><span class="line"><span class="comment">// 保证T1获取写锁</span></span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">T2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;</span><br><span class="line">  <span class="comment">//阻塞在悲观读锁</span></span><br><span class="line">  lock.readLock()</span><br><span class="line">);</span><br><span class="line">T2.start();</span><br><span class="line"><span class="comment">// 保证T2阻塞在读锁</span></span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//中断线程T2</span></span><br><span class="line"><span class="comment">//会导致线程T2所在CPU飙升</span></span><br><span class="line">T2.interrupt();</span><br><span class="line">T2.join();</span><br></pre></td></tr></table></figure><p>所以，**使用StampedLock一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁readLockInterruptibly()和写锁writeLockInterruptibly()**。</p><h1 id="CountDownLatch和CyclicBarrier：如何让多线程步调一致"><a href="#CountDownLatch和CyclicBarrier：如何让多线程步调一致" class="headerlink" title="CountDownLatch和CyclicBarrier：如何让多线程步调一致"></a>CountDownLatch和CyclicBarrier：如何让多线程步调一致</h1><p>CountDownLatch和CyclicBarrier都是线程同步的工具类。</p><p><strong>CountDownLatch</strong>允许一个或多个线程一直等待，直到这些线程完成它们的操作。</p><p>而<strong>CyclicBarrier</strong>是允许一组线程之间互相等待，它往往是当线程到达某状态后，暂停下来等待其他线程，等到所有线程均到达后，才继续执行。</p><p>可以发现这两者等待的主体是不一样的。<br>CountDownLatch调用await()通常是主线程&#x2F;调用线程，而CyclicBarrier调用await()是在任务线程调用的。<br>所以，CyclicBarrier中的阻塞的是任务的线程，而主线程是不受影响的。</p><p>这两个类都是基于AQS实现的。<br>当我们构建CountDownLatch对象时，传入的值其实就会赋值给AQS的关键变量state<br>执行countDown方法时，其实就是利用CAS将state减1。<br>执行await方法时，其实就是判断state是否为0，不为0则加入到队列中，将该线程阻塞掉（除了头节点）。<br>因为头节点会一直自旋等待state为0，当state为0时，头节点把剩余的在队列中阻塞的节点也一并唤醒。</p><p>而CyclicBarrier是直接借助ReentranLock加上Condition等待唤醒功能，进而实现的。<br>在构建CyclicBarrier时，传入的值会赋值给CyclicBarrier内部维护的count变量，也会赋值给parties变量（这是可以复用的关键）。<br>每次调用await时，会将count-1，操作count值是直接使用ReentrantLock来保证线程安全性。<br>如果count不为0，则添加condition队列中，<br>如果count等于0，则把节点从condition队列添加至AQS的队列中进行全部唤醒，并且将parties的值重新赋值为count的值（实现复用）。</p><h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List里面只有一个实现类就是<strong>CopyOnWriteArrayList</strong>。CopyOnWrite，顾名思义就是写的时候会将共享变量新复制一份出来，这样做的好处是读操作完全无锁。</p><p>CopyOnWriteArrayList内部维护了一个数组，成员变量array就指向这个内部数组，所有的读操作都是基于array进行的，如下图所示，迭代器Iterator遍历的就是array数组。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/f06c4663e699c62822545b9340e0d5dcf4ec93d4.png" alt="image-20250909114326977"></p><p>如果在遍历array的同时，还有一个写操作，例如增加元素，CopyOnWriteArrayList是如何处理的呢？CopyOnWriteArrayList会将array复制一份，然后在新复制处理的数组上执行增加元素的操作，执行完之后再将array指向这个新的数组。通过下图你可以看到，读写是可以并行的，遍历操作一直都是基于原array执行，而写操作则是基于新array进行。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/423092db2304b5e43058d78561138deb1c4cf172.png" alt="image-20250909114354086"></p><p>使用CopyOnWriteArrayList需要注意的“坑”主要有两个方面。一个是应用场景，CopyOnWriteArrayList仅适用于写操作非常少的场景，而且能够容忍读写的短暂不一致。例如上面的例子中，写入的新元素并不能立刻被遍历到。另一个需要注意的是，CopyOnWriteArrayList迭代器是只读的，不支持增删改。因为迭代器遍历的仅仅是一个快照，而对快照进行增删改是没有意义的。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map接口的两个实现是ConcurrentHashMap和ConcurrentSkipListMap，它们从应用的角度来看，主要区别在于<strong>ConcurrentHashMap的key是无序的，而ConcurrentSkipListMap的key是有序的</strong>。所以如果你需要保证key的顺序，就只能使用ConcurrentSkipListMap。</p><p>使用ConcurrentHashMap和ConcurrentSkipListMap需要注意的地方是，它们的key和value都不能为空，否则会抛出<code>NullPointerException</code>这个运行时异常。</p><blockquote><p>ConcurrentHashMap 为什么 key 和 value 不能为 null？</p></blockquote><p>key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。如果你用null作为键，那么你就无法区分这个键是否存在于ConcurrentHashMap中，还是根本没有这个键。同样，如果你用null作为值，那么你就无法区分这个值是否是真正存储在ConcurrentHashMap中的，还是因为找不到对应的键而返回的。<br>拿 get 方法取值来说，返回的结果为 null 存在两种情况： - 值没有在集合中 ； - 值本身就是 null。 这也就是二义性的由来。 具体可以参考 [ConcurrentHashMap 源码分析]( <a href="https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html" title="ConcurrentHashMap 源码分析 | JavaGuide(Java面试   学习指南)">ConcurrentHashMap 源码分析 | JavaGuide(Java面试 学习指南)</a> ) 。<br>多线程环境下，存在一个线程操作该ConcurrentHashMap时，其他的线程将该ConcurrentHashMap修改的情况，所以无法通过 containsKey(key)来判断否存在这个键值对，也就没办法解决二义性问题了。 与此形成对比的是，HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入null作为参数，就会返回hash值为0的位置的值。单线程环境下，不存在一个线程操作该HashMap时，其他的线程将该HashMap修改的情况，所以可以通过contains(key)来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。 </p><blockquote><p>为什么源码不设计成可以判断是否存在null值的key？</p></blockquote><p>正如上面所述，如果允许key为null，那么就会带来很多不必要的麻烦和开销。比如，你需要用额外的数据结构或者标志位来记录哪些key是null的，而且在多线程环境下，还要保证对这些额外的数据结构或者标志位的操作也是线程安全的。而且，key为null的意义也不大，因为它并不能表示任何有用的信息。 如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。 <code>java public static final Object NULL = new Object(); </code> </p><blockquote><p>containsKey方法后被修改，导致不可重复读，算线程不安全吗? </p></blockquote><p>ConcurrentHashMap 是线程安全的，但它不能保证所有的复合操作都是原子性的。如果需要保证复合操作的原子性，就要使用额外的同步或协调机制。这并不违反线程安全的定义，而是属于不同层次的一致性要求。 containsKey() 和 get() 方法都是单独的操作，它们之间没有同步保证。因此，如果在调用 containsKey() 后，另一个线程修改或删除了相应的键值对，那么 get() 方法可能会返回 null 或者过期的值。这确实是不可重复读的情况，但这并不违反线程安全的定义。 为什么不提供类似for update的方法呢？ Java 8中，ConcurrentHashMap增加了一些原子更新操作的方法，如compute、computeIfAbsent、computeIfPresent、merge等等。这些方法都可以接受一个函数作为参数，根据给定的key和value来计算一个新的value，并且将其更新到map中。</p><p>ConcurrentSkipListMap里面的SkipList本身就是一种数据结构，中文一般都翻译为“跳表”。跳表插入、删除、查询操作平均的时间复杂度是 O(log n)，理论上和并发线程数没有关系，所以在并发度非常高的情况下，若你对ConcurrentHashMap的性能还不满意，可以尝试一下ConcurrentSkipListMap。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set接口的两个实现是CopyOnWriteArraySet和ConcurrentSkipListSet，使用场景可以参考前面讲述的CopyOnWriteArrayList和ConcurrentSkipListMap，它们的原理都是一样的，这里就不再赘述了。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Java并发包里面Queue这类并发容器是最复杂的，你可以从以下两个维度来分类。</p><p>一个维度是<strong>阻塞与非阻塞</strong>，所谓阻塞指的是当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。</p><p>另一个维度是<strong>单端与双端</strong>，单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。Java并发包里<strong>阻塞队列都用Blocking关键字标识，单端队列使用Queue标识，双端队列使用Deque标识</strong>。</p><p>这两个维度组合后，可以将Queue细分为四大类，分别是：</p><p>1.<strong>单端阻塞队列</strong>：其实现有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、LinkedTransferQueue、PriorityBlockingQueue和DelayQueue。</p><p>内部一般会持有一个队列，这个队列可以是数组（其实现是ArrayBlockingQueue）也可以是链表（其实现是LinkedBlockingQueue）；甚至还可以不持有队列（其实现是SynchronousQueue），此时生产者线程的入队操作必须等待消费者线程的出队操作。</p><p>而LinkedTransferQueue融合LinkedBlockingQueue和SynchronousQueue的功能，性能比LinkedBlockingQueue更好；</p><p>PriorityBlockingQueue支持按照优先级出队；</p><p>DelayQueue支持延时出队。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/57bc6af2b278aa6012275440033164e8de07de08.png" alt="image-20250909140930497"></p><p>2.<strong>双端阻塞队列</strong>：其实现是LinkedBlockingDeque。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/b74ef2deac8b873cefa72a16256582935d15f30e.png" alt="image-20250909140951805"></p><p>3.<strong>单端非阻塞队列</strong>：其实现是ConcurrentLinkedQueue。</p><p>4.<strong>双端非阻塞队列</strong>：其实现是ConcurrentLinkedDeque。</p><p>使用队列时，需要格外注意队列是否支持有界（所谓有界指的是内部的队列是否有容量限制）。实际工作中，一般都不建议使用无界的队列，因为数据量大了之后很容易导致OOM。</p><p>上面我们提到的这些Queue中，只有ArrayBlockingQueue和LinkedBlockingQueue是支持有界的，所以<strong>在使用其他无界队列时，一定要充分考虑是否存在导致OOM的隐患</strong>。</p><h2 id="无锁方案实现原理"><a href="#无锁方案实现原理" class="headerlink" title="无锁方案实现原理"></a>无锁方案实现原理</h2><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p><strong>只有当目前count的值和期望值expect相等时，才会将count更新为newValue</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimulatedCAS</span>&#123;</span><br><span class="line">  <span class="type">int</span> count；</span><br><span class="line">  <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">cas</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> expect, <span class="type">int</span> newValue)</span>&#123;</span><br><span class="line">    <span class="comment">// 读目前count的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">curValue</span> <span class="operator">=</span> count;</span><br><span class="line">    <span class="comment">// 比较目前count值是否==期望值</span></span><br><span class="line">    <span class="keyword">if</span>(curValue == expect)&#123;</span><br><span class="line">      <span class="comment">// 如果是，则更新count的值</span></span><br><span class="line">      count = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回写入前的值</span></span><br><span class="line">    <span class="keyword">return</span> curValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用CAS来解决并发问题，一般都会伴随着自旋，而所谓自旋，其实就是循环尝试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimulatedCAS</span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line">  <span class="comment">// 实现count+=1</span></span><br><span class="line">  addOne()&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      newValue = count+<span class="number">1</span>; <span class="comment">//①</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(count !=</span><br><span class="line">      cas(count,newValue) <span class="comment">//②</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 模拟实现CAS，仅用来帮助理解</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">cas</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> expect, <span class="type">int</span> newValue)</span>&#123;</span><br><span class="line">    <span class="comment">// 读目前count的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">curValue</span> <span class="operator">=</span> count;</span><br><span class="line">    <span class="comment">// 比较目前count值是否==期望值</span></span><br><span class="line">    <span class="keyword">if</span>(curValue == expect)&#123;</span><br><span class="line">      <span class="comment">// 如果是，则更新count的值</span></span><br><span class="line">      count= newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回写入前的值</span></span><br><span class="line">    <span class="keyword">return</span> curValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在CAS方案中，有一个问题可能会常被你忽略，那就是<strong>ABA</strong>的问题。</p><p>前面我们提到“如果cas(count,newValue)返回的值<strong>不等于</strong>count，意味着线程在执行完代码①处之后，执行代码②处之前，count的值被其他线程<strong>更新过</strong>”，那如果cas(count,newValue)返回的值<strong>等于</strong>count，是否就能够认为count的值没有被其他线程<strong>更新过</strong>呢？显然不是的，假设count原本是A，线程T1在执行完代码①处之后，执行代码②处之前，有可能count被线程T2更新成了B，之后又被T3更新回了A，这样线程T1虽然看到的一直是A，但是其实已经被其他线程更新过了，这就是ABA问题。</p><p>解决ABA问题的最简单粗暴的方式就是加个版本号，每更新过一次就+1，这样即使更新回了原值，也会被记录下来。</p><p>我们所熟知的原子类AtomicLong的底层就是CAS实现的，在Java 1.8版本中，getAndIncrement()方法会转调unsafe.getAndAddLong()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddLong(<span class="built_in">this</span>, valueOffset, <span class="number">1L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unsafe.getAndAddLong()方法的源码如下，该方法首先会在内存中读取共享变量的值，之后循环调用compareAndSwapLong()方法来尝试设置共享变量的值，直到成功为止。compareAndSwapLong()是一个native方法，只有当内存中共享变量的值等于expected时，才会将共享变量的值更新为x，并且返回true；否则返回fasle。compareAndSwapLong的语义和CAS指令的语义的差别仅仅是返回值不同而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getAndAddLong</span><span class="params">(</span></span><br><span class="line"><span class="params">  Object o, <span class="type">long</span> offset, <span class="type">long</span> delta)</span>&#123;</span><br><span class="line">  <span class="type">long</span> v;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 读取内存中的值</span></span><br><span class="line">    v = getLongVolatile(o, offset);</span><br><span class="line">  &#125; <span class="keyword">while</span> (!compareAndSwapLong(</span><br><span class="line">      o, offset, v, v + delta));</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子性地将变量更新为x</span></span><br><span class="line"><span class="comment">//条件是内存中的值等于expected</span></span><br><span class="line"><span class="comment">//更新成功则返回true</span></span><br><span class="line"><span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(</span></span><br><span class="line"><span class="params">  Object o, <span class="type">long</span> offset, </span></span><br><span class="line"><span class="params">  <span class="type">long</span> expected,</span></span><br><span class="line"><span class="params">  <span class="type">long</span> x)</span>;</span><br></pre></td></tr></table></figure><p>Java提供的原子类里面CAS一般被实现为compareAndSet()，compareAndSet()的语义和CAS指令的语义的差别仅仅是返回值不同而已，compareAndSet()里面如果更新成功，则会返回true，否则返回false。</p><h1 id="AQS：保证并发安全的终极奥秘"><a href="#AQS：保证并发安全的终极奥秘" class="headerlink" title="AQS：保证并发安全的终极奥秘"></a>AQS：保证并发安全的终极奥秘</h1><p>AQS 是 Java 并发包的核心，它的理念和设计思想贯穿于 Java 中许多并发工具和框架，如 ReentrantLock、Semaphore、CountDownLatch 等。</p><h2 id="AQS-在-ReentrantLock-的应用"><a href="#AQS-在-ReentrantLock-的应用" class="headerlink" title="AQS 在 ReentrantLock 的应用"></a>AQS 在 ReentrantLock 的应用</h2><p>我们来使用一张图来描述 ReentrantLock 对于 AQS 的应用：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/ea862502337fb6abaafaf9a8af032c003df49741.png" alt="image-20250910174354523"></p><p>我们分析下上图，在 ReetrantLock 中存在加锁和解锁两个方法，这两个方法是借助 Sync 这个内部类来完成的。Sync 这个内部类实现了 AQS 抽象类，并实现了公平锁和非公平锁两种加锁方式！</p><p>公平锁的 <strong>FairSync#tryAcquire</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前的线程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取当前的加锁状态 在ReentrantLock中，state=0的时候是没有加锁，state=1的时候是加锁状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有人占用锁的时候，因为是公平锁，所以优先判断队列中是否存在排队的</span></span><br><span class="line">        <span class="comment">// 如果没有排队的，直接使用CAS进行加锁，将0 替换为 1，</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 将当前线程设置到exclusiveOwnerThread变量，表示这个线程持有锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="comment">//返回加锁成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//我们在前面讲过，ReentrantLock是可重入锁，当前面逻辑加锁失败，则判断是不是当前线程持有的锁，如果是当前线程持有锁，则符合可重入规则</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">//将state 累加  由 1  变成 2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果存在排队任务，或者CAS变换state的值失败，则证明当前不能加锁，直接返回false加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的注释能够印证出我们前面所学的，公平锁、可重入锁、CAS 的特性。</p><ul><li>首先进行加锁的时候，因为公平锁的原因，会先判断等待队列中是否存在任务。如果存在，就不能去加锁，需要去排队！如果没有排队的任务，那么就开始使用 CAS 进行加锁，此时可能会出现其他线程也在加锁，如果其他线程加锁成功，那么此时 CAS 就会返回 false。</li><li>假设上面的加锁条件全部满足，就能够加锁成功，它会将 state 变为 1，将当前线程设置到一个变量中去，并且为了保证重入锁的特性，将当前线程保存到变量中，表示这个线程持有这把锁。</li><li>如果上面的加锁条件不满足，不会第一时间就返回加锁失败，因为 ReentrantLock 是可重入锁，所以在加锁失败后，会判断当前持有锁的线程和所需要加锁的线程是不是一个，如果是一个就附和可重入锁的特性，那么就把加锁数量 +1，同时返回加锁成功。</li><li>如果全部都不满足，则直接返回 false，加锁失败。</li></ul><p>我们使用一个图来理解这个流程：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/40a848f019bb80afa664c3876b24d128db5462c3.png" alt="image-20250910174532176"></p><p>线程加锁失败后，会开始进行入队操作，也就是 <strong>addWaiter</strong> 方法。AQS 的队列与传统队列不同，AQS 的队列是一个双向链表，排队的线程都是用 next 指向下一个节点任务。head 节点可能为空，因为当第一个任务入队的时候，会初始化 head 节点，head 节点内线程数据为空，但是 head 节点的 next 会指向第一个等待线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个node节点 排它锁的mode = null</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 获取当前的尾节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//将当前节点的上一个节点设置为尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// cas替换 将当前节点设置为tail节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">//将当前的尾节点的下一节点设为当前追加的节点</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//针对第一个任务初始化head节点操作</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是整个AQS的执行流程及加锁逻辑：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/c62be37f9d8c32e0db046409ffcf7921a1e095d5.png" alt="Pasted image 20230719091028"></p><p>简单来说，加锁无非就是通过 CAS 去改变 State 的值，等于 0 且能改变成功就加锁成功，如果改变失败，就入队后阻塞。</p><p>解锁流程：</p><ol><li>解锁就是对 state 进行减一操作（重入次数 -1），当 state &#x3D; 0 的时候，就将持有锁的线程设置为 null，且返回解锁的结果。</li><li>因为 <code>ReentrantLock</code> 是可重入锁，一个线程多次获取锁，state 的数量会大于 1，当解锁的时候，必须当前<strong>线程解锁次数 &#x3D; 加锁次数</strong>才能解锁成功，否则解锁失败。</li><li>无论是解锁成功与否，都必须将当前 state 的数量使用 CAS 更新为最新的。</li></ol><p>解锁成功后，会调用 head 节点后的等到任务的 unPark 解锁线程，使得阻塞的线程重新开始循环获取锁的操作，直到获取锁成功。</p><ul><li><strong>公平锁当发现 state &#x3D; 0 也就是没有任务占有锁的情况下，会判断队列中是存在等待任务，如果存在就会加锁失败，然后执行入队操作。</strong></li><li><strong>而非公平锁发现 state &#x3D; 0 也就是没有任务占有锁的情况下，会直接进行 CAS 加锁，只要 CAS 加锁成功了，就会直接返回加锁成功而不会进行入队操作</strong></li></ul><h2 id="AQS-在-CountDownLatch-的应用"><a href="#AQS-在-CountDownLatch-的应用" class="headerlink" title="AQS 在 CountDownLatch 的应用"></a>AQS 在 CountDownLatch 的应用</h2><p>与 ReentrantLock 相同的是，我们同样可以在 CountDownLatch 中寻找到 AQS 的实现类 Sync。没错，CountDownLatch 的实现也是基于 AQS 来做的。</p><p>在初始化 CountDownLatch 的时候，我们传递了 10，然后开启了 10 个线程执行任务，每一个线程执行完毕之后都会调用 <code>countDownLatch.countDown();</code> 来进行递减操作。我们在主线程调用 <code>countDownLatch.await();</code> 来等待 CountDownLatch 变为 0 后，它会解除阻塞继续向下执行！</p><p>当 state 的值不为 0 的时候，证明 CountDown 还没有释放完毕，此时应该阻塞，先将当前节点加入到等待队列，然后同 ReentrantLock 一样，在阻塞之前也会先判断自己是不是 head 的下一个节点，如果是的话会再次尝试判断一下 state 是不是等于 0 了，如果此时等于 0 了，就不用阻塞了，可以直接返回。</p><p>此时如果 state 依旧不为 0，则开始与 ReentrantLock 一样调用 park 进行阻塞等待唤醒。</p><p>事实上，await 阻塞的逻辑十分简单。我们总结来说，就是当程序调用 await 方法的时候，会判断 state 的值是不是 0，如果不是 0 就阻塞，是 0 就直接返回。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/9f0ba1d75a6936cc20df70470f5f42465e6fde4b.png" alt="image-20250910175742428"></p><p>countDown 方法主要就是对 AQS 中 State 的值进行 -1 操作，当 State 的值为 0 的时候，就开始唤醒等待队列中的任务。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/29157b26ff0dd978d0b72cfb2327de6522c6f44f.png" alt="image-20250910175837917"></p><h2 id="AQS-在-ReentrantReadWriteLock-的应用"><a href="#AQS-在-ReentrantReadWriteLock-的应用" class="headerlink" title="AQS 在 ReentrantReadWriteLock 的应用"></a>AQS 在 ReentrantReadWriteLock 的应用</h2><p>AQS 中 state 主要是为了记录加锁的次数或者计数次数，但是在 ReentrantReadWriteLock 中存在读锁（共享锁）和写锁（独占锁）两种，那么此时只有一个 state 肯定是无法满足的，因为 state 是一个 int 值，我们知道 int 在 Java 占 32 位字节，所以我们考虑<strong>将 32 位分为高 16 位和低 16 位</strong>，如下图所示：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/5e8b8730fb45c3d0758136f4d194368fa76aae26.png" alt="image-20250910180229529"></p><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><p>共享锁的加锁逻辑就是先判断是不是存在写锁，存在写锁就直接加锁失败入队，不存在就加锁成功并修改 state 的高 16 位数据，并在每一个线程维护一个计数器，来计算每一个线程加锁的次数。</p><p>共享锁的解锁比较简单，解锁过程简单来说无非就是将累加器中的累加次数 -1，同时将 state 中的高 16 位 -1（state - 65536），然后再通知等待队列中的任务进行解除阻塞。</p><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>首先，它是一个独占锁，所以我们需要先判断 state 的低 16 位是不是已经存在独占锁了，如果已经存在独占锁了，那么我们就需要判断是不是重入锁！如果 state 中已经存在独占锁了，而且也不是重入锁，那么直接加锁失败，将任务放到任务队列中就可以了。</p><p>了解了写锁的加锁步骤之后，解锁步骤能猜出来：</p><ol><li>将 state - 1；</li><li>判断当前 state 的写锁数量，如果为 0 的话证明重入锁释放完毕，直接将加锁线程置空，并解锁成功。</li></ol><h1 id="Executor与线程池：如何创建正确的线程池"><a href="#Executor与线程池：如何创建正确的线程池" class="headerlink" title="Executor与线程池：如何创建正确的线程池"></a>Executor与线程池：如何创建正确的线程池</h1><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>ThreadPoolExecutor的构造函数非常复杂，如下面代码所示，这个最完备的构造函数有7个参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ThreadPoolExecutor</span>(</span><br><span class="line">  <span class="type">int</span> corePoolSize,</span><br><span class="line">  <span class="type">int</span> maximumPoolSize,</span><br><span class="line">  <span class="type">long</span> keepAliveTime,</span><br><span class="line">  TimeUnit unit,</span><br><span class="line">  BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">  ThreadFactory threadFactory,</span><br><span class="line">  RejectedExecutionHandler handler) </span><br></pre></td></tr></table></figure><p>下面我们一一介绍这些参数的意义，你可以<strong>把线程池类比为一个项目组，而线程就是项目组的成员</strong>。</p><ul><li><p><strong>corePoolSize</strong>：表示线程池保有的最小线程数。有些项目很闲，但是也不能把人都撤了，至少要留corePoolSize个人坚守阵地。</p></li><li><p><strong>maximumPoolSize</strong>：表示线程池创建的最大线程数。当项目很忙时，就需要加人，但是也不能无限制地加，最多就加到maximumPoolSize个人。当项目闲下来时，就要撤人了，最多能撤到corePoolSize个人。</p></li><li><p><strong>keepAliveTime &amp; unit</strong>：上面提到项目根据忙闲来增减人员，那在编程世界里，如何定义忙和闲呢？很简单，一个线程如果在一段时间内，都没有执行任务，说明很闲，keepAliveTime 和 unit 就是用来定义这个“一段时间”的参数。也就是说，如果一个线程空闲了<code>keepAliveTime &amp; unit</code>这么久，而且线程池的线程数大于 corePoolSize ，那么这个空闲的线程就要被回收了。</p></li><li><p><strong>workQueue</strong>：工作队列，和上面示例代码的工作队列同义。</p></li><li><p><strong>threadFactory</strong>：通过这个参数你可以自定义如何创建线程，例如你可以给线程指定一个有意义的名字。</p></li><li><p>handler</p><p>：通过这个参数你可以自定义任务的拒绝策略。如果线程池中所有的线程都在忙碌，并且工作队列也满了（前提是工作队列是有界队列），那么此时提交任务，线程池就会拒绝接收。至于拒绝的策略，你可以通过handler这个参数来指定。ThreadPoolExecutor已经提供了以下4种策略。</p><ul><li>CallerRunsPolicy：提交任务的线程自己去执行该任务。</li><li>AbortPolicy：默认的拒绝策略，会throws RejectedExecutionException。</li><li>DiscardPolicy：直接丢弃任务，没有任何异常抛出。</li><li>DiscardOldestPolicy：丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入到工作队列。</li></ul></li></ul><h2 id="线程池处理任务流程"><a href="#线程池处理任务流程" class="headerlink" title="线程池处理任务流程"></a>线程池处理任务流程</h2><p>当我们向线程池中提交了大量的任务后，提交的任务会经历以下的历程：</p><ul><li>任务开始提交后，当线程池中的线程数小于 corePoolSize 的时候，那么线程池会立即创建一个新的线程去执行这个任务，因此这个任务会被立即运行。</li><li>随着任务数量的提升，当线程池中的线程数大于等于 corePoolSize 且小于 maximumPoolSize 的时候，线程池会将这些任务暂时存放在 workQueue 中等待核心线程运行完毕后，来消费这些等待的任务。</li><li>随着任务数量还在不停地上涨，任务队列（workQueue）也放不下了，任务已经被放满，此时会开始继续新建线程去消费任务队列的任务，直到当前线程池中存活的线程数量等于 maximumPoolSize 为止。</li><li>此时，如果系统还在不停地提交任务，workQueue 被放满了，线程池中存活的线程数量也等于 maximumPoolSize 了，那么线程池会认为它执行不了这么多任务。为了避免出现不可预测的问题，那么超出线程池极限的这部分任务，会被线程池调用拒绝策略（Handler）来拒绝执行。</li><li>终于，一波任务高峰过去了，系统终于不再提交新的任务，此时 maximumPoolSize 个线程会赶紧将手头的任务执行完毕，然后开始协助消费 workQueue 中等待的任务，直至将等待队列中的任务消费完毕。此时 maximumPoolSize 个线程开始没活干了，就开始闲着，当空闲时间超过了 <strong>keepAliveTime 与 unit</strong> 所规定的空闲时间，线程池就开始回收这些空闲的线程，直至线程池中存活的线程数量等于 corePoolSize 为止。</li></ul><h2 id="使用线程池要注意些什么"><a href="#使用线程池要注意些什么" class="headerlink" title="使用线程池要注意些什么"></a>使用线程池要注意些什么</h2><p>不建议使用Executors的最重要的原因是：Executors提供的很多方法默认使用的都是无界的LinkedBlockingQueue，高负载情境下，无界队列很容易导致OOM，而OOM会导致所有请求都无法处理，这是致命问题。所以<strong>强烈建议使用有界队列</strong>。</p><p>使用有界队列，当任务过多时，线程池会触发执行拒绝策略，线程池默认的拒绝策略会throw RejectedExecutionException 这是个运行时异常，对于运行时异常编译器并不强制catch它，所以开发人员很容易忽略。因此<strong>默认拒绝策略要慎重使用</strong>。如果线程池处理的任务非常重要，建议自定义自己的拒绝策略；并且在实际工作中，自定义的拒绝策略往往和降级策略配合使用。</p><p>使用线程池，还要注意异常处理的问题，例如通过ThreadPoolExecutor对象的execute()方法提交任务时，如果任务在执行的过程中出现运行时异常，会导致执行任务的线程终止；不过，最致命的是任务虽然异常了，但是你却获取不到任何通知，这会让你误以为任务都执行得很正常。虽然线程池提供了很多用于异常处理的方法，但是最稳妥和简单的方案还是捕获所有异常并按需处理，你可以参考下面的示例代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//业务逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">  <span class="comment">//按需处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">  <span class="comment">//按需处理</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="ThreadLocal：线程本地存储模式"><a href="#ThreadLocal：线程本地存储模式" class="headerlink" title="ThreadLocal：线程本地存储模式"></a>ThreadLocal：线程本地存储模式</h1><p>Java的实现里面也有一个Map，叫做ThreadLocalMap，不过持有ThreadLocalMap的不是ThreadLocal，而是Thread。Thread这个类内部有一个私有属性threadLocals，其类型就是ThreadLocalMap，ThreadLocalMap的Key是ThreadLocal。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/ad2c2e1196e4cc6bf4a0d507c4cc8524489fa836.png" alt="image-20250909190952775"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="comment">//内部持有ThreadLocalMap</span></span><br><span class="line">  ThreadLocal.ThreadLocalMap  threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//首先获取线程持有的</span></span><br><span class="line">    <span class="comment">//ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> Thread.currentThread().threadLocals;</span><br><span class="line">    <span class="comment">//在ThreadLocalMap中</span></span><br><span class="line">    <span class="comment">//查找变量</span></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span>  map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> e.value;  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span>&#123;</span><br><span class="line">    <span class="comment">//内部是数组而不是Map</span></span><br><span class="line">    Entry[] table;</span><br><span class="line">    <span class="comment">//根据ThreadLocal查找Entry</span></span><br><span class="line">    Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal key)</span>&#123;</span><br><span class="line">      <span class="comment">//省略查找逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Entry定义</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span></span><br><span class="line">    <span class="title class_">WeakReference</span>&lt;ThreadLocal&gt;&#123;</span><br><span class="line">      Object value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Java的实现方案里面，ThreadLocal仅仅是一个代理工具类，内部并不持有任何与线程相关的数据，所有和线程相关的数据都存储在Thread里面，这样的设计容易理解。而从数据的亲缘性上来讲，ThreadLocalMap属于Thread也更加合理。</p><p>当然还有一个更加深层次的原因，那就是<strong>不容易产生内存泄露</strong>。</p><p>Java的实现中Thread持有ThreadLocalMap，而且ThreadLocalMap里对ThreadLocal的引用还是弱引用（WeakReference），所以只要Thread对象可以被回收，那么ThreadLocalMap就能被回收。</p><h2 id="ThreadLocal与内存泄露"><a href="#ThreadLocal与内存泄露" class="headerlink" title="ThreadLocal与内存泄露"></a>ThreadLocal与内存泄露</h2><blockquote><p>在线程池中使用ThreadLocal为什么可能导致内存泄露呢？</p></blockquote><p>原因就出在线程池中线程的存活时间太长，往往都是和程序同生共死的，这就意味着Thread持有的ThreadLocalMap一直都不会被回收，再加上ThreadLocalMap中的Entry对ThreadLocal是弱引用（WeakReference），所以只要ThreadLocal结束了自己的生命周期是可以被回收掉的。但是Entry中的Value却是被Entry强引用的，所以即便Value的生命周期结束了，Value也是无法被回收的，从而导致内存泄露。</p><p>既然JVM不能做到自动释放对Value的强引用，那我们手动释放就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es;</span><br><span class="line">ThreadLocal tl;</span><br><span class="line">es.execute(()-&gt;&#123;</span><br><span class="line">  <span class="comment">//ThreadLocal增加变量</span></span><br><span class="line">  tl.set(obj);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 省略业务逻辑代码</span></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//手动清理ThreadLocal </span></span><br><span class="line">    tl.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="高性能限流器Guava-RateLimiter"><a href="#高性能限流器Guava-RateLimiter" class="headerlink" title="高性能限流器Guava RateLimiter"></a>高性能限流器Guava RateLimiter</h1><p>Guava是Google开源的Java类库，提供了一个工具类RateLimiter。我们先来看看RateLimiter的使用，让你对限流有个感官的印象。假设我们有一个线程池，它每秒只能处理两个任务，如果提交的任务过快，可能导致系统不稳定，这个时候就需要用到限流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限流器流速：2个请求/秒</span></span><br><span class="line"><span class="type">RateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">2.0</span>);</span><br><span class="line"><span class="comment">//执行任务的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//记录上一次执行时间</span></span><br><span class="line">prev = System.nanoTime();</span><br><span class="line"><span class="comment">//测试执行20次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">  <span class="comment">//限流器限流</span></span><br><span class="line">  limiter.acquire();</span><br><span class="line">  <span class="comment">//提交任务异步执行</span></span><br><span class="line">  es.execute(()-&gt;&#123;</span><br><span class="line">    <span class="type">long</span> cur=System.nanoTime();</span><br><span class="line">    <span class="comment">//打印时间间隔：毫秒</span></span><br><span class="line">    System.out.println((cur-prev)/<span class="number">1000_000</span>);</span><br><span class="line">    prev = cur;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>…<br>500<br>499<br>499<br>500<br>499</p><h2 id="经典限流算法：令牌桶算法"><a href="#经典限流算法：令牌桶算法" class="headerlink" title="经典限流算法：令牌桶算法"></a>经典限流算法：令牌桶算法</h2><p>Guava采用的是<strong>令牌桶算法</strong>，其<strong>核心是要想通过限流器，必须拿到令牌</strong>。也就是说，只要我们能够限制发放令牌的速率，那么就能控制流速了。令牌桶算法的详细描述如下：</p><ol><li>令牌以固定的速率添加到令牌桶中，假设限流的速率是 r&#x2F;秒，则令牌每 1&#x2F;r 秒会添加一个；</li><li>假设令牌桶的容量是 b ，如果令牌桶已满，则新的令牌会被丢弃；</li><li>请求能够通过限流器的前提是令牌桶中有令牌。</li></ol><p>这个算法中，限流的速率 r 还是比较容易理解的，但令牌桶的容量 b 该怎么理解呢？b 其实是burst的简写，意义是<strong>限流器允许的最大突发流量</strong>。比如b&#x3D;10，而且令牌桶中的令牌已满，此时限流器允许10个请求同时通过限流器，当然只是突发流量而已，这10个请求会带走10个令牌，所以后续的流量只能按照速率 r 通过限流器。</p><p>令牌桶这个算法，如何用Java实现呢？</p><p>很可能你的直觉会告诉你生产者-消费者模式：一个生产者线程定时向阻塞队列中添加令牌，而试图通过限流器的线程则作为消费者线程，只有从阻塞队列中获取到令牌，才允许通过限流器。</p><p>可实际情况却是使用限流的场景大部分都是高并发场景，而且系统压力已经临近极限了，此时这个实现就有问题了。问题就出在定时器上，在高并发场景下，当系统压力已经临近极限的时候，定时器的精度误差会非常大，同时定时器本身会创建调度线程，也会对系统的性能产生影响。</p><h2 id="Guava如何实现令牌桶算法"><a href="#Guava如何实现令牌桶算法" class="headerlink" title="Guava如何实现令牌桶算法"></a>Guava如何实现令牌桶算法</h2><p>Guava实现令牌桶算法，用了一个很简单的办法，其关键是<strong>记录并动态计算下一令牌发放的时间</strong>。</p><p>假设令牌桶的容量为 b&#x3D;1，限流速率 r &#x3D; 1个请求&#x2F;秒，如下图所示，如果当前令牌桶中没有令牌，下一个令牌的发放时间是在第3秒，而在第2秒的时候有一个线程T1请求令牌，此时该如何处理呢？</p><p><img src="https://i0.hdslb.com/bfs/openplatform/ecbcdfd6834fbcb0a5193a2b870bc18528225e63.png" alt="image-20250910160423107"></p><p>对于这个请求令牌的线程而言，很显然需要等待1秒，因为1秒以后（第3秒）它就能拿到令牌了。此时需要注意的是，下一个令牌发放的时间也要增加1秒，为什么呢？因为第3秒发放的令牌已经被线程T1预占了。处理之后如下图所示。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/2152701f00cb9e5cdff36719e4320442e5ef427c.png" alt="image-20250910160451591"></p><p>假设T1在预占了第3秒的令牌之后，马上又有一个线程T2请求令牌，如下图所示。</p><p>很显然，由于下一个令牌产生的时间是第4秒，所以线程T2要等待两秒的时间，才能获取到令牌，同时由于T2预占了第4秒的令牌，所以下一令牌产生时间还要增加1秒，完全处理之后，如下图所示。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/a17f801cf65aa8d6bc99e6bb17cc64cfb425b688.png" alt="image-20250910160522162"></p><p>上面线程T1、T2都是在<strong>下一令牌产生时间之前</strong>请求令牌，如果线程在<strong>下一令牌产生时间之后</strong>请求令牌会如何呢？假设在线程T1请求令牌之后的5秒，也就是第7秒，线程T3请求令牌，如下图所示。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/373c0630e3f88b7e13312e3aff8d092369778874.png" alt="image-20250910160539644"></p><p>由于在第5秒已经产生了一个令牌，所以此时线程T3可以直接拿到令牌，而无需等待。在第7秒，实际上限流器能够产生3个令牌，第5、6、7秒各产生一个令牌。由于我们假设令牌桶的容量是1，所以第6、7秒产生的令牌就丢弃了，其实等价地你也可以认为是保留的第7秒的令牌，丢弃的第5、6秒的令牌，也就是说第7秒的令牌被线程T3占有了，于是下一令牌的的产生时间应该是第8秒，如下图所示。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/ee575bff63b1ab97666a92a7ab81b6acb1fb7eb0.png" alt="image-20250910160614686"></p><p>通过上面简要地分析，你会发现，我们<strong>只需要记录一个下一令牌产生的时间，并动态更新它，就能够轻松完成限流功能</strong>。</p><p>关键是<strong>reserve()方法</strong>，这个方法会为请求令牌的线程预分配令牌，同时返回该线程能够获取令牌的时间。其实现逻辑就是上面提到的：如果线程请求令牌的时间在下一令牌产生时间之后，那么该线程立刻就能够获取令牌；反之，如果请求时间在下一令牌产生时间之前，那么该线程是在下一令牌产生的时间获取令牌。由于此时下一令牌已经被该线程预占，所以下一令牌产生的时间需要加上1秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleLimiter</span> &#123;</span><br><span class="line">  <span class="comment">//下一令牌产生时间</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">  <span class="comment">//发放令牌间隔：纳秒</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">interval</span> <span class="operator">=</span> <span class="number">1000_000_000</span>;</span><br><span class="line">  <span class="comment">//预占令牌，返回能够获取令牌的时间</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(<span class="type">long</span> now)</span>&#123;</span><br><span class="line">    <span class="comment">//请求时间在下一令牌产生时间之后</span></span><br><span class="line">    <span class="comment">//重新计算下一令牌产生时间</span></span><br><span class="line">    <span class="keyword">if</span> (now &gt; next)&#123;</span><br><span class="line">      <span class="comment">//将下一令牌产生时间重置为当前时间</span></span><br><span class="line">      next = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//能够获取令牌的时间</span></span><br><span class="line">    <span class="type">long</span> at=next;</span><br><span class="line">    <span class="comment">//设置下一令牌产生时间</span></span><br><span class="line">    next += interval;</span><br><span class="line">    <span class="comment">//返回线程需要等待的时间</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(at, <span class="number">0L</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//申请令牌</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//申请令牌时的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="comment">//预占令牌</span></span><br><span class="line">    <span class="type">long</span> at=reserve(now);</span><br><span class="line">    <span class="type">long</span> waitTime=max(at-now, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//按照条件等待</span></span><br><span class="line">    <span class="keyword">if</span>(waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.NANOSECONDS</span><br><span class="line">          .sleep(waitTime);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果令牌桶的容量大于1，又该如何处理呢？按照令牌桶算法，令牌要首先从令牌桶中出，所以我们需要按需计算令牌桶中的数量，当有线程请求令牌时，先从令牌桶中出。具体的代码实现如下所示。</p><p>我们增加了一个<strong>resync()方法</strong>，在这个方法中，如果线程请求令牌的时间在下一令牌产生时间之后，会重新计算令牌桶中的令牌数，<strong>新产生的令牌的计算公式是：(now-next)&#x2F;interval</strong>，你可对照上面的示意图来理解。reserve()方法中，则增加了先从令牌桶中出令牌的逻辑，不过需要注意的是，如果令牌是从令牌桶中出的，那么next就无需增加一个 interval 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleLimiter</span> &#123;</span><br><span class="line">  <span class="comment">//当前令牌桶中的令牌数量</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">storedPermits</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//令牌桶的容量</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">maxPermits</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">  <span class="comment">//下一令牌产生时间</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">  <span class="comment">//发放令牌间隔：纳秒</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">interval</span> <span class="operator">=</span> <span class="number">1000_000_000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//请求时间在下一令牌产生时间之后,则</span></span><br><span class="line">  <span class="comment">// 1.重新计算令牌桶中的令牌数</span></span><br><span class="line">  <span class="comment">// 2.将下一个令牌发放时间重置为当前时间</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">resync</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (now &gt; next) &#123;</span><br><span class="line">      <span class="comment">//新产生的令牌数</span></span><br><span class="line">      <span class="type">long</span> newPermits=(now-next)/interval;</span><br><span class="line">      <span class="comment">//新令牌增加到令牌桶</span></span><br><span class="line">      storedPermits=min(maxPermits, storedPermits + newPermits);</span><br><span class="line">      <span class="comment">//将下一个令牌发放时间重置为当前时间</span></span><br><span class="line">      next = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//预占令牌，返回能够获取令牌的时间</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(<span class="type">long</span> now)</span>&#123;</span><br><span class="line">    resync(now);</span><br><span class="line">    <span class="comment">//能够获取令牌的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">at</span> <span class="operator">=</span> next;</span><br><span class="line">    <span class="comment">//令牌桶中能提供的令牌</span></span><br><span class="line">    <span class="type">long</span> fb=min(<span class="number">1</span>, storedPermits);</span><br><span class="line">    <span class="comment">//令牌净需求：首先减掉令牌桶中的令牌</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">nr</span> <span class="operator">=</span> <span class="number">1</span> - fb;</span><br><span class="line">    <span class="comment">//重新计算下一令牌产生时间</span></span><br><span class="line">    next = next + nr*interval;</span><br><span class="line">    <span class="comment">//重新计算令牌桶中的令牌</span></span><br><span class="line">    <span class="built_in">this</span>.storedPermits -= fb;</span><br><span class="line">    <span class="keyword">return</span> at;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//申请令牌</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//申请令牌时的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="comment">//预占令牌</span></span><br><span class="line">    <span class="type">long</span> at=reserve(now);</span><br><span class="line">    <span class="type">long</span> waitTime=max(at-now, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//按照条件等待</span></span><br><span class="line">    <span class="keyword">if</span>(waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.NANOSECONDS.sleep(waitTime);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uhr考勤</title>
      <link href="/2025/07/14/uhr%E8%80%83%E5%8B%A4%E6%A8%A1%E5%9D%97%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91/"/>
      <url>/2025/07/14/uhr%E8%80%83%E5%8B%A4%E6%A8%A1%E5%9D%97%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h1 id="1自动生成年假"><a href="#1自动生成年假" class="headerlink" title="1自动生成年假"></a>1自动生成年假</h1><h2 id="1-1基本业务场景"><a href="#1-1基本业务场景" class="headerlink" title="1.1基本业务场景"></a>1.1基本业务场景</h2><p>假期类型为定额类且规则是自动生成的需要定时任务自动生成假期，根据基准值和生成条件来确定年假生成的额度。<br><img src="https://i0.hdslb.com/bfs/openplatform/f0088aaee1cdc5c9bb9796c0aac8fd0f055648ec.png" alt="image-20250714170445623"></p><p><img src="https://i0.hdslb.com/bfs/openplatform/f2a257b70f9cf40c4a976c8c7627830453b19c82.png" alt="image-20250714170504252"></p><p><img src="https://i0.hdslb.com/bfs/openplatform/555ded81855f9ee25dd4f9e7a2deeea258148e3c.png" alt="image-20250714170518878"></p><p><strong>基准值</strong>：福利工龄日期、社会工龄日期<br>!!#ff0000 <strong>生成条件</strong>!!：福利工龄日期满N个月、社会工龄日期满N个月</p><p><strong>是否预支年假</strong>：是、否。即是生成已工作年份年假和未来为工作时间的年假（预支，员工刚入职生成今年一年的年假）<br><strong>基准值单位：</strong>月、自然年<br><strong>例如：基准值以月为单位：</strong><br>基准值单位选择为“月”，非预支类型年假，若起始日期为2022年10月1日，则2023年10月1日基准值满12个月<br>示例：若年假计算规则：以“福利工龄”为基准值+“福利工龄”为基础条件+“自然年”为计算周期+取整方式为“向下取整”+额度单位为“天”+基准值单位为“月”： 小王于2015年7月12日首次参加工作，于2022年2月10日加入公司，公司规定：福利工龄满12个月（2023年2月10日）后给予年假，年假阶梯是福利工龄12个月<del>60个月给予5天，60个月</del>120个月给予7天。 小王于2022年5月10日，入职满12个月，此时生成年假。 计算规则为：（20221231-20220211）&#x2F;365<em>7&#x3D;6.19，向下取整为6天。<br><strong>基准值以自然年为单位：</strong><br>基准值单位选择为“自然年”，非预支类型年假，若起始日期为2022年10月1日，2023年1月1日开始则为第二个自然年。<br>示例：若年假计算规则：以“福利工龄”为基准值+“福利工龄”为基础条件+“自然年”为计算周期+取整方式为“向下取整”+额度单位为“天”+基准值单位为“自然年”： 小王于2018年7月12日首次参加工作，于2022年2月10日加入公司，公司规定：福利工龄满12个月（2023年2月10日）后给予年假，年假阶梯是社会工龄第1-5自然年给予5天， 小王于2023年2月10日，入职满12个月，此时生成年假。 计算规则为：（20221231-20220210）&#x2F;365</em>5&#x3D;4.42，向下取整为4天。</p><h2 id="1-2业务实现逻辑梳理"><a href="#1-2业务实现逻辑梳理" class="headerlink" title="1.2业务实现逻辑梳理"></a>1.2业务实现逻辑梳理</h2><h3 id="整体逻辑流程图"><a href="#整体逻辑流程图" class="headerlink" title="整体逻辑流程图"></a>整体逻辑流程图</h3><p><img src="https://i0.hdslb.com/bfs/openplatform/9a074dde5b69432d6346787bf1b3cef3d6452e90.png" alt="image-20250714170735668"></p><h3 id="以自然年为计算周期逻辑"><a href="#以自然年为计算周期逻辑" class="headerlink" title="以自然年为计算周期逻辑"></a>以自然年为计算周期逻辑</h3><p>名词解释：</p><ul><li><p>基准：基准值日期（社会工龄日期 or 福利工龄日期）</p></li><li><p>M：以基准值日期为准，生成条件满M个月</p></li><li><p>T：当前时间</p></li><li><p>司内（红点）：入职日期</p></li><li><p>司内年底（黑点）：入职当年的自然年底</p></li><li><p>司内2年底（黑点）：入职第二年的自然年底</p></li></ul><p><strong>1.不预支年假，即满足年假生成条件，生成上年应休年假</strong><br><img src="https://i0.hdslb.com/bfs/openplatform/fd077ccfa48ea3c644fb11471b12ed1577c0ef98.png" alt="image-20250714170540813"><br><strong>2.预支年假</strong><br><img src="https://i0.hdslb.com/bfs/openplatform/6915b5e655025e6781644f25d991079854a21f93.png" alt="image-20250714170551746"><br><strong>3.不预支年假，即满足年假生成条件</strong><br><img src="https://i0.hdslb.com/bfs/openplatform/aa281597ee5d251c57bf70a49c85e6156068e903.png" alt="image-20250714170603847"><br><strong>4.预支年假</strong><br><img src="https://i0.hdslb.com/bfs/openplatform/b6a8d35bc7053bb3aca9a8526556dc76162a5791.png" alt="image-20250714170616417"></p><p><em>代码逻辑：通过比较当前时间在哪个时间段、是否预支年假，传入不同的额度开始计算日期参数，再根据是否存在跨额度的情况计算出最终的应休年假。</em></p><h2 id="1-3特殊场景-年假跨额度生成处理方式"><a href="#1-3特殊场景-年假跨额度生成处理方式" class="headerlink" title="1.3特殊场景-年假跨额度生成处理方式"></a>1.3特殊场景-年假跨额度生成处理方式</h2><p>1 员工当前年年假生成数刚好在两个阶段中是，需要对两个阶段进行合并计算出最终的年假<br>年假跨阶段7天&#x2F;10天； 计算公式：(153&#x2F;365)*7+(173&#x2F;365)*10<br><img src="https://i0.hdslb.com/bfs/openplatform/d44ec787f485b1cfd751d3442de69dbb3119be00.png" alt="image-20250714170640952"></p><h2 id="1-4测试用例"><a href="#1-4测试用例" class="headerlink" title="1.4测试用例"></a>1.4测试用例</h2><p>根据以下测试用例可以和上面的流程图相结合，便于理解年假生成逻辑。</p><p><strong>不预支年假：</strong></p><p><img src="https://i0.hdslb.com/bfs/openplatform/d03b5acc62ec9451080fc00e675a68dc62938a9a.png" alt="image-20250714171231119"></p><p><strong>预支年假：</strong></p><p><img src="https://i0.hdslb.com/bfs/openplatform/db530e93d367b991b894228030bc5d5cacbb3315.png"></p><p><strong>高管类个性化规则：</strong></p><p><img src="https://i0.hdslb.com/bfs/openplatform/17ad2f8c00bf767a0a1bfed325b1d8b0b41f7bec.png" alt="image-20250714171407722"></p><h1 id="2初始化有效打卡记录"><a href="#2初始化有效打卡记录" class="headerlink" title="2初始化有效打卡记录"></a>2初始化有效打卡记录</h1><p>一般来讲，考勤计算需要先拿到每个员工每天每个班次的有效打卡记录，以这个记录为基准来计算考勤。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/d290f8e750aa53a54a87946ebd8668e5d9e08c13.png" alt="image-20250715172749571"></p><h1 id="3考勤计算全流程"><a href="#3考勤计算全流程" class="headerlink" title="3考勤计算全流程"></a>3考勤计算全流程</h1><p>考勤计算分为数据准备、数据验证、组装数据、数据拆分计算这四个步骤，其中涉及的表及业务逻辑如下图。</p><p>考勤计算的定时任务也和初始化有效打卡记录的整体逻辑一致，都是根据员工的pdc时间筛选出需要计算考勤的员工和考勤日期，按照日期给每个员工计算考勤。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/fd1b6cb9f2ff196d1e4d0f1966dabbeba83acd69.png" alt="image-20250715172047166"></p><p>考勤计算涉及的相关表：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/0726a8b1949c0b2b501f83e7e26a00767a45de1d.png" alt="image-20250717151034055"></p><h2 id="3-1数据准备"><a href="#3-1数据准备" class="headerlink" title="3.1数据准备"></a>3.1数据准备</h2><p><img src="https://i0.hdslb.com/bfs/openplatform/d3fe75c1771bb5643c18803617374d2eefe31a43.png" alt="image-20250715171507019"></p><h2 id="3-2数据验证"><a href="#3-2数据验证" class="headerlink" title="3.2数据验证"></a>3.2数据验证</h2><p><img src="https://i0.hdslb.com/bfs/openplatform/41716aab8440e3ac1aa8e55e6e293400bdcc676b.png" alt="image-20250715171624480"></p><h2 id="3-3组装数据"><a href="#3-3组装数据" class="headerlink" title="3.3组装数据"></a>3.3组装数据</h2><p>此处获取班次信息（标记0点）的作用是，跨天班次可能会存在休息时间跨天的情况，也可能跨天时是排班的情况，需要将0点前后的考勤状态拆分。</p><p>例如：跨天班次B(19:00-5:00)，休息时间为23:00–1:00,3:00–4:00</p><p>拆分0点后，班次结果为：   [2025-07-16  19:00,2025-07-16 23:00]【排班】</p><p>​[2025-07-16  23:00,2025-07-16 0:00] 【休息】</p><p>​[2025-07-17  0:00,2025-07-17 1:00] 【休息】</p><p>​[2025-07-17  1:00,2025-07-17 3:00] 【排班】</p><p>​[2025-07-17  3:00,2025-07-17 4:00] 【休息】</p><p>​[2025-07-17  4:00,2025-07-17 5:00] 【排班】</p><p>后续的考勤拆分是以这个拆分了0点后的班次作为循环条件，与打卡、请假、销假、出差等数据进行比较。<img src="https://i0.hdslb.com/bfs/openplatform/9287b759e47205192f431f45ef7e1284d893a0fd.png" alt="image-20250715171644104"></p><h2 id="3-4数据拆分计算"><a href="#3-4数据拆分计算" class="headerlink" title="3.4数据拆分计算"></a>3.4数据拆分计算</h2><h3 id="考勤核算流程图"><a href="#考勤核算流程图" class="headerlink" title="考勤核算流程图"></a>考勤核算流程图</h3><p><img src="https://i0.hdslb.com/bfs/openplatform/1250b18924e17d13981b40a42ac836ea5c7ec625.png" alt="image-20250715171705033"></p><h3 id="考勤核算规则"><a href="#考勤核算规则" class="headerlink" title="考勤核算规则"></a>考勤核算规则</h3><p><img src="https://i0.hdslb.com/bfs/openplatform/712f8d78d39fd934dee9bb7225f3ab269d7f88f1.png" alt="image-20250715172024559"></p><p><img src="https://i0.hdslb.com/bfs/openplatform/dcf709c964d1d3bc88900189570ffdd7c6100be6.png" alt="image-20250715172037235"></p><h3 id="考勤状态"><a href="#考勤状态" class="headerlink" title="考勤状态"></a>考勤状态</h3><p><code>休息</code>、<code>请假</code>、<code>出差</code>、<code>正常出勤</code>、<code>早到</code>、<code>迟到</code>、<code>早退</code>、<code>延迟下班</code>、<code>旷工</code>、<code>排班</code>、<code>弹性排班</code></p><p><strong>三、数据处理（考勤计算前）</strong><br>1、数据准备：所有数据需分段存储至GtdAttendanceResult对象中，并标识出该段目前的考勤状态<br>例：班次为9:00-18:00，休息时间为12:00-14:00<br>分段存储后：9:00-12:00（排班），12:00-14:00（休息），14:00-18:00（排班）</p><h3 id="考勤计算"><a href="#考勤计算" class="headerlink" title="考勤计算"></a>考勤计算</h3><p><strong>1、初次比较</strong><br>1.1、以班次作为基础数据，打卡、请假、销假、出差等数据作为比较数据</p><p><img src="https://i0.hdslb.com/bfs/openplatform/c20c5e47e668d47e7a3bbfe9a2f2caa8c5cc3286.png" alt="image-20250715172448644"></p><p>1.2、根据考勤核算规则优先级，将比较数据逐一与基础数据进行比对，不重合时间段保留当前考勤状态，重合时间段按照优先级比对出两段考勤状态<br>1.3、为了提升比对效率，若当前比较数据比对完毕，则终止循环，进入下一次比较数据的循环<br><img src="https://i0.hdslb.com/bfs/openplatform/fffc12387eeedafe635dc4aba6a7841bfdf57ff9.png" alt="image-20250715172416478"></p><p><strong>2、二次比较</strong><br>2.1、二次比较确定考勤异常最终状态，例：初次比较得出迟到、早退，需要与系统配置的时长进行比对，确定是否为旷工</p><p><strong>3、弹性班次注意事项</strong><br>3.1、需先计算员工应下班时间（根据上班打卡时间和上班总时长计算）<br>3.2、班次时间需这样拆分 -&gt; 最早到岗时间,最晚到岗时间 ; 最晚到岗时间,实际下班时间 ; 实际下班时间,最晚下班时间</p><p><strong>4、多段班注意事项</strong><br>4.1、多段班需要逐段班次进行比较</p><p><strong>五、考勤结果、明细存储</strong><br>1、保存考勤明细存在转换天数精度丢失问题<br>现采用减法计算：1 - 请假天数 - 实际出勤天数(包含出差天数) &#x3D; 旷工天数<br>特殊处理：若考勤结果无旷工时间段，且减法后旷工天数 &gt; 0 ,则将旷工天数补入实际出勤天数</p><h1 id="4考勤处理流程"><a href="#4考勤处理流程" class="headerlink" title="4考勤处理流程"></a>4考勤处理流程</h1><p>考勤一般都是与OA流程挂钩的，员工的请假、加班、出差、销假等操作在OA系统发起，对接到UHR系统，对接后考勤处理流程如下。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/654e3789730d7e6c9b95b2a3dac3ac6515ff602d.png" alt="image-20250715173137044"></p><h2 id="4-1拆分请假-出差数据"><a href="#4-1拆分请假-出差数据" class="headerlink" title="4.1拆分请假&#x2F;出差数据"></a>4.1拆分请假&#x2F;出差数据</h2><p>员工提交整段请假记录时，后台需要按照员工班次进行拆分，存储到数据库时请假结果按天存储，销假是也要删除对应拆分结果。</p><p>而且对于员工排班发生变更前的请假&#x2F;出差记录，计算考勤前需要重新拆分。</p><p>具体拆分逻辑如下：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/7c1af1dfc15a95bc298c721c4151fc215107f6ad.png" alt="image-20250715173311178"></p><h1 id="5考勤日历"><a href="#5考勤日历" class="headerlink" title="5考勤日历"></a>5考勤日历</h1><h2 id="5-1相关表设计"><a href="#5-1相关表设计" class="headerlink" title="5.1相关表设计"></a>5.1相关表设计</h2><p>其中 gtd_emp_calendar 因数据量过大，不再使用。</p><p>gtd_work_calendar_details工作日历明细表，精确到天，每天绑定一个班次。</p><p>sys_organization为组织表，emp_org_allocation为员工的组织分配表（员工有异动时添加一条数据）。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/21e03b05f82fb068d2c9e64eb9c4bd72080e5905.png" alt="image-20250716142327119"></p><ul><li>gtd_holiday_manage：节假日管理实体，包含节假日名称、代码、开始日期、结束日期、法定节假日、调休日期等信息。</li><li>gtd_work_calendar_details：工作日历明细表，记录每个工作日历的具体日期安排，包括班次、日期类型等。</li><li>gtd_holiday_calendar_history：工作日历和节假日关联历史表，用于记录工作日历应用节假日前的原始数据，便于后续恢复或修改。</li></ul><h2 id="5-2相关业务逻辑"><a href="#5-2相关业务逻辑" class="headerlink" title="5.2相关业务逻辑"></a>5.2相关业务逻辑</h2><h3 id="工作日历按周期顺延"><a href="#工作日历按周期顺延" class="headerlink" title="工作日历按周期顺延"></a>工作日历按周期顺延</h3><p><img src="https://i0.hdslb.com/bfs/openplatform/f968b9835cb84efae8ed4b508cad7112780e82bc.png" alt="image-20250716193716828"></p><h3 id="节假日应用工作日历"><a href="#节假日应用工作日历" class="headerlink" title="节假日应用工作日历"></a>节假日应用工作日历</h3><p>节假日管理信息配置中，支持编辑法定节假日日期、关联调休日期、法定节假日（非3倍计薪）</p><p><img src="https://i0.hdslb.com/bfs/openplatform/230b79f95edb3a2fee6717963695671162af55c8.png" alt="image-20250717102302183"></p><p>一个节假日支持应用到多个工作日历上</p><p><img src="https://i0.hdslb.com/bfs/openplatform/a863988dcccef29b887e5a622622d3f6ed9ddd30.png" alt="image-20250717103717525"></p><p>节假日应用到多个工作日历的业务流程图如下：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/2693723abd13324a138173e8113fe4d5429a698d.png" alt="image-20250717111533223"></p><p>整个节假日历史关联表的业务逻辑可以总结为：</p><ol><li><p>历史记录管理 ：</p><ul><li>保存原始工作日历数据（ holidayId 为 null ）</li><li>保存节假日应用后的工作日历数据（ holidayId 为节假日ID）</li><li>当修改节假日设置时，先恢复原始数据，再应用新设置</li></ul></li><li><p>节假日应用 ：</p><ul><li>将节假日期间的工作日设置为休息日（ classId 为 null ）</li><li>根据节假日类型设置不同的 holidayType （法定节假日或普通节假日）</li></ul></li><li><p>调休处理 ：</p><ul><li>将调休日设置为工作日（ holidayType 为普通日期）</li><li>为调休日分配合适的班次（通过查找最近的班次）</li></ul></li><li><p>数据一致性 ：</p><ul><li>通过事务保证工作日历明细和历史记录的一致性</li><li>通过批量操作提高性能</li></ul></li></ol><h3 id="获取员工班次步骤"><a href="#获取员工班次步骤" class="headerlink" title="获取员工班次步骤"></a>获取员工班次步骤</h3><p><strong>员工班次有两种来源：</strong><br>①.直接导入员工班次到员工班次明细表；<br>②.通过部门绑定工作日历或直接给员工绑定工作日历；<br>两者都存在时①优先级高于②</p><p><img src="https://i0.hdslb.com/bfs/openplatform/739fc29e74f303da58a471285da004af7e9ca6dd.png" alt="image-20250716143401092"></p><h3 id="员工工作日历变更"><a href="#员工工作日历变更" class="headerlink" title="员工工作日历变更"></a>员工工作日历变更</h3><h4 id="组织绑定工作日历"><a href="#组织绑定工作日历" class="headerlink" title="组织绑定工作日历"></a>组织绑定工作日历</h4><p><img src="https://i0.hdslb.com/bfs/openplatform/3c6a0d7a66d3aac073c529851903a18791b9f1e8.png" alt="image-20250716162159584"></p><h4 id="入职-异动刷新员工考勤日历逻辑"><a href="#入职-异动刷新员工考勤日历逻辑" class="headerlink" title="入职&#x2F;异动刷新员工考勤日历逻辑"></a>入职&#x2F;异动刷新员工考勤日历逻辑</h4><p><strong>组织与日历绑定关系</strong></p><ul><li>组织1 （2024-01-01 日历A），（2024-01-25 日历B）<br>组织1组 （2024-01-30 日历C），（2024-05-02 日历D）</li><li>组织2 （2024-01-01 日历E）<br>组织2组</li><li>组织3 （2024-01-01 日历F）<br>组织3组</li></ul><p><strong>员工异动流程</strong></p><p>在2024-01-01号入职组织2组<br>在2024-01-20号从组织2组异动至组织1组<br>在2024-05-01号从组织1组异动至组织3组</p><p>组织2组：[2024-01-01,2024-01-20]<br>组织1组：[2024-01-20,2024-05-01] 异动时间段<br>组织3组：[2024-05-01,9999-12-31]<br>异动时间段需生成的考勤日历：20号，25号，30号共三条</p><p><strong>获取组织1组及上级所有考勤日历</strong></p><p>倒序排序（2024-05-02，2024-01-30，2024-01-25，2024-01-01）</p><p>如此以下遍历员工所在的各个组织比较…</p><p><img src="https://i0.hdslb.com/bfs/openplatform/477a1f0b5e395c27f8a9bdbf5ecfa602308faccb.png" alt="image-20250716151015869"></p><h1 id="6生成员工补卡余额"><a href="#6生成员工补卡余额" class="headerlink" title="6生成员工补卡余额"></a>6生成员工补卡余额</h1><p>每个月会给员工生成补卡余额，定时任务会每天更新该员工的补卡余额。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/b1c9ddc3793b9a9a27a9e0060dc7f342f98f1fb0.png" alt="image-20250716164814345"></p><h1 id="7加班审核"><a href="#7加班审核" class="headerlink" title="7加班审核"></a>7加班审核</h1><p><img src="https://i0.hdslb.com/bfs/openplatform/8c9c198048126f68657611239069028322fdb0d1.png" alt="image-20250716175428067"></p>]]></content>
      
      
      <categories>
          
          <category> 场景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes</title>
      <link href="/2025/07/09/kubernetes/"/>
      <url>/2025/07/09/kubernetes/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>虽然容器技术开启了云原生时代，但它也只走出了一小步，再继续前进就无能为力了，因为这已经不再是隔离一两个进程的普通问题，而是要隔离数不清的进程，还有它们之间互相通信、互相协作的超级问题，困难程度可以说是指数级别的上升。</p><p>这些容器之上的管理、调度工作，就是这些年最流行的词汇：“<strong>容器编排</strong>”（Container Orchestration）。</p><p>面对单机上的几个容器，“人肉”编排调度还可以应付，但如果规模上到几百台服务器、成千上万的容器，处理它们之间的复杂联系就必须要依靠计算机了，而目前计算机用来调度管理的“事实标准”，就是：Kubernetes。</p><p>Kubernetes就是一个<strong>生产级别的容器编排平台和集群管理系统</strong>，不仅能够创建、调度容器，还能够监控、管理服务器。</p><h1 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h1><p><img src="https://i0.hdslb.com/bfs/openplatform/79bb57777a6a9f4496d72b0b436a15e1039038c9.png" alt="image-20250709171226550"></p><p>Kubernetes采用了现今流行的“<strong>控制面&#x2F;数据面</strong>”（Control Plane &#x2F; Data Plane）架构，集群里的计算机被称为“<strong>节点</strong>”（Node），可以是实机也可以是虚机，少量的节点用作控制面来执行集群的管理维护工作，其他的大部分节点都被划归数据面，用来跑业务应用。</p><p>控制面的节点在Kubernetes里叫做<strong>Master Node</strong>，一般简称为<strong>Master</strong>，它是整个集群里最重要的部分，可以说是Kubernetes的大脑和心脏。</p><p>数据面的节点叫做<strong>Worker Node</strong>，一般就简称为<strong>Worker</strong>或者<strong>Node</strong>，相当于Kubernetes的手和脚，在Master的指挥下干活。</p><p>Node的数量非常多，构成了一个资源池，Kubernetes就在这个池里分配资源，调度应用。因为资源被“池化”了，所以管理也就变得比较简单，可以在集群中任意添加或者删除节点。</p><p>在这张架构图里，我们还可以看到有一个kubectl，它就是Kubernetes的客户端工具，用来操作Kubernetes，但它位于集群之外，理论上不属于集群。</p><p>你可以使用命令 <code>kubectl get node</code> 来查看Kubernetes的节点状态：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/openplatform/dfd4a2527bef0983fad179df40bc3b305de1a6e5.png" alt="image-20250709171414500"></p><h2 id="Master-Node"><a href="#Master-Node" class="headerlink" title="Master Node"></a>Master Node</h2><p>Master里有4个组件，分别是<strong>apiserver</strong>、<strong>etcd</strong>、<strong>scheduler</strong>、<strong>controller-manager</strong>。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/2d59b019a9e9faeaa05cbba7953a42212b505735.png" alt="image-20250710101927564"></p><p>apiserver是Master节点——同时也是整个Kubernetes系统的唯一入口，它对外公开了一系列的RESTful API，并且加上了验证、授权等功能，所有其他组件都只能和它直接通信，可以说是Kubernetes里的联络员。</p><p>etcd是一个高可用的分布式Key-Value数据库，用来持久化存储系统里的各种资源对象和状态，相当于Kubernetes里的配置管理员。注意它只与apiserver有直接联系，也就是说任何其他组件想要读写etcd里的数据都必须经过apiserver。</p><p>scheduler负责容器的编排工作，检查节点的资源状态，把Pod调度到最适合的节点上运行，相当于部署人员。因为节点状态和Pod信息都存储在etcd里，所以scheduler必须通过apiserver才能获得。</p><p>controller-manager负责维护容器和节点等资源的状态，实现故障检测、服务迁移、应用伸缩等功能，相当于监控运维人员。同样地，它也必须通过apiserver获得存储在etcd里的信息，才能够实现对资源的各种操作。</p><p>这4个组件也都被容器化了，运行在集群的Pod里，我们可以用kubectl来查看它们的状态，使用命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod <span class="literal">-n</span> kube<span class="literal">-system</span></span><br></pre></td></tr></table></figure><h2 id="Worker-Node"><a href="#Worker-Node" class="headerlink" title="Worker Node"></a>Worker Node</h2><p><img src="https://i0.hdslb.com/bfs/openplatform/2d76640bd8013f0ed5517cf78e154cdfb0646e75.png" alt="image-20250710102645156"></p><p>kubelet是Node的代理，负责管理Node相关的绝大部分操作，Node上只有它能够与apiserver通信，实现状态报告、命令下发、启停容器等功能，相当于是Node上的一个“小管家”。</p><p>kube-proxy的作用有点特别，它是Node的网络代理，只负责管理容器的网络通信，简单来说就是为Pod转发TCP&#x2F;UDP数据包，相当于是专职的“小邮差”。</p><p>第三个组件container-runtime我们就比较熟悉了，它是容器和镜像的实际使用者，在kubelet的指挥下创建容器，管理Pod的生命周期，是真正干活的“苦力”。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>现在，我们再把Node里的组件和Master里的组件放在一起来看，就能够明白Kubernetes的大致工作流程了：</p><ul><li>每个Node上的kubelet会定期向apiserver上报节点状态，apiserver再存到etcd里。</li><li>每个Node上的kube-proxy实现了TCP&#x2F;UDP反向代理，让容器对外提供稳定的服务。</li><li>scheduler通过apiserver得到当前的节点状态，调度Pod，然后apiserver下发命令给某个Node的kubelet，kubelet调用container-runtime启动容器。</li><li>controller-manager也通过apiserver得到实时的节点状态，监控可能的异常情况，再使用相应的手段去调节恢复。</li></ul><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p>Docker Desktop 自带了 Kubernetes 支持，可以通过 Docker Desktop 的应用程序界面开启 Kubernetes 集群。</p><p>而且Docker Desktop 启动 Kubernetes 后，会自动配置 kubectl 命令行工具，便于我们日常学习，减少安装成本。</p><h2 id="Kuboard"><a href="#Kuboard" class="headerlink" title="Kuboard"></a>Kuboard</h2><p>Kuboard 是一款免费的 Kubernetes 管理工具，旨在帮助用户快速在 Kubernetes 上落地微服务。它提供了丰富的功能，包括但不限于 Kubernetes 基本管理功能、节点管理、名称空间管理、存储类&#x2F;存储卷管理、控制器管理、Service&#x2F;Ingress 管理、ConfigMap&#x2F;Secret 管理、CustomerResourceDefinition 管理、问题诊断、容器日志及终端、认证与授权、CI&#x2F;CD集成等。</p><p>拉取镜像：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull eipwork/kuboard:v3</span><br></pre></td></tr></table></figure><p>运行命令(挂载的路径需要更改)：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span>=kuboard <span class="literal">-p</span> <span class="number">8089</span>:<span class="number">80</span>/tcp <span class="literal">-p</span> <span class="number">10081</span>:<span class="number">10081</span>/tcp <span class="literal">-e</span> KUBOARD_ENDPOINT=<span class="string">&quot;http://192.168.3.220:8089&quot;</span> <span class="literal">-e</span> KUBOARD_AGENT_SERVER_TCP_PORT=<span class="string">&quot;10081&quot;</span> <span class="literal">-v</span> F:\docker\wsl\DockerDesktopWSL\mount\k8s eipwork/kuboard:v3</span><br></pre></td></tr></table></figure><p>访问 Kuboard：</p><p>地址： <a href="http://127.0.0.1:8089/">http://127.0.0.1:8089/</a></p><p>账号：admin</p><p>密码：Kuboard123</p><p>登录进去后，<strong>添加 Kubernetes 集群到 Kuboard</strong></p><p>![image-20250709172637479](<a href="https://i0.hdslb.com/bfs/openplatform/60c473e12d77b12fd152e25a23d26125f3574ac3.png">https://i0.hdslb.com/bfs/openplatform/60c473e12d77b12fd152e25a23d26125f3574ac3.png</a></p><p><img src="https://i0.hdslb.com/bfs/openplatform/69a5b05ea94f6a685f67b5b03b86d009957df83c.png" alt="image-20250709175827891"></p><p>按照以下步骤执行：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/7186fb0f2c24d373756ddafcc9ee8150aa7aa6a5.png" alt="image-20250709180129062"></p><p><strong>导入Kuboard</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> curl.exe <span class="literal">-k</span> <span class="string">&#x27;http://192.168.3.220:8089/kuboard-api/cluster/Ashley-k8s/kind/KubernetesCluster/Ashley-k8s/resource/installAgentToKubernetes?token=wfzV3KBKl48kGMr6lO6CQ2lIrDGdNj5j&#x27;</span> <span class="literal">-o</span> kuboard<span class="literal">-agent</span>.yaml</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line"><span class="number">100</span>  <span class="number">5611</span>    <span class="number">0</span>  <span class="number">5611</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">314</span>k      <span class="number">0</span> <span class="literal">--</span>:<span class="literal">--</span>:<span class="literal">--</span> <span class="literal">--</span>:<span class="literal">--</span>:<span class="literal">--</span> <span class="literal">--</span>:<span class="literal">--</span>:<span class="literal">--</span>  <span class="number">322</span>k</span><br></pre></td></tr></table></figure><p>导入之前先要执行以下两个命令</p><p>获取当前 Kubernetes 集群中的所有 <code>Pod</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\jr10003509&gt; kubectl get pods</span><br><span class="line">No resources found <span class="keyword">in</span> default namespace.</span><br></pre></td></tr></table></figure><p>显示当前 Kubernetes 配置中所有上下文</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\jr10003509&gt; kubectl config <span class="built_in">get-contexts</span></span><br><span class="line">CURRENT   NAME             CLUSTER          AUTHINFO         NAMESPACE</span><br><span class="line">*         docker<span class="literal">-desktop</span>   docker<span class="literal">-desktop</span>   docker<span class="literal">-desktop</span></span><br></pre></td></tr></table></figure><p>切换 <code>kubectl</code> 操作的上下文到名为 <code>docker-desktop</code> 的上下文</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\jr10003509&gt; kubectl config <span class="built_in">use-context</span> docker<span class="literal">-desktop</span></span><br><span class="line">Switched to context <span class="string">&quot;docker-desktop&quot;</span>.</span><br></pre></td></tr></table></figure><p>获取（列出）当前 Kubernetes 集群中的所有节点（Node）的信息</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\jr10003509&gt; kubectl get nodes</span><br><span class="line">NAME             STATUS   ROLES           AGE   VERSION</span><br><span class="line">docker<span class="literal">-desktop</span>   Ready    control<span class="literal">-plane</span>   <span class="number">26</span>m   v1.<span class="number">28.2</span></span><br></pre></td></tr></table></figure><p>将本地文件 <code>.\kuboard-agent.yaml</code> 中定义的 <code>Kubernetes</code> 资源对象应用到 <code>Kubernetes</code> 集群中。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\jr10003509&gt; kubectl apply <span class="operator">-f</span> ./kuboard<span class="literal">-agent</span>.yaml</span><br><span class="line">namespace/kuboard unchanged</span><br><span class="line">serviceaccount/kuboard<span class="literal">-admin</span> unchanged</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kuboard<span class="literal">-admin-crb</span> unchanged</span><br><span class="line">serviceaccount/kuboard<span class="literal">-viewer</span> unchanged</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kuboard<span class="literal">-viewer-crb</span> unchanged</span><br><span class="line">deployment.apps/kuboard<span class="literal">-agent-ashley</span> created</span><br><span class="line">deployment.apps/kuboard<span class="literal">-agent-ashley-2</span> created</span><br></pre></td></tr></table></figure><p>导入成功！</p><p><img src="https://i0.hdslb.com/bfs/openplatform/70902d2bfdd82244b17079d484f06c07c6a5290f.png" alt="image-20250709180841125"></p><h1 id="API对象"><a href="#API对象" class="headerlink" title="API对象"></a>API对象</h1><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>Pod是对容器的“打包”，里面的容器是一个整体，总是能够一起调度、一起运行，绝不会出现分离的情况，而且Pod属于Kubernetes，可以在不触碰下层容器的情况下任意定制修改。</p><p>Kubernetes让Pod去编排处理容器，然后把Pod作为应用调度部署的<strong>最小单位</strong>，Pod也因此成为了Kubernetes世界里的“原子”（当然这个“原子”内部是有结构的，不是铁板一块），基于Pod就可以构建出更多更复杂的业务形态了。</p><h2 id="Job-CronJob"><a href="#Job-CronJob" class="headerlink" title="Job&#x2F;CronJob"></a>Job&#x2F;CronJob</h2><p>Kubernetes里有两大类业务。一类是像Nginx这样长时间运行的“<strong>在线业务</strong>”，另一类是像busybox这样短时间运行的“<strong>离线业务</strong>”。</p><p>“在线业务”类型的应用有很多，比如Nginx、Node.js、MySQL、Redis等等，一旦运行起来基本上不会停，也就是永远在线。</p><p>而“离线业务”类型的应用也并不少见，它们一般不直接服务于外部用户，只对内部用户有意义，比如日志分析、数据建模、视频转码等等，虽然计算量很大，但只会运行一段时间。“离线业务”的特点是<strong>必定会退出</strong>，不会无期限地运行下去，所以它的调度策略也就与“在线业务”存在很大的不同，需要考虑运行超时、状态检查、失败重试、获取计算结果等管理事项。</p><p>而这些业务特性与容器管理没有必然的联系，如果由Pod来实现就会承担不必要的义务，违反了“单一职责”，所以我们应该把这部分功能分离到另外一个对象上实现，让这个对象去控制Pod的运行，完成附加的工作。</p><p>“离线业务”也可以分为两种。一种是“<strong>临时任务</strong>”，跑完就完事了，下次有需求了说一声再重新安排；另一种是“<strong>定时任务</strong>”，可以按时按点周期运行，不需要过多干预。</p><p>对应到Kubernetes里，“临时任务”就是API对象<strong>Job</strong>，“定时任务”就是API对象<strong>CronJob</strong>，使用这两个对象你就能够在Kubernetes里调度管理任意的离线业务了。</p><p>可以看到，Job对象里应用了组合模式，<code>template</code> 字段定义了一个“<strong>应用模板</strong>”，里面嵌入了一个Pod，这样Job就可以从这个模板来创建出Pod。而这个Pod因为受Job的管理控制，不直接和apiserver打交道，也就没必要重复apiVersion等“头字段”，只需要定义好关键的 <code>spec</code>，描述清楚容器相关的信息就可以了，可以说是一个“无头”的Pod对象。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/c0824e862bf99bc953f78ffe2f66d9503bee7086.png" alt="image-20250710111135700"></p><p>而定时任务”的CronJob对象也很好理解了，使用schedule指定了执行周期，又组合了Job而生成的新对象。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/b1bcabe3ca8354818e418913c673451e73d8a837.png" alt="image-20250710111413288"></p><p>CronJob使用定时规则控制Job，Job使用并发数量控制Pod，Pod再定义参数控制容器，容器再隔离控制进程，进程最终实现业务功能，层层递进的形式有点像设计模式里的Decorator（装饰模式），链条里的每个环节都各司其职，在Kubernetes的统一指挥下完成任务。</p><h2 id="Deployment：让应用永不宕机"><a href="#Deployment：让应用永不宕机" class="headerlink" title="Deployment：让应用永不宕机"></a>Deployment：让应用永不宕机</h2><p>在线业务远不是单纯启动一个Pod这么简单，还有多实例、高可用、版本更新等许多复杂的操作。比如最简单的多实例需求，为了提高系统的服务能力，应对突发的流量和压力，我们需要创建多个应用的副本，还要即时监控它们的状态。如果还是只使用Pod，那就会又走回手工管理的老路，没有利用好Kubernetes自动化运维的优势。</p><p>Deployment，就是用来管理Pod，实现在线业务应用的新API对象。</p><p> <code>replicas</code> 字段。它的含义比较简单明了，就是“副本数量”的意思，也就是说，指定要在Kubernetes集群里运行多少个Pod实例。</p><p>接下来Kubernetes还会持续地监控Pod的运行状态，万一有Pod发生意外消失了，数量不满足“期望状态”，它就会通过apiserver、scheduler等核心组件去选择新的节点，创建出新的Pod，直至数量与“期望状态”一致。</p><p> <code>selector</code>，它的作用是“筛选”出要被Deployment管理的Pod对象，下属字段“<strong>matchLabels</strong>”定义了Pod对象应该携带的label，它必须和“template”里Pod定义的“labels”完全相同，否则Deployment就会找不到要控制的Pod对象，apiserver也会告诉你YAML格式校验错误无法创建。</p><p>Kubernetes采用的是这种“贴标签”的方式，通过在API对象的“metadata”元信息里加各种标签（labels），我们就可以使用类似关系数据库里查询语句的方式，筛选出具有特定标识的那些对象。<strong>通过标签这种设计，Kubernetes就解除了Deployment和模板里Pod的强绑定，把组合关系变成了“弱引用”</strong>。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/f50ba2a6e58009faefceefa1106ef497dc22df56.png" alt="image-20250710115117565"></p><p><strong>在Deployment部署成功之后，你还可以随时调整Pod的数量，实现所谓的“应用伸缩”</strong>。这项工作在Kubernetes出现之前对于运维来说是一件很困难的事情，而现在由于有了Deployment就变得轻而易举了。</p><h2 id="DaemonSet：节点的守护者"><a href="#DaemonSet：节点的守护者" class="headerlink" title="DaemonSet：节点的守护者"></a>DaemonSet：节点的守护者</h2><p>Deployment并不关心这些Pod会在集群的哪些节点上运行，<strong>在它看来，Pod的运行环境与功能是无关的，只要Pod的数量足够，应用程序应该会正常工作</strong>。</p><p>这个假设对于大多数业务来说是没问题的，比如Nginx、WordPress、MySQL，它们不需要知道集群、节点的细节信息，只要配置好环境变量和存储卷，在哪里“跑”都是一样的。</p><p>但是有一些业务比较特殊，它们不是完全独立于系统运行的，而是与主机存在“绑定”关系，必须要依附于节点才能产生价值，比如说：</p><ul><li>网络应用（如kube-proxy），必须每个节点都运行一个Pod，否则节点就无法加入Kubernetes网络。</li><li>监控应用（如Prometheus），必须每个节点都有一个Pod用来监控节点的状态，实时上报信息。</li><li>日志应用（如Fluentd），必须在每个节点上运行一个Pod，才能够搜集容器运行时产生的日志数据。</li><li>安全应用，同样的，每个节点都要有一个Pod来执行安全审计、入侵检查、漏洞扫描等工作。</li></ul><p>所以，Kubernetes就定义了新的API对象DaemonSet，它在形式上和Deployment类似，都是管理控制Pod，但管理调度策略却不同。DaemonSet的目标是在集群的每个节点上运行且仅运行一个Pod，就好像是为节点配上一只“看门狗”，忠实地“守护”着节点，这就是DaemonSet名字的由来。</p><p>DaemonSet仅仅是在Pod的部署调度策略上和Deployment不同，其他的都是相同的，某种程度上我们也可以把DaemonSet看做是Deployment的一个特例。</p><p>我还是把YAML描述文件画了一张图，好让你看清楚与Deployment的差异：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/ed917d93f0354d88671162e734856f1f935a6229.png" alt="image-20250710141911055"></p><h1 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h1><p>首先你要知道，应用程序有很多类别的配置信息，但从数据安全的角度来看可以分成两类：</p><ul><li>一类是明文配置，也就是不保密，可以任意查询修改，比如服务端口、运行参数、文件路径等等。</li><li>另一类则是机密配置，由于涉及敏感信息需要保密，不能随便查看，比如密码、密钥、证书等等。</li></ul><p>这两类配置信息本质上都是字符串，只是由于安全性的原因，在存放和使用方面有些差异，所以Kubernetes也就定义了两个API对象，<strong>ConfigMap</strong>用来保存明文配置，<strong>Secret</strong>用来保存秘密配置。</p><p>因为ConfigMap和Secret只是一些存储在etcd里的字符串，所以如果想要在运行时产生效果，就必须要以某种方式“<strong>注入</strong>”到Pod里，让应用去读取。在这方面的处理上Kubernetes和Docker是一样的，也是两种途径：<strong>环境变量</strong>和<strong>加载文件</strong>。</p><h2 id="环境变量注入"><a href="#环境变量注入" class="headerlink" title="环境变量注入"></a>环境变量注入</h2><p>从这张图你就应该能够比较清楚地看出Pod与ConfigMap、Secret的“松耦合”关系，它们不是直接嵌套包含，而是使用“KeyRef”字段间接引用对象，这样，同一段配置信息就可以在不同的对象之间共享。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/8e60029d79e1da7e50de61ed9749eeefe1da454e.png" alt="image-20250710113004281"></p><h2 id="文件加载注入"><a href="#文件加载注入" class="headerlink" title="文件加载注入"></a>文件加载注入</h2><p>Kubernetes为Pod定义了一个“<strong>Volume</strong>”的概念，可以翻译成是“存储卷”。如果把Pod理解成是一个虚拟机，那么Volume就相当于是虚拟机里的磁盘。</p><p>我们可以为Pod“挂载（mount）”多个Volume，里面存放供Pod访问的数据，这种方式有点类似 <code>docker run -v</code>，虽然用法复杂了一些，但功能也相应强大一些。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/b7f9270835ea7ba5452a9515c7f37d34a0c1735c.png" alt="image-20250710113256011"></p><p>挂载Volume的方式和环境变量又不太相同。环境变量是直接引用了ConfigMap&#x2F;Secret，而Volume又多加了一个环节，需要先用Volume引用ConfigMap&#x2F;Secret，然后在容器里挂载Volume。</p><p>这种方式的好处在于：以Volume的概念统一抽象了所有的存储，不仅现在支持ConfigMap&#x2F;Secret，以后还能够支持临时卷、持久卷、动态卷、快照卷等许多形式的存储，扩展性非常好。</p><p>因为这种形式上的差异，以Volume的方式来使用ConfigMap&#x2F;Secret，就和环境变量不太一样。环境变量用法简单，更适合存放简短的字符串，而Volume更适合存放大数据量的配置文件，在Pod里加载成文件后让应用直接读取使用。</p><h1 id="Service：微服务架构的应对之道"><a href="#Service：微服务架构的应对之道" class="headerlink" title="Service：微服务架构的应对之道"></a>Service：微服务架构的应对之道</h1><p>在Kubernetes集群里Pod的生命周期是比较“短暂”的，虽然Deployment和DaemonSet可以维持Pod总体数量的稳定，但在运行过程中，难免会有Pod销毁又重建，这就会导致Pod集合处于动态的变化之中。</p><p>这种“动态稳定”对于现在流行的微服务架构来说是非常致命的，试想一下，后台Pod的IP地址老是变来变去，客户端该怎么访问呢？如果不处理好这个问题，Deployment和DaemonSet把Pod管理得再完善也是没有价值的。</p><p>其实，这个问题也并不是什么难事，业内早就有解决方案来针对这样“不稳定”的后端服务，那就是“<strong>负载均衡</strong>”，典型的应用有LVS、Nginx等等。它们在前端与后端之间加入了一个“中间层”，屏蔽后端的变化，为前端提供一个稳定的服务。</p><p>但LVS、Nginx毕竟不是云原生技术，所以Kubernetes就按照这个思路，定义了新的API对象：<strong>Service</strong>。</p><p>Kubernetes会给Service分配一个静态IP地址，然后它再去自动管理、维护后面动态变化的Pod集合，当客户端访问Service，它就根据某种策略，把流量转发给后面的某个Pod。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/516cf8ccd1a88d24082699e5e3c0c5b499b40e49.png" alt="image-20250710145331433"></p><p><code>selector</code> 和Deployment&#x2F;DaemonSet里的作用是一样的，用来过滤出要代理的那些Pod。因为我们指定要代理Deployment，所以Kubernetes就为我们自动填上了ngx-dep的标签，会选择这个Deployment对象部署的所有Pod。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/e9e6e6f453efca2e173de96475441c69b13fb2ff.png" alt="image-20250710145555926"></p><p>Pod被Deployment对象管理，删除后会自动重建，而Service又会通过controller-manager实时监控Pod的变化情况，所以就会立即更新它代理的IP地址。</p><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>Kubernetes有一个默认的名字空间，叫“<strong>default</strong>”，如果不显式指定，API对象都会在这个“default”名字空间里。而其他的名字空间都有各自的用途，比如“kube-system”就包含了apiserver、etcd等核心组件的Pod。</p><p>通常我们会使用namespce区分线上环境。</p><p>Service对象的域名完全形式是“<strong>对象.名字空间.svc.cluster.local</strong>”，但很多时候也可以省略后面的部分，直接写“<strong>对象.名字空间</strong>”甚至“<strong>对象名</strong>”就足够了，默认会使用对象所在的名字空间（比如这里就是default）。</p><p>我们不再关心Service对象的IP地址，只需要知道它的名字，就可以用DNS的方式去访问后端服务。</p><h1 id="Ingress：集群进出流量的总管"><a href="#Ingress：集群进出流量的总管" class="headerlink" title="Ingress：集群进出流量的总管"></a>Ingress：集群进出流量的总管</h1><p><strong>Ingress的意思是集群内外边界上的入口，它作为流量的总入口，统管集群的进出口数据</strong>，“扇入”“扇出”流量（也就是我们常说的“南北向”），让外部用户能够安全、顺畅、便捷地访问内部服务。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/fef1938ec77144482a19e396dc7dd2fd59235dcd.png" alt="image-20250710174017411"></p><p>再对比一下Service我们就能更透彻地理解Ingress。</p><p>Ingress可以说是在七层上另一种形式的Service，它同样会代理一些后端的Pod，也有一些路由规则来定义流量应该如何分配、转发，只不过这些规则都使用的是HTTP&#x2F;HTTPS协议。</p><p>你应该知道，Service本身是没有服务能力的，它只是一些iptables规则，<strong>真正配置、应用这些规则的实际上是节点里的kube-proxy组件</strong>。如果没有kube-proxy，Service定义得再完善也没有用。</p><p>同样的，Ingress也只是一些HTTP路由规则的集合，相当于一份静态的描述文件，真正要把这些规则在集群里实施运行，还需要有另外一个东西，这就是 <code>Ingress Controller</code>，它的作用就相当于Service的kube-proxy，能够读取、应用Ingress规则，处理、调度流量。</p><p>理来说，Kubernetes应该把Ingress Controller内置实现，作为基础设施的一部分，就像kube-proxy一样。</p><p><strong>不过Ingress Controller要做的事情太多，与上层业务联系太密切，所以Kubernetes把Ingress Controller的实现交给了社区</strong>，任何人都可以开发Ingress Controller，只要遵守Ingress规则就好。</p><p>这就造成了Ingress Controller“百花齐放”的盛况。</p><p>由于Ingress Controller把守了集群流量的关键入口，掌握了它就拥有了控制集群应用的“话语权”，所以众多公司纷纷入场，精心打造自己的Ingress Controller，意图在Kubernetes流量进出管理这个领域占有一席之地。</p><p>这些实现中最著名的，就是老牌的反向代理和负载均衡软件Nginx了。从Ingress Controller的描述上我们也可以看到，HTTP层面的流量管理、安全控制等功能其实就是经典的反向代理，而Nginx则是其中稳定性最好、性能最高的产品，所以它也理所当然成为了Kubernetes里应用得最广泛的Ingress Controller。</p><p>根据Docker Hub上的统计，<strong>Nginx公司的开发实现是下载量最多的Ingress Controller</strong>，所以我将以它为例，讲解Ingress和Ingress Controller的用法。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/c4aab8c9306f5ef219e3edc97d4fb0a1774d7ba6.png" alt="image-20250710174349077"></p><h2 id="IngressClass"><a href="#IngressClass" class="headerlink" title="IngressClass"></a>IngressClass</h2><p>那么到现在，有了Ingress和Ingress Controller，我们是不是就可以完美地管理集群的进出流量了呢？</p><p>最初Kubernetes也是这么想的，一个集群里有一个Ingress Controller，再给它配上许多不同的Ingress规则，应该就可以解决请求的路由和分发问题了。</p><p>但随着Ingress在实践中的大量应用，很多用户发现这种用法会带来一些问题，比如：</p><ul><li>由于某些原因，项目组需要引入不同的Ingress Controller，但Kubernetes不允许这样做；</li><li>Ingress规则太多，都交给一个Ingress Controller处理会让它不堪重负；</li><li>多个Ingress对象没有很好的逻辑分组方式，管理和维护成本很高；</li><li>集群里有不同的租户，他们对Ingress的需求差异很大甚至有冲突，无法部署在同一个Ingress Controller上。</li></ul><p>所以，Kubernetes就又提出了一个 <code>Ingress Class</code> 的概念，让它插在Ingress和Ingress Controller中间，作为流量规则和控制器的协调人，解除了Ingress和Ingress Controller的强绑定关系。</p><p>现在，<strong>Kubernetes用户可以转向管理Ingress Class，用它来定义不同的业务逻辑分组，简化Ingress规则的复杂度</strong>。比如说，我们可以用Class A处理博客流量、Class B处理短视频流量、Class C处理购物流量。</p><p>有了Ingress Controller，这些API对象的关联就更复杂了，你可以用下面的这张图来看出它们是如何使用对象名字联系起来的：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/cb7dff89b0e7076adfc7a1e0b13c1ec3d535cd91.png" alt="image-20250710174938720"></p><h1 id="PersistentVolume：数据持久化"><a href="#PersistentVolume：数据持久化" class="headerlink" title="PersistentVolume：数据持久化"></a>PersistentVolume：数据持久化</h1><p>前面说到，pod是kubernetes中运行的最小单位，但是其中存在一个很严重的问题：Pod没有持久化功能，因为Pod里的容器是由镜像产生的，而镜像文件本身是只读的，进程要读写磁盘只能用一个临时的存储空间，一旦Pod销毁，临时存储也就会立即回收释放，数据也就丢失了。</p><p>为了保证即使Pod销毁后重建数据依然存在，我们就需要找出一个解决方案，让Pod用上真正的“虚拟盘”。Kubernetes延伸出了<strong>PersistentVolume</strong>对象，它专门用来表示持久存储设备。<strong>作为存储的抽象，PV实际上就是一些存储设备、文件系统</strong>，比如Ceph、GlusterFS、NFS，甚至是本地磁盘，管理它们已经超出了Kubernetes的能力范围，所以，一般会由系统管理员单独维护，然后再在Kubernetes里创建对应的PV。</p><p>要注意的是，PV属于集群的系统资源，是和Node平级的一种对象，Pod对它没有管理权，只有使用权。</p><h2 id="PersistentVolumeClaim"><a href="#PersistentVolumeClaim" class="headerlink" title="PersistentVolumeClaim"></a>PersistentVolumeClaim</h2><p>PersistentVolumeClaim，简称PVC，从名字上看比较好理解，就是用来向Kubernetes申请存储资源的。PVC是给Pod使用的对象，它相当于是Pod的代理，代表Pod向系统申请PV。一旦资源申请成功，Kubernetes就会把PV和PVC关联在一起，这个动作叫做“<strong>绑定</strong>”（bind）。</p><p>但是，系统里的存储资源非常多，如果要PVC去直接遍历查找合适的PV也很麻烦，所以就要用到StorageClass。</p><h2 id="StorageClass"><a href="#StorageClass" class="headerlink" title="StorageClass"></a>StorageClass</h2><p>StorageClass抽象了特定类型的存储系统（比如Ceph、NFS），在PVC和PV之间充当“协调人”的角色，帮助PVC找到合适的PV。也就是说它可以简化Pod挂载“虚拟盘”的过程，让Pod看不到PV的实现细节。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/cf9a383122edf826ccd7ece51440ae077ecab02e.png" alt="image-20250711153617343"></p><h1 id="StatefulSet：管理有状态的应用"><a href="#StatefulSet：管理有状态的应用" class="headerlink" title="StatefulSet：管理有状态的应用"></a>StatefulSet：管理有状态的应用</h1><p>用Deployment来保证高可用，用PersistentVolume来存储数据，确实可以部分达到管理“有状态应用”的目的。但“状态”不仅仅是数据持久化，在集群化、分布式的场景里，还有多实例的依赖关系、启动顺序和网络标识等问题需要解决，而这些问题恰恰是Deployment力所不及的。</p><p>因为只使用Deployment，多个实例之间是无关的，启动的顺序不固定，Pod的名字、IP地址、域名也都是完全随机的，这正是“无状态应用”的特点。</p><p>但对于“有状态应用”，多个实例之间可能存在依赖关系，比如master&#x2F;slave、active&#x2F;passive，需要依次启动才能保证应用正常运行，外界的客户端也可能要使用固定的网络标识来访问实例，而且这些信息还必须要保证在Pod重启后不变。</p><p>所以，Kubernetes就在Deployment的基础之上定义了一个新的API对象，名字也很好理解，就叫StatefulSet，专门用来管理有状态的应用。</p><p>前面提到，Service自己会有一个域名，格式是“<strong>对象名.名字空间</strong>”，每个Pod也会有一个域名，形式是“<strong>IP地址.名字空间</strong>”。但因为IP地址不稳定，所以Pod的域名并不实用，一般我们会使用稳定的Service域名。</p><p>当我们把Service对象应用于StatefulSet的时候，情况就不一样了。</p><p>Service发现这些Pod不是一般的应用，而是有状态应用，需要有稳定的网络标识，所以就会为Pod再多创建出一个新的域名，格式是“<strong>Pod名.服务名.名字空间.svc.cluster.local</strong>”。当然，这个域名也可以简写成“<strong>Pod名.服务名</strong>”。</p><p>显然，在StatefulSet里的这两个Pod都有了各自的域名，也就是稳定的网络标识。那么接下来，外部的客户端只要知道了StatefulSet对象，就可以用固定的编号去访问某个具体的实例了，虽然Pod的IP地址可能会变，但这个有编号的域名由Service对象维护，是稳定不变的。</p><h2 id="StatefulSet的数据持久化"><a href="#StatefulSet的数据持久化" class="headerlink" title="StatefulSet的数据持久化"></a>StatefulSet的数据持久化</h2><p>现在StatefulSet已经有了固定的名字、启动顺序和网络标识，只要再给它加上数据持久化功能，我们就可以实现对“有状态应用”的管理了。</p><p>不过，为了强调持久化存储与StatefulSet的一对一绑定关系，Kubernetes为StatefulSet专门定义了一个字段“<strong>volumeClaimTemplates</strong>”，直接把PVC定义嵌入StatefulSet的YAML文件里。这样能保证创建StatefulSet的同时，就会为每个Pod自动创建PVC，让StatefulSet的可用性更高。</p><h1 id="滚动更新：平滑的应用升降级"><a href="#滚动更新：平滑的应用升降级" class="headerlink" title="滚动更新：平滑的应用升降级"></a>滚动更新：平滑的应用升降级</h1><h2 id="应用升级"><a href="#应用升级" class="headerlink" title="应用升级"></a>应用升级</h2><p>在Kubernetes里，版本更新使用的不是API对象，而是两个命令：<code>kubectl apply</code> 和 <code>kubectl rollout</code>，当然它们也要搭配部署应用所需要的Deployment、DaemonSet等YAML文件。</p><p>Kubernetes里应用都是以Pod的形式运行的，而Pod通常又会被Deployment等对象来管理，<strong>所以应用的“版本更新”实际上更新的是整个Pod</strong>。</p><p>Pod是由YAML描述文件来确定的，更准确地说，是Deployment等对象里的字段 <code>template</code>。所以，<strong>在Kubernetes里应用的版本变化就是 <code>template</code> 里Pod的变化</strong>，哪怕 <code>template</code> 里只变动了一个字段，那也会形成一个新的版本，也算是版本变化。</p><p>Kubernetes不是把旧Pod全部销毁再一次性创建出新Pod，而是在逐个地创建新Pod，同时也在销毁旧Pod，保证系统里始终有足够数量的Pod在运行，不会有“空窗期”中断服务。</p><p>新Pod数量增加的过程有点像是“滚雪球”，从零开始，越滚越大，所以这就是所谓的“<strong>滚动更新</strong>”（rolling update）。</p><p>其实“滚动更新”就是由Deployment控制的两个同步进行的“应用伸缩”操作，老版本缩容到0，同时新版本扩容到指定值，是一个“此消彼长”的过程。</p><h2 id="应用回滚"><a href="#应用回滚" class="headerlink" title="应用回滚"></a>应用回滚</h2><p>对于更新后出现的问题，Kubernetes为我们提供了“后悔药”，也就是更新历史，你可以查看之前的每次更新记录，并且回退到任何位置，和我们开发常用的Git等版本控制软件非常类似。</p><p>如果想要回退到上一个版本，就可以使用命令 <code>kubectl rollout undo</code>，也可以加上参数 <code>--to-revision</code> 回退到任意一个历史版本。<code>kubectl rollout undo</code> 的操作过程其实和 <code>kubectl apply</code> 是一样的，执行的仍然是“滚动更新”，只不过使用的是旧版本Pod模板，把新版本Pod数量收缩到0，同时把老版本Pod扩展到指定值。</p><h1 id="应用保障：如何让Pod运行得更健康？"><a href="#应用保障：如何让Pod运行得更健康？" class="headerlink" title="应用保障：如何让Pod运行得更健康？"></a>应用保障：如何让Pod运行得更健康？</h1><h2 id="容器资源配额"><a href="#容器资源配额" class="headerlink" title="容器资源配额"></a>容器资源配额</h2><p>创建容器有三大隔离技术：namespace、cgroup、chroot。其中的namespace实现了独立的进程空间，cgroup的作用是管控CPU、内存，保证容器不会无节制地占用基础资源，进而影响到系统里的其他应用，chroot实现了独立的文件系统。</p><p>与PersistentVolumeClaim用法有些类似，就是容器需要先提出一个“书面申请”，Kubernetes再依据这个“申请”决定资源是否分配和如何分配。使用 <code>resources</code> 字段加上资源配额之后，Pod在Kubernetes里的运行就有了初步保障，Kubernetes会监控Pod的资源使用情况，让它既不会“饿死”也不会“撑死”。</p><p>Kubernetes会根据每个Pod声明的需求，像搭积木或者玩俄罗斯方块一样，把节点尽量“塞满”，充分利用每个节点的资源，让集群的效益最大化。</p><h2 id="容器状态探针"><a href="#容器状态探针" class="headerlink" title="容器状态探针"></a>容器状态探针</h2><p>一个程序即使正常启动了，它也有可能因为某些原因无法对外提供服务。其中最常见的情况就是运行时发生“死锁”或者“死循环”的故障，这个时候从外部来看进程一切都是正常的，但内部已经是一团糟了。</p><p>Kubernetes为检查应用状态定义了三种探针，它们分别对应容器不同的状态：</p><ul><li><strong>Startup</strong>，启动探针，用来检查应用是否已经启动成功，适合那些有大量初始化工作要做，启动很慢的应用。</li><li><strong>Liveness</strong>，存活探针，用来检查应用是否正常运行，是否存在死锁、死循环。</li><li><strong>Readiness</strong>，就绪探针，用来检查应用是否可以接收流量，是否能够对外提供服务。</li></ul><p>你需要注意这三种探针是递进的关系：应用程序先启动，加载完配置文件等基本的初始化数据就进入了Startup状态，之后如果没有什么异常就是Liveness存活状态，但可能有一些准备工作没有完成，还不一定能对外提供服务，只有到最后的Readiness状态才是一个容器最健康可用的状态。</p><p>那Kubernetes具体是如何使用状态和探针来管理容器的呢？</p><p>如果一个Pod里的容器配置了探针，<strong>Kubernetes在启动容器后就会不断地调用探针来检查容器的状态</strong>：</p><ul><li>如果Startup探针失败，Kubernetes会认为容器没有正常启动，就会尝试反复重启，当然其后面的Liveness探针和Readiness探针也不会启动。</li><li>如果Liveness探针失败，Kubernetes就会认为容器发生了异常，也会重启容器。</li><li>如果Readiness探针失败，Kubernetes会认为容器虽然在运行，但内部有错误，不能正常提供服务，就会把容器从Service对象的负载均衡集合中排除，不会给它分配流量。</li></ul><p><img src="https://i0.hdslb.com/bfs/openplatform/76404447854f331194c43631155b944c36c2d4e7.png" alt="image-20250711172041991"></p><h1 id="集群管理：如何用名字空间分隔系统资源？"><a href="#集群管理：如何用名字空间分隔系统资源？" class="headerlink" title="集群管理：如何用名字空间分隔系统资源？"></a>集群管理：如何用名字空间分隔系统资源？</h1><p>Kubernetes的名字空间并不是一个实体对象，只是一个逻辑上的概念。它可以把集群切分成一个个彼此独立的区域，然后我们把对象放到这些区域里，就实现了类似容器技术里namespace的隔离效果，应用只能在自己的名字空间里分配资源和运行，不会干扰到其他名字空间里的应用。</p><h2 id="资源配额"><a href="#资源配额" class="headerlink" title="资源配额"></a>资源配额</h2><p>有了名字空间，我们就可以像管理容器一样，给名字空间设定配额，把整个集群的计算资源分割成不同的大小，按需分配给团队或项目使用。</p><p>不过集群和单机不一样，除了限制最基本的CPU和内存，还必须限制各种对象的数量，否则对象之间也会互相挤占资源。</p><h2 id="默认资源配额"><a href="#默认资源配额" class="headerlink" title="默认资源配额"></a>默认资源配额</h2><p>学到这里估计你也发现了，在名字空间加上了资源配额限制之后，它会有一个合理但比较“烦人”的约束：要求所有在里面运行的Pod都必须用字段 <code>resources</code> 声明资源需求，否则就无法创建。</p><p>Kubernetes这样做的原因也很好理解，如果Pod里没有 <code>resources</code> 字段，就可以无限制地使用CPU和内存，这显然与名字空间的资源配额相冲突。<strong>为了保证名字空间的资源总量可管可控，Kubernetes就只能拒绝创建这样的Pod了。</strong></p><p>那么能不能让Kubernetes自动为Pod加上资源限制呢？也就是说给个默认值，这样就可以省去反复设置配额的烦心事。</p><p>这个时候就要用到一个<strong>很小但很有用的辅助对象了—— <code>LimitRange</code>，简称是 <code>limits</code>，它能为API对象添加默认的资源配额限制</strong>。</p><h1 id="系统监控：如何使用Metrics-Server和Prometheus？"><a href="#系统监控：如何使用Metrics-Server和Prometheus？" class="headerlink" title="系统监控：如何使用Metrics Server和Prometheus？"></a>系统监控：如何使用Metrics Server和Prometheus？</h1><p>希望给集群也安装上“检查探针”，观察到集群的资源利用率和其他指标，让集群的整体运行状况对我们“透明可见”，这样才能更准确更方便地做好集群的运维工作。</p><h2 id="Metrics-Server"><a href="#Metrics-Server" class="headerlink" title="Metrics Server"></a>Metrics Server</h2><p>Metrics Server是一个专门用来收集Kubernetes核心资源指标（metrics）的工具，它定时从所有节点的kubelet里采集信息，但是对集群的整体性能影响极小，每个节点只大约会占用1m的CPU和2MB的内存，所以性价比非常高。</p><p>它调用kubelet的API拿到节点和Pod的指标，再把这些信息交给apiserver，这样kubectl、HPA就可以利用apiserver来读取指标了：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/a3506f759b38d478201c9ae99c841c0e5082fd54.png" alt="image-20250711172952961"></p><h2 id="HorizontalPodAutoscaler"><a href="#HorizontalPodAutoscaler" class="headerlink" title="HorizontalPodAutoscaler"></a>HorizontalPodAutoscaler</h2><p>有了Metrics Server，我们就可以轻松地查看集群的资源使用状况了，不过它另外一个更重要的功能是辅助实现应用的“<strong>水平自动伸缩</strong>”。</p><p>“<strong>HorizontalPodAutoscaler</strong>”，简称是“<strong>hpa</strong>”。顾名思义，它是专门用来自动伸缩Pod数量的对象，适用于Deployment和StatefulSet，但不能用于DaemonSet。</p><p>HorizontalPodAutoscaler的能力完全基于Metrics Server，它从Metrics Server获取当前应用的运行指标，主要是CPU使用率，再依据预定的策略增加或者减少Pod的数量。</p><p>因为Metrics Server大约每15秒采集一次数据，所以HorizontalPodAutoscaler的自动化扩容和缩容也是按照这个时间点来逐步处理的。</p><p>当它发现目标的CPU使用率超过了预定的5%后，就会以2的倍数开始扩容，一直到数量上限，然后持续监控一段时间，如果CPU使用率回落，就会再缩容到最小值。</p><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p>显然，有了Metrics Server和HorizontalPodAutoscaler的帮助，我们的应用管理工作又轻松了一些。不过，Metrics Server能够获取的指标还是太少了，只有CPU和内存，想要监控到更多更全面的应用运行状况，还得请出这方面的权威项目“<strong>Prometheus</strong>”。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/bacc77beade046913111576c813dbc1027ebdf7e.png" alt="image-20250711173914580"></p><p>Prometheus系统的核心是它的Server，里面有一个时序数据库TSDB，用来存储监控数据，另一个组件Retrieval使用拉取（Pull）的方式从各个目标收集数据，再通过HTTP Server把这些数据交给外界使用。</p><p>在Prometheus Server之外还有三个重要的组件：</p><ul><li>Push Gateway，用来适配一些特殊的监控目标，把默认的Pull模式转变为Push模式。</li><li>Alert Manager，告警中心，预先设定规则，发现问题时就通过邮件等方式告警。</li><li>Grafana是图形化界面，可以定制大量直观的监控仪表盘。</li></ul><h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><p>Kubernetes提出了一个自己的网络模型“<strong>IP-per-pod</strong>”，能够很好地适应集群系统的网络需求，它有下面的这4点基本假设：</p><ul><li>集群里的每个Pod都会有唯一的一个IP地址。</li><li>Pod里的所有容器共享这个IP地址。</li><li>集群里的所有Pod都属于同一个网段。</li><li>Pod直接可以基于IP地址直接访问另一个Pod，不需要做麻烦的网络地址转换（NAT）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker的使用技巧</title>
      <link href="/2025/07/09/docker%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2025/07/09/docker%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>镜像是容器的静态形式，它打包了应用程序的所有运行依赖项，方便保存和传输。使用容器技术运行镜像，就形成了动态的容器，由于镜像只读不可修改，所以应用程序的运行环境总是一致的。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ol><li>容器就是操作系统里一个特殊的“沙盒”环境，里面运行的进程只能看到受限的信息，与外部系统实现了隔离。</li><li>容器隔离的目的是为了系统安全，限制了进程能够访问的各种资源。</li><li>相比虚拟机技术，容器更加轻巧、更加高效，消耗的系统资源非常少，在云计算时代极具优势。</li></ol><p>进入容器命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec <span class="literal">-it</span> <span class="number">062</span> sh</span><br></pre></td></tr></table></figure><h1 id="Docker-Desktop"><a href="#Docker-Desktop" class="headerlink" title="Docker Desktop"></a>Docker Desktop</h1><p>Docker Desktop 是<strong>容器化应用开发与部署的一体化工具</strong>，支持在本地环境创建、管理和运行Docker容器。</p><p>很多人以为，只要换了新电脑或者格式化电脑后，在docker desktop拉取的镜像、容器都会消失，现在我就来介绍一下将 Docker Desktop 的容器打包成镜像，上传到 docker hub 的方法，以后就可以像代码一样管理维护自己的docker镜像。</p><h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>在使用 <code>docker pull</code> 获取镜像的时候，我们并没有明确地指定镜像仓库。在这种情况下，Docker就会使用一个默认的镜像仓库，也就是大名鼎鼎的“<strong>Docker Hub</strong>”。</p><p>docker hub地址：<a href="https://hub.docker.com/repository/docker/wuziqing/planet/general">hub.docker.com</a></p><p>Docker Hub里面不仅有Docker自己打包的镜像，而且还对公众免费开放，任何人都可以上传自己的作品。经过这8年的发展，Docker Hub已经不再是一个单纯的镜像仓库了，更应该说是一个丰富而繁荣的容器社区。</p><p>如果想覆盖仓库中已有镜像，可以在本地重新构建镜像后，使用相同的标签推送镜像到仓库。</p><ol><li><p>docker hub 账号在本地验证登录</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure></li><li><p>将容器commit成镜像</p></li></ol><p>docker tag <existing-image>  <hub-user>&#x2F;<repo-name>[:<tag>]</tag></repo-name></hub-user></existing-image></p><p>   docker commit <existing-container>  <hub-user>&#x2F;<repo-name>[:<tag>]</tag></repo-name></hub-user></existing-container></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit <span class="number">277</span>e80820516 hub<span class="literal">-user</span>/repo<span class="literal">-name</span>:tag</span><br></pre></td></tr></table></figure><ol start="3"><li><p>docker push 镜像到 docker hub 仓库</p><p>docker push  <hub-user>&#x2F;<repo-name>[:<tag>]</tag></repo-name></hub-user></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push hub<span class="literal">-user</span>/repo<span class="literal">-name</span>:tag</span><br></pre></td></tr></table></figure></li><li><p>验证</p><p>命令验证：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect hub<span class="literal">-user</span>/repo<span class="literal">-name</span>:tag</span><br></pre></td></tr></table></figure><p>线上仓库验证：登录docker hub，刷新仓库页，查看是否推送成功。</p></li><li><p>拉取镜像到本地</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hub<span class="literal">-user</span>/repo<span class="literal">-name</span>:tag</span><br></pre></td></tr></table></figure></li></ol><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>镜像就是一个打包文件，里面包含了应用程序还有它运行所依赖的环境，例如文件系统、环境变量、配置参数等等。</p><p>环境变量、配置参数这些东西还是比较简单的，随便用一个manifest清单就可以管理，真正麻烦的是文件系统。为了保证容器运行环境的一致性，镜像必须把应用程序所在操作系统的根目录，也就是rootfs，都包含进来。</p><p>由此引出容器镜像的一个重大创新点：分层，术语叫“<strong>Layer</strong>”。就是把重复的部分抽取出来，只存放一份Ubuntu根目录文件，然后让这一千个镜像以某种方式共享这部分数据。</p><p>Dockerfile非常普通，它就是一个纯文本，里面记录了一系列的构建指令，比如选择基础镜像、拷贝文件、运行脚本等等，每个指令都会生成一个Layer，而Docker顺序执行这个文件里的所有步骤，最后就会创建出一个新的镜像出来。</p><p>创建镜像命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build <span class="operator">-f</span> Dockerfile.busybox .</span><br></pre></td></tr></table></figure><h2 id="docker-build-是怎么工作的"><a href="#docker-build-是怎么工作的" class="headerlink" title="docker build 是怎么工作的"></a>docker build 是怎么工作的</h2><p>命令行“docker”是一个简单的客户端，真正的镜像构建工作是由服务器端的“Docker daemon”来完成的，所以“docker”客户端就只能把“构建上下文”目录打包上传（显示信息 <code>Sending build context to Docker daemon</code> ），这样服务器才能够获取本地的这些文件。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/f631fc44deb0f0ccb46b3e68dcfbd2d123f4e13a.png" alt="image-20250709160506558"></p><h2 id="Dockerfile-编写规范"><a href="#Dockerfile-编写规范" class="headerlink" title="Dockerfile 编写规范"></a>Dockerfile 编写规范</h2><ol><li>创建镜像需要编写Dockerfile，写清楚创建镜像的步骤，每个指令都会生成一个Layer。</li><li>Dockerfile里，第一个指令必须是 <code>FROM</code>，用来选择基础镜像，常用的有Alpine、Ubuntu等。其他常用的指令有：<code>COPY</code>、<code>RUN</code>、<code>EXPOSE</code>，分别是拷贝文件，运行Shell命令，声明服务端口号。</li><li><code>docker build</code> 需要用 <code>-f</code> 来指定Dockerfile，如果不指定就使用当前目录下名字是“Dockerfile”的文件。</li><li><code>docker build</code> 需要指定“构建上下文”，其中的文件会打包上传到Docker daemon，所以尽量不要在“构建上下文”中存放多余的文件。</li><li>创建镜像的时候应当尽量使用 <code>-t</code> 参数，为镜像起一个有意义的名字，方便管理。</li></ol><h1 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker-compose"></a>Docker-compose</h1><p>在Docker把容器技术大众化之后，Docker周边涌现出了数不胜数的扩展、增强产品，其中有一个名字叫“Fig”的小项目格外令人瞩目。</p><p>Fig为Docker引入了“容器编排”的概念，使用YAML来定义容器的启动参数、先后顺序和依赖关系，让用户不再有Docker冗长命令行的烦恼，第一次见识到了“声明式”的威力。因此，docker-compose自身的定位是管理和运行多个Docker容器的工具。</p><p>docker-compose里管理容器的核心概念是“<strong>service</strong>”。注意，它与Kubernetes里的 <code>Service</code> 虽然名字很像，但却是完全不同的东西。docker-compose里的“service”就是一个容器化的应用程序，通常是一个后台服务，用YAML定义这些容器的参数和相互之间的关系。</p><p>如果硬要和Kubernetes对比的话，和“service”最像的API对象应该算是Pod里的container了，同样是管理容器运行，但docker-compose的“service”又融合了一些Service、Deployment的特性。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis实战：场景设计</title>
      <link href="/2025/07/07/Redis%E5%AE%9E%E6%88%98%EF%BC%9A%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/"/>
      <url>/2025/07/07/Redis%E5%AE%9E%E6%88%98%EF%BC%9A%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-热升级"><a href="#Redis-热升级" class="headerlink" title="Redis 热升级"></a>Redis 热升级</h1><p>对于线上较大流量的业务，单个 Redis 实例的内存占用很容易达到数 G 的容量，对应的 aof 会占用数十 G 的空间。即便每天流量低峰时间，对 Redis 进行 rewriteaof，减少数据冗余，但由于业务数据多，写操作多，aof 文件仍然会达到 10G 以上。</p><p>此时，在 Redis 需要升级版本或修复 bug 时，如果直接重启变更，由于需要数据恢复，这个过程需要近 10 分钟的时间，时间过长，会严重影响系统的可用性。</p><p>首先构建一个 Redis 壳程序，将 redisServer 的所有属性（包括redisDb、client等）保存为全局变量。然后将 Redis 的处理逻辑代码全部封装到动态连接库 so 文件中。Redis 第一次启动，从磁盘加载恢复数据，在后续升级时，通过指令，壳程序重新加载 Redis 新的 so 文件，即可完成功能升级，毫秒级完成 Redis 的版本升级。而且整个过程中，所有 Client 连接仍然保留，在升级成功后，原有 Client 可以继续进行读写操作，整个过程对业务完全透明。</p><h1 id="Redis-功能扩展"><a href="#Redis-功能扩展" class="headerlink" title="Redis 功能扩展"></a>Redis 功能扩展</h1><p>在 Redis 使用中，也经常会遇到一些特殊业务场景，是当前 Redis 的数据结构无法很好满足的。此时可以对 Redis 进行定制化扩展。可以根据业务数据特点，扩展新的数据结构，甚至扩展新的 Redis 存储模型，来提升 Redis 的内存效率和处理性能。</p><p>在微博中，有个业务类型是关注列表。关注列表存储的是一个用户所有关注的用户 uid。关注列表可以用来验证关注关系，也可以用关注列表，进一步获取所有关注人的微博列表等。由于用户数量过于庞大，存储关注列表的 Redis 是作为一个缓存使用的，即不活跃的关注列表会很快被踢出 Redis。在再次需要这个用户的关注列表时，重新从 DB 加载，并写回 Redis。关注列表的元素全部 long，最初使用 set 存储，回种 set 时，使用 sadd 进行批量添加。线上发现，对于关注数比较多的关注列表，比如关注数有数千上万个用户，需要 sadd 上成千上万个 uid，即便分几次进行批量添加，每次也会消耗较多时间，数据回种效率较低，而且会导致 Redis 卡顿。另外，用 set 存关注列表，内存效率也比较低。</p><p>于是，我们对 Redis 扩展了 longset 数据结构。longset 本质上是一个 long 型的一维开放数组。可以采用 double-hash 进行寻址。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/f8431237bd0f6b0a50fdcd1d1807a555e2786814.png" alt="image-20250709141345697"></p><p>从 DB 加载到用户的关注列表，准备写入 Redis 前。Client 首先根据关注的 uid 列表，构建成 long 数组的二进制格式，然后通过扩展的 lsset 指令写入 Redis。</p><p>longset 中的 long 数组，采用 double-hash 进行寻址，即对每个 long 值采用 2 个哈希函数计算，然后按 (h1 + n*h2)% 数组长度 的方式，确定 long 值的位置。n 从 0 开始计算，如果出现哈希冲突，即计算的哈希位置，已经有其他元素，则 n 加 1，继续向前推进计算，最大计算次数是数组的长度。</p><p>在向 longset 数据结构不断增加 long 值元素的过程中，当数组的填充率超过阀值，Redis 则返回 longset 过满的异常。此时 Client 会根据最新全量数据，构建一个容量加倍的一维 long 数组，再次 lsset 回 Redis 中。</p><h2 id="完全增量复制"><a href="#完全增量复制" class="headerlink" title="完全增量复制"></a>完全增量复制</h2><p>微博整合 Redis 的 rdb 和 aof 策略，构建了完全增量复制方案。</p><p>在完全增量方案中，aof 文件不再只有一个，而是按后缀 id 进行递增，如 aof.00001、aof.00002，当 aof 文件超过阀值，则创建下一个 id 加 1 的文件，从而滚动存储最新的写指令。在 bgsave 构建 rdb 时，rdb 文件除了记录当前的内存数据快照，还会记录 rdb 构建时间，对应 aof 文件的 id 及位置。这样 rdb 文件和其记录 aof 文件位置之后的写指令，就构成一份完整的最新数据记录。</p><p>主从复制时，master 通过独立的复制线程向 slave 同步数据。每个 slave 会创建一个复制线程。第一次复制是全量复制，之后的复制，不管 slave 断开复制连接有多久，只要 aof 文件没有被删除，都是增量复制。</p><p>第一次全量复制时，复制线程首先将 rdb 发给 slave，然后再将 rdb 记录的 aof 文件位置之后的所有数据，也发送给 slave，即可完成。整个过程不用重新构建 rdb。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/14de3f441fc9bb6f9c597c228c18c7e02b4fa8db.png" alt="image-20250709141402578"></p><p>后续同步时，slave 首先传递之前复制的 aof 文件的 id 及位置。master 的复制线程根据这个信息，读取对应 aof 文件位置之后的所有内容，发送给 slave，即可完成数据同步。</p><p>由于整个复制过程，master 在独立复制线程中进行，所以复制过程不影响用户的正常请求。为了减轻 master 的复制压力，全增量复制方案仍然支持 slave 嵌套，即可以在 slave 后继续挂载多个 slave，从而把复制压力分散到多个不同的 Redis 实例。</p><h1 id="如何为秒杀系统设计缓存体系"><a href="#如何为秒杀系统设计缓存体系" class="headerlink" title="如何为秒杀系统设计缓存体系"></a>如何为秒杀系统设计缓存体系</h1><p>在设计秒杀系统时，有两个设计原则。</p><p>首先，要尽力将请求拦截在系统上游，层层设阻拦截，过滤掉无效或超量的请求。因为访问量远远大于商品数量，所有的请求打到后端服务的最后一步，其实并没有必要，反而会严重拖慢真正能成交的请求，降低用户体验。</p><p>其次，要充分利用缓存，提升系统的性能和可用性。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/0247772e6c2f55ffc860328565ffef5bff57208f.png" alt="image-20250709141433518"></p><p>秒杀系统专为秒杀活动服务，售卖商品确定，因此可以在设计秒杀商品页面时，将商品信息提前设计为静态信息，将静态的商品信息以及常规的 CSS、JS、宣传图片等静态资源，一起独立存放到 CDN 节点，加速访问，且降低系统访问压力。</p><p>在访问前端也可以制定种种限制策略，比如活动没开始时，抢购按钮置灰，避免抢先访问，用户抢购一次后，也将按钮置灰，让用户排队等待，避免反复刷新。</p><p>用户所有的请求进入秒杀系统前，通过负载均衡策略均匀分发到不同 Web 服务器，避免节点过载。在 Web 服务器中，首先进行各种服务预处理，检查用户的访问权限，识别并发刷订单的行为。同时在真正服务前，也要进行服务前置检查，避免超售发生。如果发现售出数量已经达到秒杀数量，则直接返回结束。</p><p>秒杀系统在处理抢购业务逻辑时，除了对用户进行权限校验，还需要访问商品服务，对库存进行修改，访问订单服务进行订单创建，最后再进行支付、物流等后续服务。这些依赖服务，可以专门为秒杀业务设计排队策略，或者额外部署实例，对秒杀系统进行专门服务，避免影响其他常规业务系统。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/1366a88cadb61bd665fb9cffdb884430bed63509.png" alt="image-20250709141443825"></p><p>由于秒杀的参与者远大于商品数，为了提高抢购的概率，时常会出现一些利用脚本和僵尸账户并发频繁调用接口进行强刷的行为，秒杀系统需要构建访问记录缓存，记录访问 IP、用户的访问行为，发现异常访问，提前进行阻断及返回。同时还需要构建用户缓存，并针对历史数据分析，提前缓存僵尸强刷专业户，方便在秒杀期间对其进行策略限制。这些访问记录、用户数据，通过缓存进行存储，可以加速访问，另外，对用户数据还进行缓存预热，避免活动期间大量穿透。</p><p>在业务请求处理时，所有操作尽可能由缓存交互完成。由于秒杀商品较少，相关信息全部加载到内存，把缓存暂时当作存储用，并不会带来过大成本负担。</p><p>为秒杀商品构建商品信息缓存，并对全部目标商品进行预热加载。同时对秒杀商品构建独立的库存缓存，加速库存检测。这样通过秒杀商品列表缓存，进行快速商品信息查询，通过库存缓存，可以快速确定秒杀活动进程，方便高效成交或无可售商品后的快速检测及返回。在用户抢购到商品后，要进行库存事务变更，进行库存、订单、支付等相关的构建和修改，这些操作可以尽量由系统只与缓存组件交互完成初步处理。后续落地等操作，必须要入DB库的操作，可以先利用消息队列机，记录成交事件信息，然后再逐步分批执行，避免对 DB 造成过大压力。</p><p>总之，在秒杀系统中，除了常规的分拆访问内容和服务，最重要的是尽量将所有数据访问进行缓存化，尽量减少 DB 的访问，在大幅提升系统性能的同时，提升用户体验。</p><h1 id="如何为海量计数场景设计缓存体系"><a href="#如何为海量计数场景设计缓存体系" class="headerlink" title="如何为海量计数场景设计缓存体系"></a>如何为海量计数场景设计缓存体系</h1><h2 id="计数常规方案"><a href="#计数常规方案" class="headerlink" title="计数常规方案"></a>计数常规方案</h2><p>计数服务在互联网系统中非常常见，用户的关注粉丝数、帖子数、评论数等都需要进行计数存储。计数的存储格式也很简单，key 一般是用户 uid 或者帖子 id 加上后缀，value 一般是 8 字节的 long 型整数。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/302df249ad520edfdd0d51b42abe7f69b0bda7bc.png" alt="image-20250709141501087"></p><p>最常见的计数方案是采用缓存 + DB 的存储方案。当计数变更时，先变更计数 DB，计数加 1，然后再变更计数缓存，修改计数存储的 Memcached 或 Redis。这种方案比较通用且成熟，但在高并发访问场景，支持不够友好。在互联网社交系统中，有些业务的计数变更特别频繁，比如微博 feed 的阅读数，计数的变更次数和访问次数相当，每秒十万到百万级以上的更新量，如果用 DB 存储，会给 DB 带来巨大的压力，DB 就会成为整个计数服务的瓶颈所在。即便采用聚合延迟更新 DB 的方案，由于总量特别大，同时请求均衡分散在大量不同的业务端，巨大的写压力仍然是 DB 的不可承受之重。因此这种方案只适合中小规模的计数服务使用。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/d8fdb89f1386e9102e52a06292f559feea9eb23f.png" alt="image-20250709141514173"></p><p>在 Redis 问世并越来越成熟后，很多互联网系统会直接把计数全部存储在 Redis 中。通过 hash 分拆的方式，可以大幅提升计数服务在 Redis 集群的写性能，通过主从复制，在 master 后挂载多个从库，利用读写分离，可以大幅提升计数服务在 Redis 集群的读性能。而且 Redis 有持久化机制，不会丢数据，在很多大中型互联网场景，这都是一个比较适合的计数服务方案。</p><p>在互联网移动社交领域，由于用户基数巨大，每日发表大量状态数据，且相互之间有大量的交互动作，从而产生了海量计数和超高并发访问，如果直接用 Redis 进行存储，会带来巨大的成本和性能问题。</p><h2 id="海量计数场景"><a href="#海量计数场景" class="headerlink" title="海量计数场景"></a>海量计数场景</h2><p>以微博为例，系统内有大量的待计数对象。如从用户维度，日活跃用户 2 亿+，月活跃用户接近 5 亿。从 Feed 维度，微博历史 Feed 有数千亿条，而且每日新增数亿条的新 Feed。这些用户和 Feed 不但需要进行计数，而且需要进行多个计数。比如，用户维度，每个用户需要记录关注数、粉丝数、发表 Feed 数等。而从 Feed 维度，每条 Feed 需要记录转发数、评论数、赞、阅读等计数。</p><p>而且，在微博业务场景下，每次请求都会请求多个对象的多个计数。比如查看用户时，除了获取该用户的基本信息，还需要同时获取用户的关注数、粉丝数、发表 Feed 数。获取微博列表时，除了获取 Feed 内容，还需要同时获取 Feed 的转发数、评论数、赞数，以及阅读数。因此，微博计数服务的总访问量特别大，很容易达到百万级以上的 QPS。</p><p><strong>方案选择：</strong></p><p>因此，在海量计数高并发访问场景，如果采用缓存 + DB 的架构，首先 DB 在计数更新就会存在瓶颈，其次，单个请求一次请求数十个计数，一旦缓存 miss，穿透到 DB，DB 的读也会成为瓶颈。因为 DB 能支撑的 TPS 不过 3000~6000 之间，远远无法满足高并发计数访问场景的需要。</p><p>采用 Redis 全量存储方案，通过分片和主从复制，读写性能不会成为主要问题，但容量成本却会带来巨大开销。</p><p>因为，一方面 Redis 作为通用型存储来存储计数，<strong>内存存储效率低</strong>。以存储一个 key 为 long 型 id、value 为 4 字节的计数为例，Redis 至少需要 65 个字节左右，不同版本略有差异。但这个计数理论只需要占用 12 个字节即可。内存有效负荷只有 12⁄65&#x3D;18.5%。如果再考虑一个 long 型 id 需要存 4 个不同类型的 4 字节计数，内存有效负荷只有 (8+16)&#x2F;(65*4)&#x3D; 9.2%。</p><p>另一方面，Redis 所有数据均存在内存，单存储历史千亿级记录，单份数据拷贝需要 10T 以上，要考虑核心业务上 1 主 3 从，需要 40T 以上的内存，再考虑多 IDC 部署，<strong>轻松占用上百 T 内存</strong>。就按单机 100G 内存来算，计数服务就要占用上千台大内存服务器。存储成本太高。</p><h2 id="海量计数服务架构"><a href="#海量计数服务架构" class="headerlink" title="海量计数服务架构"></a>海量计数服务架构</h2><p><img src="https://i0.hdslb.com/bfs/openplatform/0580bed1c59bb8eb3ad4c2035e37592012c8216c.png" alt="image-20250709141528777"></p><p>为了解决海量计数的存储及访问的问题，微博基于 Redis 定制开发了计数服务系统，该计数服务兼容 Redis 协议，将所有数据分别存储在内存和磁盘 2 个区域。首先，内存会预分配 N 块大小相同的 Table 空间，线上一般每个 Table 占用 1G 字节，最大分配 10 个左右的 Table 空间。首先使用 Table0，当存储填充率超过阀值，就使用 Table1，依次类推。每个 Table 中，key 是微博 id，value 是自定义的多个计数。</p><p>微博的 id 按时间递增，因此每个内存 Table 只用存储一定范围内的 id 即可。内存 Table 预先按设置分配为相同 size 大小的 key-value 槽空间。每插入一个新 key，就占用一个槽空间，当槽位填充率超过阀值，就滚动使用下一个 Table，当所有预分配的 Table 使用完毕，还可以根据配置，继续从内存分配更多新的 Table 空间。当内存占用达到阀值，就会把内存中 id 范围最小的 Table 落盘到 SSD 磁盘。落盘的 Table 文件称为 DDB。每个内存 Table 对应落盘为 1 个 DDB 文件。</p><p>计数服务会将落盘 DDB 文件的索引记录在内存，这样当查询需要从内存穿透到磁盘时，可以直接定位到磁盘文件，加快查询速度。</p><p>计数服务可以设置 Schema 策略，使一个 key 的 value 对应存储多个计数。每个计数占用空间根据 Schema 确定，可以精确到 bit。key 中的各个计数，设置了最大存储空间，所以只能支持有限范围内的计数。如果计数超过设置的阀值，则需要将这个 key 从 Table 中删除，转储到 aux dict 辅助词典中。</p><p>同时每个 Table 负责一定范围的 id，由于微博 id 随时间增长，而非逐一递增，Table 滚动是按照填充率达到阀值来进行的。当系统发生异常时，或者不同区域网络长时间断开重连后，在老数据修复期间，可能在之前的 Table 中插入较多的计数 key。如果旧 Table 插入数据量过大，超过容量限制，或者持续搜索存储位置而不得，查找次数超过阀值，则将新 key 插入到 extend dict 扩展词典中。</p><p>微博中的 feed 一般具有明显的冷热区分，并且越新的 feed 越热，访问量越大，越久远的 feed 越冷。新的热 key 存放内存 Table，老的冷 key 随所在的 Table 被置换到 DDB 文件。当查询 DDB 文件中的冷 key 时，会采用多线程异步并行查询，基本不影响业务的正常访问。同时，这些冷 key 从 DDB 中查询后，会被存放到 LRU 中，从而方便后续的再次访问。</p><p>计数服务的内存数据快照仍然采用前面讲的 RDB + 滚动 AOF 策略。RDB 记录构建时刻对应的 AOF 文件 id 及 pos 位置。全量复制时，master 会将磁盘中的 DDB 文件，以及内存数据快照对应的 RDB 和 AOF 全部传送给 slave。</p><p>在之后的所有复制就是全增量复制，slave 在断开连接，再次重连 master 时，汇报自己同步的 AOF 文件 id 及位置，master 将对应文件位置之后的内容全部发送给 slave，即可完成同步。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/02cf1e7531de2672ca7a37ed4776e0710bb09a9a.png" alt="image-20250709141539168"></p><p>计数服务中的内存 Table 是一个一维开放数据，每个 key-value 按照 Schema 策略占用相同的内存。每个 key-value 内部，key 和多个计数紧凑部署。首先 8 字节放置 long 型 key，然后按Schema 设置依次存放各个计数。</p><p>key 在插入及查询时，流程如下。</p><p>首先根据所有 Table 的 id 范围，确定 key 所在的内存 Table。</p><p>然后再根据 double-hash 算法计算 hash，用 2 个 hash 函数分别计算出 2 个 hash 值，采用公示 h1+N*h2 来定位查找。</p><p>在对计数插入或变更时，如果查询位置为空，则立即作为新值插入 key&#x2F;value，否则对比 key，如果 key 相同，则进行计数增减；如果 key 不同，则将 N 加 1，然后进入到下一个位置，继续进行前面的判断。如果查询的位置一直不为空，且 key 不同，则最多查询设置的阀值次数，如果仍然没查到，则不再进行查询。将该 key 记录到 extend dict 扩展词典中。</p><p>在对计数 key 查找时，如果查询的位置为空，说明 key 不存在，立即停止。如果 key 相同，返回计数，否则 N 加 1，继续向后查询，如果查询达到阀值次数，没有遇到空，且 key 不同，再查询 aux dict 辅助字典 和 extend dict 扩展字典，如果也没找到该 key，则说明该 key 不存在，即计数为 0。</p><h2 id="海量计数服务收益"><a href="#海量计数服务收益" class="headerlink" title="海量计数服务收益"></a>海量计数服务收益</h2><p>微博计数服务，多个计数按 Schema 进行紧凑存储，共享同一个 key，每个计数的 size 按 bit 设计大小，没有额外的指针开销，内存占用只有 Redis 的 10% 以下。同时，由于 key 的计数 size 固定，如果计数超过阀值，则独立存储 aux dict 辅助字典中。</p><p>同时由于一个 key 存储多个计数，同时这些计数一般都需要返回，这样一次查询即可同时获取多个计数，查询性能相比每个计数独立存储的方式提升 3~5 倍。</p><h1 id="如何为社交feed场景设计缓存体系"><a href="#如何为社交feed场景设计缓存体系" class="headerlink" title="如何为社交feed场景设计缓存体系"></a>如何为社交feed场景设计缓存体系</h1><h2 id="Feed-流场景分析"><a href="#Feed-流场景分析" class="headerlink" title="Feed 流场景分析"></a>Feed 流场景分析</h2><p><img src="https://i0.hdslb.com/bfs/openplatform/449049dfc24eacb62e14241de43667710b3173d6.png" alt="image-20250709141559577"></p><p>Feed 流是很多移动互联网系统的重要一环，如微博、微信朋友圈、QQ 好友动态、头条&#x2F;抖音信息流等。虽然这些产品形态各不相同，但业务处理逻辑却大体相同。用户日常的“刷刷刷”，就是在获取 Feed 流，这也是 Feed 流的一个最重要应用场景。用户刷新获取 Feed 流的过程，对于服务后端，就是一个获取用户感兴趣的 Feed，并对 Feed 进行过滤、动态组装的过程。</p><p>接下来，我将以微博为例，介绍用户在发出刷新 Feed 流的请求后，服务后端是如何进行处理的。</p><p>获取 Feed 流操作是一个重操作，后端数据处理存在 100 ~ 1000 倍以上的读放大。也就是说，前端用户发出一个接口请求，服务后端需要请求数百甚至数千条数据，然后进行组装处理并返回响应。因此，为了提升处理性能、快速响应用户，微博 Feed 平台重度依赖缓存，几乎所有的数据都从缓存获取。如用户的关注关系从 Redis 缓存中获取，用户发出的 Feed 或收到特殊 Feed 从 Memcached 中获取，用户及 Feed 的各种计数从计数服务中获取。</p><h2 id="Feed-流流程分析"><a href="#Feed-流流程分析" class="headerlink" title="Feed 流流程分析"></a>Feed 流流程分析</h2><p>Feed 流业务作为微博系统的核心业务，为了保障用户体验，SLA 要求较高，核心接口的可用性要达到 4 个 9，接口耗时要在 50<del>100ms 以内，后端数据请求平均耗时要在 3</del>5ms 以内，因此为了满足亿级庞大用户群的海量并发访问需求，需要对缓存体系进行良好架构且不断改进。</p><p>在 Feed 流业务中，核心业务数据的缓存命中率基本都在 99% 以上，这些缓存数据，由 Feed 系统进行多线程并发获取及组装，从而及时发送响应给用户。</p><p>Feed 流获取的处理流程如下。</p><p>首先，根据用户信息，获取用户的关注关系，一般会得到 300~2000 个关注用户的 UID。</p><p>然后，再获取用户自己的 Feed inbox 收件箱。收件箱主要存放其他用户发表的供部分特定用户可见的微博 ID 列表。</p><p>接下来，再获取所有关注列表用户的微博 ID 列表，即关注者发表的所有用户或者大部分用户可见的 Feed ID 列表。这些 Feed ID 列表都以 vector 数组的形式存储在缓存。由于一般用户的关注数会达到数百甚至数千，因此这一步需要获取数百或数千个 Feed vector。</p><p>然后，Feed 系统将 inbox 和关注用户的所有 Feed vector 进行合并，并排序、分页，即得到目标 Feed 的 ID 列表。</p><p>接下来，再根据 Feed ID 列表获取对应的 Feed 内容，如微博的文字、视频、发表时间、源微博 ID 等。</p><p>然后，再进一步获取所有微博的发表者 user 详细信息、源微博内容等信息，并进行内容组装。</p><p>之后，如果用户设置的过滤词，还要将这些 Feed 进行过滤筛选，剔除用户不感兴趣的 Feed。</p><p>接下来，再获取用户对这些 Feed 的收藏、赞等状态，并设置到对应微博中。</p><p>最后，获取这些 Feed 的转发数、评论数、赞数等，并进行计数组装。至此，Feed 流获取处理完毕，Feed 列表以 JSON 形式返回给前端，用户刷新微博首页成功完成。</p><h2 id="Feed-流缓存架构"><a href="#Feed-流缓存架构" class="headerlink" title="Feed 流缓存架构"></a>Feed 流缓存架构</h2><p>Feed 流处理中，缓存核心业务数据主要分为 6 大类。</p><p>第一类是用户的 inbox 收件箱，在用户发表仅供少量用户可见的 Feed 时，为了提升访问效率，这些 Feed ID 并不会进入公共可见的 outbox 发件箱，而会直接推送到目标客户的收件箱。</p><p>第二类是用户的 outbox 发件箱。用户发表的普通微博都进入 outbox，这些微博几乎所有人都可见，由粉丝在刷新 Feed 列表首页时，系统直接拉取组装。</p><p>第三类是 Social Graph 即用户的关注关系，如各种关注列表、粉丝列表。</p><p>第四类是 Feed Content 即 Feed 的内容，包括 Feed 的文字、视频、发表时间、源微博 ID 等。</p><p>第五类是 Existence 存在性判断缓存，用来判断用户是否阅读了某条 Feed，是否赞了某条 Feed 等。对于存在性判断，微博是采用自研的 phantom 系统，通过 bloomfilter 算法进行存储的。</p><p>第六类是 Counter 计数服务，用来存储诸如关注数、粉丝数，Feed 的转发、评论、赞、阅读等各种计数。</p><p>对于 Feed 的 inbox 收件箱、outbox 发件箱，Feed 系统通过 Memcached 进行缓存，以 feed id的一维数组格式进行存储。</p><p>对于关注列表，Feed 系统采用 Redis 进行缓存，存储格式为 longset。longset 在之前的课时介绍过，是微博扩展的一种数据结构，它是一个采用 double-hash 寻址的一维数组。当缓存 miss 后，业务 client 可以从 DB 加载，并直接构建 longset 的二进制格式数据作为 value写入Redis，Redis 收到后直接 restore 到内存，而不用逐条加入。这样，即便用户有成千上万个关注，也不会引发阻塞。</p><p>Feed content 即 Feed 内容，采用 Memcached 存储。由于 Feed 内容有众多的属性，且时常需要根据业务需要进行扩展，Feed 系统采用 Google 的 protocol bufers 的格式进行存放。protocol buffers 序列化后的所生成的二进制消息非常紧凑，二进制存储空间比 XML 小 3~10 倍，而序列化及反序列化的性能却高 10 倍以上，而且扩展及变更字段也很方便。微博的 Feed content 最初采用 XML 和 JSON 存储，在 2011 年之后逐渐全部改为 protocol buffers 存储。</p><p>对于存在性判断，微博 Feed 系统采用自研的 phantom 进行存储。数据存储采用 bloom filter 存储结构。实际上 phantom 本身就是一个分段存储的 bloomfilter 结构。bloomFilter 采用 bit 数组来表示一个集合，整个数组最初所有 bit 位都是 0，插入 key 时，采用 k 个相互独立的 hash 函数计算，将对应 hash 位置置 1。而检测某个 key 是否存在时，通过对 key 进行多次 hash，检查对应 hash 位置是否为 1 即可，如果有一个为 0，则可以确定该 key 肯定不存在，但如果全部为 1，大概率说明该 key 存在，但该 key 也有可能不存在，即存在一定的误判率，不过这个误判率很低，一般平均每条记录占用 1.2 字节时，误判率即可降低到 1%，1.8 字节，误判率可以降到千分之一。基本可以满足大多数业务场景的需要。</p><p>对于计数服务，微博就是用前面讲到的 CounterService。CounterService 采用 schema 策略，支持一个 key 对应多个计数，只用 5<del>10% 的空间，却提升 3</del>5 倍的读取性能。</p><p>对于 Feed 流中的 Redis 存储访问，业务的 Redis 部署基本都采用 1 主多从的方式。同时多个子业务按类型分为 cluster 集群，通过多租户 proxy 进行访问。对于一些数据量很小的业务，还可以共享 Redis 存储，进行混合读写。对于一些响应时间敏感的业务，基于性能考虑，也支持smart client 直接访问 Redis 集群。整个 Redis 集群，由 clusterManager 进行运维、slot 维护及迁移。配置中心记录集群相关的 proxy 部署及 Redis 配置及部署等。这个架构在之前的经典分布式缓存系统课程中有详细介绍，此处不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring循环依赖及解决原理</title>
      <link href="/2025/06/19/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8E%9F%E7%90%86/"/>
      <url>/2025/06/19/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h1><p>字面上理解就是A依赖B的同时，B也依赖了A。</p><p>体现在启动控制台就是以下的日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌─────┐</span><br><span class="line">|  asyncServiceImpl defined in file [D:\Download\GitLabProject\uhr\jr-uhr-provider\jr-uhr-attendance\target\classes\com\jr\uhr\gtd\service\impl\AsyncServiceImpl.class]</span><br><span class="line">↑     ↓</span><br><span class="line">|  gtdClassServiceImpl defined in file [D:\Download\GitLabProject\uhr\jr-uhr-provider\jr-uhr-attendance\target\classes\com\jr\uhr\gtd\service\impl\GtdClassServiceImpl.class]</span><br><span class="line">└─────┘</span><br></pre></td></tr></table></figure><p>体现在代码层次就是这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// A中注入了B</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">// B中也注入了A</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较特殊的还有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己依赖自己</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// A中注入了A</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="什么情况下循环依赖可以被处理"><a href="#什么情况下循环依赖可以被处理" class="headerlink" title="什么情况下循环依赖可以被处理"></a>什么情况下循环依赖可以被处理</h1><p>在回答这个问题之前首先要明确一点，Spring解决循环依赖是有前置条件的</p><ol><li>出现循环依赖的Bean必须要是单例</li><li>依赖注入的方式不能全是构造器注入的方式</li></ol><p>其中第一点应该很好理解，第二点：不能全是构造器注入是什么意思呢？我们还是用代码说话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="comment">//@Autowired</span></span><br><span class="line"><span class="comment">//private B b;</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Autowired</span></span><br><span class="line"><span class="comment">//private A a;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，A中注入B的方式是通过构造器，B中注入A的方式也是通过构造器，这个时候循环依赖是无法被解决，如果你的项目中有两个这样相互依赖的Bean，在启动时就会报出以下错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="string">&#x27;a&#x27;</span>: Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br></pre></td></tr></table></figure><p>为了测试循环依赖的解决情况跟注入方式的关系，我们做如下四种情况的测试</p><table><thead><tr><th>依赖情况</th><th>依赖注入方式</th><th>循环依赖是否被解决</th></tr></thead><tbody><tr><td>AB相互依赖（循环依赖）</td><td>均采用setter方法注入</td><td>是</td></tr><tr><td>AB相互依赖（循环依赖）</td><td>均采用构造器注入</td><td>否</td></tr><tr><td>AB相互依赖（循环依赖）</td><td>A中注入B的方式为setter方法，B中注入A的方式为构造器</td><td>是</td></tr><tr><td>AB相互依赖（循环依赖）</td><td>B中注入A的方式为setter方法，A中注入B的方式为构造器</td><td>否</td></tr></tbody></table><h1 id="Spring是如何解决的循环依赖"><a href="#Spring是如何解决的循环依赖" class="headerlink" title="Spring是如何解决的循环依赖"></a>Spring是如何解决的循环依赖</h1><h2 id="简单的循环依赖（没有AOP）"><a href="#简单的循环依赖（没有AOP）" class="headerlink" title="简单的循环依赖（没有AOP）"></a>简单的循环依赖（没有AOP）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// A中注入了B</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">// B中也注入了A</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上文我们已经知道了这种情况下的循环依赖是能够被解决的，那么具体的流程是什么呢？我们一步步分析</p><p>首先，我们要知道<strong>Spring在创建Bean的时候默认是按照自然排序来进行创建的，所以第一步Spring会去创建A</strong>。</p><p>与此同时，我们应该知道，Spring在创建Bean的过程中分为三步</p><ol><li>实例化，对应方法：<code>AbstractAutowireCapableBeanFactory</code>中的<code>createBeanInstance</code>方法</li><li>属性注入，对应方法：<code>AbstractAutowireCapableBeanFactory</code>的<code>populateBean</code>方法</li><li>初始化，对应方法：<code>AbstractAutowireCapableBeanFactory</code>的<code>initializeBean</code></li></ol><p>简单翻译下，就是：</p><ol><li>实例化，简单理解就是new了一个对象</li><li>属性注入，为实例化中new出来的对象填充属性</li><li>初始化，执行aware接口中的方法，初始化方法，完成<code>AOP</code>代理</li></ol><p>整个创建A这个Bean的流程图如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDcwNjEzMzAxODY2OS5wbmc?x-oss-process=image/format,png" alt="image-20200706133018669"></p><p>从上图中我们可以看到，虽然在创建B时会提前给B注入了一个还未初始化的A对象，但是在创建A的流程中一直使用的是注入到B中的A对象的引用，之后会根据这个引用对A进行初始化，所以这是没有问题的。</p><h2 id="结合了AOP的循环依赖"><a href="#结合了AOP的循环依赖" class="headerlink" title="结合了AOP的循环依赖"></a>结合了AOP的循环依赖</h2><p>对A进行了<code>AOP</code>代理的话，那么此时<code>getEarlyBeanReference</code>将返回一个代理后的对象，而不是实例化阶段创建的对象，这样就意味着B中注入的A将是一个代理对象而不是A的实例化阶段创建后的对象。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDcwNjE2MTcwOTgyOS5wbmc?x-oss-process=image/format,png" alt="image-20200706161709829"></p><p>看到这个图你可能会产生下面这些疑问</p><ol><li>在给B注入的时候为什么要注入一个代理对象？</li></ol><p>答：当我们对A进行了<code>AOP</code>代理时，说明我们希望从容器中获取到的就是A代理后的对象而不是A本身，因此把A当作依赖进行注入时也要注入它的代理对象</p><ol start="2"><li>明明初始化的时候是A对象，那么Spring是在哪里将代理对象放入到容器中的呢？</li></ol><p>在完成初始化后，Spring又调用了一次<code>getSingleton</code>方法，这一次传入的参数又不一样了，false可以理解为禁用三级缓存，前面图中已经提到过了，在为B中注入A时已经将三级缓存中的工厂取出，并从工厂中获取到了一个对象放入到了二级缓存中，所以这里的这个<code>getSingleton</code>方法做的时间就是从二级缓存中获取到这个代理后的A对象。</p><ol start="3"><li>初始化的时候是对A对象本身进行初始化，而容器中以及注入到B中的都是代理对象，这样不会有问题吗？</li></ol><p>答：不会，这是因为不管是<code>cglib</code>代理还是<code>jdk</code>动态代理生成的代理类，内部都持有一个目标类的引用，当调用代理对象的方法时，实际会去调用目标对象的方法，A完成初始化相当于代理对象自身也完成了初始化</p><ol start="4"><li>三级缓存为什么要使用工厂而不是直接使用引用？换而言之，为什么需要这个三级缓存，直接通过二级缓存暴露一个引用不行吗？</li></ol><p>答：<strong>这个工厂的目的在于延迟对实例化阶段生成的对象的代理，只有真正发生循环依赖的时候，才去提前生成代理对象，否则只会创建一个工厂并将其放入到三级缓存中，但是不会去通过这个工厂去真正创建对象</strong></p><p>我们思考一种简单的情况，就以单独创建A为例，假设AB之间现在没有依赖关系，但是A被代理了，这个时候当A完成实例化后还是会进入下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A是单例的，mbd.isSingleton()条件满足</span></span><br><span class="line"><span class="comment">// allowCircularReferences：这个变量代表是否允许循环依赖，默认是开启的，条件也满足</span></span><br><span class="line"><span class="comment">// isSingletonCurrentlyInCreation：正在在创建A，也满足</span></span><br><span class="line"><span class="comment">// 所以earlySingletonExposure=true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                  isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="comment">// 还是会进入到这段代码中</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 还是会通过三级缓存提前暴露一个工厂对象</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了吧，即使没有循环依赖，也会将其添加到三级缓存中，而且是不得不添加到三级缓存中，因为到目前为止Spring也不能确定这个Bean有没有跟别的Bean出现循环依赖。</p><p>假设我们在这里直接使用二级缓存的话，那么意味着所有的Bean在这一步都要完成<code>AOP</code>代理。这样做有必要吗？</p><p>不仅没有必要，而且违背了Spring在结合<code>AOP</code>跟Bean的生命周期的设计！Spring结合<code>AOP</code>跟Bean的生命周期本身就是通过<code>AnnotationAwareAspectJAutoProxyCreator</code>这个后置处理器来完成的，在这个后置处理的<code>postProcessAfterInitialization</code>方法中对初始化后的Bean完成<code>AOP</code>代理。如果出现了循环依赖，那没有办法，只有给Bean先创建代理，但是没有出现循环依赖的情况下，设计之初就是让Bean在生命周期的最后一步完成代理而不是在实例化后就立马完成代理。</p><h2 id="三级缓存真的提高了效率了吗？"><a href="#三级缓存真的提高了效率了吗？" class="headerlink" title="三级缓存真的提高了效率了吗？"></a>三级缓存真的提高了效率了吗？</h2><p>现在我们已经知道了三级缓存的真正作用，但是这个答案可能还无法说服你，所以我们再最后总结分析一波，三级缓存真的提高了效率了吗？分为两点讨论：</p><ol><li>没有进行<code>AOP</code>的Bean间的循环依赖</li></ol><p>从上文分析可以看出，这种情况下三级缓存根本没用！所以不会存在什么提高了效率的说法</p><ol><li>进行了<code>AOP</code>的Bean间的循环依赖</li></ol><p>就以我们上的A、B为例，其中A被<code>AOP</code>代理，我们先分析下使用了三级缓存的情况下，A、B的创建流程</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDcwNjE3MTUxNDMyNy5wbmc?x-oss-process=image/format,png" alt="image-20200706171514327"></p><p>假设不使用三级缓存，直接在二级缓存中</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDcwNjE3MjUyMzI1OC5wbmc?x-oss-process=image/format,png" alt="image-20200706172523258"></p><p>上面两个流程的唯一区别在于为A对象创建代理的时机不同，在使用了三级缓存的情况下为A创建代理的时机是在B中需要注入A的时候，而不使用三级缓存的话在A实例化后就需要马上为A创建代理然后放入到二级缓存中去。对于整个A、B的创建过程而言，消耗的时间是一样的</p><p>综上，不管是哪种情况，三级缓存提高了效率这种说法都是错误的！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>面试官：”Spring是如何解决的循环依赖？“</p><p>答：Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（<code>singletonObjects</code>）,二级缓存为早期曝光对象<code>earlySingletonObjects</code>，三级缓存为早期曝光对象工厂（<code>singletonFactories</code>）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！</p><p>面试官：”为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？“</p><p>答：如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过<code>AnnotationAwareAspectJAutoProxyCreator</code>这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>销售提成合并滚动明细逻辑</title>
      <link href="/2025/05/28/%E9%94%80%E5%94%AE%E6%8F%90%E6%88%90%E5%90%88%E5%B9%B6%E6%BB%9A%E5%8A%A8%E6%98%8E%E7%BB%86%E9%80%BB%E8%BE%91/"/>
      <url>/2025/05/28/%E9%94%80%E5%94%AE%E6%8F%90%E6%88%90%E5%90%88%E5%B9%B6%E6%BB%9A%E5%8A%A8%E6%98%8E%E7%BB%86%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h1 id="销售提成合并滚动明细逻辑"><a href="#销售提成合并滚动明细逻辑" class="headerlink" title="销售提成合并滚动明细逻辑"></a>销售提成合并滚动明细逻辑</h1><h2 id="滚动明细"><a href="#滚动明细" class="headerlink" title="滚动明细"></a>滚动明细</h2><p>回款金额暂未发完的账单，会滚动到下一个工资月继续发放</p><p><img src="https://i0.hdslb.com/bfs/openplatform/06f807252c94f6304466fed3e58fdd3301fbd9e4.png" alt="image-20250709140851076"></p><h2 id="同步底表"><a href="#同步底表" class="headerlink" title="同步底表"></a>同步底表</h2><p>增量同步BI底表数据，系统自动给本次拉取的数据打上“工资月份”的标识，BPO(T+2),HRO(T+1)。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/2d9552d9da8647d5ce51de4070692878b2540d24.png" alt="image-20250709140905455"></p><h2 id="合并明细"><a href="#合并明细" class="headerlink" title="合并明细"></a>合并明细</h2><p>合并时注意需保留用户编辑后的数据，部分字段需延用（自动带出）上个账单月的数值。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/f43b2dc9cf0ae59d05e87d0fccf45dbf0230156f.png" alt="image-20250709140920033"></p>]]></content>
      
      
      <categories>
          
          <category> 场景 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>销售提成计算引擎实现</title>
      <link href="/2025/05/28/%E9%94%80%E5%94%AE%E6%8F%90%E6%88%90%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/05/28/%E9%94%80%E5%94%AE%E6%8F%90%E6%88%90%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="销售提成计算引擎实现"><a href="#销售提成计算引擎实现" class="headerlink" title="销售提成计算引擎实现"></a>销售提成计算引擎实现</h1><h2 id="1-模块概述"><a href="#1-模块概述" class="headerlink" title="1. 模块概述"></a>1. 模块概述</h2><p>该模块是销售提成计算系统的具体实现层，基于模板方法模式设计，实现了不同业务线（BPO、HRO）的提成计算逻辑。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/8c105790c8be2b324e1f4a08f74287ecd5ac54af.png" alt="image-20250709140808203"></p><h2 id="2-目录结构"><a href="#2-目录结构" class="headerlink" title="2. 目录结构"></a>2. 目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CopyInsertcalculation/engine/</span><br><span class="line">├── AbstractCalculationEngine.java    # 抽象计算引擎基类</span><br><span class="line">├── CalculationEngine.java           # 计算引擎接口</span><br><span class="line">├── BpoCalculationEngine.java        # BPO业务线计算引擎实现</span><br><span class="line">└── HroCalculationEngine.java        # HRO业务线计算引擎实现</span><br></pre></td></tr></table></figure><h2 id="3-核心组件说明"><a href="#3-核心组件说明" class="headerlink" title="3. 核心组件说明"></a>3. 核心组件说明</h2><h3 id="3-1-计算引擎接口"><a href="#3-1-计算引擎接口" class="headerlink" title="3.1 计算引擎接口"></a>3.1 计算引擎接口</h3><p><code>CalculationEngine</code></p><ul><li><p>定义了计算引擎的基本契约</p></li><li><p>核心方法：</p><ul><li><p><code>calculation(CalculationDto)</code>: 执行业务数据核算</p></li><li><p><code>supportedProductLine()</code>: 声明支持的产品线类型</p></li></ul></li></ul><h3 id="3-2-抽象计算引擎"><a href="#3-2-抽象计算引擎" class="headerlink" title="3.2 抽象计算引擎"></a>3.2 抽象计算引擎</h3><p><code>AbstractCalculationEngine</code></p><ul><li><p>实现了计算引擎的通用逻辑</p></li><li><p>核心功能：</p><ol><li><strong>计算流程控制</strong></li></ol><ul><li><code>calculation(CalculationDto)</code>: 总体计算流程控制<ul><li><code>processCalculation()</code>: 执行具体计算过程</li><li><code>validateCalculationDto()</code>: 验证计算参数</li></ul></li></ul><ol start="2"><li><strong>数据处理</strong><ul><li><code>getDetailData()</code>: 获取业务数据</li><li><code>getBasicSubjectValues()</code>: 获取基础科目值</li><li><code>processTableDataBatch()</code>: 处理单个表数据（in查询批量处理）</li><li><code>setDetailInfoBasicSubjectValues()</code>: 设置明细数据基础科目值</li></ul></li><li><strong>结果处理</strong><ul><li><code>processCalculationResults()</code>: 处理计算结果</li><li><code>writeCalculationDetail()</code>: 写入计算明细</li><li><code>handleCalculationSuccess()</code>: 处理计算成功</li><li><code>handleCalculationFailure()</code>: 处理计算失败</li><li><code>handleErrorResults()</code>: 处理错误结果</li></ul></li></ol></li></ul><h3 id="3-3-具体业务实现"><a href="#3-3-具体业务实现" class="headerlink" title="3.3 具体业务实现"></a>3.3 具体业务实现</h3><h4 id="3-3-1-BPO业务计算引擎"><a href="#3-3-1-BPO业务计算引擎" class="headerlink" title="3.3.1 BPO业务计算引擎"></a>3.3.1 BPO业务计算引擎</h4><p><code>BpoCalculationEngine</code></p><ul><li><p>特点：</p><ul><li><p>继承<code>AbstractCalculationEngine</code></p></li><li><p>实现BPO业务特有的数据获取和处理逻辑</p></li></ul></li><li><p>核心方法：</p><ul><li><p><code>getDetailData()</code>: 获取BPO业务数据</p></li><li><p><code>writeDetailInfo()</code>: 写入BPO计算结果</p></li><li><p><code>supportedProductLine()</code>: 返回BPO产品线标识</p></li></ul></li></ul><h4 id="3-3-2-HRO业务计算引擎"><a href="#3-3-2-HRO业务计算引擎" class="headerlink" title="3.3.2 HRO业务计算引擎"></a>3.3.2 HRO业务计算引擎</h4><p><code>HroCalculationEngine</code></p><ul><li><p>特点：</p><ul><li><p>继承<code>AbstractCalculationEngine</code></p></li><li><p>实现HRO业务特有的数据获取和处理逻辑</p></li></ul></li><li><p>核心方法：</p><ul><li><p><code>getDetailData()</code>: 获取HRO业务数据</p></li><li><p><code>writeDetailInfo()</code>: 写入HRO计算结果</p></li><li><p><code>supportedProductLine()</code>: 返回HRO产品线标识</p></li></ul></li></ul><h2 id="4-核心流程说明"><a href="#4-核心流程说明" class="headerlink" title="4. 核心流程说明"></a>4. 核心流程说明</h2><h3 id="4-1-计算流程"><a href="#4-1-计算流程" class="headerlink" title="4.1 计算流程"></a>4.1 计算流程</h3><ol><li><p>参数验证</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">validateCalculationDto(calculationDto)</span><br></pre></td></tr></table></figure></li><li><p>获取分布式锁</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(RedisConstant.CALCULATION_LOCK_PREFIX + batch.getId());</span><br><span class="line"> <span class="keyword">if</span> (!lock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;核算进行中，请稍后再试&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>创建计算任务</p></li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SysCalculationProcess</span> <span class="variable">process</span> <span class="operator">=</span> calculationProcessService</span><br><span class="line">                .saveProcess(batch.getId(), calculationDto.getProductLineCode());</span><br></pre></td></tr></table></figure><ol start="4"><li>用户登录信息存入上下文</li></ol><p>  因计算过程是异步的，且区分于定时任务调用、用户手动调用，需在核算开始前添加用户登录信息至上下文，核算结束后生成的错误文件明细数据是用户数据权限下的数据。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先从 上下文 获取用户，如果没有再从 ServletUtils 获取</span></span><br><span class="line">      <span class="type">LoginUser</span> <span class="variable">currentUser</span> <span class="operator">=</span>  UserContext.getUser();</span><br><span class="line">      <span class="keyword">if</span> (currentUser == <span class="literal">null</span>) &#123;</span><br><span class="line">          currentUser = ServletUtils.getLoginUser();</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">// 使用装饰器包装任务</span></span><br><span class="line">      taskExecutor.execute(UserContextDecorator.decorate(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              processCalculation(calculationDto, batch, process, subjects);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (BusinessException e) &#123;</span><br><span class="line">              handleCalculationFailure(batch, process, e);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              log.error(<span class="string">&quot;计算过程发生异常：&#123;&#125;&quot;</span>, e.getMessage(), e);</span><br><span class="line">              handleCalculationFailure(batch, process, e);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              lock.forceUnlock();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, currentUser));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  用户装饰器类，这里使用了装饰器模式，不修改原有的代码结构的前提下，动态地在异步任务开始前设置用户上下文，异步任务结束后清理用户的上下文。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContextDecorator</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable delegate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoginUser user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String taskId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserContextDecorator</span><span class="params">(Runnable delegate, LoginUser user)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">        <span class="comment">// 生成唯一任务ID</span></span><br><span class="line">        <span class="built_in">this</span>.taskId = UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Task[&#123;&#125;] setting user context in thread: &#123;&#125;&quot;</span>, taskId, threadName);</span><br><span class="line">            <span class="comment">// 前置处理：设置用户上下文</span></span><br><span class="line">            UserContext.setUser(user);</span><br><span class="line">              <span class="comment">// 执行原始任务</span></span><br><span class="line">            delegate.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Task[&#123;&#125;] clearing user context in thread: &#123;&#125;&quot;</span>, taskId, threadName);</span><br><span class="line">             <span class="comment">// 后置处理：清理用户上下文</span></span><br><span class="line">            UserContext.clear();</span><br><span class="line">            <span class="comment">// 额外验证确保清理成功</span></span><br><span class="line">            <span class="keyword">if</span> (UserContext.getUser() != <span class="literal">null</span>) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Task[&#123;&#125;] failed to clear user context in thread: &#123;&#125;&quot;</span>, taskId, threadName);</span><br><span class="line">                <span class="comment">// 再次尝试清理</span></span><br><span class="line">                UserContext.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title function_">decorate</span><span class="params">(Runnable task, LoginUser user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserContextDecorator</span>(task, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>获取业务数据</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;DetailData&gt; details = getDetailData(calculationDto)</span><br></pre></td></tr></table></figure><ol start="6"><li><p>获取基础科目值</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Long, Map&lt;String, Object&gt;&gt; basicSubjectValues = getBasicSubjectValues(subjects, details)</span><br></pre></td></tr></table></figure></li><li><p>执行计算</p></li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行计算</span></span><br><span class="line"><span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>(subjects, details);</span><br><span class="line">List&lt;CalculationResult&gt; results = calculator.calculate();</span><br></pre></td></tr></table></figure><p>  为了提升每次核算的速度，将每条明细数据的核算过程并行处理</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行计算过程</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 计算结果列表，每个明细一条结果记录</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;CalculationResult&gt; <span class="title function_">calculate</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 1. 预先验证所有公式</span></span><br><span class="line">      validateAllMethods();</span><br><span class="line">      <span class="comment">// 2. 使用并行流处理明细</span></span><br><span class="line">      <span class="keyword">return</span> details.parallelStream().map(<span class="built_in">this</span>::calculateDetail).collect(Collectors.toList());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  每次计算都创建一次计算上下文，计算完成后将计算结果存进内存</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CalculationResult <span class="title function_">calculateDetail</span><span class="params">(DetailData detail)</span> &#123;</span><br><span class="line">       DefaultContext&lt;String, Object&gt; context = createCalculationContext(detail);</span><br><span class="line">       <span class="type">CalculationResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculationResult</span>();</span><br><span class="line">       result.setDetailInfoId(detail.getDetailInfoId());</span><br><span class="line">       result.setIsCommissionPaidThisMonth(detail.getIsCommissionPaidThisMonth());</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">for</span> (SysSubject subject : subjects) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">calculationMethod</span> <span class="operator">=</span> subject.getCalculationMethod();</span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isBlank(calculationMethod)) &#123;</span><br><span class="line">               log.warn(<span class="string">&quot;科目计算的公式为空: &#123;&#125;&quot;</span>, subject.getSubjectName());</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 使用缓存的验证结果</span></span><br><span class="line">               <span class="keyword">if</span> (!methodValidationCache.getOrDefault(calculationMethod, <span class="literal">false</span>)) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(String.format(<span class="string">&quot;科目[%s]的计算公式配置错误&quot;</span>, subject.getSubjectName()));</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="type">Object</span> <span class="variable">computed</span> <span class="operator">=</span> calculateSubject(detail, subject, context);</span><br><span class="line">               saveCalculateResult(result, subject, computed);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (BusinessException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> e;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               handleCalculationError(detail, subject, result, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>  使用规则引擎进行计算</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行单个科目的计算</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Object <span class="title function_">calculateSubject</span><span class="params">(DetailData detail, SysSubject subject,</span></span><br><span class="line"><span class="params">                                  DefaultContext&lt;String, Object&gt; context)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> subject.getCalculationMethod();</span><br><span class="line">      log.debug(<span class="string">&quot;计算明细表 detail ID: &#123;&#125;, 公式: &#123;&#125;&quot;</span>, detail.getDetailInfoId(), method);</span><br><span class="line">      <span class="type">Object</span> <span class="variable">computed</span> <span class="operator">=</span> QlExpressUtils.computer(method, context);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 保留小数位</span></span><br><span class="line">      <span class="keyword">if</span> (subject.getDecimalPlaces() != <span class="literal">null</span> &amp;&amp; computed != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">BigDecimal</span> <span class="variable">bigDecimal</span> <span class="operator">=</span> Convert.toBigDecimal(computed, BigDecimal.ZERO);</span><br><span class="line">          computed = bigDecimal.setScale(subject.getDecimalPlaces(), RoundingMode.HALF_UP);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      context.put(subject.getSubjectCode(), computed);</span><br><span class="line">      log.debug(<span class="string">&quot;计算后的上下文: &#123;&#125;&quot;</span>, context);</span><br><span class="line">      <span class="keyword">return</span> computed;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  使用懒加载模式，只在首次使用时初始化，避免了类加载时的初始化开销，保持了线程安全性</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">computer</span><span class="params">(String express, DefaultContext&lt;String, Object&gt; context)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isBlank(express) || Objects.isNull(context)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       initializeIfNeeded();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 为每个计算创建独立的上下文</span></span><br><span class="line">           DefaultContext&lt;String, Object&gt; localContext = <span class="keyword">new</span> <span class="title class_">DefaultContext</span>&lt;&gt;();</span><br><span class="line">           localContext.putAll(context);</span><br><span class="line">           <span class="keyword">return</span> expressRunner.execute(express, localContext, <span class="literal">null</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">       &#125;  <span class="keyword">catch</span> (QLBizException | QLException e) &#123;</span><br><span class="line">           <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">           <span class="keyword">if</span> (cause != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(cause.getMessage());</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e.getMessage());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           log.error(<span class="string">&quot;计算运算公式：&#123;&#125; 失败，参数为:&#123;&#125;&quot;</span>, express, JSONObject.toJSONString(context));</span><br><span class="line">           log.error(<span class="string">&quot;计算运算失败&quot;</span>, e);</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用懒加载单例模式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initializeIfNeeded</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (expressRunner == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">              <span class="keyword">if</span> (expressRunner == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 优先使用Spring容器中的bean</span></span><br><span class="line">                  <span class="type">ExpressRunner</span> <span class="variable">runner</span> <span class="operator">=</span> SpringUtils.getBean(ExpressRunner.class);</span><br><span class="line">                  <span class="keyword">if</span> (runner == <span class="literal">null</span>) &#123;</span><br><span class="line">                      runner = <span class="keyword">new</span> <span class="title class_">QlExpressConfig</span>().expressRunner();</span><br><span class="line">                  &#125;</span><br><span class="line">                  </span><br><span class="line">                  Map&lt;String, String&gt; defineClass = <span class="keyword">new</span> <span class="title class_">QlExpressConfig</span>().selfDefineClass(runner);</span><br><span class="line">                  </span><br><span class="line">                  <span class="type">ExpressParse</span> <span class="variable">parse</span> <span class="operator">=</span> SpringUtils.getBean(ExpressParse.class);</span><br><span class="line">                  <span class="keyword">if</span> (parse == <span class="literal">null</span>) &#123;</span><br><span class="line">                      parse = <span class="keyword">new</span> <span class="title class_">QlExpressConfig</span>().expressParse(runner);</span><br><span class="line">                  &#125;</span><br><span class="line">                  </span><br><span class="line">                  <span class="comment">// 所有初始化完成后才赋值给静态变量</span></span><br><span class="line">                  expressRunner = runner;</span><br><span class="line">                  selfDefineClass = defineClass;</span><br><span class="line">                  expressParse = parse;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>处理结果</li></ol><ul><li><p>将批次id写入提成明细</p></li><li><p>写入科目计算结果</p></li><li><p>写入销售提成金额</p></li><li><p>处理错误信息，生成错误文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个事务：处理核心计算结果</span></span><br><span class="line">        transactionTemplate.executeWithoutResult(status -&gt; &#123;</span><br><span class="line">            writeDetailInfo(results, batch);</span><br><span class="line">            writeCalculationDetail(results, batch);</span><br><span class="line">            writeSaleCommissionDetail(results, batch);</span><br><span class="line">            handleErrorResults(results, process, calculationDto.getSalaryMonth());</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li><li><p>实时生成提成统计，并更改任务状态</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 第二个事务：处理统计数据</span></span><br><span class="line">         transactionTemplate.executeWithoutResult(status -&gt; &#123;</span><br><span class="line">             generateStatisticData(calculationDto);</span><br><span class="line">         &#125;);</span><br><span class="line">         <span class="comment">// 第三个事务：更新状态</span></span><br><span class="line">         transactionTemplate.executeWithoutResult(status -&gt; &#123;</span><br><span class="line">             handleCalculationSuccess(batch, process, subjects);</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         log.error(<span class="string">&quot;生成统计数据或更新状态失败&quot;</span>, e);</span><br><span class="line">         <span class="comment">// 更新为部分完成状态</span></span><br><span class="line">         handlePartialSuccess(batch, process, subjects, e);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-错误处理"><a href="#4-2-错误处理" class="headerlink" title="4.2 错误处理"></a>4.2 错误处理</h3><ul><li>计算失败处理  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleCalculationFailure(batch, process, exception)</span><br></pre></td></tr></table></figure></li><li>结果错误处理  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleErrorResults(results, process)</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-扩展指南"><a href="#5-扩展指南" class="headerlink" title="5. 扩展指南"></a>5. 扩展指南</h2><h3 id="5-1-添加新的业务线"><a href="#5-1-添加新的业务线" class="headerlink" title="5.1 添加新的业务线"></a>5.1 添加新的业务线</h3><ol><li><p>创建新的业务线计算引擎类，继承<code>AbstractCalculationEngine</code></p></li><li><p>实现必要的抽象方法：</p><ul><li><p><code>getDetailData()</code></p></li><li><p><code>writeDetailInfo()</code></p></li><li><p><code>supportedProductLine()</code></p></li></ul></li><li><p>根据业务需求，可能需要重写其他方法</p></li></ol><h3 id="5-2-修改计算逻辑"><a href="#5-2-修改计算逻辑" class="headerlink" title="5.2 修改计算逻辑"></a>5.2 修改计算逻辑</h3><ol><li>核心计算逻辑在<code>processCalculation()</code>方法中</li><li>基础数据处理逻辑在<code>getBasicSubjectValues()</code>方法中</li><li>结果处理逻辑在<code>processCalculationResults()</code>方法中</li></ol>]]></content>
      
      
      <categories>
          
          <category> 场景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QlExpress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的缓存组件Redis是如何运行的</title>
      <link href="/2025/02/24/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6Redis%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
      <url>/2025/02/24/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6Redis%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>Redis 是一款基于 ANSI C 语言编写的，BSD 许可的，日志型 key-value 存储组件，它的所有数据结构都存在内存中，可以用作缓存、数据库和消息中间件。</p><p>Redis 是 Remote dictionary server 即远程字典服务的缩写，一个 Redis 实例可以有多个存储数据的字典，客户端可以通过 select 来选择字典即 DB 进行数据存储。</p><h1 id="Redis核心数据类型"><a href="#Redis核心数据类型" class="headerlink" title="Redis核心数据类型"></a>Redis核心数据类型</h1><p>同为 key-value 存储组件，Memcached 只能支持二进制字节块这一种数据类型。而 Redis 的数据类型却丰富的多，它具有 8 种核心数据类型，每种数据类型都有一系列操作指令对应。</p><p>首先，来看一下 Redis 的核心数据类型。Redis 有 8 种核心数据类型，分别是 ：</p><ul><li>string 字符串类型；</li><li>list 列表类型；</li><li>set 集合类型；</li><li>sorted set 有序集合类型；</li><li>hash 类型；</li><li>bitmap 位图类型；</li><li>geo 地理位置类型；</li><li>HyperLogLog 基数统计类型。</li></ul><h2 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a>string 字符串</h2><p>string 是 Redis 的最基本数据类型。可以把它理解为 Mc 中 key 对应的 value 类型。string 类型是二进制安全的，即 string 中可以包含任何数据。</p><p>Redis 中的普通 string 采用 raw encoding 即原始编码方式，该编码方式会动态扩容，并通过提前预分配冗余空间，来减少内存频繁分配的开销。</p><p>在字符串长度小于 1MB 时，按所需长度的 2 倍来分配，超过 1MB，则按照每次额外增加 1MB 的容量来预分配。</p><p>Redis 中的数字也存为 string 类型，但编码方式跟普通 string 不同，数字采用整型编码，字符串内容直接设为整数值的二进制字节序列。</p><p><strong>需要存储常规数据的场景</strong></p><ul><li>举例 ：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。</li><li>相关命令 ： <code>SET</code>、<code>GET</code>、<code>MSET</code>、<code>INCR</code>、<code>DECR</code>。</li><li>项目相关：jwt + Redis 的 token 存储，在 Redis 上可实现登录过期失效即登出功能</li></ul><p><strong>需要计数的场景</strong></p><ul><li>举例 ：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li><li>相关命令 ：<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> 。</li></ul><h2 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h2><p>Redis 的 list 列表，是一个快速双向链表，存储了一系列的 string 类型的字串值。list 中的元素按照插入顺序排列。插入元素的方式，可以通过 lpush 将一个或多个元素插入到列表的头部，也可以通过 rpush 将一个或多个元素插入到队列尾部，还可以通过 lset、linsert 将元素插入到指定位置或指定元素的前后。</p><p>feed timeline 存储时，由于 feed id 一般是递增的，可以直接存为 list，用户发表新 feed，就直接追加到队尾。另外消息队列、热门 feed 等业务场景，都可以使用 list 数据结构。</p><p><strong>信息流展示</strong></p><ul><li>举例 ：最新文章、最新动态。</li><li>相关命令 ： <code>LPUSH</code>、<code>LRANGE</code>。</li><li>项目相关：漫画项目中，对优惠活动场次的存储，key为起止时间，对应的活动中涉及到的产品idList为value</li></ul><h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h2><p>set 是 string 类型的无序集合，set 中的元素是唯一的，即 set 中不会出现重复的元素。Redis 中的集合一般是通过 dict 哈希表实现的，所以插入、删除，以及查询元素，可以根据元素 hash 值直接定位，时间复杂度为 O(1)。</p><p>set 集合的特点是查找、插入、删除特别高效，时间复杂度为 O(1)，所以在社交系统中，可以用于存储关注的好友列表，用来判断是否关注，还可以用来做好友推荐使用。另外，还可以利用 set 的唯一性，来对服务的来源业务、来源 IP 进行精确统计。</p><p><strong>需要存放的数据不能重复的场景</strong></p><ul><li>举例：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</li><li>相关命令：<code>SCARD</code>（获取集合数量） 。</li></ul><p><strong>需要获取多个数据源交集、并集和差集的场景</strong></p><ul><li>举例 ：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集） 、订阅号推荐（差集+交集） 等场景。</li><li>相关命令：<code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）。</li></ul><h2 id="Sorted-Set（有序集合）"><a href="#Sorted-Set（有序集合）" class="headerlink" title="Sorted Set（有序集合）"></a>Sorted Set（有序集合）</h2><p>Redis 中的 sorted set 有序集合也称为 zset，有序集合同 set 集合类似，也是 string 类型元素的集合，且所有元素不允许重复。</p><p>但有序集合中，每个元素都会关联一个 double 类型的 score 分数值。有序集合通过这个 score 值进行由小到大的排序。有序集合中，元素不允许重复，但 score 分数值却允许重复。</p><p><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></p><ul><li>举例 ：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li><li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li></ul><p><strong>需要存储的数据有优先级或者重要程度的场景</strong> 比如优先级任务队列。</p><ul><li>举例 ：优先级任务队列。</li><li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li></ul><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Redis 中的哈希实际是 field 和 value 的一个映射表。</p><p>hash 数据结构的特点是在单个 key 对应的哈希结构内部，可以记录多个键值对，即 field 和 value 对，value 可以是任何字符串。而且这些键值对查询和修改很高效。</p><p><strong>对象数据存储场景</strong></p><ul><li>举例 ：用户信息、商品信息、文章信息、购物车信息。</li><li>相关命令 ：<code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）。</li><li>项目相关：存储产品的详细信息，key为固定字符串（即说明是优惠活动上架的商品信息），field为活动id-产品id，value为序列化后的对象（产品的数量名字起止时间等等，包括设置该产品的随机码（UUID），防恶意攻击）</li></ul><h2 id="Bitmap-位图"><a href="#Bitmap-位图" class="headerlink" title="Bitmap 位图"></a>Bitmap 位图</h2><p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p><p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p><p><strong>需要保存状态信息（0&#x2F;1 即可表示）的场景</strong></p><ul><li>举例 ：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li><li>相关命令 ：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</li></ul><blockquote><p>使用 Bitmap 统计活跃用户怎么做？</p></blockquote><p>使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</p><p>初始化数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; SETBIT 20210308 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; SETBIT 20210308 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; SETBIT 20210309 1 1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>统计 20210308~20210309 总活跃用户数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITOP and desk1 20210308 20210309</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; BITCOUNT desk1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>统计 20210308~20210309 在线活跃用户数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITOP or desk2 20210308 20210309</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; BITCOUNT desk2</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h2 id="hyperLogLog-基数统计"><a href="#hyperLogLog-基数统计" class="headerlink" title="hyperLogLog 基数统计"></a>hyperLogLog 基数统计</h2><p>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：</p><ul><li><strong>稀疏矩阵</strong> ：计数较少的时候，占用空间很小。</li><li><strong>稠密矩阵</strong> ：计数达到某个阈值的时候，占用 12k 的空间。</li></ul><p>基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> 。）。</p><p><strong>数量量巨大（百万、千万级别以上）的计数场景</strong></p><ul><li>举例 ：热门网站每日&#x2F;每周&#x2F;每月访问 ip 数统计、热门帖子 uv 统计、</li><li>相关命令 ：<code>PFADD</code>、<code>PFCOUNT</code> 。</li></ul><h2 id="Geospatial-index"><a href="#Geospatial-index" class="headerlink" title="Geospatial index"></a>Geospatial index</h2><p>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。</p><p>通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p><p><strong>需要管理使用地理空间数据的场景</strong></p><ul><li>举例：附近的人。</li><li>相关命令: <code>GEOADD</code>、<code>GEORADIUS</code>、<code>GEORADIUSBYMEMBER</code></li></ul><h2 id="Redis使用规范小建议"><a href="#Redis使用规范小建议" class="headerlink" title="Redis使用规范小建议"></a>Redis使用规范小建议</h2><h3 id="键值对使用规范"><a href="#键值对使用规范" class="headerlink" title="键值对使用规范"></a>键值对使用规范</h3><p><strong>key命名规范</strong>：通过 key 的前缀区分不同的业务数据，可以使用相应的英文单词的首字母表示（ key 字符串的长度增加时，SDS 中的元数据也会占用更多内存空间）</p><p><strong>避免使用bigKey</strong>：Redis 是使用单线程读写数据，bigkey 的读写操作会阻塞线程。</p><ul><li>情况一：键值对的值大小本身就很大，例如 value 为 1MB 的 String 类型数据。为了避免 String 类型的 bigkey，在业务层，我们要尽量把 String 类型的数据大小控制在 10KB 以下。</li><li>情况二：键值对的值是集合类型，集合元素个数非常多，例如包含 100 万个元素的 Hash 集合类型数据。为了避免集合类型的 bigkey，我给你的设计规范建议是，<strong>尽量把集合类型的元素个数控制在 1 万以下</strong>。</li></ul><p><strong>使用高效序列化方法和压缩方法</strong>：Redis 中的字符串都是使用二进制安全的字节数组来保存的，所以，我们可以把业务数据序列化成二进制数据写入到 Redis 中。</p><p><strong>使用整数对象共享池</strong>：整数是常用的数据类型，Redis 内部维护了 0 到 9999 这 1 万个整数对象，并把这些整数作为一个共享池使用。</p><p>那什么时候不能用整数对象共享池呢？主要有两种情况。</p><p>第一种情况是，<strong>如果 Redis 中设置了 maxmemory，而且启用了 LRU 策略（allkeys-lru 或 volatile-lru 策略），那么，整数对象共享池就无法使用了</strong>。这是因为，LRU 策略需要统计每个键值对的使用时间，如果不同的键值对都共享使用一个整数对象，LRU 策略就无法进行统计了。</p><p>第二种情况是，如果集合类型数据采用 ziplist 编码，而集合元素是整数，这个时候，也不能使用共享池。因为 ziplist 使用了紧凑型内存结构，判断整数对象的共享情况效率低。</p><h3 id="数据保存规范"><a href="#数据保存规范" class="headerlink" title="数据保存规范"></a>数据保存规范</h3><ul><li>使用redis保存热数据</li><li>不同业务数据分实例存储</li><li>数据保存时设置过期时间</li><li>控制Redis实例的容量：设置在 2~6GB</li></ul><h3 id="命令使用规范"><a href="#命令使用规范" class="headerlink" title="命令使用规范"></a>命令使用规范</h3><ol><li>线上禁用部分命令：<ul><li><strong>KEYS</strong>，按照键值对的 key 内容进行匹配，返回符合匹配条件的键值对，该命令需要对 Redis 的全局哈希表进行全表扫描，严重阻塞 Redis 主线程；</li><li><strong>FLUSHALL</strong>，删除 Redis 实例上的所有数据，如果数据量很大，会严重阻塞 Redis 主线程；</li><li><strong>FLUSHDB</strong>，删除当前数据库中的数据，如果数据量很大，同样会阻塞 Redis 主线程。</li></ul></li></ol><p>对于 KEYS 命令来说，你可以用 SCAN 命令代替 KEYS 命令。</p><p>对于FLUSHALL、FLUSHDB命令来说，可以加上ASYNC选项，让这两个命令使用后台线程异步删除数据。</p><ol start="2"><li><p>慎用 MONITOR 命令</p><p>Redis 的 MONITOR 命令在执行后，会持续输出监测到的各个命令操作。如果线上命令的操作很多，输出缓冲区很快就会溢出了，这就会对 Redis 性能造成影响，甚至引起服务崩溃。</p></li><li><p>慎用全量操作命令</p><p> Hash 类型的 HGETALL、Set 类型的 SMEMBERS。这些操作会对 Hash 和 Set 类型的底层数据结构进行全量扫描，如果集合类型数据较多的话，就会阻塞 Redis 主线程。</p><p>如果想要获得集合类型的全量数据，我给你三个小建议。</p><ul><li>你可以使用 SSCAN、HSCAN 命令分批返回集合中的数据，减少对主线程的阻塞。</li><li>你可以化整为零，把一个大的 Hash 集合拆分成多个小的 Hash 集合。这个操作对应到业务层，就是对业务数据进行拆分，按照时间、地域、用户 ID 等属性把一个大集合的业务数据拆分成多个小集合数据。例如，当你统计用户的访问情况时，就可以按照天的粒度，把每天的数据作为一个 Hash 集合。</li><li>最后一个建议是，如果集合类型保存的是业务数据的多个属性，而每次查询时，也需要返回这些属性，那么，你可以使用 String 类型，将这些属性序列化后保存，每次直接返回 String 数据就行，不用再对集合类型做全量扫描了。</li></ul></li></ol><h1 id="Redis存储结构"><a href="#Redis存储结构" class="headerlink" title="Redis存储结构"></a>Redis存储结构</h1><p>Redis 中所有数据都保存在 DB 中，一个 Redis 默认最多支持 16 个 DB。Redis 中的每个 DB 都对应一个 redisDb 结构，即每个 Redis 实例，默认有 16 个 redisDb。用户访问时，默认使用的是 0 号 DB，可以通过 select $dbID 在不同 DB 之间切换。</p><p>redisDb 主要包括 2 个核心 dict 字典、3 个非核心 dict 字典、dbID 和其他辅助属性。2 个核心 dict 包括一个 dict 主字典和一个 expires 过期字典。主 dict 字典用来存储当前 DB 中的所有数据，它将 key 和各种数据类型的 value 关联起来，该 dict 也称 key space。过期字典用来存储过期时间 key，存的是 key 与过期时间的映射。日常的数据存储和访问基本都会访问到 redisDb 中的这两个 dict。</p><p>Redis 的所有内存数据结构都存在全局的 dict 字典中，dict 类似 Memcached 的 hashtable。Redis 的 dict 也有 2 个哈希表，插入新 key 时，一般用 0 号哈希表，随着 key 的插入或删除，当 0 号哈希表的 keys 数大于哈希表桶数，或 kyes 数小于哈希桶的 1⁄10 时，就对 hash 表进行扩缩。dict 中，哈希表解决冲突的方式，与 Memcached 相同，也是使用桶内单链表，来指向多个 hash 相同的 key&#x2F;value 数据。</p><h1 id="Redis淘汰key"><a href="#Redis淘汰key" class="headerlink" title="Redis淘汰key"></a>Redis淘汰key</h1><h2 id="淘汰原理"><a href="#淘汰原理" class="headerlink" title="淘汰原理"></a>淘汰原理</h2><p>当 key 过期后，或者 Redis 实际占用的内存超过阀值后，Redis 就会对 key 进行淘汰，删除过期的或者不活跃的 key，回收其内存，供新的 key 使用。Redis 的内存阀值是通过 maxmemory 设置的，而超过内存阀值后的淘汰策略，是通过 maxmemory-policy 设置的。</p><p>Redis 会在 2 种场景下对 key 进行淘汰，第一种是在定期执行 serverCron 时，检查淘汰 key；第二种是在执行命令时，检查淘汰 key。</p><ul><li><p>第一种场景，Redis 定期执行 serverCron 时，会对 DB 进行检测，清理过期 key。</p><p>清理流程如下。首先轮询每个 DB，检查其 expire dict，即带过期时间的过期 key 字典，从所有带过期时间的 key 中，随机选取 20 个样本 key，检查这些 key 是否过期，如果过期则清理删除。如果 20 个样本中，超过 5 个 key 都过期，即过期比例大于 25%，就继续从该 DB 的 expire dict 过期字典中，再随机取样 20 个 key 进行过期清理，持续循环，直到选择的 20 个样本 key 中，过期的 key 数小于等于 5，当前这个 DB 则清理完毕，然后继续轮询下一个 DB。</p><p>在执行 serverCron 时，如果在某个 DB 中，过期 dict 的填充率低于 1%，则放弃对该 DB 的取样检查，因为效率太低。如果 DB 的过期 dict 中，过期 key 太多，一直持续循环回收，会占用大量主线程时间，所以 Redis 还设置了一个过期时间。这个过期时间根据 serverCron 的执行频率来计算，5.0 版本及之前采用慢循环过期策略，默认是 25ms，如果回收超过 25ms 则停止，6.0 非稳定版本采用快循环策略，过期时间为 1ms。</p></li><li><p>第二种场景，Redis 在执行命令请求时。会检查当前内存占用是否超过 maxmemory 的数值，如果超过，则按照设置的淘汰策略，进行删除淘汰 key 操作。</p></li></ul><h2 id="淘汰方式"><a href="#淘汰方式" class="headerlink" title="淘汰方式"></a>淘汰方式</h2><p>Redis 中 key 的淘汰方式有两种，分别是同步删除淘汰和异步删除淘汰。</p><p><strong>异步删除淘汰：</strong>在 serverCron 定期清理过期 key 时，如果设置了延迟过期配置 lazyfree-lazy-expire，会检查 key 对应的 value 是否为多元素的复合类型，即是否是 list 列表、set 集合、zset 有序集合和 hash 中的一种，并且 value 的元素数大于 64，则在将 key 从 DB 中 expire dict 过期字典和主 dict 中删除后，value 存放到 BIO 任务队列，由 BIO 延迟删除线程异步回收；</p><p><strong>同步删除淘汰：</strong>否则，直接从 DB 的 expire dict 和主 dict 中删除，并回收 key、value 所占用的空间。</p><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>Redis 提供了 8 种 maxmemory_policy 淘汰策略来应对内存超过阀值的情况。</p><p>第一种淘汰策略是 noeviction，它是 Redis 的默认策略。在内存超过阀值后，Redis 不做任何清理工作，然后对所有写操作返回错误，但对读请求正常处理。noeviction 适合数据量不大的业务场景，将关键数据存入 Redis 中，将 Redis 当作 DB 来使用。</p><p>第二种淘汰策略是 volatile-lru，它对带过期时间的 key 采用最近最少访问算法来淘汰。使用这种策略，Redis 会从 redisDb 的 expire dict 过期字典中，首先随机选择 N 个 key，计算 key 的空闲时间，然后插入 evictionPool 中，最后选择空闲时间最久的 key 进行淘汰。这种策略适合的业务场景是，需要淘汰的key带有过期时间，且有冷热区分，从而可以淘汰最久没有访问的key。</p><p>第三种策略是 volatile-lfu，它对带过期时间的 key 采用最近最不经常使用的算法来淘汰。使用这种策略时，Redis 会从 redisDb 中的 expire dict 过期字典中，首先随机选择 N 个 key，然后根据其 value 的 lru 值，计算 key 在一段时间内的使用频率相对值。对于 lfu，要选择使用频率最小的 key，为了沿用 evictionPool 的 idle 概念，Redis 在计算 lfu 的 Idle 时，采用 255 减去使用频率相对值，从而确保 Idle 最大的 key 是使用次数最小的 key，计算 N 个 key 的 Idle 值后，插入 evictionPool，最后选择 Idle 最大，即使用频率最小的 key，进行淘汰。这种策略也适合大多数 key 带过期时间且有冷热区分的业务场景。</p><p>第四种策略是 volatile-ttl，它是对带过期时间的 key 中选择最早要过期的 key 进行淘汰。使用这种策略时，Redis 也会从 redisDb 的 expire dict 过期字典中，首先随机选择 N 个 key，然后用最大无符号 long 值减去 key 的过期时间来作为 Idle 值，计算 N 个 key 的 Idle 值后，插入evictionPool，最后选择 Idle 最大，即最快就要过期的 key，进行淘汰。这种策略适合，需要淘汰的key带过期时间，且有按时间冷热区分的业务场景。</p><p>第五种策略是 volatile-random，它是对带过期时间的 key 中随机选择 key 进行淘汰。使用这种策略时，Redis 从 redisDb 的 expire dict 过期字典中，随机选择一个 key，然后进行淘汰。如果需要淘汰的key有过期时间，没有明显热点，主要被随机访问，那就适合选择这种淘汰策略。</p><p>第六种策略是 allkey-lru，它是对所有 key，而非仅仅带过期时间的 key，采用最近最久没有使用的算法来淘汰。这种策略与 volatile-lru 类似，都是从随机选择的 key 中，选择最长时间没有被访问的 key 进行淘汰。区别在于，volatile-lru 是从 redisDb 中的 expire dict 过期字典中选择 key，而 allkey-lru 是从所有的 key 中选择 key。这种策略适合，需要对所有 key 进行淘汰，且数据有冷热读写区分的业务场景。</p><p><img src="https://i0.hdslb.com/bfs/article/4e748a17cf32172b6cb126927350db7e171301454.png" alt="image-20250226170831894"></p><p>第七种策略是 allkeys-lfu，它也是针对所有 key 采用最近最不经常使用的算法来淘汰。这种策略与 volatile-lfu 类似，都是在随机选择的 key 中，选择访问频率最小的 key 进行淘汰。区别在于，volatile-flu从expire dict 过期字典中选择 key，而 allkeys-lfu 是从主 dict 中选择 key。这种策略适合的场景是，需要从所有的 key 中进行淘汰，但数据有冷热区分，且越热的数据访问频率越高。</p><p>最后一种策略是 allkeys-random，它是针对所有 key 进行随机算法进行淘汰。它也是从主 dict 中随机选择 key，然后进行删除回收。如果需要从所有的 key 中进行淘汰，并且 key 的访问没有明显热点，被随机访问，即可采用这种策略。</p><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>Redis 的持久化是通过 RDB 和 AOF 文件进行的。</p><ul><li>RDB 只记录某个时间点的快照，可以通过设置指定时间内修改 keys 数的阀值，超过则自动构建 RDB 内容快照，不过线上运维，一般会选择在业务低峰期定期进行。RDB 存储的是构建时刻的数据快照，内存数据一旦落地，不会理会后续的变更。</li><li>AOF，记录是构建整个数据库内容的命令，它会随着新的写操作不断进行追加操作。由于不断追加，AOF 会记录数据大量的中间状态，AOF 文件会变得非常大，此时，可以通过 bgrewriteaof 指令，对 AOF 进行重写，只保留数据的最后内容，来大大缩减 AOF 的内容。</li></ul><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>触发构建 RDB 的场景主要有以下四种。</p><ol><li>第一种场景是通过 save 或 bgsave 命令进行主动 RDB 快照构建。它是由调用方调用 save 或 bgsave 指令进行触发的。</li><li>第二种场景是利用配置 save m n 来进行自动快照生成。它是指在 m 秒中，如果插入或变更 n 个 key，则自动触发 bgsave。这个配置可以设置多个配置行，以便组合使用。由于峰值期间，Redis 的压力大，变更的 key 也比较多，如果再进行构建 RDB 的操作，会进一步增加机器负担，对调用方请求会有一定的影响，所以线上使用时需要谨慎。</li><li>第三种场景是主从复制，如果从库需要进行全量复制，此时主库也会进行 bgsave 生成一个 RDB 快照。</li><li>第四种场景是在运维执行 flushall 清空所有数据，或执行 shutdown 关闭服务时，也会触发 Redis 自动构建 RDB 快照。</li></ol><p>save 是在主进程中进行 RDB 持久化的，持久化期间 Redis 处于阻塞状态，不处理任何客户请求，所以一般使用较少。而 bgsave 是 fork 一个子进程，然后在子进程中构建 RDB 快照，构建快照的过程不直接影响用户的访问，但仍然会增加机器负载。线上 Redis 快照备份，一般会选择凌晨低峰时段，通过 bgsave 主动触发进行备份。</p><p>RDB 快照文件主要由 3 部分组成。</p><ol><li>第一部分是 RDB 头部，主要包括 RDB 的版本，以及 Redis 版本、创建日期、占用内存等辅助信息。</li><li>第二部分是各个 RedisDB 的数据。存储每个 RedisDB 时，会首先记录当前 RedisDB 的DBID，然后记录主 dict 和 expire dict 的记录数量，最后再轮询存储每条数据记录。存储数据记录时，如果数据有过期时间，首先记录过期时间。如果 Redis 的 maxmemory_policy 过期策略采用 LRU 或者 LFU，还会将 key 对应的 LRU、LFU 值进行落地，最后记录数据的类型、key，以及 value。</li><li>第三部部分是 RDB 的尾部。RDB 尾部，首先存储 Redis 中的 Lua 脚本等辅助信息。然后存储 EOF 标记，即值为 255 的字符。最后存 RDB 的 cksum。</li></ol><p>RDB 采用二进制方式存储内存数据，文件小，且启动时恢复速度快。但构建 RDB 时，一个快照文件只能存储，构建时刻的内存数据，无法记录之后的数据变更。构建 RDB 的过程，即便在子进程中进行，但仍然属于 CPU 密集型的操作，而且每次落地全量数据，耗时也比较长，不能随时进行，特别是不能在高峰期进行。由于 RDB 采用二进制存储，可读性差，而且由于格式固定，不同版本之间可能存在兼容性问题。</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>Redis 的 AOF 持久化是以命令追加的方式进行数据落地的。通过打开 appendonly 配置，Redis 将每一个写指令追加到磁盘 AOF 文件，从而及时记录内存数据的最新状态。这样即便 Redis 被 crash 或异常关闭后，再次启动，也可以通过加载 AOF，来恢复最新的全量数据，基本不会丢失数据。</p><p>AOF 文件中存储的协议是写指令的 multibulk 格式，这是 Redis 的标准协议格式，所以不同的 Redis 版本均可解析并处理，兼容性很好。</p><p>但是，由于 Redis 会记录所有写指令操作到 AOF，大量的中间状态数据，甚至被删除的过期数据，都会存在 AOF 中，冗余度很大，而且每条指令还需通过加载和执行来进行数据恢复，耗时会比较大。</p><p>AOF 数据的落地流程如下。Redis 在处理完写指令后，首先将写指令写入 AOF 缓冲，然后通过 server_cron 定期将 AOF 缓冲写入文件缓冲。最后按照配置策略进行 fsync，将文件缓冲的数据真正同步写入磁盘。</p><p><img src="https://i0.hdslb.com/bfs/article/8432570784b531c74bc5418d935c0abc171301454.png" alt="image-20250303101943498"></p><p>Redis 通过 appendfsync 来设置三种不同的同步文件缓冲策略。</p><ol><li>第一种配置策略是 no，即 Redis 不主动使用 fsync 进行文件数据同步落地，而是由操作系统的 write 函数去确认同步时间，在 Linux 系统中大概每 30 秒会进行一次同步，如果 Redis 发生 crash，就会造成大量的数据丢失。</li><li>第二种配置策略是 always，即每次将 AOF 缓冲写入文件，都会调用 fsync 强制将内核数据写入文件，安全性最高，但性能上会比较低效，而且由于频繁的 IO 读写，磁盘的寿命会大大降低。</li><li>第三种配置策略是 everysec。即每秒通过 BIO 线程进行一次 fsync。这种策略在安全性、性能，以及磁盘寿命之间做较好的权衡，可以较好的满足线上业务需要。</li></ol><p>随着时间的推移，AOF 持续记录所有的写指令，AOF 会越来越大，而且会充斥大量的中间数据、过期数据，为了减少无效数据，提升恢复时间，可以定期对 AOF 进行 rewrite 操作。</p><p>AOF 的 rewrite 操作可以通过运维执行 bgrewiretaof 命令来进行，也可以通过配置重写策略进行，由 Redis 自动触发进行。当对 AOF 进行 rewrite 时，首先会 fork 一个子进程。子进程轮询所有 RedisDB 快照，将所有内存数据转为 cmd，并写入临时文件。在子进程 rewriteaof 时，主进程可以继续执行用户请求，执行完毕后将写指令写入旧的 AOF 文件和 rewrite 缓冲。子进程将 RedisDB 中数据落地完毕后，通知主进程。主进程从而将 AOF rewite 缓冲数据写入 AOF 临时文件，然后用新的 AOF 文件替换旧的 AOF 文件，最后通过 BIO 线程异步关闭旧的 AOF 文件。至此，AOF 的 rewrite 过程就全部完成了。</p><p>AOF 持久化的优势是可以记录全部的最新内存数据，最多也就是 1-2 秒的数据丢失。同时 AOF 通过 Redis 协议来追加记录数据，兼容性高，而且可以持续轻量级的保存最新数据。最后因为是直接通过 Redis 协议存储，可读性也比较好。</p><h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><p>Redis 在 4.0 版本之后，引入了混合持久化方式，而且在 5.0 版本后默认开启。前面讲到 RDB 加载速度快，但构建慢，缺少最新数据。AOF 持续追加最新写记录，可以包含所有数据，但冗余大，加载速度慢。混合模式一体化使用 RDB 和 AOF，综合 RDB 和 AOF 的好处。即可包含全量数据，加载速度也比较快。可以使用 aof-use-rdb-preamble 配置来明确打开混合持久化模式。</p><p>混合持久化也是通过 bgrewriteaof 来实现的。当启用混合存储后，进行 bgrewriteaof 时，主进程首先依然是 fork 一个子进程，子进程首先将内存数据以 RDB 的二进制格式写入 AOF 临时文件中。然后，再将落地期间缓冲的新增写指令，以命令的方式追加到临时文件。然后再通知主进程落地完毕。主进程将临时文件修改为 AOF 文件，并关闭旧的 AOF 文件。这样主体数据以 RDB 格式存储，新增指令以命令方式追加的混合存储方式进行持久化。后续执行的任务，以正常的命令方式追加到新的 AOF 文件即可。</p><p>混合持久化综合了 RDB 和 AOF 的优缺点，优势是包含全量数据，加载速度快。不足是头部的 RDB 格式兼容性和可读性较差。</p><p><img src="https://i0.hdslb.com/bfs/article/e866239a20926c53ef4056bc353957b2171301454.png" alt="image-20250226175656070"></p><p>为了提升系统的可扩展性，提升读操作的支撑能力，Redis 支持 master-slave 的复制功能。当 Redis 的 slave 部署并设置完毕后，slave 会和 master 建立连接，进行全量同步。</p><p>第一次建立连接，或者长时间断开连接后，缺失的指令超过 master 复制缓冲区的大小，都需要先进行一次全量同步。全量同步时，master 会启动一个子进程，将数据库快照保存到文件中，然后将这个快照文件发给 slave，同时将快照之后的写指令也同步给 slave。</p><p>全量同步完成后，如果 slave 短时间中断，然后重连复制，缺少的写指令长度小于 master 的复制缓冲大小，master 就会把 slave 缺失的内容全部发送给 slave，进行增量复制。</p><p>Redis 的 master 可以挂载多个 slave，同时 slave 还可以继续挂载 slave，通过这种方式，可以有效减轻 master 的压力，同时在 master 挂掉后，可以在 slave 通过 slaveof no one 指令，使当前 slave 停止与 master 的同步，转而成为新的 master。</p><h1 id="Redis高性能"><a href="#Redis高性能" class="headerlink" title="Redis高性能"></a>Redis高性能</h1><p>Redis 性能很高，单线程压测可以达到 10~11w 的 QPS。</p><p>Redis 一般被看作单进程&#x2F;单线程组件，因为 Redis 的网络 IO 和命令处理，都在核心进程中由单线程处理。Redis 基于 Epoll 事件模型开发，可以进行非阻塞网络 IO，同时由于单线程命令处理，整个处理过程不存在竞争，不需要加锁，没有上下文切换开销，所有数据操作都是在内存中操作，所以 Redis 的性能很高，单个实例即可以达到 10w 级的 QPS。核心线程除了负责网络 IO 及命令处理外，还负责写数据到缓冲，以方便将最新写操作同步到 AOF、slave。</p><ul><li>收到 bgrewriteaof 命令时，Redis 调用 fork，构建一个子进程，子进程往临时 AOF文件中，写入重建数据库状态的所有命令，当写入完毕，子进程则通知父进程，父进程把新增的写操作也追加到临时 AOF 文件，然后将临时文件替换老的 AOF 文件，并重命名。</li><li>收到 bgsave 命令时，Redis 构建子进程，子进程将内存中的所有数据通过快照做一次持久化落地，写入到 RDB 中。</li><li>当需要进行全量复制时，master 也会启动一个子进程，子进程将数据库快照保存到 RDB 文件，在写完 RDB 快照文件后，master 就会把 RDB 发给 slave，同时将后续新的写指令都同步给 slave。</li></ul><p><img src="https://i0.hdslb.com/bfs/article/0f0427bdab6125719ce8e29d27fef000171301454.png" alt="image-20250224103803951"></p><p>主进程中，除了主线程处理网络 IO 和命令操作外，还有 3 个辅助 BIO 线程。这 3 个 BIO 线程分别负责处理，文件关闭、AOF 缓冲数据刷新到磁盘，以及清理对象这三个任务队列。这是一个生产-消费模型，一般都是由主线程生产慢任务，放到处理队列中，BIO线程充当消费者来消费任务。</p><p>Redis 在启动时，会同时启动这三个 BIO 线程，然后 BIO 线程休眠等待任务。当需要执行相关类型的后台任务时，就会构建一个 bio_job 结构，记录任务参数，然后将 bio_job 追加到任务队列尾部。然后唤醒 BIO 线程，即可进行任务执行。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>Redis 6.0 的多线程处理流程如下图所示。主线程负责监听端口，注册连接读事件，当有新连接进入时，主线程accept新连接，创建client，并为新连接注册请求读事件。</p><p><img src="https://i0.hdslb.com/bfs/article/d5ce44917fa00607ba06aa02c3964deb171301454.png" alt="image-20250307101658118"></p><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="Redis复制原理"><a href="#Redis复制原理" class="headerlink" title="Redis复制原理"></a>Redis复制原理</h2><p>通过数据复制，Redis 的一个 master 可以挂载多个 slave，而 slave 下还可以挂载多个 slave，形成多层嵌套结构。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/32d1c9e07f517779764407af4bd2ffb006f66271.png" alt="image-20250709141026195"></p><p>master 在分发写请求时，同时会将写指令复制一份存入复制积压缓冲，这样当 slave 短时间断开重连时，只要 slave 的复制位置点仍然在复制积压缓冲，则可以从之前的复制位置点之后继续进行复制，提升复制效率。</p><h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><p>哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/e94fdd5b2c39197abfaeeb8eda4bf8e05c1a2ce6.png" alt="image-20250709141146570"></p><p>但是，在监控和选主这两个任务中，哨兵需要做出两个决策：</p><ul><li>在监控任务中，哨兵需要判断主库是否处于下线状态；</li><li>在选主任务中，哨兵也要决定选择哪个从库实例作为主库。</li></ul><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><p><strong>哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态</strong>。如果哨兵发现<strong>从库</strong>对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。</p><p><strong>而主库的下线，通常会采用哨兵集群（多实例组成的集群模式进行部署）判断</strong>。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/716bf87a3b237d7fd245471a3d8d05a7903d8f2f.png" alt="image-20250709141158788"></p><p>简单来说，“客观下线”的标准就是，当有 N 个哨兵实例时，最好要有 N&#x2F;2 + 1 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”。这样一来，就可以减少误判的概率，也能避免误判带来的无谓的主从库切换。（当然，有多少个实例做出“主观下线”的判断才可以，可以由 Redis 管理员自行设定）。</p><h3 id="选定新主库"><a href="#选定新主库" class="headerlink" title="选定新主库"></a>选定新主库</h3><p>筛选条件：判断从库之前的网络连接状态，检查从库当前的在线状态。</p><p>打分条件：</p><ul><li><strong>第一轮：优先级最高的从库得分高。</strong>用户可以通过 slave-priority 配置项，给不同的从库设置不同优先级。</li><li><strong>第二轮：和旧主库同步程度最接近的从库得分高。</strong>从库的复制位点离旧主库的复制进度最近。</li><li><strong>第三轮：ID 号小的从库得分高。</strong></li></ul><h4 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h4><p>脑裂发生的原因主要是原主库发生了假故障，我们来总结下假故障的两个原因。</p><ol><li>和主库部署在同一台服务器上的其他程序临时占用了大量资源（例如 CPU 资源），导致主库资源使用受限，短时间内无法响应心跳。其它程序不再使用资源时，主库又恢复正常。</li><li>主库自身遇到了阻塞的情况，例如，处理 bigkey 或是发生内存 swap（物理机器内存不足），短时间内无法响应心跳，等主库阻塞解除后，又恢复正常的请求处理了。</li></ol><p>Redis 已经提供了两个配置项来限制主库的请求处理，分别是 min-slaves-to-write 和 min-slaves-max-lag。</p><ul><li>min-slaves-to-write：这个配置项设置了主库能进行数据同步的最少从库数量；</li><li>min-slaves-max-lag：这个配置项设置了主从库间进行数据复制时，从库给主库发送 ACK 消息的最大延迟（以秒为单位）。</li></ul><p>有了这两个配置项后，我们就可以轻松地应对脑裂问题了。</p><p>假设我们将 min-slaves-to-write 设置为 1，把 min-slaves-max-lag 设置为 12s，把哨兵的 down-after-milliseconds 设置为 10s，主库因为某些原因卡住了 15s，导致哨兵判断主库客观下线，开始进行主从切换。同时，因为原主库卡住了 15s，没有一个从库能和原主库在 12s 内进行数据复制，原主库也无法接收客户端请求了。这样一来，主从切换完成后，也只有新主库能接收请求，不会发生脑裂，也就不会发生数据丢失的问题了。</p><h1 id="Redis集群管理"><a href="#Redis集群管理" class="headerlink" title="Redis集群管理"></a>Redis集群管理</h1><p>Redis 的集群管理有 3 种方式。</p><ul><li><p>client 分片访问，client 对 key 做 hash，然后按取模或一致性 hash，把 key 的读写分散到不同的 Redis 实例上。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/8ffa5dc03351ad6983d5f9c1dc23ef3304a75bf0.png" alt="image-20250709141214450"></p></li><li><p>proxy端分区，在 Redis 前加一个 proxy，把路由策略、后端 Redis 状态维护的工作都放到 proxy 中进行，client 直接访问 proxy，后端 Redis 变更，只需修改 proxy 配置即可。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/28ed197a1da98de17944dd059088d8754800346c.png" alt="image-20250709141239383"></p></li><li><p>直接使用 Redis cluster。Redis 创建之初，使用方直接给 Redis 的节点分配 slot，后续访问时，对 key 做 hash 找到对应的 slot，然后访问 slot 所在的 Redis 实例。在需要扩容缩容时，可以在线通过 cluster setslot 指令，以及 migrate 指令，将 slot 下所有 key 迁移到目标节点，即可实现扩缩容的目的。</p></li></ul><p><img src="https://i0.hdslb.com/bfs/openplatform/b2d396db5857a6815dee9624d3545b47b169b311.png" alt="image-20250709141228028"></p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存的基本思想</title>
      <link href="/2025/02/17/%E7%BC%93%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/"/>
      <url>/2025/02/17/%E7%BC%93%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="缓存的基本思想"><a href="#缓存的基本思想" class="headerlink" title="缓存的基本思想"></a>缓存的基本思想</h1><p>空间换时间。</p><p>缓存中的数据通常存储于内存中，因此访问速度非常快。为了避免内存中的数据在重启或者宕机之后丢失，很多缓存中间件会利用磁盘做持久化。</p><p>缓存相比较于我们常用的关系型数据库来说访问速度要快非常多，为了避免用户请求数据库中的数据速度过于缓慢，我们可以在数据库之上增加一层缓存。</p><p>除了能提高访问速度之外，缓存支持的并发量也要大。有了缓存后，数据库的压力也会随之变小。</p><h1 id="缓存的分类"><a href="#缓存的分类" class="headerlink" title="缓存的分类"></a>缓存的分类</h1><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p><img src="https://i0.hdslb.com/bfs/article/05ae15dcc71bb5e395ccd2aee0c5437c171301454.png" alt="Pasted image 20221215181540"><br><strong>本地缓存的方案</strong></p><ol><li>JDK 自带的 HashMap 和 ConcurrentHashMap</li></ol><ul><li>ConcurrentHashMap 是线程安全版本的 HashMap，大部分场景不会使用这两者做缓存，因为只提供了缓存的功能，并没有提供其他诸如过期时间之类的功能。</li></ul><ol start="2"><li>Ehcache、Guava Cache、Spring Cache 比较常用的本地缓存框架</li></ol><ul><li>Ehcache 比其他两者更重量。Ehcache 可以嵌入到 Hibernate 和 MyBatis 作为多级缓存，并且可以将缓存的数据持久化到本地磁盘中</li><li>Guava Cache 和 Spring Cache 两者比较像。Guava 使用更多一点，提供了 API 方便使用，也提供了设置缓存有效时间等功能。</li><li>使用 Spring Cache 注解实现缓存，代码会看着干净优雅，但是很容易出现缓存穿透、内存溢出等问题。</li></ul><ol start="3"><li>Caffeine</li></ol><ul><li>一般建议替代 Guava</li></ul><p>本地缓存缺陷：</p><ul><li>当同一个相同服务部署到多台机器上时，各个服务之间的缓存无法共享，因为本地缓存在当前机器</li><li>如果当前系统服务所耗费的内存多，那么本地缓存可用的容量就很少</li></ul><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p><img src="https://i0.hdslb.com/bfs/article/2a4d9ea416e4a24215f7c89f422c7486171301454.png" alt="Pasted image 20221215181816"><br>使用分布式缓存后，缓存服务可以部署在一台单独的服务器上，即使同一个相同的服务部署在多台机器上，也是使用的同一份缓存。并且，单独的分布式缓存服务的性能、容量和提供的功能都更加强大。</p><h1 id="常见的缓存更新策略"><a href="#常见的缓存更新策略" class="headerlink" title="常见的缓存更新策略"></a>常见的缓存更新策略</h1><h2 id="Cache-Aside-Pattern-旁路缓存模式"><a href="#Cache-Aside-Pattern-旁路缓存模式" class="headerlink" title="Cache Aside Pattern 旁路缓存模式"></a>Cache Aside Pattern 旁路缓存模式</h2><p>Cache Aside Pattern 比较适合读请求比较多的场景。服务端需要同时维系数据库和缓存，以 db 的结果为准。</p><p>写：<br><img src="https://i0.hdslb.com/bfs/article/cd5c0c1a5a9957ea0012ca938d12a9b4171301454.png" alt="Pasted image 20221216124739"></p><blockquote><p>为什么要删除cache，而不是更新cache?</p></blockquote><p><strong>原因：</strong><br>1.对服务端资源造成浪费：删除cache更直接，因为cache中存放的一些数据需要通过服务端经过大量的计算才能得出，会消耗服务端的资源。如果频繁修改db，就会导致频繁更新cache，而cache中的数据可能没有被访问到。<br>2.产生数据不一致的情况：并发场景下，更新cache产生数据不一致的概率会更大。</p><blockquote><p><strong>可以先删除 cache 后更新 db 吗？</strong></p></blockquote><p>不行，会造成数据不一致的情况。</p><ol><li>请求1先删除 cache 中的 A 数据</li><li>请求2从 db 中读取数据</li><li>请求1再把 db 中的 A 数据更新</li><li>导致请求2读取到的 A 数据就是旧值</li></ol><blockquote><p><strong>在写数据过程中，先更新 db，后删除 cache 就没问题了吗？</strong></p></blockquote><p>不一定，有可能会产生数据不一致的问题。</p><ol><li>请求1从 db 读取数据 A</li><li>请求2更新 db 中的数据 A（此时缓存中没有数据A，不需要删除）</li><li>请求1将数据A写入cache</li><li>导致cache中存放的是旧值</li></ol><p>读：<br><img src="https://i0.hdslb.com/bfs/article/a41e75b82d5b209db3af29f1e7e2061e171301454.png" alt="Pasted image 20221216124806"></p><p><strong>Cache Aside Pattern 缺陷及解决方案</strong></p><p>缺陷1：首次请求数据一定不在cache中：可以将热点数据提前放入cache中</p><p>缺陷2：写操作比较频繁导致cache中的数据会被频繁地删除，这样会影响缓存命中率</p><ul><li><p>数据库和缓存数据强一致场景：更新db的时候同样更新cache，不过需要加一个锁&#x2F;分布式锁来保证更新cache的时候不存在线程安全问题</p></li><li><p>可以短暂允许数据库与缓存数据不一致的场景：更新db的时候同样更新cache,但是给缓存一个较短的过期时间，这样可以保证即使数据不一致，影响也比较小。</p></li></ul><h2 id="Read-Write-Through-读写穿透"><a href="#Read-Write-Through-读写穿透" class="headerlink" title="Read&#x2F;Write Through 读写穿透"></a>Read&#x2F;Write Through 读写穿透</h2><p>对于 Cache Aside 模式，业务应用需要同时维护 cache 和 DB 两个数据存储方，过于繁琐，于是就有了 Read&#x2F;Write Through 模式。</p><p>在这种模式下，业务应用只关注一个存储服务即可，业务方的读写 cache 和 DB 的操作，都由存储服务代理。存储服务收到业务应用的写请求时，会首先查 cache，如果数据在 cache 中不存在，则只更新 DB，如果数据在 cache 中存在，则先更新 cache，然后更新 DB。而存储服务收到读请求时，如果命中 cache 直接返回，否则先从 DB 加载，回种到 cache 后返回响应。</p><p>这种模式的特点是，存储服务封装了所有的数据处理细节，业务应用端代码只用关注业务逻辑本身，系统的隔离性更佳。另外，进行写操作时，如果 cache 中没有数据则不更新，有缓存数据才更新，内存效率更高。</p><p>微博 Feed 的 Outbox Vector（即用户最新微博列表）就采用这种模式。一些粉丝较少且不活跃的用户发表微博后，Vector 服务会首先查询 Vector Cache，如果 cache 中没有该用户的 Outbox 记录，则不写该用户的 cache 数据，直接更新 DB 后就返回，只有 cache 中存在才会通过 CAS 指令进行更新。</p><h2 id="Write-Behind-Pattern-异步缓存写入"><a href="#Write-Behind-Pattern-异步缓存写入" class="headerlink" title="Write Behind Pattern 异步缓存写入"></a>Write Behind Pattern 异步缓存写入</h2><p>只更新缓存，不直接更新 db，而是改为异步批量的方式更新 db</p><p>消息队列中消息的异步写入磁盘、Mysql 的 InnoDB Buffer Pool 机制都用到了这种策略</p><p>Write Pool Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、阅读量。</p><p>该模式的特点是，数据存储的写性能最高，非常适合一些变更特别频繁的业务，特别是可以合并写请求的业务，比如对一些计数业务，一条 Feed 被点赞 1万 次，如果更新 1万 次 DB 代价很大，而合并成一次请求直接加 1万，则是一个非常轻量的操作。</p><p>但这种模型有个显著的缺点，即数据的一致性变差，甚至在一些极端场景下可能会丢失数据。比如系统 Crash、机器宕机时，如果有数据还没保存到 DB，则会存在丢失的风险。所以这种读写模式适合变更频率特别高，但对一致性要求不太高的业务，这样写操作可以异步批量写入 DB，减小 DB 压力。</p><h1 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>缓存里的数据存储基本上都是以 key 为索引进行存储和获取的。业务访问时，如果大量的 key 同时过期，很多缓存数据访问都会 miss，进而穿透到 DB，DB 的压力就会明显上升，由于 DB 的性能较差，只在缓存的 1%~2% 以下，这样请求的慢查率会明显上升。这就是缓存失效的问题。</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>导致缓存失效，特别是很多 key 一起失效的原因，跟我们日常写缓存的过期时间息息相关。</p><p>在某些场景，一大批数据会被系统主动或被动从 DB 批量加载，然后写入缓存。这些数据写入缓存时，由于使用相同的过期时间，在经历这个过期时间之后，这批数据就会一起到期，从而被缓存淘汰。此时，对这批数据的所有请求，都会出现缓存失效，从而都穿透到 DB，DB 由于查询量太大，就很容易压力大增，请求变慢。</p><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>同一批火车票、飞机票，当可以售卖时，系统会一次性加载到缓存，如果缓存写入时，过期时间按照预先设置的过期值，那过期时间到期后，系统就会因缓存失效出现变慢的问题。</p><p>微博业务，会有后台离线系统，持续计算热门微博，每当计算结束，会将这批热门微博批量写入对应的缓存。</p><p>很多业务，在部署新 IDC 或新业务上线时，会进行缓存预热，也会一次性加载大批热数据。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>设计缓存的过期时间时，使用公式：过期时间&#x3D;baes 时间+随机时间。</p><p>即相同业务数据写缓存时，在基础过期时间之上，再加一个随机的过期时间，让数据在未来一段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过大压力。</p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>缓存穿透发生的概率很低，所以一般很难被发现。但是，一旦你发现了，而且量还不小，你可能立即就会经历一个忙碌的夜晚。</p><p>缓存穿透，则意味着有特殊访客在查询一个不存在的 key，导致每次查询都会穿透到 DB，如果这个特殊访客再控制一批肉鸡机器，持续访问你系统里不存在的 key，就会对 DB 产生很大的压力，从而影响正常服务。</p><h2 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h2><p>缓存穿透存在的原因，就是因为我们在系统设计时，更多考虑的是正常访问路径，对特殊访问路径、异常访问路径考虑相对欠缺。</p><p>缓存访问设计的正常路径，是先访问 cache，cache miss 后查 DB，DB 查询到结果后，回种缓存返回。这对于正常的 key 访问是没有问题的，但是如果用户访问的是一个不存在的 key，查 DB 返回空（即一个 NULL），那就不会把这个空写回cache。那以后不管查询多少次这个不存在的 key，都会 cache miss，都会查询 DB。整个系统就会退化成一个“前端+DB“的系统，由于 DB 的吞吐只在 cache 的 1%~2% 以下，如果有特殊访客，大量访问这些不存在的 key，就会导致系统的性能严重退化，影响正常用户的访问。</p><h2 id="业务场景-1"><a href="#业务场景-1" class="headerlink" title="业务场景"></a>业务场景</h2><p>缓存穿透的业务场景很多，比如通过不存在的 UID 访问用户，通过不存在的车次 ID 查看购票信息。用户输入错误，偶尔几个这种请求问题不大，但如果是大量这种请求，就会对系统影响非常大。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>第一种方案就是，查询这些不存在的数据时，第一次查 DB，虽然没查到结果返回 NULL，仍然记录这个 key 到缓存，只是这个 key 对应的 value 是一个特殊设置的值。</li><li>第二种方案是，构建一个 BloomFilter 缓存过滤器，记录全量数据，这样访问数据时，可以直接通过 BloomFilter 判断这个 key 是否存在，如果不存在直接返回即可，根本无需查缓存和 DB。</li></ul><p>不过这两种方案在设计时仍然有一些要注意的坑。</p><ul><li>对于方案一，如果特殊访客持续访问大量的不存在的 key，这些 key 即便只存一个简单的默认值，也会占用大量的缓存空间，导致正常 key 的命中率下降。所以进一步的改进措施是，对这些不存在的 key 只存较短的时间，让它们尽快过期；或者将这些不存在的 key 存在一个独立的公共缓存，从缓存查找时，先查正常的缓存组件，如果 miss，则查一下公共的非法 key 的缓存，如果后者命中，直接返回，否则穿透 DB，如果查出来是空，则回种到非法 key 缓存，否则回种到正常缓存。</li><li>对于方案二，BloomFilter 要缓存全量的 key，这就要求全量的 key 数量不大，10亿 条数据以内最佳，因为 10亿 条数据大概要占用 1.2GB 的内存。也可以用 BloomFilter 缓存非法 key，每次发现一个 key 是不存在的非法 key，就记录到 BloomFilter 中，这种记录方案，会导致 BloomFilter 存储的 key 持续高速增长，为了避免记录 key 太多而导致误判率增大，需要定期清零处理。</li></ul><h3 id="BloomFilter"><a href="#BloomFilter" class="headerlink" title="BloomFilter"></a>BloomFilter</h3><p>BloomFilter 是一个非常有意思的数据结构，不仅仅可以挡住非法 key 攻击，还可以低成本、高性能地对海量数据进行判断，比如一个系统有数亿用户和百亿级新闻 feed，就可以用 BloomFilter 来判断某个用户是否阅读某条新闻 feed。下面来对 BloomFilter 数据结构做一个分析，如下图所示。</p><p><img src="https://i0.hdslb.com/bfs/article/bc779ec51bf9095b1365e6bcde13d8dd171301454.png" alt="image-20250218114027598"></p><p>BloomFilter 的目的是检测一个元素是否存在于一个集合内。它的原理，是用 bit 数据组来表示一个集合，对一个 key 进行多次不同的 Hash 检测，如果所有 Hash 对应的 bit 位都是 1，则表明 key 非常大概率存在，平均单记录占用 1.2 字节即可达到 99%，<strong>只要有一次 Hash 对应的 bit 位是 0，就说明这个 key 肯定不存在于这个集合内。</strong></p><p><strong>BloomFilter 的算法：</strong></p><ul><li><p>首先分配一块内存空间做 bit 数组，数组的 bit 位初始值全部设为 0。</p></li><li><p>加入元素时，采用 k 个相互独立的 Hash 函数计算，然后将元素 Hash 映射的 K 个位置全部设置为 1。</p></li><li><p>检测 key 时，仍然用这 k 个 Hash 函数计算出 k 个位置，如果位置全部为 1，则表明 key 存在，否则不存在。</p></li></ul><p><strong>BloomFilter 的优势：</strong>全内存操作，性能很高。空间效率非常高，要达到 1% 的误判率，平均单条记录占用 1.2 字节即可。而且，平均单条记录每增加 0.6 字节，还可让误判率继续变为之前的 1&#x2F;10，即平均单条记录占用 1.8 字节，误判率可以达到 1&#x2F;1000；平均单条记录占用 2.4 字节，误判率可以到 1&#x2F;10000，以此类推。这里的误判率是指，BloomFilter 判断某个 key 存在，但它实际不存在的概率，因为它存的是 key 的 Hash 值，而非 key 的值，所以有概率存在这样的 key，它们内容不同，但多次 Hash 后的 Hash 值都相同。对于 BloomFilter 判断不存在的 key ，则是 100% 不存在的，反证法，如果这个 key 存在，那它每次 Hash 后对应的 Hash 值位置肯定是 1，而不会是 0。</p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>系统运行过程中，缓存雪崩是一个非常严重的问题。缓存雪崩是指部分缓存节点不可用，导致整个缓存体系甚至甚至服务系统不可用的情况。缓存雪崩按照缓存是否 rehash（即是否漂移）分两种情况：</p><ul><li>缓存不支持 rehash 导致的系统雪崩不可用</li><li>缓存支持 rehash 导致的缓存雪崩不可用</li></ul><h2 id="原因分析-2"><a href="#原因分析-2" class="headerlink" title="原因分析"></a>原因分析</h2><ul><li><p>缓存不进行 rehash 时产生的雪崩，一般是由于较多缓存节点不可用，大量 Cache 访问会失败，根据缓存读写模型，这些请求会进一步访问 DB，而且 DB 可承载的访问量要远比缓存小的多，请求量过大，就很容易造成 DB 过载，大量慢查询，最终阻塞甚至 Crash，从而导致服务异常。</p></li><li><p>缓存支持 rehash 时产生的雪崩，则大多跟流量洪峰有关，流量洪峰到达，引发部分缓存节点过载 Crash，然后因 rehash 扩散到其他缓存节点，最终整个缓存体系异常。</p><p>在缓存分布设计时，很多同学会选择<strong>一致性 Hash 分布方式</strong>，同时在部分节点异常时，<strong>采用 rehash 策略</strong>，即把异常节点请求平均分散到其他缓存节点。在一般情况下，一致性 Hash 分布+rehash 策略可以很好得运行，但在较大的流量洪峰到临之时，如果大流量 key 比较集中，正好在某 1～2 个缓存节点，很容易将这些缓存节点的内存、网卡过载，缓存节点异常 Crash，然后这些异常节点下线，这些大流量 key 请求又被 rehash 到其他缓存节点，进而导致其他缓存节点也被过载 Crash，缓存异常持续扩散，最终导致整个缓存体系异常，无法对外提供服务。</p></li></ul><h2 id="业务场景-2"><a href="#业务场景-2" class="headerlink" title="业务场景"></a>业务场景</h2><p>微博最初很多业务缓存采用一致性 Hash+rehash 策略，在突发洪水流量来临时，部分缓存节点过载 Crash 甚至宕机，然后这些异常节点的请求转到其他缓存节点，又导致其他缓存节点过载异常，最终整个缓存池过载。</p><p>机架断电，导致业务缓存多个节点宕机，大量请求直接打到 DB，也导致 DB 过载而阻塞，整个系统异常。最后缓存机器复电后，DB 重启，数据逐步加热后，系统才逐步恢复正常。</p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><p>预防缓存雪崩，这里给出 3 个解决方案。</p><ul><li><p>方案一，对业务 DB 的访问增加读写开关，当发现 DB 请求变慢、阻塞，慢请求超过阀值时，就会关闭读开关，部分或所有读 DB 的请求进行 failfast 立即返回，待 DB 恢复后再打开读开关，如下图。</p><p><img src="https://i0.hdslb.com/bfs/article/9c10f297f7fc8bd7f4656efdd0f228c1171301454.png" alt="image-20250218115208783"></p></li><li><p>方案二，对缓存增加多个副本，缓存异常或请求 miss 后，再读取其他缓存副本，而且多个缓存副本尽量部署在不同机架，从而确保在任何情况下，缓存系统都会正常对外提供服务。</p></li><li><p>方案三，对缓存体系进行实时监控，当请求访问的慢速比超过阀值时，及时报警，通过机器替换、服务替换进行及时恢复；也可以通过各种自动故障转移策略，自动关闭异常接口、停止边缘服务、停止部分非核心功能措施，确保在极端场景下，核心功能的正常运行。</p></li></ul><p>实际上，微博平台系统，这三种方案都采用了，通过三管齐下，规避缓存雪崩的发生。</p><h1 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h1><h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><p>七大缓存经典问题的第四个问题是数据不一致。同一份数据，可能会同时存在 DB 和缓存之中。那就有可能发生，DB 和缓存的数据不一致。如果缓存有多个副本，多个缓存副本里的数据也可能会发生不一致现象。</p><h2 id="原因分析-3"><a href="#原因分析-3" class="headerlink" title="原因分析"></a>原因分析</h2><p>不一致的问题大多跟缓存更新异常有关。比如更新 DB 后，写缓存失败，从而导致缓存中存的是老数据。另外，如果系统采用一致性 Hash 分布，同时采用 rehash 自动漂移策略，在节点多次上下线之后，也会产生脏数据。缓存有多个副本时，更新某个副本失败，也会导致这个副本的数据是老数据。</p><h2 id="业务场景-3"><a href="#业务场景-3" class="headerlink" title="业务场景"></a>业务场景</h2><p>导致数据不一致的场景也不少。如下图所示，在缓存机器的带宽被打满，或者机房网络出现波动时，缓存更新失败，新数据没有写入缓存，就会导致缓存和 DB 的数据不一致。缓存 rehash 时，某个缓存机器反复异常，多次上下线，更新请求多次 rehash。这样，一份数据存在多个节点，且每次 rehash 只更新某个节点，导致一些缓存节点产生脏数据。</p><p><img src="https://i0.hdslb.com/bfs/article/5f7ad3c1eca3c42e545bc6b67849fa42171301454.png" alt="image-20250220181055343"></p><h2 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h2><p>要尽量保证数据的一致性。这里也给出了 3 个方案，可以根据实际情况进行选择。</p><ul><li>第一个方案，cache 更新失败后，可以进行重试，如果重试失败，则将失败的 key 写入队列机服务，待缓存访问恢复后，将这些 key 从缓存删除。这些 key 在再次被查询时，重新从 DB 加载，从而保证数据的一致性。</li><li>第二个方案，缓存时间适当调短，让缓存数据及早过期后，然后从 DB 重新加载，确保数据的最终一致性。</li><li>第三个方案，不采用 rehash 漂移策略，而采用缓存分层策略，尽量避免脏数据产生。</li></ul><p><img src="https://i0.hdslb.com/bfs/article/91fc4102393e9273256f807ea4f3573f171301454.png" alt="image-20250220181337645"></p><h1 id="并发竞争"><a href="#并发竞争" class="headerlink" title="并发竞争"></a>并发竞争</h1><h2 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h2><p>第五个经典问题是数据并发竞争。互联网系统，线上流量较大，缓存访问中很容易出现数据并发竞争的现象。数据并发竞争，是指在高并发访问场景，一旦缓存访问没有找到数据，大量请求就会并发查询 DB，导致 DB 压力大增的现象。</p><p>数据并发竞争，主要是由于多个进程&#x2F;线程中，有大量并发请求获取相同的数据，而这个数据 key 因为正好过期、被剔除等各种原因在缓存中不存在，这些进程&#x2F;线程之间没有任何协调，然后一起并发查询 DB，请求那个相同的 key，最终导致 DB 压力大增，如下图。</p><p><img src="https://i0.hdslb.com/bfs/article/3fd4eaf59fa5b9436128c4f9a04adf0a171301454.png" alt="image-20250220181533138"></p><h2 id="业务场景-4"><a href="#业务场景-4" class="headerlink" title="业务场景"></a>业务场景</h2><p>数据并发竞争在大流量系统也比较常见，比如车票系统，如果某个火车车次缓存信息过期，但仍然有大量用户在查询该车次信息。又比如微博系统中，如果某条微博正好被缓存淘汰，但这条微博仍然有大量的转发、评论、赞。上述情况都会造成该车次信息、该条微博存在并发竞争读取的问题。</p><h2 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h2><p>要解决并发竞争，有 2 种方案。</p><ul><li><p>方案一是使用全局锁。如下图所示，即当缓存请求 miss 后，先尝试加全局锁，只有加全局锁成功的线程，才可以到 DB 去加载数据。其他进程&#x2F;线程在读取缓存数据 miss 时，如果发现这个 key 有全局锁，就进行等待，待之前的线程将数据从 DB 回种到缓存后，再从缓存获取。</p><p><img src="https://i0.hdslb.com/bfs/article/5ed2a325de08e7c3a060d9c69ee193df171301454.png" alt="image-20250220182352733"></p></li><li><p>方案二是，对缓存数据保持多个备份，即便其中一个备份中的数据过期或被剔除了，还可以访问其他备份，从而减少数据并发竞争的情况，如下图。</p><p><img src="https://i0.hdslb.com/bfs/article/2b594cbc54242d55dd8619e00442780c171301454.png" alt="image-20250220181834329"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java业务开发常见问题</title>
      <link href="/2025/02/07/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2025/02/07/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-框架：IoC-和-AOP-是扩展的核心"><a href="#Spring-框架：IoC-和-AOP-是扩展的核心" class="headerlink" title="Spring 框架：IoC 和 AOP 是扩展的核心"></a>Spring 框架：IoC 和 AOP 是扩展的核心</h1><blockquote><p>当 Bean 产生循环依赖时，比如 BeanA 的构造方法依赖 BeanB 作为成员需要注入，BeanB 也依赖 BeanA，你觉得会出现什么问题呢？又有哪些解决方式呢？</p></blockquote><p>答：Bean 产生循环依赖，主要包括两种情况：一种是注入属性或字段涉及循环依赖，另一种是构造方法注入涉及循环依赖。接下来，我分别和你讲一讲。</p><p>第一种，注入属性或字段涉及循环依赖，比如 TestA 和 TestB 相互依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对这个问题，Spring 内部通过三个 Map 的方式解决了这个问题，不会出错。基本原理是，因为循环依赖，所以实例的初始化无法一次到位，需要分步进行：</p><p>创建 A（仅仅实例化，不注入依赖）；</p><p>创建 B（仅仅实例化，不注入依赖）；</p><p>为 B 注入 A（此时 B 已健全）；</p><p>为 A 注入 B（此时 A 也健全）。</p><p>网上有很多相关的分析，我找了一篇比较详细的，可供你参考。</p><p>第二种，构造方法注入涉及循环依赖。遇到这种情况的话，程序无法启动，比如 TestC 和 TestD 的相互依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestD testD;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestC</span><span class="params">(TestD testD)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.testD = testD;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestD</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestC testC;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestD</span><span class="params">(TestC testC)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.testC = testC;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种循环依赖的主要解决方式，有 2 种：</p><p>改为属性或字段注入；</p><p>使用 @Lazy 延迟注入。比如如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestD testD;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestC</span><span class="params">(<span class="meta">@Lazy</span> TestD testD)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.testD = testD;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，这种 @Lazy 方式注入的就不是实际的类型了，而是代理类，获取的时候通过代理去拿值（实例化）。所以，它可以解决循环依赖无法实例化的问题。</p><h1 id="数据库索引：索引并不是万能药"><a href="#数据库索引：索引并不是万能药" class="headerlink" title="数据库索引：索引并不是万能药"></a>数据库索引：索引并不是万能药</h1><blockquote><p>索引除了可以用于加速搜索外，还可以在排序时发挥作用，你能通过 EXPLAIN 来证明吗？你知道，针对排序在什么情况下，索引会失效吗？</p></blockquote><p>答：排序使用到索引，在执行计划中的体现就是 key 这一列。如果没有用到索引，会在 Extra 中看到 Using filesort，代表使用了内存或磁盘进行排序。而具体走内存还是磁盘，是由 sort_buffer_size 和排序数据大小决定的。</p><p>排序无法使用到索引的情况有：</p><ul><li><p>对于使用联合索引进行排序的场景，多个字段排序 ASC 和 DESC 混用；</p></li><li><p>a+b 作为联合索引，按照 a 范围查询后按照 b 排序；</p></li><li><p>排序列涉及到的多个字段不属于同一个联合索引；</p></li><li><p>排序列使用了表达式。</p></li></ul><h2 id="为什么联合索引无法优化排序"><a href="#为什么联合索引无法优化排序" class="headerlink" title="为什么联合索引无法优化排序"></a>为什么联合索引无法优化排序</h2><ul><li>联合索引 <code>(a, b)</code> 的设计是为了优化 <code>a</code> 列的查询和 <code>a</code> 列相同情况下的 <code>b</code> 列查询。</li><li>当 <code>a</code> 列是范围查询时，<code>b</code> 列的顺序在索引中被打乱，因此无法直接利用索引来优化 <code>b</code> 列的排序。</li></ul><p>如果需要对 <code>b</code> 列进行排序，同时又有 <code>a</code> 列的范围查询，可以考虑以下优化方法：</p><h3 id="方法-1：调整索引顺序"><a href="#方法-1：调整索引顺序" class="headerlink" title="方法 1：调整索引顺序"></a>方法 1：调整索引顺序</h3><ul><li>如果查询条件中 <code>b</code> 列的排序是必须的，可以尝试调整索引顺序为 <code>(b, a)</code>。</li><li>这样，MySQL 可以先按 <code>b</code> 列排序，然后再按 <code>a</code> 列过滤。但这种方法可能不适用于所有场景，具体取决于查询条件。</li></ul><h3 id="方法-2：覆盖索引"><a href="#方法-2：覆盖索引" class="headerlink" title="方法 2：覆盖索引"></a>方法 2：覆盖索引</h3><ul><li>如果查询只需要 <code>a</code> 和 <code>b</code> 列，可以创建一个覆盖索引 <code>(a, b)</code>，并确保查询只选择 <code>a</code> 和 <code>b</code> 列。</li><li>这样，MySQL 可以直接从索引中获取数据，而不需要回表查询，从而提高性能。</li></ul><h3 id="方法-3：拆分查询"><a href="#方法-3：拆分查询" class="headerlink" title="方法 3：拆分查询"></a>方法 3：拆分查询</h3><ul><li>如果数据量较大，可以将查询拆分为两步：<ol><li>先根据 <code>a</code> 列的范围条件查询出主键。</li><li>再根据主键查询数据，并对 <code>b</code> 列进行排序。</li></ol></li></ul><h1 id="数据源头：任何客户端的东西都不可信任"><a href="#数据源头：任何客户端的东西都不可信任" class="headerlink" title="数据源头：任何客户端的东西都不可信任"></a>数据源头：任何客户端的东西都不可信任</h1><blockquote><p>问题 1：在讲述用户标识不能从客户端获取这个要点的时候，我提到开发同学可能会因为用户信息未打通而通过前端来传用户 ID。那我们有什么好办法，来打通不同的系统甚至不同网站的用户标识吗？</p></blockquote><p>答：打通用户在不同系统之间的登录，大致有以下三种方案。</p><p>第一种，把用户身份放在统一的服务端，每一个系统都需要到这个服务端来做登录状态的确认，确认后在自己网站的 Cookie 中保存会话，这就是单点登录的做法。这种方案要求所有关联系统都对接一套中央认证服务器（中央保存用户会话），在未登录的时候跳转到中央认证服务器进行登录或登录状态确认。因此，这种方案适合一个公司内部的不同域名下的网站。</p><p>第二种，把用户身份信息直接放在 Token 中，在客户端任意传递，Token 由服务端进行校验（如果共享密钥话，甚至不需要同一个服务端进行校验），无需采用中央认证服务器，相对比较松耦合，典型的标准是 JWT。这种方案适合异构系统的跨系统用户认证打通，而且相比单点登录的方案，用户体验会更好一些。</p><p>第三种，如果需要打通不同公司系统的用户登录状态，那么一般都会采用 OAuth 2.0 的标准中的授权码模式，基本流程如下：</p><ul><li><p>第三方网站客户端转到授权服务器，上送 ClientID、重定向地址 RedirectUri 等信息。</p></li><li><p>用户在授权服务器进行登录并且进行授权批准（授权批准这步可以配置为自动完成）。</p></li><li><p>授权完成后，重定向回到之前客户端提供的重定向地址，附上授权码。</p></li><li><p>第三方网站服务端通过授权码 +ClientID+ClientSecret 去授权服务器换取 Token。这里的 Token 包含访问 Token 和刷新 Token，访问 Token 过期后用刷新 Token 去获得新的访问 Token。</p><p>因为我们不会对外暴露 ClientSecret，也不会对外暴露访问 Token，同时使用授权码换取 Token 的过程是服务端进行的，客户端拿到的只是一次性的授权码，所以这种模式比较安全。</p></li></ul><blockquote><p>问题 2：还有一类和客户端数据相关的漏洞非常重要，那就是 URL 地址中的数据。在把匿名用户重定向到登录页面的时候，我们一般会带上 redirectUrl，这样用户登录后可以快速返回之前的页面。黑客可能会伪造一个活动链接，由真实的网站 + 钓鱼的 redirectUrl 构成，发邮件诱导用户进行登录。用户登录时访问的其实是真的网站，所以不容易察觉到 redirectUrl 是钓鱼网站，登录后却来到了钓鱼网站，用户可能会不知不觉就把重要信息泄露了。这种安全问题，我们叫做开放重定向问题。你觉得，从代码层面应该怎么预防开放重定向问题呢？</p></blockquote><p>答：要从代码层面预防开放重定向问题，有以下三种做法可供参考：</p><p>第一种，固定重定向的目标 URL。</p><p>第二种，可采用编号方式指定重定向的目标 URL，也就是重定向的目标 URL 只能是在我们的白名单内的。</p><p>第三种，用合理充分的校验方式来校验跳转的目标地址，如果是非己方地址，就告知用户跳转有风险，小心钓鱼网站的威胁。</p><h1 id="安全兜底：涉及钱时，必须考虑防刷、限量和防重"><a href="#安全兜底：涉及钱时，必须考虑防刷、限量和防重" class="headerlink" title="安全兜底：涉及钱时，必须考虑防刷、限量和防重"></a>安全兜底：涉及钱时，必须考虑防刷、限量和防重</h1><blockquote><p>问题 1：防重、防刷都是事前手段，如果我们的系统正在被攻击或利用，你有什么办法及时发现问题吗？</p></blockquote><p>答：对于及时发现系统正在被攻击或利用，监控是较好的手段，关键点在于报警阈值怎么设置。我觉得可以对比昨天同时、上周同时的量，发现差异达到一定百分比报警，而且报警需要有升级机制。此外，有的时候大盘很大的话，活动给整个大盘带来的变化不明显，如果进行整体监控可能出了问题也无法及时发现，因此可以考虑对于活动做独立的监控报警。</p><blockquote><p>问题 2：任何三方资源的使用一般都会定期对账，如果在对账中发现我们系统记录的调用量低于对方系统记录的使用量，你觉得一般是什么问题引起的呢？</p></blockquote><p>答：我之前遇到的情况是，在事务内调用外部接口，调用超时后本地事务回滚本地就没有留下数据。更合适的做法是：</p><p>请求发出之前先记录请求数据提交事务，记录状态为未知。</p><p>发布调用外部接口的请求，如果可以拿到明确的结果，则更新数据库中记录的状态为成功或失败。如果出现超时或未知异常，不能假设第三方接口调用失败，需要通过查询接口查询明确的结果。</p><p>写一个定时任务补偿数据库中所有未知状态的记录，从第三方接口同步结果。</p><p>值得注意的是，对账的时候一定要对两边，不管哪方数据缺失都可能是因为程序逻辑有 bug，需要重视。此外，任何涉及第三方系统的交互，都建议在数据库中保持明细的请求 &#x2F; 响应报文，方便在出问题的时候定位 Bug 根因。</p><blockquote><p>问题3：开放平台资源的使用需要考虑防刷，该怎么限制短信接口被盗刷？</p></blockquote><p>第一种方式，只有固定的请求头才能发送验证码。</p><p>也就是说，我们通过请求头中网页或 App 客户端传给服务端的一些额外参数，来判断请求是不是 App 发起的。其实，这种方式“防君子不防小人”。</p><p>比如，判断是否存在浏览器或手机型号、设备分辨率请求头。对于那些使用爬虫来抓取短信接口地址的程序来说，往往只能抓取到 URL，而难以分析出请求发送短信还需要的额外请求头，可以看作第一道基本防御。</p><p>第二种方式，只有先到过注册页面才能发送验证码。</p><p>对于普通用户来说，不管是通过 App 注册还是 H5 页面注册，一定是先进入注册页面才能看到发送验证码按钮，再点击发送。我们可以在页面或界面打开时请求固定的前置接口，为这个设备开启允许发送验证码的窗口，之后的请求发送验证码才是有效请求。</p><p>这种方式可以防御直接绕开固定流程，通过接口直接调用的发送验证码请求，并不会干扰普通用户。</p><p>第三种方式，控制相同手机号的发送次数和发送频次。</p><p>除非是短信无法收到，否则用户不太会请求了验证码后不完成注册流程，再重新请求。因此，我们可以限制同一手机号每天的最大请求次数。验证码的到达需要时间，太短的发送间隔没有意义，所以我们还可以控制发送的最短间隔。比如，我们可以控制相同手机号一天只能发送 10 次验证码，最短发送间隔 1 分钟。</p><p>第四种方式，增加前置图形验证码。</p><p>短信轰炸平台一般会收集很多免费短信接口，一个接口只会给一个用户发一次短信，所以控制相同手机号发送次数和间隔的方式不够有效。这时，我们可以考虑对用户体验稍微有影响，但也是最有效的方式作为保底，即将弹出图形验证码作为前置。</p><p>除了图形验证码，我们还可以使用其他更友好的人机验证手段（比如滑动、点击验证码等），甚至是引入比较新潮的无感知验证码方案（比如，通过判断用户输入手机号的打字节奏，来判断是用户还是机器），来改善用户体验。</p><p>此外，我们也可以考虑在监测到异常的情况下再弹出人机检测。比如，短时间内大量相同远端 IP 发送验证码的时候，才会触发人机检测。</p><p>总之，我们要确保，只有正常用户经过正常的流程才能使用开放平台资源，并且资源的用量在业务需求合理范围内。此外，还需要考虑做好短信发送量的实时监控，遇到发送量激增要及时报警。</p><blockquote><p>钱的进出一定要和订单挂钩并且实现幂等</p></blockquote><p>涉及钱的进出，需要做好以下两点。</p><p>第一，任何资金操作都需要在平台侧生成业务属性的订单，可以是优惠券发放订单，可以是返现订单，也可以是借款订单，一定是先有订单再去做资金操作。同时，订单的产生需要有业务属性。业务属性是指，订单不是凭空产生的，否则就没有控制的意义。比如，返现发放订单必须关联到原先的商品订单产生；再比如，借款订单必须关联到同一个借款合同产生。</p><p>第二，一定要做好防重，也就是实现幂等处理，并且幂等处理必须是全链路的。这里的全链路是指，从前到后都需要有相同的业务订单号来贯穿，实现最终的支付防重。</p><p>对于支付操作，我们一定是调用三方支付公司的接口或银行接口进行处理的。一般而言，这些接口都会有商户订单号的概念，对于相同的商户订单号，无法进行重复的资金处理，所以三方公司的接口可以实现唯一订单号的幂等处理。</p><p>但是，业务系统在实现资金操作时容易犯的错是，没有自始至终地使用一个订单号作为商户订单号，透传给三方支付接口。出现这个问题的原因是，比较大的互联网公司一般会把支付独立一个部门。支付部门可能会针对支付做聚合操作，内部会维护一个支付订单号，然后使用支付订单号和三方支付接口交互。最终虽然商品订单是一个，但支付订单是多个，相同的商品订单因为产生多个支付订单导致多次支付。</p><p>如果说，支付出现了重复扣款，我们可以给用户进行退款操作，但给用户付款的操作一旦出现重复付款，就很难把钱追回来了，所以更要小心。</p><p>这，就是全链路的意义，从一开始就需要先有业务订单产生，然后使用相同的业务订单号一直贯穿到最后的资金通路，才能真正避免重复资金操作。</p><h1 id="如何正确保存和传输敏感数据？"><a href="#如何正确保存和传输敏感数据？" class="headerlink" title="如何正确保存和传输敏感数据？"></a>如何正确保存和传输敏感数据？</h1><blockquote><p>问题 1：虽然我们把用户名和密码脱敏加密保存在数据库中，但日志中可能还存在明文的敏感数据。你有什么思路在框架或中间件层面，对日志进行脱敏吗？</p></blockquote><p>答：如果我们希望在日志的源头进行脱敏，那么可以在日志框架层面做。比如对于 logback 日志框架，我们可以自定义 MessageConverter，通过正则表达式匹配敏感信息脱敏。</p><p>需要注意的是，这种方式有两个缺点。</p><p>第一，正则表达式匹配敏感信息的格式不一定精确，会出现误杀漏杀的现象。一般来说，这个问题不会很严重。要实现精确脱敏的话，就只能提供各种脱敏工具类，然后让业务应用在日志中记录敏感信息的时候，先手动调用工具类进行脱敏。</p><p>第二，如果数据量比较大的话，脱敏操作可能会增加业务应用的 CPU 和内存使用，甚至会导致应用不堪负荷出现不可用。考虑到目前大部分公司都引入了 ELK 来集中收集日志，并且一般而言都不允许上服务器直接看文件日志，因此我们可以考虑在日志收集中间件中（比如 logstash）写过滤器进行脱敏。这样可以把脱敏的消耗转义到 ELK 体系中，不过这种方式同样有第一点提到的字段不精确匹配导致的漏杀误杀的缺点。</p><blockquote><p>问题 2：你知道 HTTPS 双向认证的目的是什么吗？流程上又有什么区别呢？</p></blockquote><p>答：单向认证一般用于 Web 网站，浏览器只需要验证服务端的身份。对于移动端 App，如果我们希望有更高的安全性，可以引入 HTTPS 双向认证，也就是除了客户端验证服务端身份之外，服务端也验证客户端的身份。</p><p>单向认证和双向认证的流程区别，主要包括以下三个方面。</p><p>第一，不仅仅服务端需要有 CA 证书，客户端也需要有 CA 证书。</p><p>第二，双向认证的流程中，客户端校验服务端 CA 证书之后，客户端会把自己的 CA 证书发给服务端，然后服务端需要校验客户端 CA 证书的真实性。</p><p>第三，客户端给服务端的消息会使用自己的私钥签名，服务端可以使用客户端 CA 证书中的公钥验签。</p><p>这里还想补充一点，对于移动应用程序考虑到更强的安全性，我们一般也会把服务端的公钥配置在客户端中，这种方式的叫做 SSL Pinning。也就是说由客户端直接校验服务端证书的合法性，而不是通过证书信任链来校验。采用 SSL Pinning，由于客户端绑定了服务端公钥，因此我们无法通过在移动设备上信用根证书实现抓包。不过这种方式的缺点是需要小心服务端 CA 证书过期后续证书注意不要修改公钥。</p><h1 id="缓存设计：缓存可以锦上添花也可以落井下石"><a href="#缓存设计：缓存可以锦上添花也可以落井下石" class="headerlink" title="缓存设计：缓存可以锦上添花也可以落井下石"></a>缓存设计：缓存可以锦上添花也可以落井下石</h1><blockquote><p>问题 1：在聊到缓存并发问题时，我们说到热点 Key 回源会对数据库产生的压力问题，如果 Key 特别热的话，可能缓存系统也无法承受，毕竟所有的访问都集中打到了一台缓存服务器。如果我们使用 Redis 来做缓存，那可以把一个热点 Key 的缓存查询压力，分散到多个 Redis 节点上吗？</p></blockquote><p>答：Redis 4.0 以上如果开启了 LFU 算法作为 maxmemory-policy，那么可以使用–hotkeys 配合 redis-cli 命令行工具来探查热点 Key。此外，我们还可以通过 MONITOR 命令来收集 Redis 执行的所有命令，然后配合redis-faina 工具来分析热点 Key、热点前缀等信息。</p><p>对于重要节假日、线上促销活动、集中推送这些提前已知的事情，可以提前评估出可能的热 key 来。而对于突发事件，无法提前评估，可以通过 Spark，对应流任务进行实时分析，及时发现新发布的热点 key。而对于之前已发出的事情，逐步发酵成为热 key 的，则可以通过 Hadoop 对批处理任务离线计算，找出最近历史数据中的高频热 key。</p><p>找到热 key 后，就有很多解决办法了。首先可以将这些热 key 进行分散处理，比如一个热 key 名字叫 hotkey，可以被分散为 hotkey#1、hotkey#2、hotkey#3，……hotkey#n，这 n 个 key 分散存在多个缓存节点，然后 client 端请求时，随机访问其中某个后缀的 hotkey，这样就可以把热 key 的请求打散，避免一个缓存节点过载。</p><p><img src="https://i0.hdslb.com/bfs/article/148b232811c1452b7be86393dd006511171301454.png" alt="image-20250208160154244"></p><p>其次，也可以 key 的名字不变，对缓存提前进行多副本+多级结合的缓存架构设计。</p><p>再次，如果热 key 较多，还可以通过监控体系对缓存的 SLA 实时监控，通过快速扩容来减少热 key 的冲击。</p><p>最后，业务端还可以使用本地缓存，将这些热 key 记录在本地缓存，来减少对远程缓存的冲击。</p><p>当然，除了分散 Redis 压力之外，我们也可以考虑再做一层短时间的本地缓存，结合 Redis 的 Keyspace 通知功能，当 Redis 集群压力超过阈值时，熔断降级直接返回本地缓存或默认值。</p><blockquote><p>问题 2：大 Key 也是数据缓存容易出现的一个问题。如果一个 Key 的 Value 特别大，那么可能会对 Redis 产生巨大的性能影响，因为 Redis 是单线程模型，对大 Key 进行查询或删除等操作，可能会引起 Redis 阻塞甚至是高可用切换。你知道怎么查询 Redis 中的大 Key，以及如何在设计上实现大 Key 的拆分吗？</p></blockquote><p>答：Redis 的大 Key 可能会导致集群内存分布不均问题，并且大 Key 的操作可能也会产生阻塞。</p><p>关于查询 Redis 中的大 Key，我们可以使用 <code>redis-cli –bigkeys</code> 命令来实时探查大 Key。此外，我们还可以使用 redis-rdb-tools 工具来分析 Redis 的 RDB 快照，得到包含 Key 的字节数、元素个数、最大元素长度等信息的 CSV 文件。然后，我们可以把这个 CSV 文件导入 MySQL 中，写 SQL 去分析。</p><p>针对大 Key，我们可以考虑几方面的优化：</p><p>第一，是否有必要在 Redis 保存这么多数据。一般情况下，我们在缓存系统中保存面向呈现的数据，而不是原始数据；对于原始数据的计算，我们可以考虑其它文档型或搜索型的 NoSQL 数据库。</p><p>第二，考虑把具有二级结构的 Key（比如 List、Set、Hash）拆分成多个小 Key，来独立获取（或是用 MGET 获取）。将大 key 分拆为多个 key，尽量减少大 key 的存在。同时由于大 key 一旦穿透到 DB，加载耗时很大，所以可以对这些大 key 进行特殊照顾，比如设置较长的过期时间，比如缓存内部在淘汰 key 时，同等条件下，尽量不淘汰这些大 key。</p><p>第三，可以扩展新的数据结构，同时让 client 在这些大 key 写缓存之前，进行序列化构建，然后通过 restore 一次性写入。</p><p>此外值得一提的是，大 Key 的删除操作可能会产生较大性能问题。从 Redis 4.0 开始，我们可以使用 UNLINK 命令而不是 DEL 命令在后台删除大 Key；而对于 4.0 之前的版本，我们可以考虑使用游标删除大 Key 中的数据，而不是直接使用 DEL 命令，比如对于 Hash 使用 HSCAN+HDEL 结合管道功能来删除。</p><h1 id="异步处理好用，但非常容易用错"><a href="#异步处理好用，但非常容易用错" class="headerlink" title="异步处理好用，但非常容易用错"></a>异步处理好用，但非常容易用错</h1><blockquote><p>在用户注册后发送消息到 MQ，然后会员服务监听消息进行异步处理的场景下，有些时候我们会发现，虽然用户服务先保存数据再发送 MQ，但会员服务收到消息后去查询数据库，却发现数据库中还没有新用户的信息。你觉得，这可能是什么问题呢，又该如何解决呢？</p></blockquote><p>答：我先来分享下，我遇到这个问题的真实情况。</p><p>当时，我们是因为业务代码把保存数据和发 MQ 消息放在了一个事务中，收到消息的时候有可能事务还没有提交完成。为了解决这个问题，开发同学当时的处理方式是，收 MQ 消息的时候 Sleep 1 秒再去处理。这样虽然解决了问题，但却大大降低了消息处理的吞吐量。</p><p>更好的做法是先提交事务，完成后再发 MQ 消息。但是，这又引申出来一个问题：MQ 消息发送失败怎么办，如何确保发送消息和本地事务有整体事务性？</p><h2 id="方案-1：本地消息表（Local-Message-Table）"><a href="#方案-1：本地消息表（Local-Message-Table）" class="headerlink" title="方案 1：本地消息表（Local Message Table）"></a>方案 1：<strong>本地消息表（Local Message Table）</strong></h2><p>这是一种经典的分布式事务解决方案，核心思想是通过本地事务保证消息的可靠性。</p><p><strong>实现步骤：</strong></p><ol><li>在用户服务的数据库中创建一个本地消息表，用于存储待发送的 MQ 消息。</li><li>用户服务在保存用户数据的同时，将 MQ 消息写入本地消息表（同一个事务）。</li><li>事务提交后，通过一个后台任务（或定时任务）从本地消息表中读取消息，并发送到 MQ。</li><li>消息发送成功后，删除本地消息表中的记录。</li></ol><p><strong>优点：</strong></p><ul><li>保证了本地事务和消息发送的一致性。</li><li>即使消息发送失败，也可以通过后台任务重试。</li></ul><p><strong>缺点：</strong></p><ul><li>需要维护一个本地消息表，增加了数据库的复杂性。</li><li>需要实现后台任务来发送消息。</li></ul><h2 id="方案-2：事务消息（Transactional-Outbox）"><a href="#方案-2：事务消息（Transactional-Outbox）" class="headerlink" title="方案 2：事务消息（Transactional Outbox）"></a>方案 2：<strong>事务消息（Transactional Outbox）</strong></h2><p>这是一种基于消息队列的事务性解决方案，适用于支持事务消息的 MQ（如 RocketMQ、Kafka）。</p><p><strong>实现步骤：</strong></p><ol><li>用户服务在保存用户数据的同时，将 MQ 消息写入本地消息表（同一个事务）。</li><li>使用 MQ 的事务消息功能，将消息发送到 MQ。</li><li>如果消息发送成功，MQ 会通知用户服务删除本地消息表中的记录。</li><li>如果消息发送失败，MQ 会触发重试机制。</li></ol><p><strong>优点：</strong></p><ul><li>消息发送和本地事务具有强一致性。</li><li>不需要额外的后台任务。</li></ul><p><strong>缺点：</strong></p><ul><li>依赖 MQ 的事务消息功能，不是所有 MQ 都支持。</li><li>实现复杂度较高。</li></ul><h2 id="方案-3：消息队列的最终一致性"><a href="#方案-3：消息队列的最终一致性" class="headerlink" title="方案 3：消息队列的最终一致性"></a>方案 3：<strong>消息队列的最终一致性</strong></h2><p>这是一种基于消息队列的最终一致性解决方案，适用于对一致性要求不是特别高的场景。</p><p><strong>实现步骤：</strong></p><ol><li>用户服务在保存用户数据后，发送 MQ 消息。</li><li>如果消息发送失败，用户服务会记录日志，并通过定时任务重试发送消息。</li><li>会员服务监听到消息后，处理新用户的信息。如果查询不到新用户的信息，可以等待一段时间后重试。</li></ol><p><strong>优点：</strong></p><ul><li>实现简单，适用于大多数场景。</li><li>不需要依赖复杂的分布式事务机制。</li></ul><p><strong>缺点：</strong></p><ul><li>无法保证强一致性，只能保证最终一致性。</li><li>需要处理消息重复消费的问题（幂等性）。</li></ul><h2 id="方案-4：分布式事务框架（如-Seata）"><a href="#方案-4：分布式事务框架（如-Seata）" class="headerlink" title="方案 4：分布式事务框架（如 Seata）"></a>方案 4：<strong>分布式事务框架（如 Seata）</strong></h2><p>如果业务对一致性要求非常高，可以使用分布式事务框架（如 Seata）来保证本地事务和消息发送的一致性。</p><p><strong>实现步骤：</strong></p><ol><li>用户服务在保存用户数据后，发送 MQ 消息。</li><li>Seata 会协调用户服务和 MQ 的事务，确保两者同时提交或回滚。</li></ol><p><strong>优点：</strong></p><ul><li>保证了强一致性。</li><li>适用于复杂的分布式事务场景。</li></ul><p><strong>缺点：</strong></p><ul><li>实现复杂度高，性能开销较大。</li><li>需要引入额外的分布式事务框架。</li></ul><h2 id="推荐方案"><a href="#推荐方案" class="headerlink" title="推荐方案"></a>推荐方案</h2><p>根据你的场景和需求，推荐以下方案：</p><ol><li><strong>如果对一致性要求较高</strong>，可以选择 <strong>本地消息表</strong> 或 <strong>事务消息</strong>。</li><li><strong>如果对一致性要求较低</strong>，可以选择 <strong>消息队列的最终一致性</strong>，并通过重试机制和幂等性来保证数据的正确性。</li></ol><h1 id="数据服务系统架构"><a href="#数据服务系统架构" class="headerlink" title="数据服务系统架构"></a>数据服务系统架构</h1><p>我们设计了一个包含多个数据库系统的、能应对各种高并发场景的一套数据服务的系统架构，其中包含了同步写服务、异步写服务和查询服务三部分，分别实现主数据库写入、辅助数据库写入和查询路由。</p><p>我们按照服务来依次分析下这个架构。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/b0001fb75ba9d4897dd4e4b5fc07356f2c555d23.png" alt="image-20250716115523752"></p><p>首先要明确的是，重要的业务主数据只能保存在 MySQL 这样的关系型数据库中，原因有三点：</p><ul><li><p>RDBMS 经过了几十年的验证，已经非常成熟；</p></li><li><p>RDBMS 的用户数量众多，Bug 修复快、版本稳定、可靠性很高；</p></li><li><p>RDBMS 强调 ACID，能确保数据完整。</p></li></ul><p>有两种类型的查询任务可以交给 MySQL 来做，性能会比较好，这也是 MySQL 擅长的地方：</p><ul><li><p>按照主键 ID 的查询。直接查询聚簇索引，其性能会很高。但是单表数据量超过亿级后，性能也会衰退，而且单个数据库无法承受超大的查询并发，因此我们可以把数据表进行 Sharding 操作，均匀拆分到多个数据库实例中保存。我们把这套数据库集群称作 Sharding 集群。</p></li><li><p>按照各种条件进行范围查询，查出主键 ID。对二级索引进行查询得到主键，只需要查询一棵 B+ 树，效率同样很高。但索引的值不宜过大，比如对 varchar(1000) 进行索引不太合适，而索引外键（一般是 int 或 bigint 类型）性能就会比较好。因此，我们可以在 MySQL 中建立一张“索引表”，除了保存主键外，主要是保存各种关联表的外键，以及尽可能少的 varchar 类型的字段。这张索引表的大部分列都可以建上二级索引，用于进行简单搜索，搜索的结果是主键的列表，而不是完整的数据。由于索引表字段轻量并且数量不多（一般控制在 10 个以内），所以即便索引表没有进行 Sharding 拆分，问题也不会很大。</p></li></ul><p>如图上蓝色线所示，写入两种 MySQL 数据表和发送 MQ 消息的这三步，我们用一个同步写服务完成了。我在“异步处理”中提到，所有异步流程都需要补偿，这里的异步流程同样需要。只不过为了简洁，我在这里省略了补偿流程。</p><p>然后，如图中绿色线所示，有一个异步写服务，监听 MQ 的消息，继续完成辅助数据的更新操作。这里我们选用了 ES 和 InfluxDB 这两种辅助数据库，因此整个异步写数据操作有三步：</p><p>MQ 消息不一定包含完整的数据，甚至可能只包含一个最新数据的主键 ID，我们需要根据 ID 从查询服务查询到完整的数据。</p><p>写入 InfluxDB 的数据一般可以按时间间隔进行简单聚合，定时写入 InfluxDB。因此，这里会进行简单的客户端聚合，然后写入 InfluxDB。</p><p>ES 不适合在各索引之间做连接（Join）操作，适合保存扁平化的数据。比如，我们可以把订单下的用户、商户、商品列表等信息，作为内嵌对象嵌入整个订单 JSON，然后把整个扁平化的 JSON 直接存入 ES。</p><p>对于数据写入操作，我们认为操作返回的时候同步数据一定是写入成功的，但是由于各种原因，异步数据写入无法确保立即成功，会有一定延迟，比如：</p><ul><li><p>异步消息丢失的情况，需要补偿处理；</p></li><li><p>写入 ES 的索引操作本身就会比较慢；</p></li><li><p>写入 InfluxDB 的数据需要客户端定时聚合。</p></li></ul><p>因此，对于查询服务，如图中红色线所示，我们需要根据一定的上下文条件（比如查询一致性要求、时效性要求、搜索的条件、需要返回的数据字段、搜索时间区间等）来把请求路由到合适的数据库，并且做一些聚合处理：</p><p>需要根据主键查询单条数据，可以从 MySQL Sharding 集群或 Redis 查询，如果对实时性要求不高也可以从 ES 查询。</p><p>按照多个条件搜索订单的场景，可以从 MySQL 索引表查询出主键列表，然后再根据主键从 MySQL Sharding 集群或 Redis 获取数据详情。</p><p>各种后台系统需要使用比较复杂的搜索条件，甚至全文搜索来查询订单数据，或是定时分析任务需要一次查询大量数据，这些场景对数据实时性要求都不高，可以到 ES 进行搜索。此外，MySQL 中的数据可以归档，我们可以在 ES 中保留更久的数据，而且查询历史数据一般并发不会很大，可以统一路由到 ES 查询。</p><p>监控系统或后台报表系统需要呈现业务监控图表或表格，可以把请求路由到 InfluxDB 查询。</p>]]></content>
      
      
      <categories>
          
          <category> 场景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java程序从虚拟机迁移到Kubernetes的一些坑</title>
      <link href="/2025/02/07/Java%E7%A8%8B%E5%BA%8F%E4%BB%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%81%E7%A7%BB%E5%88%B0Kubernetes%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
      <url>/2025/02/07/Java%E7%A8%8B%E5%BA%8F%E4%BB%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%81%E7%A7%BB%E5%88%B0Kubernetes%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>在大多数的公司中，Kubernetes 集群由运维来搭建，而程序的发布一般也是由 CI&#x2F;CD 平台完成。从虚拟机到 Kubernetes 的整个迁移过程，基本不需要修改任何代码，可能只是重新发布一次而已。所以，我们 Java 开发人员可能对迁移这个事情本身感知不强烈，认为 Kubernetes 只是运维需要知道的事情。但是程序一旦部署到了 Kubernetes 集群中，在容器环境中运行，总是会出现各种各样之前没有的奇怪的问题。</p><h2 id="Pod-IP-不固定带来的坑"><a href="#Pod-IP-不固定带来的坑" class="headerlink" title="Pod IP 不固定带来的坑"></a>Pod IP 不固定带来的坑</h2><p>Pod 是 Kubernetes 中能够创建和部署应用的最小单元，我们可以通过 Pod IP 来访问到某一个应用实例，但需要注意的是，如果没有经过特殊配置，Pod IP 并不是固定不变的，会在 Pod 重启后会发生变化。</p><p>不过好在，通常我们的 Java 微服务都是没有状态的，我们并不需要通过 Pod IP 来访问到某一个特定的 Java 服务实例。通常来说，要访问到部署在 Kubernetes 中的微服务集群，有两种服务发现和访问的方式：</p><p>通过 Kubernetes 来实现。也就是通过 Service 进行内部服务的互访，通过 Ingress 从外部访问到服务集群。</p><p>通过微服务注册中心（比如 Eureka）来实现。也就是服务之间的互访通过客户端负载均衡后 + 直接访问 Pod IP 进行，外部访问到服务集群通过微服务网关转发请求。</p><p>使用这两种方式进行微服务的访问，我们都没有和 Pod IP 直接打交道，也不会把 Pod IP 记录持久化，所以一般不需要太关注 Pod IP 变动的问题。不过，在一些场景下，Pod IP 的变动会造成一些问题。</p><p>之前我就遇到过这样的情况：某任务调度中间件会记录被调度节点的 IP 到数据库，随后通过访问节点 IP 查看任务节点执行日志的时候，如果节点部署在 Kubernetes 中，那么节点重启后 Pod IP 就会变动。这样，之前记录在数据库中的老节点的 Pod IP 必然访问不到，那么就会发生无法查看任务日志的情况。</p><p>遇到这种情况，我们应该怎么做呢？这时候，可能就需要修改这个中间件，把任务执行日志也进行持久化，从而避免这种访问任务节点来查看日志的行为。</p><p>总之，我们需要意识到 Pod IP 不固定的问题，并且进行“避坑操作”：在迁移到 Kubernetes 集群之前，摸排一下是否会存在需要通过 IP 访问到老节点的情况，如果有的话需要进行改造。</p><h2 id="程序因为-OOM-被杀进程的坑"><a href="#程序因为-OOM-被杀进程的坑" class="headerlink" title="程序因为 OOM 被杀进程的坑"></a>程序因为 OOM 被杀进程的坑</h2><p>在 Kubernetes 集群中部署程序的时候，我们通常会为容器设置一定的内存限制（limit），容器不可以使用超出其资源 limit 属性所设置的资源量。如果容器内的 Java 程序使用了大量内存，可能会出现各种 OOM 的情况。</p><p>第一种情况，是 OS OOM Kill 问题。如果过量内存导致操作系统 Kernel 不稳定，操作系统可能就会杀死 Java 进程。这时候，你能在操作系统 &#x2F;var&#x2F;log&#x2F;messages 日志中找到类似 oom_kill_process 的关键字。</p><p>第二种情况，是我们最常遇到的 Java 程序的 OOM 问题。程序超出堆内存的限制申请内存，导致 Heap OOM，后续可能会因为健康检测没有通过被 Kubernetes 重启 Pod。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e4%b8%9a%e5%8a%a1%e5%bc%80%e5%8f%91%e5%b8%b8%e8%a7%81%e9%94%99%e8%af%af%20100%20%e4%be%8b/assets/2cf6d48915a0bce6834cf46edb462c04.png" alt="img"></p><p>在 Kubernetes 中部署 Java 程序时，这两种情况都很常见，表现出的症状也都是 OOM 关键字 + 重启。所以，当运维同学说程序因为 OOM 被杀死或重启的时候，我们一定要和运维同学一起去区分清楚，到底是哪一种情况，然后再对症处理。</p><p>对于情况 1，问题的原因往往不是 Java 堆内存不够，更可能是程序使用了太多的堆外内存，超过了内存限制。这个时候，调大 JVM 最大堆内存只会让问题更严重，因为堆内存是可以通过 GC 回收的。我们需要分析 Java 进程哪部分区域内存占用过大，是不是合理，以及是否可能存在内存泄露问题。Java 进程的内存占用除了堆之外，还包括</p><p>直接内存</p><p>元数据区</p><p>线程栈大小 Xss * 线程数</p><p>JIT 代码缓存</p><p>GC、编译器使用额外空间</p><p>……</p><p>我们可以使用 NMT 打印各部分区域大小，从而判断到底是哪部分内存区域占用了过多内存，或是可能有内存泄露问题：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -<span class="variable constant_">XX</span><span class="symbol">:NativeMemoryTracking=smmary/detail</span> -<span class="variable constant_">XX</span><span class="symbol">:+UnlockDiagnosticVMOptions</span> -<span class="variable constant_">XX</span><span class="symbol">:+PrintNMTStatistics</span></span><br></pre></td></tr></table></figure><p>如果你确认 OOM 是情况 2，那么我同样不建议直接调大堆内存的限制，防止之后再出现情况 1。我会更建议你把堆内存限制为容器内存限制的 50%~70%，预留出足够多的内存给堆外和 OS 核心。如果需要扩容堆内存的话，那么也需要同步扩容容器的内存 limit。此外，也需要通过 Heap Dump 等手段来排查为什么堆内存占用会这么大，排除潜在的内存泄露的可能性。</p><h2 id="内存和-CPU-资源配置不适配容器的坑"><a href="#内存和-CPU-资源配置不适配容器的坑" class="headerlink" title="内存和 CPU 资源配置不适配容器的坑"></a>内存和 CPU 资源配置不适配容器的坑</h2><p>刚刚我们提到了，堆内存扩容需要结合容器内存 limit 同步进行。其实，我们更希望的是，Java 程序的堆内存配置能随着容器的资源配置，实现自动扩容或缩容，而不是写死 Xmx 和 Xms。这样一来，运维同学可以更方便地针对整个集群进行扩容或缩容。</p><p>对于 JDK&gt;8u191 的版本，我们可以设置下面这些 JVM 参数，来让 JVM 自动根据容器内存限制来设置堆内存用量。比如，下面配置相当于把 Xmx 和 Xms 都设置为了容器内存 limit 的 50%：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">XX</span><span class="symbol">:MaxRAMPercentage=</span><span class="number">50.0</span> -<span class="variable constant_">XX</span><span class="symbol">:InitialRAMPercentage=</span><span class="number">50.0</span> -<span class="variable constant_">XX</span><span class="symbol">:MinRAMPercentage=</span><span class="number">50.0</span></span><br></pre></td></tr></table></figure><p>接下来，我们看看 CPU 资源配置不适配容器的坑，以及对应的解决方案。</p><p>对于 CPU 资源的使用，我们主要需要注意的是，代码中的各种组件甚至是 JVM 本身，会根据 CPU 数来配置并发数等重要参数指标，那么：</p><p>如果这个值因为 JVM 对容器的兼容性问题取到了 Kubernetes 工作节点的 CPU 数量，那么这个数量可能就不是 4 或 8，而是 128 以上，进而导致并发数过高。</p><p>对于 JDK&gt;8u191 的版本可能会对容器兼容性较好，但是其获取到的 Runtime.getRuntime().availableProcessors() 其实是 request 的值而不是 limit 的值（比如我们设置 request 为 2、limit 为 8、CICompilerCount 和 ParallelGCThreads 可能只是 2），那么可能并发数就会过低，进而影响 JVM 的 GC 或编译性能。</p><p>所以，我的建议是：</p><p>第一，通过 -XX:+PrintFlagsFinal 开关，来确认 ActiveProcessorCount 是不是符合我们的期望，并且确认 CICompilerCount、ParallelGCThreads 等重要参数配置是否合理。</p><p>第二，直接设置 CPU 的 request 和 limit 一致，或是对于 JDK&gt;8u191 的版本可以通过 -XX:ActiveProcessorCount&#x3D;xxx 直接把 ActiveProcessorCount 设置为容器的 CPU limit。</p><h2 id="Pod-重启以及重启后没有现场的坑"><a href="#Pod-重启以及重启后没有现场的坑" class="headerlink" title="Pod 重启以及重启后没有现场的坑"></a>Pod 重启以及重启后没有现场的坑</h2><p>除非宿主机有问题，否则虚拟机不太会自己重启或被重启，而 Kubernetes 中 Pod 的重启绝非小概率事件。在存活检测不通过、Pod 重新进行节点调度等情况下，Pod 都会进行重启。对于 Pod 的重启，我们需要关注两个问题。</p><p>第一个问题是，分析 Pod 为什么会重启。</p><p>其中，除了“程序因为 OOM 被杀进程的坑”这部分提到的 OOM 的问题之外，我们还需要关注存活检查不通过的情况。</p><p>Kubernetes 有 readinessProbe 和 livenessProbe 两个探针，前者用于检查应用是否已经启动完成，后者用于持续探活。一般而言，运维同学会配置这 2 个探针为一个健康检测的断点，如果健康检测访问一次需要消耗比较长的时间（比如涉及到存储或外部服务可用性检测），那么很可能可以通过 readinessProbe 的检查但不通过 livenessProbe 检查（毕竟我们通常会为 readinessProbe 设置比较长的超时时间，而对于 livenessProbe 则没有那么宽容）。此外，健康检测也可能会受到 Full GC 的干扰导致超时。所以，我们需要和运维同学一起确认 livenessProbe 的配置地址和超时时间设置是否合理，防止偶发的 livenessProbe 探活失败导致的 Pod 重启。</p><p>第二个问题是，要理解 Pod 和虚拟机不同。</p><p>虚拟机一般都是有状态的，即便部署在虚拟机内的 Java 程序重启了，我们始终能有现场。而对于 Pod 重启来说，则是新建一个 Pod，这就意味着老的 Pod 无法进入。因此，如果因为堆 OOM 问题导致重启，我们希望事后查看当时 OS 的一些日志或是在现场执行一些命令来分析问题，就不太可能了。</p><p>所以，我们需要想办法在 Pod 关闭之前尽可能保留现场，比如：</p><p>对于程序的应用日志、标准输出、GC 日志等可以直接挂载到持久卷，不要保存在容器内部。</p><p>对于程序的堆栈现场保留，可以配置 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath 在堆 OOM 的时候生成 Dump；还可以让 JVM 调用任一个 shell 脚本，通过脚本来保留线程栈等信息：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:OnOutOfMemoryError=saveinfo</span>.sh</span><br></pre></td></tr></table></figure><p>对于容器的现场保留，可以让运维配置 preStop 钩子，在 Pod 关闭之前把必要的信息上传到持久卷或云上。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>今天，我们探讨了 Java 应用部署到 Kubernetes 集群会遇到的 4 类问题。</p><p>第一类问题是，我们需要理解应用的 IP 会动态变化，因此要在设计上解除对 Pod IP 的强依赖，使用依赖服务发现来定位到应用。</p><p>第二类问题是，在出现 OOM 问题的时候，首先要区分 OOM 的原因来自 Java 进程层面还是容器层面。如果是容器层面的话，我们还需要进一步分析到底是哪个内存区域占用了过多内存，定位到问题后再根据容器资源设置合理的 JVM 参数或进行资源扩容。</p><p>第三类问题是，需要确保程序使用的内存和 CPU 资源匹配容器的资源限制，既要确保程序所“看”到的主机资源信息是容器本身的而不是物理机的，又要确保程序能尽可能随着容器扩容而扩容其资源限制。</p><p>第四类问题是，我们需要重点关注程序非发布期重启的问题，并且针对 Pod 的重启问题做好现场保留的准备工作，排除资源配置不合理、存活检查不通过等可能性，以避免因为程序频繁重启导致的偶发性能问题或可用性问题。</p><p>只有解决了这些隐患，才能让 Kubernetes 集群更好地发挥作用。</p>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漫谈RocketMQ消息发送</title>
      <link href="/2025/01/26/%E6%BC%AB%E8%B0%88RocketMQ%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/"/>
      <url>/2025/01/26/%E6%BC%AB%E8%B0%88RocketMQ%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="topic路由机制"><a href="#topic路由机制" class="headerlink" title="topic路由机制"></a>topic路由机制</h1><p>消息发送者向某一个topic发送消息时，需要查询topic的路由信息。初次发送时会根据topic的名称向NameServer集群查询topic的路由信息，然后将其缓存在本地内存中，并且每隔30s依次遍历缓存中的topic，向NameServer查询最新的路由信息。如果成功查询到路由信息，会将这些信息更新到本地缓存，实现topic路由信息的动态感知。</p><p>RocketMQ提供了自动创建主题的机制，消息发送者向一个不存在的主题发送消息时，向NameServer查询该主题的路由信息会先返回空，如果开启了自动创建主题机制，会使用一个默认的主题名再次从NameServer查询路由信息，然后消息发送者会使用默认主题的路由信息进行负载均衡，但不会直接使用默认路由信息为新主题创建对应的路由信息。</p><p><img src="https://i0.hdslb.com/bfs/article/7c203d765aa13dc7d121605b562f93e5171301454.png" alt="image-20250126182926724"></p><h2 id="生产环境中，为何不建议自动创建topic"><a href="#生产环境中，为何不建议自动创建topic" class="headerlink" title="生产环境中，为何不建议自动创建topic"></a>生产环境中，为何不建议自动创建topic</h2><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>因为生产环境一般是集群部署多台broker服务器，autoCreateTopicEnable设置为true，表示开启topic自动创建，但新创建的topic的路由信息只包含在其中一台broker服务器上。</p><p>期望回答：为了消息发送的高可用，希望新创建的topic在集群中的每台broker上创建对应的队列，避免broker的单节点故障。</p><p>在RocketMQ中，如果autoCreateTopicEnable设置为true，消息发送者向NameServer查询主题的路由消息返回空时，会尝试用一个系统默认的主题名称(MixAll.AUTO_CREATE_TOPIC_KEY_TOPIC)，此时消息发送者得到的路由信息为：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFv937FNO2g61wLud0L59P0dS9WndkJ2k15kWPEIyO9TA2hDEpfrf7micsVLukSFptGK84pqicjbs6Og/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>默认Topic在集群的每一台Broker上创建8个队列，那问题来了，为啥新创建的Topic只在一个Broker上创建4个队列呢？</p><p>Step1：在Broker启动流程中，会构建TopicConfigManager对象，其构造方法中首先会判断是否开启了允许自动创建主题，如果启用了自动创建主题，则向topicConfigTable中添加默认主题的路由信息。</p><p>BrokerConfig的defaultTopicQueueNum默认为8。两台Broker服务器都会运行上面的过程，故最终Nameserver中关于默认主题的路由信息中，会包含两个Broker分别各8个队列信息。</p><p>Step2：生产者寻找路由信息<br>生产者首先向NameServer查询路由信息，由于是一个不存在的主题，故此时返回的路由信息为空，RocketMQ会使用默认的主题再次寻找，由于开启了自动创建路由信息，NameServer会向生产者返回默认主题的路由信息。然后从返回的路由信息中选择一个队列（默认轮询）。消息发送者从Nameserver获取到默认的Topic的队列信息后，队列的个数会改变吗？答案是会的。</p><p>消息发送者在到默认路由信息时，其队列数量，会选择DefaultMQProducer#defaultTopicQueueNums与Nameserver返回的的队列数取最小值，<strong>DefaultMQProducer#defaultTopicQueueNums默认值为4，故自动创建的主题，其队列数量默认为4。</strong></p><p>Step3：发送消息</p><p>在消息发送时的请求报文中，设置默认topic名称，消息发送topic名称，使用的队列数量为DefaultMQProducer#defaultTopicQueueNums，即默认为4。</p><p>Step4：Broker端收到消息后的处理流程</p><p>在Broker端，首先会使用TopicConfigManager根据topic查询路由信息，如果Broker端不存在该主题的路由配置(路由信息),且Broker中存在默认主题的路由配置信息，则根据消息发送请求中的队列数量，在Broker创建新Topic的路由信息。这样Broker服务端就会存在主题的路由信息。</p><p>在Broker端的topic配置管理器中存在的路由信息，一会向Nameserver发送心跳包，汇报到Nameserver，另一方面会有一个定时任务，定时存储在broker端，具体路径为${ROCKET_HOME}&#x2F;store&#x2F;config&#x2F;topics.json中，这样在Broker关闭后再重启，并不会丢失路由信息。</p><h3 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h3><p>经过上面自动创建路由机制的创建流程，我们可以比较容易的分析得出如下结论：</p><p>因为开启了自动创建路由信息，消息发送者根据Topic去NameServer无法得到路由信息，但接下来根据默认Topic从NameServer是能拿到路由信息(在每个Broker中，存在8个队列)，因为两个Broker在启动时都会向NameServer汇报路由信息。此时消息发送者缓存的路由信息是2个Broker，每个Broker默认4个队列</p><p>消息发送者然后按照轮询机制，发送第一条消息选择(broker-a的messageQueue:0)，向Broker发送消息，Broker服务器在处理消息时，首先会查看自己的路由配置管理器(TopicConfigManager)中的路由信息，此时不存在对应的路由信息，然后尝试查询是否存在默认Topic的路由信息，如果存在，说明启用了autoCreateTopicEnable，则在TopicConfigManager中创建新Topic的路由信息，此时存在与Broker服务端的内存中，然后本次消息发送结束。此时，在NameServer中还不存在新创建的Topic的路由信息。</p><p>这里有三个关键点：</p><ol><li>启用autoCreateTopicEnable创建主题时，在Broker端创建主题的时机为，消息生产者往Broker端发送消息时才会创建。</li><li>然后Broker端会在一个心跳包周期内，将新创建的路由信息发送到NameServer，于此同时，Broker端还会有一个定时任务，定时将内存中的路由信息，持久化到Broker端的磁盘上。</li><li>消息发送者会每隔30s向NameServer更新路由信息，如果消息发送端一段时间内未发送消息，就不会有消息发送集群内的第二台Broker，那么NameServer中新创建的Topic的路由信息只会包含Broker-a，然后消息发送者会向NameServer拉取最新的路由信息，此时就会消息发送者原本缓存了2个broker的路由信息，将会变为一个Broker的路由信息，则该Topic的消息永远不会发送到另外一个Broker，就出现了上述现象。</li></ol><p>原因就分析到这里了，现在我们还可以的大胆假设，开启autoCreateTopicEnable机制，什么情况会在两个Broker上都创建队列，其实，我们只需要连续快速的发送9条消息，就有可能在2个Broker上都创建队列，验证代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 1public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException &#123;</span><br><span class="line"> <span class="number">2</span>    <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line"> <span class="number">3</span>    producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line"> <span class="number">4</span>    producer.start();</span><br><span class="line"> <span class="number">5</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line"> <span class="number">6</span>        <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="number">7</span>            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest10&quot;</span> ,<span class="string">&quot;TagA&quot;</span> , (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"> <span class="number">8</span>            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line"> <span class="number">9</span>            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line"><span class="number">10</span>        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="number">11</span>            e.printStackTrace();</span><br><span class="line"><span class="number">12</span>            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="number">13</span>        &#125;</span><br><span class="line"><span class="number">14</span>    &#125;</span><br><span class="line"><span class="number">15</span>    producer.shutdown();</span><br><span class="line"><span class="number">16</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全小妙招</title>
      <link href="/2025/01/26/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%B0%8F%E5%A6%99%E6%8B%9B/"/>
      <url>/2025/01/26/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%B0%8F%E5%A6%99%E6%8B%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="TreadLocal的正确打开方式"><a href="#TreadLocal的正确打开方式" class="headerlink" title="TreadLocal的正确打开方式"></a>TreadLocal的正确打开方式</h1><p>我们知道，ThreadLocal 适用于变量在线程间隔离，而在方法或类间共享的场景。如果用户信息的获取比较昂贵（比如从数据库查询用户信息），那么在 ThreadLocal 中缓存数据是比较合适的做法。</p><p>但是如果错误地使用了ThreadLocal，可能会导致有时获取到的用户信息是别人的。为什么会出现用户信息错乱的 Bug 呢？</p><p>我们来复现一下这个场景。</p><p>使用 Spring Boot 创建一个 Web 应用程序，使用 ThreadLocal 存放一个 Integer 的值，来暂且代表需要在线程中保存的用户信息，这个值初始是 null。在业务逻辑中，我先从 ThreadLocal 获取一次值，然后把外部传入的参数设置到 ThreadLocal 中，来模拟从当前上下文获取到用户信息的逻辑，随后再获取一次值，最后输出两次获得的值和线程名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentUser = ThreadLocal.withInitial(() -&gt; <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;wrong&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map <span class="title function_">wrong</span><span class="params">(<span class="meta">@RequestParam(&quot;userId&quot;)</span> Integer userId)</span> &#123;</span><br><span class="line">    <span class="comment">//设置用户信息之前先查询一次ThreadLocal中的用户信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">before</span>  <span class="operator">=</span> Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + currentUser.get();</span><br><span class="line">    <span class="comment">//设置用户信息到ThreadLocal</span></span><br><span class="line">    currentUser.set(userId);</span><br><span class="line">    <span class="comment">//设置用户信息之后再查询一次ThreadLocal中的用户信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">after</span>  <span class="operator">=</span> Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + currentUser.get();</span><br><span class="line">    <span class="comment">//汇总输出两次查询结果</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    result.put(<span class="string">&quot;before&quot;</span>, before);</span><br><span class="line">    result.put(<span class="string">&quot;after&quot;</span>, after);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按理说，在设置用户信息之前第一次获取的值始终应该是 null，但我们要意识到，程序运行在 Tomcat 中，执行程序的线程是 Tomcat 的工作线程，而 Tomcat 的工作线程是基于线程池的。</p><p><strong>顾名思义，线程池会重用固定的几个线程，一旦线程重用，那么很可能首次从 ThreadLocal 获取的值是之前其他用户的请求遗留的值。这时，ThreadLocal 中的用户信息就是其他用户的信息。</strong></p><p>为了更快地重现这个问题，我在配置文件中设置一下 Tomcat 的参数，把工作线程池最大线程数设置为 1，这样始终是同一个线程在处理请求：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.tomcat.max-threads</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure><p>运行程序后先让用户 1 来请求接口，可以看到第一和第二次获取到用户 ID 分别是 null 和 1，符合预期：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e4%b8%9a%e5%8a%a1%e5%bc%80%e5%8f%91%e5%b8%b8%e8%a7%81%e9%94%99%e8%af%af%20100%20%e4%be%8b/assets/4b8f38415d03423132c7a3608ebe2430.png" alt="img"></p><p>随后用户 2 来请求接口，这次就出现了 Bug，第一和第二次获取到用户 ID 分别是 1 和 2，显然第一次获取到了用户 1 的信息，原因就是 Tomcat 的线程池重用了线程。从图中可以看到，两次请求的线程都是同一个线程：http-nio-8080-exec-1。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e4%b8%9a%e5%8a%a1%e5%bc%80%e5%8f%91%e5%b8%b8%e8%a7%81%e9%94%99%e8%af%af%20100%20%e4%be%8b/assets/a9ccd42716d807687b3acff9a0baf2db.png" alt="img"></p><p>这个例子告诉我们，在写业务代码时，首先要理解代码会跑在什么线程上：</p><ul><li>我们可能会抱怨学多线程没用，因为代码里没有开启使用多线程。但其实，可能只是我们没有意识到，在 Tomcat 这种 Web 服务器下跑的业务代码，本来就运行在一个多线程环境（否则接口也不可能支持这么高的并发），<strong>并不能认为没有显式开启多线程就不会有线程安全问题。</strong></li><li>因为线程的创建比较昂贵，所以 Web 服务器往往会使用线程池来处理请求，这就意味着线程会被重用。这时，<strong>使用类似 ThreadLocal 工具来存放一些数据时，需要特别注意在代码运行完后，显式地去清空设置的数据。</strong>如果在代码中使用了自定义的线程池，也同样会遇到这个问题。</li></ul><p>理解了这个知识点后，我们修正这段代码的方案是，在代码的 finally 代码块中，显式清除 ThreadLocal 中的数据。这样一来，新的请求过来即使使用了之前的线程也不会获取到错误的用户信息了。修正后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;right&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map <span class="title function_">right</span><span class="params">(<span class="meta">@RequestParam(&quot;userId&quot;)</span> Integer userId)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">before</span>  <span class="operator">=</span> Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + currentUser.get();</span><br><span class="line">    currentUser.set(userId);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">after</span> <span class="operator">=</span> Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + currentUser.get();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        result.put(<span class="string">&quot;before&quot;</span>, before);</span><br><span class="line">        result.put(<span class="string">&quot;after&quot;</span>, after);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//在finally代码块中删除ThreadLocal中的数据，确保数据不串</span></span><br><span class="line">        currentUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行程序可以验证，再也不会出现第一次查询用户信息查询到之前用户请求的 Bug：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e4%b8%9a%e5%8a%a1%e5%bc%80%e5%8f%91%e5%b8%b8%e8%a7%81%e9%94%99%e8%af%af%20100%20%e4%be%8b/assets/0dfe40fca441b58d491fc799d120a7cc.png" alt="img"></p><p>其实如果使用<code>ThreadLocal</code> 后不及时调用 <code>remove()</code> 方法，可能还会引发内存泄漏问题。</p><p><code>ThreadLocal</code> 的实现依赖于每个线程内部的一个 <code>ThreadLocalMap</code>，<code>ThreadLocal</code> 对象作为键，存储的值作为值。<code>ThreadLocalMap</code> 中的键是对 <code>ThreadLocal</code> 对象的弱引用（<code>WeakReference</code>），而值是强引用。</p><p>当外部对 <code>ThreadLocal</code> 对象的强引用被释放后，由于 <code>ThreadLocalMap</code> 中的键是弱引用，在垃圾回收时，这个 <code>ThreadLocal</code> 实例会被回收，其对应的键会变为 <code>null</code>。但此时值仍然是强引用，只要线程一直存活，<code>ThreadLocalMap</code> 就不会被回收，这些 <code>null</code> 键对应的值就无法被访问到，却仍然占用着内存，从而造成内存泄漏。</p><h1 id="线程池的声明需手动进行"><a href="#线程池的声明需手动进行" class="headerlink" title="线程池的声明需手动进行"></a>线程池的声明需手动进行</h1><p>Java 中的 Executors 类定义了一些快捷的工具方法，来帮助我们快速创建线程池。《阿里巴巴 Java 开发手册》中提到，禁止使用这些方法来创建线程池，而应该手动 new ThreadPoolExecutor 来创建线程池。这一条规则的背后，是大量血淋淋的生产事故，最典型的就是 newFixedThreadPool 和 newCachedThreadPool，可能因为资源耗尽导致 OOM 问题。</p><p>首先，我们来看一下 newFixedThreadPool 为什么可能会出现 OOM 的问题。</p><p>我们写一段测试代码，来初始化一个单线程的 FixedThreadPool，循环 1 亿次向线程池提交任务，每个任务都会创建一个比较大的字符串然后休眠一小时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;oom1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oom1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印线程池的信息，稍后我会解释这段代码</span></span><br><span class="line">    printStats(threadPool); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000000</span>)</span><br><span class="line">                    .mapToObj(__ -&gt; <span class="string">&quot;a&quot;</span>)</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">&quot;&quot;</span>)) + UUID.randomUUID().toString();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.HOURS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.info(payload);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    threadPool.awaitTermination(<span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序后不久，日志中就出现了如下 OOM：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;http-nio-45678-ClientPoller&quot;</span> java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br></pre></td></tr></table></figure><p>翻看 newFixedThreadPool 方法的源码不难发现，线程池的工作队列直接 new 了一个 LinkedBlockingQueue，而默认构造方法的 LinkedBlockingQueue 是一个 Integer.MAX_VALUE 长度的队列，可以认为是无界的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with a capacity of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Integer#MAX_VALUE&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然使用 newFixedThreadPool 可以把工作线程控制在固定的数量上，但任务队列是无界的。如果任务较多并且执行较慢的话，队列可能会快速积压，撑爆内存导致 OOM。</p><p>我们再把刚才的例子稍微改一下，改为使用 newCachedThreadPool 方法来获得线程池。程序运行不久后，同样看到了如下 OOM 异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[11:30:30.487] [http-nio-45678-exec-1] [ERROR] [.a.c.c.C.[.[.[/].[dispatcherServlet]:175 ] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Handler dispatch failed; nested exception is java.lang.OutOfMemoryError: unable to create new native thread] with root cause</span><br><span class="line"></span><br><span class="line">java.lang.OutOfMemoryError: unable to create new native thread </span><br></pre></td></tr></table></figure><p>从日志中可以看到，这次 OOM 的原因是无法创建线程，翻看 newCachedThreadPool 的源码可以看到，这种线程池的最大线程数是 Integer.MAX_VALUE，可以认为是没有上限的，而其工作队列 SynchronousQueue 是一个没有存储空间的阻塞队列。这意味着，只要有请求到来，就必须找到一条工作线程来处理，如果当前没有空闲的线程就再创建一条新的。</p><p>由于我们的任务需要 1 小时才能执行完成，大量的任务进来后会创建大量的线程。我们知道线程是需要分配一定的内存空间作为线程栈的，比如 1MB，因此无限制创建线程必然会导致 OOM：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure><p>其实，大部分 Java 开发同学知道这两种线程池的特性，只是抱有侥幸心理，觉得只是使用线程池做一些轻量级的任务，不可能造成队列积压或开启大量线程。</p><p>但，现实往往是残酷的。我之前就遇到过这么一个事故：用户注册后，我们调用一个外部服务去发送短信，发送短信接口正常时可以在 100 毫秒内响应，TPS 100 的注册量，CachedThreadPool 能稳定在占用 10 个左右线程的情况下满足需求。在某个时间点，外部短信服务不可用了，我们调用这个服务的超时又特别长，比如 1 分钟，1 分钟可能就进来了 6000 用户，产生 6000 个发送短信的任务，需要 6000 个线程，没多久就因为无法创建线程导致了 OOM，整个应用程序崩溃。</p><p>因此，我同样不建议使用 Executors 提供的两种快捷的线程池，原因如下：</p><p>我们需要根据自己的场景、并发情况来评估线程池的几个核心参数，包括核心线程数、最大线程数、线程回收策略、工作队列的类型，以及拒绝策略，确保线程池的工作行为符合需求，一般都需要设置有界的工作队列和可控的线程数。</p><p>任何时候，都应该为自定义线程池指定有意义的名称，以方便排查问题。当出现线程数量暴增、线程死锁、线程占用大量 CPU、线程执行出现异常等问题时，我们往往会抓取线程栈。此时，有意义的线程名称，就可以方便我们定位问题。</p><p>除了建议手动声明线程池以外，我还建议用一些监控手段来观察线程池的状态。线程池这个组件往往会表现得任劳任怨、默默无闻，除非是出现了拒绝策略，否则压力再大都不会抛出一个异常。如果我们能提前观察到线程池队列的积压，或者线程数量的快速膨胀，往往可以提早发现并解决问题。</p><h1 id="线程池核心参数设置"><a href="#线程池核心参数设置" class="headerlink" title="线程池核心参数设置"></a>线程池核心参数设置</h1><p>要根据任务的“轻重缓急”来指定线程池的核心参数，包括线程数、回收策略和任务队列：</p><p>对于执行比较慢、数量不大的 IO 任务，或许要考虑更多的线程数，而不需要太大的队列。</p><p>而对于吞吐量较大的计算型任务，线程数量不宜过多，可以是 CPU 核数或核数 *2（理由是，线程一定调度到某个 CPU 进行执行，如果任务本身是 CPU 绑定的任务，那么过多的线程只会增加线程切换的开销，并不能提升吞吐量），但可能需要较长的队列来做缓冲。</p><p>Java 8 的 parallel stream 功能，可以让我们很方便地并行处理集合中的元素，其背后是共享同一个 ForkJoinPool，默认并行度是 CPU 核数 -1。对于 CPU 绑定的任务来说，使用这样的配置比较合适，但如果集合操作涉及同步 IO 操作的话（比如数据库操作、外部服务调用等），建议自定义一个 ForkJoinPool（或普通线程池）。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ集群性能调优及运维</title>
      <link href="/2025/01/24/RocketMQ%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%8F%8A%E8%BF%90%E7%BB%B4/"/>
      <url>/2025/01/24/RocketMQ%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%8F%8A%E8%BF%90%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="系统参数调优"><a href="#系统参数调优" class="headerlink" title="系统参数调优"></a>系统参数调优</h1><p>在解压 RocketMQ 安装包后，在 bin 目录中有个 os.sh 的文件，该文件由 RocketMQ 官方推荐系统参数配置。通常这些参数可以满足系统需求，也可以根据情况进行调整。</p><h2 id="最大文件数"><a href="#最大文件数" class="headerlink" title="最大文件数"></a>最大文件数</h2><p>设置用户的打开的最多文件数：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br><span class="line"><span class="section"># End of file</span></span><br><span class="line">baseuser soft nofile 655360</span><br><span class="line">baseuser hard nofile 655360</span><br><span class="line"><span class="bullet">*</span> soft nofile 655360</span><br><span class="line"><span class="bullet">*</span> hard nofile 655360</span><br></pre></td></tr></table></figure><h2 id="系统参数设置"><a href="#系统参数设置" class="headerlink" title="系统参数设置"></a>系统参数设置</h2><p>系统参数的调整以官方给出的为主，下面对各个参数做个说明。设置时可以直接执行 <code>sh os.sh</code> 完成系统参数设定，也可以编辑 <code>vim /etc/sysctl.conf</code> 文件手动添加如下内容，添加后执行 <code>sysctl -p</code> 让其生效。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vm.overcommit_memory</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">vm.drop_caches</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">vm.zone_reclaim_mode</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">vm.max_map_count</span>=<span class="number">655360</span></span><br><span class="line"><span class="attr">vm.dirty_background_ratio</span>=<span class="number">50</span></span><br><span class="line"><span class="attr">vm.dirty_ratio</span>=<span class="number">50</span></span><br><span class="line"><span class="attr">vm.dirty_writeback_centisecs</span>=<span class="number">360000</span></span><br><span class="line"><span class="attr">vm.page-cluster</span>=<span class="number">3</span></span><br><span class="line"><span class="attr">vm.swappiness</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">overcommit_memory</td><td align="left">是否允许内存的过量分配 overcommit_memory&#x3D;0 当用户申请内存的时候，内核会去检查是否有这么大的内存空间 overcommit_memory&#x3D;1 内核始终认为，有足够大的内存空间，直到它用完了为止 overcommit_memory&#x3D;2 内核禁止任何形式的过量分配内存</td></tr><tr><td align="left">drop_caches</td><td align="left">写入的时候，内核会清空缓存，腾出内存来，相当于 sync drop_caches&#x3D;1 会清空页缓存，就是文件 drop_caches&#x3D;2 会清空 inode 和目录树 drop_caches&#x3D;3 都清空</td></tr><tr><td align="left">zone_reclaim_mode</td><td align="left">zone_reclaim_mode&#x3D;0 系统会倾向于从其他节点分配内存 zone_reclaim_mode&#x3D;1 系统会倾向于从本地节点回收 Cache 内存</td></tr><tr><td align="left">max_map_count</td><td align="left">定义了一个进程能拥有的最多的内存区域，默认为 65536</td></tr><tr><td align="left">dirty_background_ratio&#x2F;dirty_ratio</td><td align="left">当 dirty cache 到了多少的时候，就启动 pdflush 进程，将 dirty cache 写回磁盘 当有 dirty_background_bytes&#x2F;dirty_bytes 存在的时候，dirty_background_ratio&#x2F;dirty_ratio 是被自动计算的</td></tr><tr><td align="left">dirty_writeback_centisecs</td><td align="left">pdflush 每隔多久，自动运行一次（单位是百分之一秒）</td></tr><tr><td align="left">page-cluster</td><td align="left">每次 swap in 或者 swap out 操作多少内存页为 2 的指数 page-cluster&#x3D;0 表示 1 页 page-cluster&#x3D;1 表示 2 页 page-cluster&#x3D;2 表示 4 页 page-cluster&#x3D;3 表示 8 页</td></tr><tr><td align="left">swappiness</td><td align="left">swappiness&#x3D;0 仅在内存不足的情况下，当剩余空闲内存低于 vm.min_free_kbytes limit 时，使用交换空间 swappiness&#x3D;1 内核版本 3.5 及以上、Red Hat 内核版本 2.6.32-303 及以上，进行最少量的交换，而不禁用交换 swappiness&#x3D;10 当系统存在足够内存时，推荐设置为该值以提高性能 swappiness&#x3D;60 默认值 swappiness&#x3D;100 内核将积极的使用交换空间</td></tr></tbody></table><h2 id="集群参数调优"><a href="#集群参数调优" class="headerlink" title="集群参数调优"></a>集群参数调优</h2><h3 id="调优建议"><a href="#调优建议" class="headerlink" title="调优建议"></a>调优建议</h3><p>对 Broker 的几个属性可能影响到集群性能的稳定性，下面进行特别说明。</p><p><strong>1. 开启异步刷盘</strong></p><p>除了一些支付类场景、或者 TPS 较低的场景（例如：TPS 在 2000 以下）生产环境建议开启异步刷盘，提高集群吞吐。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flushDiskType</span>=ASYNC_FLUSH</span><br></pre></td></tr></table></figure><p><strong>2. 开启 Slave 读权限</strong></p><p>消息占用物理内存的大小通过 accessMessageInMemoryMaxRatio 来配置默认为 40%；如果消费的消息不在内存中，开启 slaveReadEnable 时会从 slave 节点读取；提高 Master 内存利用率。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slaveReadEnable</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>3. 消费一次拉取消息数量</strong></p><p>消费时一次拉取的数量由 broker 和 consumer 客户端共同决定，默认为 32 条。Broker 端参数由 maxTransferCountOnMessageInMemory 设置。consumer 端由 pullBatchSize 设置。Broker 端建议设置大一些，例如 1000，给 consumer 端留有较大的调整空间。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxTransferCountOnMessageInMemory</span>=<span class="number">1000</span></span><br></pre></td></tr></table></figure><p><strong>4. 发送队列等待时间</strong></p><p>消息发送到 Broker 端，在队列的等待时间由参数 waitTimeMillsInSendQueue 设置，默认为 200ms。建议设置大一些，例如：1000ms~5000ms。设置过短，发送客户端会引起超时。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">waitTimeMillsInSendQueue</span>=<span class="number">1000</span></span><br></pre></td></tr></table></figure><p><strong>5. 主从异步复制</strong></p><p>为提高集群性能，在生成环境建议设置为主从异步复制，经过压力测试主从同步复制性能过低。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">brokerRole</span>=ASYNC_MASTER</span><br></pre></td></tr></table></figure><p><strong>6. 提高集群稳定性</strong></p><p>为了提高集群稳定性，对下面三个参数进行特别说明，在后面踩坑案例中也会提到。</p><p>关闭堆外内存：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">transientStorePoolEnable</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>关闭文件预热：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">warmMapedFileEnable</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>开启堆内传输：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">transferMsgByHeap</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="集群平滑运维"><a href="#集群平滑运维" class="headerlink" title="集群平滑运维"></a>集群平滑运维</h1><h2 id="优雅摘除节点"><a href="#优雅摘除节点" class="headerlink" title="优雅摘除节点"></a>优雅摘除节点</h2><h3 id="案例背景"><a href="#案例背景" class="headerlink" title="案例背景"></a>案例背景</h3><p>自建机房 4 主 4 从、异步刷盘、主从异步复制。有一天运维同学遗失其中一个 Master 节点所有账户的密码，该节点在集群中运行正常，然不能登陆该节点机器终究存在安全隐患，所以决定摘除该节点。</p><p>如何平滑地摘除该节点呢？</p><p>直接关机，有部分未同步到从节点的数据会丢失，显然不可行。线上安全的指导思路“先摘除流量”，当没有流量流入流出时，对节点的操作是安全的。</p><h3 id="流量摘除"><a href="#流量摘除" class="headerlink" title="流量摘除"></a>流量摘除</h3><p><strong>1. 摘除写入流量</strong></p><p>我们可以通过关闭 Broker 的写入权限，来摘除该节点的写入流量。RocketMQ 的 broker 节点有 3 种权限设置，brokerPermission&#x3D;2 表示只写权限，brokerPermission&#x3D;4 表示只读权限，brokerPermission&#x3D;6 表示读写权限。通过 updateBrokerConfig 命令将 Broker 设置为只读权限，执行完之后原该 Broker 的写入流量会分配到集群中的其他节点，所以摘除前需要评估集群节点的负载情况。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin/mqadmin updateBrokerConfig -<span class="selector-tag">b</span> x<span class="selector-class">.x</span><span class="selector-class">.x</span><span class="selector-class">.x</span>:<span class="number">10911</span> -n x.x.x.x:<span class="number">9876</span> -k brokerPermission -v <span class="number">4</span></span><br><span class="line">Java <span class="built_in">HotSpot</span>(TM) <span class="number">64</span>-Bit Server VM warning: ignoring option PermSize=<span class="number">128</span>m; support was removed in <span class="number">8.0</span></span><br><span class="line">Java HotSpot(TM) <span class="number">64</span>-Bit Server VM warning: ignoring option MaxPermSize=<span class="number">128</span>m; support was removed in <span class="number">8.0</span></span><br><span class="line">update broker config success, x<span class="selector-class">.x</span><span class="selector-class">.x</span><span class="selector-class">.x</span>:<span class="number">10911</span></span><br></pre></td></tr></table></figure><p>将 Broker 设置为只读权限后，观察该节点的流量变化，直到写入流量（InTPS）掉为 0 表示写入流量已摘除。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">bin/mqadmin</span> <span class="string">clusterList</span> <span class="string">-n</span> <span class="string">x.x.x.x:9876</span></span><br><span class="line"><span class="string">Java</span> <span class="string">HotSpot(TM)</span> <span class="attr">64-Bit Server VM warning:</span> <span class="string">ignoring</span> <span class="string">option</span> <span class="string">PermSize=128m;</span> <span class="string">support</span> <span class="string">was</span> <span class="string">removed</span> <span class="string">in</span> <span class="number">8.0</span></span><br><span class="line"><span class="string">Java</span> <span class="string">HotSpot(TM)</span> <span class="attr">64-Bit Server VM warning:</span> <span class="string">ignoring</span> <span class="string">option</span> <span class="string">MaxPermSize=128m;</span> <span class="string">support</span> <span class="string">was</span> <span class="string">removed</span> <span class="string">in</span> <span class="number">8.0</span></span><br><span class="line"><span class="comment">#Cluster Name #Broker Name #BID #Addr #Version #InTPS(LOAD) #OutTPS(LOAD) #PCWait(ms) #Hour #SPACE</span></span><br><span class="line"><span class="string">ClusterA</span> <span class="string">broker-a</span> <span class="number">0</span> <span class="string">x.x.x.x:10911</span> <span class="string">V4_7_0_SNAPSHOT</span> <span class="number">2492.95</span><span class="string">(0,0ms)</span> <span class="number">2269.27</span><span class="string">(1,0ms)</span> <span class="number">0</span> <span class="number">137.57</span> <span class="number">0.1861</span></span><br><span class="line"><span class="string">ClusterA</span> <span class="string">broker-a</span> <span class="number">1</span> <span class="string">x.x.x.x:10911</span> <span class="string">V4_7_0_SNAPSHOT</span> <span class="number">2485.45</span><span class="string">(0,0ms)</span> <span class="number">0.00</span><span class="string">(0,0ms)</span> <span class="number">0</span> <span class="number">125.26</span> <span class="number">0.3055</span></span><br><span class="line"><span class="string">ClusterA</span> <span class="string">broker-b</span> <span class="number">0</span> <span class="string">x.x.x.x:10911</span> <span class="string">V4_7_0_SNAPSHOT</span> <span class="number">26.47</span><span class="string">(0,0ms)</span> <span class="number">26.08</span><span class="string">(0,0ms)</span> <span class="number">0</span> <span class="number">137.24</span> <span class="number">0.1610</span></span><br><span class="line"><span class="string">ClusterA</span> <span class="string">broker-b</span> <span class="number">1</span> <span class="string">x.x.x.x:10915</span> <span class="string">V4_7_0_SNAPSHOT</span> <span class="number">20.47</span><span class="string">(0,0ms)</span> <span class="number">0.00</span><span class="string">(0,0ms)</span> <span class="number">0</span> <span class="number">125.22</span> <span class="number">0.3055</span></span><br><span class="line"><span class="string">ClusterA</span> <span class="string">broker-c</span> <span class="number">0</span> <span class="string">x.x.x.x:10911</span> <span class="string">V4_7_0_SNAPSHOT</span> <span class="number">2061.09</span><span class="string">(0,0ms)</span> <span class="number">1967.30</span><span class="string">(0,0ms)</span> <span class="number">0</span> <span class="number">125.28</span> <span class="number">0.2031</span></span><br><span class="line"><span class="string">ClusterA</span> <span class="string">broker-c</span> <span class="number">1</span> <span class="string">x.x.x.x:10911</span> <span class="string">V4_7_0_SNAPSHOT</span> <span class="number">2048.20</span><span class="string">(0,0ms)</span> <span class="number">0.00</span><span class="string">(0,0ms)</span> <span class="number">0</span> <span class="number">137.51</span> <span class="number">0.2789</span></span><br><span class="line"><span class="string">ClusterA</span> <span class="string">broker-d</span> <span class="number">0</span> <span class="string">x.x.x.x:10911</span> <span class="string">V4_7_0_SNAPSHOT</span> <span class="number">2017.40</span><span class="string">(0,0ms)</span> <span class="number">1788.32</span><span class="string">(0,0ms)</span> <span class="number">0</span> <span class="number">125.22</span> <span class="number">0.1261</span></span><br><span class="line"><span class="string">ClusterA</span> <span class="string">broker-d</span> <span class="number">1</span> <span class="string">x.x.x.x:10915</span> <span class="string">V4_7_0_SNAPSHOT</span> <span class="number">2026.50</span><span class="string">(0,0ms)</span> <span class="number">0.00</span><span class="string">(0,0ms)</span> <span class="number">0</span> <span class="number">137.61</span> <span class="number">0.2789</span></span><br></pre></td></tr></table></figure><p><strong>2. 摘除读出流量</strong></p><p>当摘除 Broker 写入流量后，读出消费流量也会逐步降低。可以通过 clusterList 命令中 OutTPS 观察读出流量变化。除此之外，也可以通过 brokerConsumeStats 观察 broker 的积压（Diff）情况，当积压为 0 时，表示消费全部完成。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#Topic</span>             <span class="selector-id">#Group</span>                <span class="selector-id">#Broker</span> <span class="selector-tag">Name</span>    <span class="selector-id">#QID</span>  <span class="selector-id">#Broker</span> <span class="selector-tag">Offset</span>   <span class="selector-id">#Consumer</span> <span class="selector-tag">Offset</span>  <span class="selector-id">#Diff</span>     <span class="selector-id">#LastTime</span></span><br><span class="line"><span class="selector-tag">test_melon_topic</span>   <span class="selector-tag">test_melon_consumer</span>     <span class="selector-tag">broker-b</span>        <span class="number">0</span>     <span class="number">2171742</span>           <span class="number">2171742</span>          <span class="number">0</span>       <span class="number">2020</span><span class="selector-tag">-08-13</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">09</span></span><br><span class="line"><span class="selector-tag">test_melon_topic</span>   <span class="selector-tag">test_melon_consumer</span>     <span class="selector-tag">broker-b</span>        <span class="number">1</span>     <span class="number">2171756</span>           <span class="number">2171756</span>          <span class="number">0</span>       <span class="number">2020</span><span class="selector-tag">-08-13</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">50</span></span><br><span class="line"><span class="selector-tag">test_melon_topic</span>   <span class="selector-tag">test_melon_consumer</span>     <span class="selector-tag">broker-b</span>        <span class="number">2</span>     <span class="number">2171740</span>           <span class="number">2171740</span>          <span class="number">0</span>       <span class="number">2020</span><span class="selector-tag">-08-13</span> <span class="number">23</span>:<span class="number">42</span>:<span class="number">58</span></span><br><span class="line"><span class="selector-tag">test_melon_topic</span>   <span class="selector-tag">test_melon_consumer</span>     <span class="selector-tag">broker-b</span>        <span class="number">3</span>     <span class="number">2171759</span>           <span class="number">2171759</span>          <span class="number">0</span>       <span class="number">2020</span><span class="selector-tag">-08-13</span> <span class="number">23</span>:<span class="number">40</span>:<span class="number">44</span></span><br><span class="line"><span class="selector-tag">test_melon_topic</span>   <span class="selector-tag">test_melon_consumer</span>     <span class="selector-tag">broker-b</span>        <span class="number">4</span>     <span class="number">2171743</span>           <span class="number">2171743</span>          <span class="number">0</span>       <span class="number">2020</span><span class="selector-tag">-08-13</span> <span class="number">23</span>:<span class="number">32</span>:<span class="number">48</span></span><br><span class="line"><span class="selector-tag">test_melon_topic</span>   <span class="selector-tag">test_melon_consumer</span>     <span class="selector-tag">broker-b</span>        <span class="number">5</span>     <span class="number">2171740</span>           <span class="number">2171740</span>          <span class="number">0</span>       <span class="number">2020</span><span class="selector-tag">-08-13</span> <span class="number">23</span>:<span class="number">35</span>:<span class="number">58</span></span><br></pre></td></tr></table></figure><p><strong>3. 节点下线</strong></p><p>在观察到该 Broker 的所有积压为 0 时，通常该节点可以摘除了。考虑到可能消息回溯到之前某个时间点重新消费，可以过了日志保存日期再下线该节点。如果日志存储为 3 天，那 3 天后再移除该节点。</p><h2 id="平滑扩所容"><a href="#平滑扩所容" class="headerlink" title="平滑扩所容"></a>平滑扩所容</h2><h3 id="案例背景-1"><a href="#案例背景-1" class="headerlink" title="案例背景"></a>案例背景</h3><p>需要将线上的集群操作系统从 CentOS 6 全部换成 CenOS 7，具体现象和原因在踩坑记中介绍。集群部署架构为 4 主 4 从，见下图，broker-a 为主节点，broker-a-s 是 broker-a 的从节点。</p><p><img src="https://i0.hdslb.com/bfs/article/bf648a1fc83c047875f4bbeba7498e9e171301454.png" alt="image-20250126151748499"></p><p>那需要思考的是如何做到平滑替换？指导思想为“先扩容再缩容”。</p><h3 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h3><p>申请 8 台相同配置的机器，机器操作系统为 CenOS 7。分别组建主从结构加入到原来的集群中，此时集群中架构为 8 主 8 从，如下图：</p><p><img src="https://i0.hdslb.com/bfs/article/aa7cf927ecf92bc1ed29e0eaddf9ccb1171301454.png" alt="image-20250126151837253"></p><p>broker-a、broker-b、broker-c、broker-d 及其从节点为 CentOS 6。broker-a1、broker-b1、broker-c1、broker-d1 及其从节点为 CentOS 7。8 主均有流量流入流出，至此我们完成了集群的平滑扩容操作。</p><h3 id="集群缩容"><a href="#集群缩容" class="headerlink" title="集群缩容"></a>集群缩容</h3><p>按照第二部分“优雅摘除节点”操作，分别摘除 broker-a、broker-b、broker-c、broker-d 及其从节点的流量。为了安全，可以在过了日志保存时间（例如：3 天）后再下线。集群中剩下操作系统为 CentOS 7 的 4 主 4 从的架构，如图。至此，完成集群的平滑缩容操作。</p><p><img src="https://i0.hdslb.com/bfs/article/4528f6a51d45c9c2c1b13343fcbd72db171301454.png" alt="image-20250126151854858"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在扩容中，我们将新申请的 8 台 CentOS 7 节点，命名为 broker-a1、broker-b1、broker-c1、broker-d1 的形式，而不是 broker-e、broker-f、broker-g、broker-h。下面看下这么命名的原因，客户端消费默认采用平均分配算法，假设有四个消费节点。</p><p><strong>第一种形式</strong></p><p>扩容后排序如下，即新加入的节点 broker-e 会排在原集群的最后。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broker-<span class="selector-tag">a</span>,broker-<span class="selector-tag">b</span>,broker-c,broker-d,broker-e,broker-f,broker-g,broker-h</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/c0e99ad51ef0b08e43d3874f1f6f9c41171301454.png" alt="image-20250126152106693"></p><p>注：当缩容摘除 broker-a、broker-b、broker-c、broker-d 的流量时，会发现 consumer-01、consumer-02 没有不能分到 Broker 节点，造成流量偏移，存在剩余的一半节点无法承载流量压力的隐患。</p><p><strong>第二种形式</strong></p><p>扩容后的排序如下，即新加入的主节点 broker-a1 紧跟着原来的主节点 broker-a。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broker-<span class="selector-tag">a</span>,broker-a1,broker-<span class="selector-tag">b</span>,broker-b1,broker-c,broker-c1,broker-d,broker-d1</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/d2b69fedbeca46dbf4c0a16ac8e919c7171301454.png" alt="image-20250126152157127"></p><p>注：当缩容摘除 broker-a、broker-b、broker-c、broker-d 的流量时，各个 consumer 均分配到了新加入的 Broker 节点，没有流量偏移的情况。</p><h2 id="集群节点进程神秘消失"><a href="#集群节点进程神秘消失" class="headerlink" title="集群节点进程神秘消失"></a>集群节点进程神秘消失</h2><h3 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h3><p>接到告警和运维反馈，一个 RocketMQ 的节点不见了。此类现象在以前从未发生过，消失肯定有原因，开始查找日志，从集群的 broker.log、stats.log、storeerror.log、store.log、watermark.log 到系统的 message 日志没发现错误日志。集群流量出入在正常水位、CPU 使用率、CPU Load、磁盘 IO、内存、带宽等无明显变化。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>继续查原因，最终通过 history 查看了历史运维操作。发现运维同学在启动 Broker 时没有在后台启动，而是在当前 session 中直接启动了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqbroker -c conf/broker-a.conf</span><br></pre></td></tr></table></figure><p>问题即出现在此命令，当 session 过期时 Broker 节点也就退出了。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>标准化运维操作，对运维的每次操作进行评审，将标准化的操作实现自动化运维就更好了。</p><p>正确启动 Broker 方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> sh bin/mqbroker -c conf/broker-a.conf &amp;</span><br></pre></td></tr></table></figure><h2 id="Master-节点-CPU-莫名飙高"><a href="#Master-节点-CPU-莫名飙高" class="headerlink" title="Master 节点 CPU 莫名飙高"></a>Master 节点 CPU 莫名飙高</h2><h3 id="现象描述-1"><a href="#现象描述-1" class="headerlink" title="现象描述"></a>现象描述</h3><p>RocketMQ 主节点 CPU 频繁飙高后回落，业务发送超时严重，由于两个从节点部署在同一个机器上，从节点还出现了直接挂掉的情况。</p><p>主节点 CPU 毛刺截图：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200910105626655.png" alt="img"></p><p>从节点 CPU 毛刺截图：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200910105701883.png" alt="img"></p><p>说明：中间缺失部分为掉线，没有采集到的情况。</p><p><strong>系统错误日志一</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020-03-16T17:56:07.505715+08:00</span> <span class="attr">VECS0xxxx kernel:</span> <span class="string">&lt;IRQ&gt;</span>  [<span class="string">&lt;ffffffff81143c31&gt;</span>] <span class="string">?</span> <span class="string">__alloc_pages_nodemask+0x7e1/0x960</span></span><br><span class="line"><span class="number">2020-03-16T17:56:07.505717+08:00</span> <span class="attr">VECS0xxxx kernel: java:</span> <span class="string">page</span> <span class="string">allocation</span> <span class="string">failure.</span> <span class="string">order:0,</span> <span class="string">mode:0x20</span></span><br><span class="line"><span class="number">2020-03-16T17:56:07.505719+08:00</span> <span class="attr">VECS0xxxx kernel: Pid:</span> <span class="number">12845</span><span class="string">,</span> <span class="attr">comm:</span> <span class="string">java</span> <span class="string">Not</span> <span class="string">tainted</span> <span class="number">2.6</span><span class="number">.32</span><span class="number">-754.17</span><span class="number">.1</span><span class="string">.el6.x86_64</span> <span class="comment">#1</span></span><br><span class="line"><span class="number">2020-03-16T17:56:07.505721+08:00</span> <span class="attr">VECS0xxxx kernel: Call Trace:</span></span><br><span class="line"><span class="number">2020-03-16T17:56:07.505724+08:00</span> <span class="attr">VECS0xxxx kernel:</span> <span class="string">&lt;IRQ&gt;</span>  [<span class="string">&lt;ffffffff81143c31&gt;</span>] <span class="string">?</span> <span class="string">__alloc_pages_nodemask+0x7e1/0x960</span></span><br><span class="line"><span class="number">2020-03-16T17:56:07.505726+08:00</span> <span class="attr">VECS0xxxx kernel:</span> [<span class="string">&lt;ffffffff8148e700&gt;</span>] <span class="string">?</span> <span class="string">dev_queue_xmit+0xd0/0x360</span></span><br><span class="line"><span class="number">2020-03-16T17:56:07.505729+08:00</span> <span class="attr">VECS0xxxx kernel:</span> [<span class="string">&lt;ffffffff814cb3e2&gt;</span>] <span class="string">?</span> <span class="string">ip_finish_output+0x192/0x380</span></span><br></pre></td></tr></table></figure><p><strong>系统错误日志二</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span> <span class="number">2020-03-27T10:35:28.769900+08:00</span> <span class="attr">VECSxxxx kernel: INFO:</span> <span class="string">task</span> <span class="string">AliYunDunUpdate:29054</span> <span class="string">blocked</span> <span class="string">for</span> <span class="string">more</span> <span class="string">than</span> <span class="number">120</span> <span class="string">seconds.</span></span><br><span class="line"><span class="number">31</span> <span class="number">2020-03-27T10:35:28.769932+08:00</span> <span class="attr">VECSxxxx kernel:</span>      <span class="string">Not</span> <span class="string">tainted</span> <span class="number">2.6</span><span class="number">.32</span><span class="number">-754.17</span><span class="number">.1</span><span class="string">.el6.x86_64</span> <span class="comment">#1</span></span><br><span class="line"><span class="number">32</span> <span class="number">2020-03-27T10:35:28.771650+08:00</span> <span class="attr">VECS0xxxx kernel:</span> <span class="string">&quot;echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs&quot;</span> <span class="string">disables</span> <span class="string">this</span> <span class="string">message.</span></span><br><span class="line"><span class="number">33</span> <span class="number">2020-03-27T10:35:28.774631+08:00</span> <span class="attr">VECS0xxxx kernel:</span> <span class="string">AliYunDunUpda</span> <span class="string">D</span> <span class="string">ffffffff815592fb</span>     <span class="number">0</span> <span class="number">29054</span>      <span class="number">1</span> <span class="number">0x10000080</span></span><br><span class="line"><span class="number">34</span> <span class="number">2020-03-27T10:35:28.777500+08:00</span> <span class="attr">VECS0xxxx kernel:</span> <span class="string">ffff8803ef75baa0</span> <span class="number">0000000000000082</span> <span class="string">ffff8803ef75ba68</span> <span class="string">ffff8803ef75ba64</span></span><br></pre></td></tr></table></figure><p>说明：系统日志显示错误“page allocation failure”和“blocked for more than 120 second”错误，日志目录 &#x2F;var&#x2F;log&#x2F;messages。</p><p><strong>GC 日志</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020-03-16T17:49:13.785</span><span class="string">+0800:</span> <span class="attr">13484510.599: Total time for which application threads were stopped:</span> <span class="number">0.0072354</span> <span class="string">seconds,</span> <span class="attr">Stopping threads took:</span> <span class="number">0.0001536</span> <span class="string">seconds</span></span><br><span class="line"><span class="number">2020-03-16T18:01:23.149</span><span class="string">+0800:</span> <span class="attr">13485239.963:</span> [<span class="string">GC</span> <span class="string">pause</span> <span class="string">(G1</span> <span class="string">Evacuation</span> <span class="string">Pause)</span> <span class="string">(young)</span> <span class="attr">13485239.965:</span> [<span class="string">G1Ergonomics</span> <span class="string">(CSet</span> <span class="string">Construction)</span> <span class="string">start</span> <span class="string">choosing</span> <span class="string">CSet</span>, <span class="attr">_pending_cards:</span> <span class="number">7738</span>, <span class="attr">predicted base time:</span> <span class="number">5.74</span> <span class="string">ms</span>, <span class="attr">remaining time:</span> <span class="number">194.26</span> <span class="string">ms</span>, <span class="attr">target pause time:</span> <span class="number">200.00</span> <span class="string">ms</span>]</span><br><span class="line"> <span class="attr">13485239.965:</span> [<span class="string">G1Ergonomics</span> <span class="string">(CSet</span> <span class="string">Construction)</span> <span class="string">add</span> <span class="string">young</span> <span class="string">regions</span> <span class="string">to</span> <span class="string">CSet</span>, <span class="attr">eden:</span> <span class="number">255</span> <span class="string">regions</span>, <span class="attr">survivors:</span> <span class="number">1</span> <span class="string">regions</span>, <span class="attr">predicted young region time:</span> <span class="number">0.52</span> <span class="string">ms</span>]</span><br><span class="line"> <span class="attr">13485239.965:</span> [<span class="string">G1Ergonomics</span> <span class="string">(CSet</span> <span class="string">Construction)</span> <span class="string">finish</span> <span class="string">choosing</span> <span class="string">CSet</span>, <span class="attr">eden:</span> <span class="number">255</span> <span class="string">regions</span>, <span class="attr">survivors:</span> <span class="number">1</span> <span class="string">regions</span>, <span class="attr">old:</span> <span class="number">0</span> <span class="string">regions</span>, <span class="attr">predicted pause time:</span> <span class="number">6.26</span> <span class="string">ms</span>, <span class="attr">target pause time:</span> <span class="number">200.00</span> <span class="string">ms</span>]</span><br><span class="line">, <span class="number">0.0090963</span> <span class="string">secs</span>]</span><br><span class="line">   [<span class="attr">Parallel Time:</span> <span class="number">2.3</span> <span class="string">ms</span>, <span class="attr">GC Workers:</span> <span class="number">23</span>]</span><br><span class="line">      [<span class="string">GC</span> <span class="string">Worker</span> <span class="string">Start</span> <span class="string">(ms):</span> <span class="attr">Min:</span> <span class="number">13485239965.1</span>, <span class="attr">Avg:</span> <span class="number">13485239965.4</span>, <span class="attr">Max:</span> <span class="number">13485239965.7</span>, <span class="attr">Diff:</span> <span class="number">0.6</span>]</span><br><span class="line">      [<span class="string">Ext</span> <span class="string">Root</span> <span class="string">Scanning</span> <span class="string">(ms):</span> <span class="attr">Min:</span> <span class="number">0.0</span>, <span class="attr">Avg:</span> <span class="number">0.3</span>, <span class="attr">Max:</span> <span class="number">0.6</span>, <span class="attr">Diff:</span> <span class="number">0.6</span>, <span class="attr">Sum:</span> <span class="number">8.0</span>]</span><br><span class="line">      [<span class="string">Update</span> <span class="string">RS</span> <span class="string">(ms):</span> <span class="attr">Min:</span> <span class="number">0.1</span>, <span class="attr">Avg:</span> <span class="number">0.3</span>, <span class="attr">Max:</span> <span class="number">0.6</span>, <span class="attr">Diff:</span> <span class="number">0.5</span>, <span class="attr">Sum:</span> <span class="number">7.8</span>]</span><br><span class="line">         [<span class="attr">Processed Buffers: Min:</span> <span class="number">2</span>, <span class="attr">Avg:</span> <span class="number">5.7</span>, <span class="attr">Max:</span> <span class="number">11</span>, <span class="attr">Diff:</span> <span class="number">9</span>, <span class="attr">Sum:</span> <span class="number">131</span>]</span><br><span class="line">      [<span class="string">Scan</span> <span class="string">RS</span> <span class="string">(ms):</span> <span class="attr">Min:</span> <span class="number">0.0</span>, <span class="attr">Avg:</span> <span class="number">0.0</span>, <span class="attr">Max:</span> <span class="number">0.1</span>, <span class="attr">Diff:</span> <span class="number">0.1</span>, <span class="attr">Sum:</span> <span class="number">0.8</span>]</span><br><span class="line">      [<span class="string">Code</span> <span class="string">Root</span> <span class="string">Scanning</span> <span class="string">(ms):</span> <span class="attr">Min:</span> <span class="number">0.0</span>, <span class="attr">Avg:</span> <span class="number">0.0</span>, <span class="attr">Max:</span> <span class="number">0.0</span>, <span class="attr">Diff:</span> <span class="number">0.0</span>, <span class="attr">Sum:</span> <span class="number">0.3</span>]</span><br><span class="line">      [<span class="string">Object</span> <span class="string">Copy</span> <span class="string">(ms):</span> <span class="attr">Min:</span> <span class="number">0.2</span>, <span class="attr">Avg:</span> <span class="number">0.5</span>, <span class="attr">Max:</span> <span class="number">0.7</span>, <span class="attr">Diff:</span> <span class="number">0.4</span>, <span class="attr">Sum:</span> <span class="number">11.7</span>]</span><br><span class="line">      [<span class="string">Termination</span> <span class="string">(ms):</span> <span class="attr">Min:</span> <span class="number">0.0</span>, <span class="attr">Avg:</span> <span class="number">0.0</span>, <span class="attr">Max:</span> <span class="number">0.0</span>, <span class="attr">Diff:</span> <span class="number">0.0</span>, <span class="attr">Sum:</span> <span class="number">0.3</span>]</span><br><span class="line">         [<span class="attr">Termination Attempts: Min:</span> <span class="number">1</span>, <span class="attr">Avg:</span> <span class="number">1.0</span>, <span class="attr">Max:</span> <span class="number">1</span>, <span class="attr">Diff:</span> <span class="number">0</span>, <span class="attr">Sum:</span> <span class="number">23</span>]</span><br><span class="line">      [<span class="string">GC</span> <span class="string">Worker</span> <span class="string">Other</span> <span class="string">(ms):</span> <span class="attr">Min:</span> <span class="number">0.0</span>, <span class="attr">Avg:</span> <span class="number">0.2</span>, <span class="attr">Max:</span> <span class="number">0.3</span>, <span class="attr">Diff:</span> <span class="number">0.3</span>, <span class="attr">Sum:</span> <span class="number">3.6</span>]</span><br><span class="line">      [<span class="string">GC</span> <span class="string">Worker</span> <span class="string">Total</span> <span class="string">(ms):</span> <span class="attr">Min:</span> <span class="number">1.0</span>, <span class="attr">Avg:</span> <span class="number">1.4</span>, <span class="attr">Max:</span> <span class="number">1.9</span>, <span class="attr">Diff:</span> <span class="number">0.8</span>, <span class="attr">Sum:</span> <span class="number">32.6</span>]</span><br><span class="line">      [<span class="string">GC</span> <span class="string">Worker</span> <span class="string">End</span> <span class="string">(ms):</span> <span class="attr">Min:</span> <span class="number">13485239966.7</span>, <span class="attr">Avg:</span> <span class="number">13485239966.9</span>, <span class="attr">Max:</span> <span class="number">13485239967.0</span>, <span class="attr">Diff:</span> <span class="number">0.3</span>]</span><br><span class="line">   [<span class="attr">Code Root Fixup:</span> <span class="number">0.0</span> <span class="string">ms</span>]</span><br><span class="line">   [<span class="attr">Code Root Purge:</span> <span class="number">0.0</span> <span class="string">ms</span>]</span><br><span class="line">   [<span class="attr">Clear CT:</span> <span class="number">0.9</span> <span class="string">ms</span>]</span><br><span class="line">   [<span class="attr">Other:</span> <span class="number">5.9</span> <span class="string">ms</span>]</span><br><span class="line">      [<span class="attr">Choose CSet:</span> <span class="number">0.0</span> <span class="string">ms</span>]</span><br><span class="line">      [<span class="attr">Ref Proc:</span> <span class="number">1.9</span> <span class="string">ms</span>]</span><br><span class="line">      [<span class="attr">Ref Enq:</span> <span class="number">0.0</span> <span class="string">ms</span>]</span><br><span class="line">      [<span class="attr">Redirty Cards:</span> <span class="number">1.0</span> <span class="string">ms</span>]</span><br><span class="line">      [<span class="attr">Humongous Register:</span> <span class="number">0.0</span> <span class="string">ms</span>]</span><br><span class="line">      [<span class="attr">Humongous Reclaim:</span> <span class="number">0.0</span> <span class="string">ms</span>]</span><br><span class="line">      [<span class="attr">Free CSet:</span> <span class="number">0.2</span> <span class="string">ms</span>]</span><br><span class="line">   [<span class="attr">Eden:</span> <span class="number">4080.</span><span class="string">0M(4080.0M)-&gt;0.0B(4080.0M)</span> <span class="attr">Survivors:</span> <span class="number">16.</span><span class="string">0M-&gt;16.0M</span> <span class="attr">Heap:</span> <span class="number">4176.</span><span class="string">5M(8192.0M)-&gt;96.5M(8192.0M)</span>]</span><br><span class="line"> [<span class="attr">Times:</span> <span class="string">user=0.05</span> <span class="string">sys=0.00</span>, <span class="string">real=0.01</span> <span class="string">secs</span>]</span><br></pre></td></tr></table></figure><p>说明：GC 日志正常。</p><p><strong>Broker 错误日志</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">55</span>:<span class="number">15</span> ERROR BrokerControllerScheduledThread1 - SyncTopicConfig <span class="built_in">Exception</span>, x.x.x.x:<span class="number">10911</span> </span><br><span class="line">org.apache.rocketmq.remoting.exception.RemotingTimeoutException: wait response on the channel &lt;x.x.x.x:<span class="number">10909</span>&gt; timeout, <span class="number">3000</span>(ms)</span><br><span class="line">        at org.apache.rocketmq.remoting.netty.NettyRemotingAbstract.<span class="title function_ invoke__">invokeSyncImpl</span>(NettyRemotingAbstract.<span class="attr">java</span>:<span class="number">427</span>) ~[rocketmq-remoting-<span class="number">4.5</span>.<span class="number">2</span>.jar:<span class="number">4.5</span>.<span class="number">2</span>]</span><br><span class="line">        at org.apache.rocketmq.remoting.netty.NettyRemotingClient.<span class="title function_ invoke__">invokeSync</span>(NettyRemotingClient.<span class="attr">java</span>:<span class="number">375</span>) ~[rocketmq-remoting-<span class="number">4.5</span>.<span class="number">2</span>.jar:<span class="number">4.5</span>.<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>说明：通过查看 RocketMQ 的集群和 GC 日志，只能说明但是网络不可用，造成主从同步问题；并未发现 Broker 自身出问题了。</p><h3 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h3><p>系统使用 CentOS 6，内核版本为 2.6。通过摸排并未发现 broker 和 GC 本身的问题，却发现了系统 message 日志有频繁的“page allocation failure”和“blocked for more than 120 second”错误。所以将目光聚焦在系统层面，通过尝试系统参数设置，例如：min_free_kbytes 和 zone_reclaim_mode，然而并不能消除 CPU 毛刺问题。通过与社区朋友的会诊讨论，内核版本 2.6 操作系统内存回收存在 Bug。我们决定更换集群的操作系统。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>将集群的 CentOS 6 升级到 CentOS 7，内核版本也从 2.6 升级到了 3.10，升级后 CPU 毛刺问题不在乎出现。升级方式采取的方式先扩容后缩容，先把 CentOS 7 的节点加入集群后，再将 CentOS 6 的节点移除，详见前面实战部分“RocketMQ 集群平滑运维”。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Linux</span> <span class="selector-tag">version</span> <span class="number">3.10</span><span class="selector-class">.0-1062</span><span class="selector-class">.4</span><span class="selector-class">.1</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span> (mockbuild<span class="variable">@kbuilder</span>.bsys.centos.org) (gcc version <span class="number">4.8</span>.<span class="number">5</span> <span class="number">20150623</span> (Red Hat <span class="number">4.8</span>.<span class="number">5</span>-<span class="number">39</span>) (GCC) ) <span class="selector-id">#1</span> <span class="selector-tag">SMP</span> <span class="selector-tag">Fri</span> <span class="selector-tag">Oct</span> <span class="number">18</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">30</span> <span class="selector-tag">UTC</span> <span class="number">2019</span></span><br></pre></td></tr></table></figure><h2 id="集群频繁抖动发送超时"><a href="#集群频繁抖动发送超时" class="headerlink" title="集群频繁抖动发送超时"></a>集群频繁抖动发送超时</h2><h3 id="现象描述-2"><a href="#现象描述-2" class="headerlink" title="现象描述"></a>现象描述</h3><p>监控和业务同学反馈发送超时，而且频繁出现。具体现象如下图。</p><h3 id="预热现象"><a href="#预热现象" class="headerlink" title="预热现象"></a>预热现象</h3><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200910095246617.jpg" alt="img"></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200910095328878.jpg" alt="img"></p><p>说明：上图分别为开启预热时（<code>warmMapedFileEnable=true</code>）集群的发送 RT 监控、Broker 开启预热设置时的日志。</p><p><strong>存传输现象</strong></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200910095358560.jpg" alt="CPU 抖动"></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200910095449761.jpg" alt="img"></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200910095559121.jpg" alt="img"></p><p>说明：上图分别为开启堆外内存传输（<code>transferMsgByHeap=fals</code>e）时的 CPU 抖动截图、系统内存分配不足截图、Broker 日志截图。</p><h3 id="原因分析-2"><a href="#原因分析-2" class="headerlink" title="原因分析"></a>原因分析</h3><p>上面展现的两种显现均会导致集群 CPU 抖动、客户端发送超时，对业务造成影响。</p><p>预热设置：在预热文件时会填充 1 个 G 的假值 0 作为占位符，提前分配物理内存，防止消息写入时发生缺页异常。然而往往伴随着磁盘写入耗时过长、CPU 小幅抖动、业务具体表现为发送耗时过长，超时错误增多。关闭预热配置从集群 TPS 摸高情况来看并未有明显的差异，但是从稳定性角度关闭却很有必要。</p><p>堆外内存：transferMsgByHeap 设置为 false 时，通过堆外内存传输数据，相比堆内存传输减少了数据拷贝、零字节拷贝、效率更高。但是可能造成堆外内存分配不够，触发系统内存回收和落盘操作，设置为 true 时运行更加平稳。</p><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p>预热 warmMapedFileEnable 默认为 false，保持默认即可。如果开启了，可以通过热更新关闭。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/mqadmin updateBrokerConfig -b x.x.x.x:10911 -n x.x.x.x:9876 -k warmMapedFileEnable -v <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>内存传输参数 transferMsgByHeap 默认为 true（即：通过堆内内存传输）保持默认即可。如果关闭了，可以通过热更新开启。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/mqadmin updateBrokerConfig -b x.x.x.x:10911 -n x.x.x.x:9876 -k transferMsgByHeap -v <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="用了此属性消费性能下降一半"><a href="#用了此属性消费性能下降一半" class="headerlink" title="用了此属性消费性能下降一半"></a>用了此属性消费性能下降一半</h2><h3 id="现象描述-3"><a href="#现象描述-3" class="headerlink" title="现象描述"></a>现象描述</h3><p>配置均采用 8C16G，RocketMQ 的消费线程 20 个，通过测试消费性能在 1.5 万 tps 左右。通过 tcpdump 显示在消费的机器存在频繁的域名解析过程；10.x.x.185 向 DNS 服务器 100.x.x.136.domain 和 10.x.x.138.domain 请求解析。而 10.x.x.185 这台机器又是消息发送者的机器 IP，测试的发送和消费分别部署在两台机器上。</p><p>问题：消费时为何会有消息发送方的 IP 呢？而且该 IP 还不断进行域名解析。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200911100907927.jpg" alt="img"></p><h3 id="原因分析-3"><a href="#原因分析-3" class="headerlink" title="原因分析"></a>原因分析</h3><p>通过 dump 线程堆栈，如下图：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200911101209514.jpg" alt="img"></p><p>代码定位：在消费时有通过 MessageExt.bornHost.getBornHostNameString 获取消费这信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageExt</span> <span class="keyword">extends</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">5720810158625748049L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> queueId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> storeSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> queueOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sysFlag;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> bornTimestamp;</span><br><span class="line">    <span class="keyword">private</span> SocketAddress bornHost;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> storeTimestamp;</span><br><span class="line">    <span class="keyword">private</span> SocketAddress storeHost;</span><br><span class="line">    <span class="keyword">private</span> String msgId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> commitLogOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> bodyCRC;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> reconsumeTimes;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> preparedTransactionOffset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 GetBornHostNameString 获取 HostName 时会根据 IP 反查 DNS 服务器：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetSocketAddress inetSocketAddress = (InetSocketAddress)<span class="keyword">this</span>.bornHost;</span><br><span class="line"><span class="keyword">return</span> inetSocketAddress.getAddress().getHostName();</span><br></pre></td></tr></table></figure><h3 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h3><p>消费的时候不要使用 MessageExt.bornHost.getBornHostNameString 即可，去掉该属性，配置 8C16G 的机器消费性能在 3 万 TPS，提升了 1 倍。</p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ消息消费原理及实战</title>
      <link href="/2025/01/24/RocketMQ%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/"/>
      <url>/2025/01/24/RocketMQ%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="DefaultMQPushConsumer-核心参数与工作原理"><a href="#DefaultMQPushConsumer-核心参数与工作原理" class="headerlink" title="DefaultMQPushConsumer 核心参数与工作原理"></a>DefaultMQPushConsumer 核心参数与工作原理</h1><h2 id="Push模型消息拉取机制"><a href="#Push模型消息拉取机制" class="headerlink" title="Push模型消息拉取机制"></a>Push模型消息拉取机制</h2><p><img src="https://i0.hdslb.com/bfs/article/34094d07a066ff7e6475acf99c7d5e6e171301454.png" alt="image-20250126143819864"></p><p>其核心关键点如下：</p><ol><li>经过队列负载机制后，会分配给当前消费者一些队列，注意一个消费组可以订阅多个主题，正如上面 pullRequestQueue 中所示，topic_test、topic_test1 这两个主题都分配了一个队列。</li><li>轮流从 pullRequestQueue 中取出一个 PullRequest 对象，根据该对象中的拉取偏移量向 Broker 发起拉取请求，默认拉取 32 条，可通过上文中提到的 pullBatchSize 参数进行改变，该方法不仅会返回消息列表，还会返更改 PullRequest 对象中的下一次拉取的偏移量。</li><li>接收到 Broker 返回的消息后，会首先放入 ProccessQueue（处理队列），该队列的内部结构为 TreeMap，key 存放的是消息在消息消费队列（consumequeue）中的偏移量，而 value 为具体的消息对象。</li><li>然后将拉取到的消息提交到消费组内部的线程池，并立即返回，并将 PullRequest 对象放入到 pullRequestQueue 中，然后取出下一个 PullRequest 对象继续重复消息拉取的流程，从这里可以看出，消息拉取与消息消费是不同的线程。</li><li>消息消费组线程池处理完一条消息后，会将消息从 ProccessQueue 中，然后会向 Broker 汇报消息消费进度，以便下次重启时能从上一次消费的位置开始消费。</li></ol><h3 id="消息消费进度提交"><a href="#消息消费进度提交" class="headerlink" title="消息消费进度提交"></a>消息消费进度提交</h3><p>通过上面的介绍，想必读者应该对消息消费进度有了一个比较直观的认识，接下来我们再来介绍一下 RocketMQ PUSH 模式的消息消费进度提交机制。</p><p>通过上文的消息消费拉取模型可以看出，消息消费组线程池在处理完一条消息后，会将消息从 ProccessQueue 中移除，并向 Broker 汇报消息消费进度，那请大家思考一下下面这个问题：</p><p><img src="https://i0.hdslb.com/bfs/article/82c160432118244a2ece7530177c739c171301454.png" alt="image-20250126143838943"></p><p>例如现在处理队列中有 5 条消息，并且是线程池并发消费，那如果消息偏移量为 3 的消息（3:msg3）先于偏移量为 0、1、2 的消息处理完，那向 Broker 如何汇报消息消费进度呢？</p><p>有读者朋友说，消息 msg3 处理完，当然是向 Broker 汇报 msg3 的偏移量作为消息消费进度呀。但细心思考一下，发现如果提交 msg3 的偏移量为消息消费进度，那汇报完毕后如果消费者发生内存溢出等问题导致 JVM 异常退出，msg1 的消息还未处理，然后重启消费者，由于消息消费进度文件中存储的是 msg3 的消息偏移量，会继续从 msg3 开始消费，会造成<strong>消息丢失</strong>。显然这种方式并不可取。</p><p>RocketMQ 采取的方式是处理完 msg3 之后，会将 msg3 从消息处理队列中移除，但在向 Broker 汇报消息消费进度时是<strong>取 ProceeQueue 中最小的偏移量为消息消费进度</strong>，即汇报的消息消费进度是 0。</p><p><img src="https://i0.hdslb.com/bfs/article/dba0487f9bf6e1bf234d2f3ce58b14df171301454.png" alt="image-20250126143931458"></p><p>即如果处理队列如上图所示，那提交的消息进度为 2。但这种方案也并非完美，有可能会造成消息重复消费，例如如果发生内存溢出等异常情况，消费者重新启动，会继续从消息偏移量为 2 的消息开始消费，msg3 就会被消费多次，故<strong>RocketMQ 不保证消息重复消费</strong>。</p><p>消息消费进度具体的提交流程如下图所示：</p><p><img src="https://i0.hdslb.com/bfs/article/00a14766630dc1a91146c33fbe28460b171301454.png" alt="image-20250126144455180"></p><p>从这里也可以看成，为了减少消费者与 Broker 的网络交互，提高性能，提交消息消费进度时会首先存入到本地缓存表中，然后定时上报到 Broker，同样 Broker 也会首先存储本地缓存表，然后定时刷写到磁盘。</p><h2 id="Push模型参数注意事项"><a href="#Push模型参数注意事项" class="headerlink" title="Push模型参数注意事项"></a>Push模型参数注意事项</h2><h3 id="ConsumeFromWhere-注意事项"><a href="#ConsumeFromWhere-注意事项" class="headerlink" title="ConsumeFromWhere 注意事项"></a>ConsumeFromWhere 注意事项</h3><p>下面首先先看一段 RokcetMQ PUSH 模式消费者的常见使用方式：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815222732166.png" alt="1"></p><p>构建需要通过 setConsumeFromWhere(…) 指定从哪消费，正如上篇提到的，RocketMQ 支持从最新消息、最早消息、指定时间戳这三种方式进行消费。大家可以思考一下，如果一个消费者启动运行了一段时间，由于版本发布等原因需要先停掉消费者，代码更新后，再启动消费者时消费者还能使用上面这三种策略，从新的一条消息消费吗？如果是这样，在发版期间新发送的消息将全部丢失，这显然是不可接受的，要从上一次开始消费的时候消费，才能保证消息不丢失。</p><p><strong>故 ConsumeFromWhere 这个参数的含义是，初次启动从何处开始消费。更准确的表述是，如果查询不到消息消费进度时，从什么地方开始消费</strong>。</p><p>所以在实际使用过程中，如果对于一个设置为 CONSUME_FROM_FIRST_OFFSET 的运行良久的消费者，当前版本的业务逻辑进行了重大重构，而且业务希望是从最新的消息开始消费，想通过如下代码来实现其业务意图，则显然是不成功的。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer<span class="selector-class">.setConsumeFromWhere</span>(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);</span><br></pre></td></tr></table></figure><p>上面做法是错误的，要达到业务目标，需要使用 RocketMQ 提供的重置位点，其命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh ./mqadmin resetOffsetByTime -n 127.0.0.1:9876  -g CID_CONSUMER_TEST -t TopicTest -s now</span><br></pre></td></tr></table></figure><p>其中参数说明如下：</p><ul><li>-n：NameServer 地址</li><li>-g：消费组名称</li><li>-t：主题名称</li><li>-s：时间戳，可选值为 now、时间戳（毫秒）、yyyy-MM-dd#HH:mm:ss:SSS</li></ul><p>当然也可以通过 RocketMQ-Console 重置位点，操作如下图所示：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815222739573.png" alt="2"></p><h3 id="消费组线程数设置注意事项"><a href="#消费组线程数设置注意事项" class="headerlink" title="消费组线程数设置注意事项"></a>消费组线程数设置注意事项</h3><p>在 RocketMQ 中，每一个消费组都会启动一个线程池用来实现消费端在消费组的隔离，RocketMQ 也提供了 consumeThreadMin、consumeThreadMax 两个参数来设置线程池中的线程个数，但是由于线程池内部持有的队列为一个无界队列，导致 consumeThreadMax 大于 consumeThreadMin，线程个数最大也只能 consumeThreadMin 个线程数量，故在实践中，往往会将这两个值设置为相同，避免给大家带来一种误解，在消息端消息很多的情况，会创建更多的线程来提高消息的处理速率。</p><p>小技巧：RocketMQ 中的消费组线程的名称会以 ConsumeMessageThread_ 开头，例如下图。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815222942104.png" alt="9"></p><h3 id="批量消费注意事项"><a href="#批量消费注意事项" class="headerlink" title="批量消费注意事项"></a>批量消费注意事项</h3><p>RocketMQ 支持消息批量消费，在消费端与批量消费相关的两个参数分别为：</p><ul><li><strong>pullBatchSize</strong>：消息客户端一次向 Broker 发送拉取消息每批返回最大的消息条数，默认为 32。</li><li><strong>consumeMessageBatchMaxSize</strong>：提交到消息消费监听器中的消息条数，默认为 1。</li></ul><h4 id="consumeMessageBatchMaxSize"><a href="#consumeMessageBatchMaxSize" class="headerlink" title="consumeMessageBatchMaxSize"></a><strong>consumeMessageBatchMaxSize</strong></h4><p>默认情况下一次消息会拉取 32 条消息，但业务监听器收到的消息默认一条，为了更直观对其了解，现给出如下示例代码：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815222950456.png" alt="10"></p><p>如果将 consumeMessageBatchMaxSize 设置 10，其运行效果如下图所示：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815222958233.png" alt="11"></p><p>可以看到该参数生效了，consumeMessageBatchMaxSize 这个参数非常适合批处理，例如结合数据库的批处理，能显著提高性能。</p><h4 id="pullBatchSize"><a href="#pullBatchSize" class="headerlink" title="pullBatchSize"></a><strong>pullBatchSize</strong></h4><p>大家发现了一个问题，如果单条消息的处理时间较快，通过增加消费组线程个数无法显著提高消息的消费 TPS，并且通过 jstack 命令，看到几乎所有的线程都处于等待处理任务，其截图类似如下：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815223006940.png" alt="12"></p><p>此种情况说明线程都“无所事事”，应该增大其工作量，自然而然地需要增大每一批次消息拉取的数量。故尝试每一次消息拉取 100 条，每批消费 50 条。即通过如下代码进行设置：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">consumer<span class="selector-class">.setPullBatchSize</span>(<span class="number">100</span>);</span><br><span class="line">consumer<span class="selector-class">.setConsumeMessageBatchMaxSize</span>(<span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>这里设置 consumeMessageBatchMaxSize 的值大于 pullBatchSize 的主要目的，就是验证每一次拉取的消息，因为如果 consumeMessageBatchMaxSize 大于 pullBatchSize，那每次批处理的消息条数等于 pullBatchSize，如果 consumeMessageBatchMaxSize 小于 pullBatchSize，会在客户端分页，然后尽最大可能一次传入 consumeMessageBatchMaxSize 条消息。</p><p>为了确保有足够的消息，在消息拉取之前，我建议先使用生产者压入大量消息。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815223014316.png" alt="13"></p><p>发现每批拉取的条数最多不会超过 32，显然服务端有足够的消息够拉取。</p><p>这是因为 Broker 端对消息拉取也提供了保护机制，同样有参数可以控制一次拉取最多返回消息的条数，其参数主要如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxTransferCountOnMessageInMemory</span><br></pre></td></tr></table></figure><p>如果此次消息拉取能全部命中，内存允许一次消息拉取的最大条数，默认值为 32 条。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxTransferBytesOnMessageInMemory</span><br></pre></td></tr></table></figure><p>如果此次消息拉取能全部命中，内存允许一次消息拉取的最大消息大小，默认为 256K。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxTransferCountOnMessageInDisk</span><br></pre></td></tr></table></figure><p>如果此次消息无法命中，内存需要从磁盘读取消息，则每一次拉取允许的最大条数，默认为 8。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxTransferBytesOnMessageInDisk</span><br></pre></td></tr></table></figure><p>如果此次消息无法命中，内存需要从磁盘读取消息，则每一次拉取允许的消息总大小，默认为 64K。</p><p>故如果需要一次拉取 100 条消息，还需要修改 broker 端相关的配置信息，通常建议修只修改命中内存相关的，如果要从磁盘拉取，为了包含 Broker，maxTransferCountOnMessageInDisk、maxTransferBytesOnMessageInDisk 保持默认值。</p><p>如果使用场景是大数据领域，建议的配置如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxTransferCountOnMessageInMemory</span>=<span class="number">5000</span></span><br><span class="line"><span class="attr">maxTransferBytesOnMessageInMemory</span> = <span class="number">5000</span> * <span class="number">1024</span></span><br></pre></td></tr></table></figure><p>如果是业务类场景，建议配置如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxTransferCountOnMessageInMemory</span>=<span class="number">2000</span></span><br><span class="line"><span class="attr">maxTransferBytesOnMessageInMemory</span> = <span class="number">2000</span> * <span class="number">1024</span></span><br></pre></td></tr></table></figure><p>修改 Broker 相关配置后，再运行上面的程序，其返回结果如下：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815223025190.png" alt="14"></p><h3 id="订阅关系不一致导致消息丢失"><a href="#订阅关系不一致导致消息丢失" class="headerlink" title="订阅关系不一致导致消息丢失"></a>订阅关系不一致导致消息丢失</h3><p>在 RocketMQ 中，一个消费组能订阅多个主题，也能订阅多个 Tag，多个 Tag 用 <code>||</code> 分割，但同一个消费组中的所有消费者的订阅关系必须一致，不能一个订阅 TAGA，另外一个消费者却订阅 TAGB</p><p>一条消息的 Tag 为 TAGA，并且消费组 dw_tag_test 其中一个消费者有订阅 TAGA，那为什么还会显示 CONSUMED_BUT_FILTERED，这个状态代表的含义是，该条消息不符合消息过滤规则被过滤了，其原理图如下所示：</p><p><img src="https://i0.hdslb.com/bfs/article/c70b4316cb1046213a2aad1790d2bd75171301454.png" alt="image-20250126150301779"></p><p>其本质原因是，一个队列同一时间只会分配给一个消费者，这样队列上不符合的消息消费会被过滤，并且消息消费进度会向前移动，这样就会造成消息丢失。</p><h1 id="DefaultLitePullConsumer-核心参数与实战"><a href="#DefaultLitePullConsumer-核心参数与实战" class="headerlink" title="DefaultLitePullConsumer 核心参数与实战"></a>DefaultLitePullConsumer 核心参数与实战</h1><p>DefaultMQPullConsumer（PULL 模式）的 API 太底层，使用起来及其不方便，RocketMQ 官方设计者也注意到这个问题，为此在 RocketMQ 4.6.0 版本中引入了 PULL 模式的另外一个实现类 DefaultLitePullConsumer，即从 4.6.0 版本后，DefaultMQPullConsumer 已经被标记为废弃，故接下来将重点介绍 DefaultLitePullConsumer，并探究如何在实际中运用它解决相关问题。</p><h2 id="Lite-Pull-与-PUSH-模式之对比"><a href="#Lite-Pull-与-PUSH-模式之对比" class="headerlink" title="Lite Pull 与 PUSH 模式之对比"></a>Lite Pull 与 PUSH 模式之对比</h2><p>从上面的示例可以看出 Lite PULL 相关的 API 比 4.6.0 之前的 DefaultMQPullConsumer 的使用上要简便不少，从编程风格上已非常接近了 PUSH 模式，其底层的实现原理是否也一致呢？显然不是的，请听我我慢慢道来。</p><p>不知大家是否注意到，Lite PULL 模式下只是通过 poll() 方法拉取一批消息，然后提交给应用程序处理，<strong>采取自动提交模式下位点的提交与消费结果并没有直接挂钩，即消息如果处理失败，其消费位点还是继续向前继续推进，缺乏消息的重试机制。</strong>为了论证笔者的观点，这里给出 DefaultLitePullConsumer 的 poll() 方法执行流程图，请大家重点关注位点提交所处的位置。</p><p><img src="https://i0.hdslb.com/bfs/article/3534cd914ea4286dc343cd52a9267d9f171301454.png" alt="image-20250126151333790"></p><p><strong>Lite Pull 模式的自动提交位点，一个非常重要的特征是 poll() 方法一返回，这批消息就默认是消费成功了</strong>，一旦没有处理好，就会造成消息丢失，那有没有方法解决上述这个问题呢，<strong>seek 方法就闪亮登场了</strong>，在业务方法处理过程中，如果处理失败，可以通过 seek 方法重置消费位点，即在捕获到消息业务处理后，需要根据返回的第一条消息中（MessageExt）信息构建一个 MessageQueue 对象以及需要重置的位点。</p><p>Lite Pull 模式的消费者相比 PUSH 模式的另外一个不同点是 Lite Pull 模式没有消息消费重试机制，PUSH 模式在并发消费模式下默认提供了 16 次重试，并且每一次重试的间隔不一致，极大的简化了编程模型。在这方面 Lite Pull 模型还是会稍显复杂。</p><p>Lite Pull 模式针对 PUSH 模式一个非常大亮点是消息拉取线程是以消息消费组为维度的，而且一个消费者默认会创建 20 个拉取任务，在消息拉取效率方面比 PUSH 模型具有无可比拟的优势，特别适合大数据领域的批处理任务，即每隔多久运行一次的拉取任务。</p><h3 id="消息位点"><a href="#消息位点" class="headerlink" title="消息位点"></a>消息位点</h3><p>消息是按到达服务端的先后顺序存储在指定主题的多个队列中，每条消息在队列中都有一个唯一的Long类型坐标，这个坐标被定义为消息位点。</p><p>队列中最早一条消息的位点为最小消息位点（MinOffset）；最新一条消息的位点为最大消息位点（MaxOffset）。虽然消息队列逻辑上是无限存储，但由于服务端物理节点的存储空间有限，云消息队列 RocketMQ 版会滚动删除队列中存储最早的消息。因此，消息的最小消费位点和最大消费位点会一直递增变化。</p><h3 id="消费位点"><a href="#消费位点" class="headerlink" title="消费位点"></a>消费位点</h3><p>每个主题的队列都可以被多个消费者分组订阅。若某条消息被某个消费者消费后直接被删除，则其他订阅了该主题的消费者将无法消费该消息。</p><p>因此，云消息队列 RocketMQ 版通过消费位点管理消息的消费进度。每条消息被某个消费者消费完成后不会立即在队列中删除，云消息队列 RocketMQ 版会<strong>基于每个消费者分组维护一份消费记录</strong>，该记录指定消费者分组消费某一个队列时，消费过的最新一条消息的位点，即消费位点。</p><p>当消费者客户端离线，又再次重新上线时，会严格按照服务端保存的消费进度继续处理消息。如果服务端保存的历史位点信息已过期被删除，此时消费位点向前移动至服务端存储的最小位点。</p><p>因此，不同应用需要设置不同的消费者组，每个应用都能独立地接收和处理该 Topic 下的所有消息，互不干扰。而且消息队列会为每个消费者组独立记录其在 Topic 中的消费位点（offset）。这意味着每个消费者组都可以从自己上次消费的位置继续消费，互不影响。</p><h3 id="长轮询实现原理"><a href="#长轮询实现原理" class="headerlink" title="长轮询实现原理"></a>长轮询实现原理</h3><p>PULL 模式通常适合大数据领域的批处理操作，对消息的实时性要求不高，更加看重的是消息的拉取效率，即一次消息需要拉取尽可能多的消息，这样方便一次性对大量数据进行处理，提高数据的处理效率，特别是希望一次消息拉取再不济也要拉取点消息，不要出现太多无效的拉取请求（没有返回消息的拉取请求）。</p><p>首先大家来看一下如下这个场景：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200817190929584.png" alt="5"></p><p>即 Broker 端没有新消息时，Broker 端采取何种措施呢？我想基本有如下两种策略进行选择：</p><ul><li>Broker 端没有新消息，立即返回，拉取结果中不包含任何消息。</li><li>当前拉取请求在 Broker 端挂起，在 Broker 端挂起，并且轮询 Broker 端是否有新消息，即轮询机制。</li></ul><p>上面说的第二种方式，有一个“高大上”的名字——<strong>轮询</strong>，根据轮询的方式又可以分为<strong>长轮询、短轮询</strong>。</p><ul><li><strong>短轮询</strong>：第一次未拉取到消息后等待一个时间间隔后再试，默认为 1s，可以在 Broker 的配置文件中设置 shortPollingTimeMills 改变默认值，即轮询一次，<strong>注意：只轮询一次</strong>。</li><li><strong>长轮询</strong>：可以由 PULL 客户端设置在 Broker 端挂起的超时时间，默认为 20s，然后在 Broker 端没有拉取到消息后默认每隔 5s 一次轮询，并且在 Broker 端获取到新消息后，会唤醒拉取线程，结束轮询，尝试一次消息拉取，然后返回一批消息到客户端，长轮询的时序图如下所示：</li></ul><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200817190938839.png" alt="6"></p><p>从这里可以看出，长轮询比短轮询，轮询等待的时间长，短轮询只轮询一次，并且默认等待时间为 1s，而长轮询默认一次阻塞 5s，但支持被唤醒。</p><p>在 broker 端与长轮询相关的参数如下：</p><ul><li>longPollingEnable：是否开启长轮询，默认为 true。</li><li>shortPollingTimeMills：短轮询等待的时间，默认为 1000，表示 1s。</li></ul><h2 id="结合实际场景顺序消费、消息过滤实战"><a href="#结合实际场景顺序消费、消息过滤实战" class="headerlink" title="结合实际场景顺序消费、消息过滤实战"></a>结合实际场景顺序消费、消息过滤实战</h2><h3 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h3><h4 id="业务场景描述"><a href="#业务场景描述" class="headerlink" title="业务场景描述"></a><strong>业务场景描述</strong></h4><p>现在开发一个银行类项目，对用户的每一笔余额变更都需要发送短信通知到用户。如果用户同时在电商平台下单，转账两个渠道在同一时间进行了余额变更，此时用户收到的短信必须顺序的，例如先网上购物，消费了 128，余额 1000，再转账给朋友 200，剩余余额 800，如果这两条短信的发送顺序颠倒，给用户会带来很大的困扰，故在该场景下必须保证顺序。这里所谓的顺序，是针对同一个账号的，不同的账号无需保证顺序性，例如用户 A 的余额发送变更，用户 B 的余额发生变更，这两条短信的发送其实相互不干扰的，故不同账号之间无需保证顺序。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><p>本篇代码主要采用截图的方式展示其关键代码，并对其进行一些简单的解读。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200823180055930.png" alt="1"></p><p>首先这里的主业务是操作账户的余额，然后是余额变更后需要发短信通知给用户，但由于发送短信与账户转载是两个相对独立但又紧密的操作，故这里可以引入消息中间件来解耦这两个操作。但由于发送短信业务，其顺序一定要与扣款的顺序保证一致，故需要使用顺序消费。</p><p>由于 RocketMQ 只提供了消息队列的局部有序，故如果要实现某一类消息的顺序执行，就必须将这类消息发送到同一个队列，故这里在消息发送时使用了 MessageQueueSelector，并且使用用户账户进行队列负载，这样同一个账户的消息就会账号余额变更的顺序到达队列，然后队列中的消息就能被顺序消费。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/2020082318010499.png" alt="2"></p><p>顺序消费的事件监听器为 MessageListenerOrderly，表示顺序消费。</p><p>顺序消费在使用上比较简单，那 RocketMQ 顺序消费是如何实现的？队列重新负载时还能保持顺序消费吗？顺序消费会重复消费吗？</p><h4 id="RocketMQ-顺序消费原理简述"><a href="#RocketMQ-顺序消费原理简述" class="headerlink" title="RocketMQ 顺序消费原理简述"></a><strong>RocketMQ 顺序消费原理简述</strong></h4><p>在 RocketMQ 中，PUSH 模式的消息拉取模型如下图所示：</p><p><img src="https://i0.hdslb.com/bfs/article/34094d07a066ff7e6475acf99c7d5e6e171301454.png" alt="image-20250126143819864"></p><p>上述流程在前面的章节中已做了详述，这里不再累述，这里想重点突出线程池。</p><p>RocketMQ 消息消费端按照消费组进行的线程隔离，即每一个消费组都会创建已线程池，由一个线程池负责分配的所有队列中的消息。</p><p><strong>所以要保证消费端对单队列中的消息顺序处理，故多线程处理，需要按照消息消费队列进行加锁。</strong>故顺序消费在消费端的并发度并不取决消费端线程池的大小，而是取决于分给给消费者的队列数量，故如果一个 Topic 是用在顺序消费场景中，建议消费者的队列数设置增多，可以适当为非顺序消费的 2~3 倍，这样有利于提高消费端的并发度，方便横向扩容。</p><p>消费端的横向扩容或 Broker 端队列个数的变更都会触发消息消费队列的重新负载，在并发消息时在队列负载的时候一个消费队列有可能被多个消费者同时消息，但顺序消费时并不会出现这种情况，因为顺序消息不仅仅在消费消息时会锁定消息消费队列，在分配到消息队列时，<strong>能从该队列拉取消息还需要在 Broker 端申请该消费队列的锁</strong>，即同一个时间只有一个消费者能拉取该队列中的消息，确保顺序消费的语义。</p><p>从前面的文章中也介绍到并发消费模式在消费失败是有重试机制，默认重试 16 次，而且重试时是先将消息发送到 Broker，然后再次拉取到消息，这种机制就会丧失其消费的顺序性，故如果是顺序消费模式，消息重试时在消费端不停的重试，重试次数为 Integer.MAX_VALUE，<strong>即如果一条消息如果一直不能消费成功，其消息消费进度就会一直无法向前推进，即会造成消息积压现象。</strong></p><blockquote><p>温馨提示：顺序消息时一定要捕捉异常，必须能区分是系统异常还是业务异常，更加准确的要能区分哪些异常是通过重试能恢复的，哪些是通过重试无法恢复的。无法恢复的一定要尽量在发送到 MQ 之前就要拦截，并且需要提高告警功能。</p></blockquote><h3 id="消息过滤实战"><a href="#消息过滤实战" class="headerlink" title="消息过滤实战"></a>消息过滤实战</h3><h4 id="业务场景描述-1"><a href="#业务场景描述-1" class="headerlink" title="业务场景描述"></a><strong>业务场景描述</strong></h4><p>例如公司采用的是微服务架构，分为如下几个子系统，基础数据、订单模块、商家模块，各个模块的数据库都是独立的。微服务带来的架构伸缩性不容质疑，但数据库的相互独立，对于基础数据的 join 操作就不那么方便了，即在订单模块需要使用基础数据，还需要通过 Dubbo 服务的方式去请求接口，为了避免接口的调用，基础数据的数据量又不是特别多的情况，项目组更倾向于将基础数据的数据同步到各个业务模块的数据库，然后基础数据发生变化及时通知订单模块，这样与基础数据的表 join 操作就可以在本库完成。</p><h4 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a><strong>技术方案</strong></h4><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200823180123686.png" alt="4"></p><p>上述方案的关键思路：</p><ol><li>基础数据一旦数据发生变化，就向 MQ 的 base_data_topic 发送一条消息。</li><li>下游系统例如订单模块、商家模块订阅 base_data_topic 完成数据的同步。</li></ol><p>问题，如果订单模块出现一些不可预知的错误，导致数据同步出现异常，并且发现的时候，存储在 MQ 中的消息已经被删除，此时需要上游（基础数据）重推数据，这个时候，如果基础数据重推的消息直接发送到 base_data_topic，那该 Topic 的所有消费者都会消费到，这显然是不合适的。怎么解决呢？</p><p>通常有两种办法：</p><ul><li>为各个子模块创建另外一个主题，例如 retry_ods_base_data_topic，这样需要向哪个子系统就向哪个 Topic 发送。</li><li>引入 Tag 机制。</li></ul><p>本节主要来介绍一下 Tag 的思路。</p><p>首先，正常情况下，基础模块将数据变更发送到 base_data_topic，并且消息的 Tag 为 all。然后为每一个子系统定义一个单独的重推 Tag，例如 ods、shop。</p><p>消费端同时订阅 all 和各自的重推 Tag，完美解决问题。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><p>在消息发送时需要按照需求指定消息的 Tag，其示例代码如下：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200823180130930.png" alt="5"></p><p>然后在消息消费时订阅时，更加各自的模块订阅各自关注的 Tag，其示例代码如下：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200823180139407.png" alt="6"></p><p>在消息订阅时一个消费组可以订阅多个 Tag，多个 Tag 使用双竖线分隔。</p><h4 id="Topic-与-Tag-之争"><a href="#Topic-与-Tag-之争" class="headerlink" title="Topic 与 Tag 之争"></a><strong>Topic 与 Tag 之争</strong></h4><p>用 Tag 对同一个主题进行区分会引来一个“副作用”，就是在重置消息消费位点时该消费组需要“处理”的是所有标签的数据，虽然在 Broker 端、消息消费端最终会过滤，不符合 Tag 的消息并不会执行业务逻辑，但在消息拉取时还是需要将消息读取到 PageCache 中并进行过滤，会有一定的性能损耗，但这个不是什么大问题。</p><p>在数据推送这个场景，除了使用 Tag 机制来区分重推数据外，也可以为重推的数据再申请一个额外的主题，即通过主题来区分不同的数据，这种方案倒不说不可以，但这个在运维管理层面需要申请众多的 Topic，而这类 Topic 存储的其实是一类数据，使用不同的 Topic 存储同类数据，会显得较为松散。当然如果是不同的业务场景，就建议使用 Topic 来隔离。</p><h4 id="消息过滤常见问题"><a href="#消息过滤常见问题" class="headerlink" title="消息过滤常见问题"></a>消息过滤常见问题</h4><ol><li>多个消费者订阅同一个Topic下的不同Tag，出现消息丢失情况。</li></ol><p>可能原因：若多个消费者是通过同一个消费者分组（Group ID）订阅的指定Topic，则所有消费者的过滤条件即订阅的Tag要一致，否则会出现订阅关系不一致，导致部分消息丢失。</p><ol start="2"><li>消费者在线无消费消息，但Group有堆积。</li></ol><p>采用SQL&#x2F;TAG消费过滤的方式，未被过滤条件命中的消息会计算为消息堆积，堆积量的计算如下所示。</p><p><img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/0584115371/CAEQTxiBgMDLjcy2jBkiIDhkM2MyMGRmNTI1MDQ1ODNhMTYzZGJiYTRhYTkxNTIw4618633_20240826151619.705.svg" alt="image"></p><ul><li>SQL消费方式：堆积量 &#x3D; 已就绪的消息量 + 处理中的消息量 - 未被SQL命中的消息数量。</li><li>TAG消费方式：堆积量 &#x3D;（已就绪的消息量 + 处理中的消息量）* TAG标签消息百分比。</li></ul>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM调优实战——解决内存占用高问题</title>
      <link href="/2025/01/23/JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E9%AB%98%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/23/JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E9%AB%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM启动后一段时间内内存占用飙升"><a href="#JVM启动后一段时间内内存占用飙升" class="headerlink" title="JVM启动后一段时间内内存占用飙升"></a>JVM启动后一段时间内内存占用飙升</h1><p>如下，是我们一服务重启后运行快2天的内存占用情况，可以发现内存一直从45%涨到了62%，8G的容器，上涨内存大小为1.36G！</p><p><img src="https://img2023.cnblogs.com/blog/2792815/202308/2792815-20230826194514366-332827220.png" alt="image_2023-08-26_20230826181426"></p><p>但我们这个服务其实没有内存泄露问题，因为JVM为堆申请的内存是虚拟内存，如4.8G，但在启动后JVM一开始可能实际只使用了3G内存，导致Linux实际只分配了3G。</p><p>然后在gc时，由于会复制存活对象到堆的空闲部分，如果正好复制到了以前未使用过的区域，就又会触发Linux进行内存分配，故一段时间内内存占用会越来越多，直到堆的所有区域都被touch到。</p><p><img src="https://img2023.cnblogs.com/blog/2792815/202308/2792815-20230826194514377-1068982994.png" alt="image_2023-08-26_20230826181452"></p><p>而通过添加JVM参数<code>-XX:+AlwaysPreTouch</code>，可以让JVM为堆申请虚拟内存后，立即把堆全部touch一遍，使得堆区域全都被分配物理内存，而由于Java进程主要活动在堆内，故后续内存就不会有很大变化了，我们另一服务添加了此参数，内存表现如下：</p><p><img src="https://img2023.cnblogs.com/blog/2792815/202308/2792815-20230826194514283-503639924.png" alt="image_2023-08-26_20230826181512"></p><p>可以看到，内存上涨幅度不到2%，无此参数可以提高内存利用度，加此参数则会使应用运行得更稳定。</p><p>如我们之前一服务一周内会有1到2次GC耗时超过2s，当我添加此参数后，再未出现过此情况。这是因为当无此参数时，若GC访问到了未读写区域，会触发Linux分配内存，大多数情况下此过程很快，但有极少数情况下会较慢，在GC日志中则表现为sys耗时较高。</p><p><img src="https://img2023.cnblogs.com/blog/2792815/202308/2792815-20230826194514361-1454953680.png" alt="image_2023-08-26_20230826191255"></p><h1 id="长连接Netty服务内存泄漏"><a href="#长连接Netty服务内存泄漏" class="headerlink" title="长连接Netty服务内存泄漏"></a>长连接Netty服务内存泄漏</h1><p>为了本地复现<code>Netty</code>泄漏，定位详细的内存泄漏代码，我们需要做这几步：</p><p>1、配置足够小的本地JVM内存，以便快速模拟堆外内存泄漏。</p><p>如图，我们设置PermSize&#x3D;30M, MaxPermSize&#x3D;43M</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-1623505/7bad239a7e433f3d67d758743cb2b37f.png" alt="img"></p><p>2、模拟足够多的长连接请求，我们使用Postman定时批量发请求，以达到服务的堆外内存泄漏。</p><p>启动项目，通过<code>JProfiler</code> JVM监控工具，我们观察到内存缓慢的增长，最终触发了本地<code>Netty</code>的堆外内存泄漏，本地复现成功：</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-1623505/9b8c75f6d2fbcf2d7572c62794535111.png" alt="img"></p><p>3、开启<code>Netty</code>的高级内存泄漏检测级别，JVM参数如下：</p><p>-Dio.netty.leakDetectionLevel&#x3D;advanced</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-1623505/5fa81cb6e671a918d3c85c004b7b79ac.png" alt="img"></p><p>再启动项目，模拟请求，达到本地应用JVM内存泄漏，Netty输出如下具体日志信息，可以看到，具体的日志信息比之前的信息更加完善：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-09-<span class="number">24</span> <span class="number">20</span>:<span class="number">11</span>:<span class="number">59.078</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] INFO  io.netty.handler.logging.LoggingHandler [<span class="number">101</span>] - [id: <span class="number">0x2a5e5026</span>, L:/<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">8883</span>] READ: [id: <span class="number">0x926e140c</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8883</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">58920</span>]</span><br><span class="line"><span class="number">2020</span>-09-<span class="number">24</span> <span class="number">20</span>:<span class="number">11</span>:<span class="number">59.078</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] INFO  io.netty.handler.logging.LoggingHandler [<span class="number">101</span>] - [id: <span class="number">0x2a5e5026</span>, L:/<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">8883</span>] READ COMPLETE</span><br><span class="line"><span class="number">2020</span>-09-<span class="number">24</span> <span class="number">20</span>:<span class="number">11</span>:<span class="number">59.079</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">8</span>] ERROR io.netty.util.ResourceLeakDetector [<span class="number">171</span>] - LEAK: ByteBuf.release() was not called before it<span class="string">&#x27;s garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.</span></span><br><span class="line"><span class="string">WARNING: 1 leak records were discarded because the leak record count is limited to 4. Use system property io.netty.leakDetection.maxRecords to increase the limit.</span></span><br><span class="line"><span class="string">Recent access records: 5</span></span><br><span class="line"><span class="string">#5:</span></span><br><span class="line"><span class="string">  io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.readBytes(AdvancedLeakAwareCompositeByteBuf.java:476)</span></span><br><span class="line"><span class="string">  io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.readBytes(AdvancedLeakAwareCompositeByteBuf.java:36)</span></span><br><span class="line"><span class="string">  com.jd.jr.keeplive.front.service.nettyServer.handler.LongRotationServerHandler.getClientMassageInfo(LongRotationServerHandler.java:169)</span></span><br><span class="line"><span class="string">  com.jd.jr.keeplive.front.service.nettyServer.handler.LongRotationServerHandler.handleHttpFrame(LongRotationServerHandler.java:121)</span></span><br><span class="line"><span class="string">  com.jd.jr.keeplive.front.service.nettyServer.handler.LongRotationServerHandler.channelRead(LongRotationServerHandler.java:80)</span></span><br><span class="line"><span class="string">  io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)</span></span><br><span class="line"><span class="string">  io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)</span></span><br><span class="line"><span class="string">  io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)</span></span><br><span class="line"><span class="string">  io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)</span></span><br><span class="line"><span class="string">  ......</span></span><br><span class="line"><span class="string">#4:</span></span><br><span class="line"><span class="string">  Hint: &#x27;</span>LongRotationServerHandler#<span class="number">0</span><span class="string">&#x27; will handle the message from this point.</span></span><br><span class="line"><span class="string">  io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.touch(AdvancedLeakAwareCompositeByteBuf.java:1028)</span></span><br><span class="line"><span class="string">  io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.touch(AdvancedLeakAwareCompositeByteBuf.java:36)</span></span><br><span class="line"><span class="string">  io.netty.handler.codec.http.HttpObjectAggregator$AggregatedFullHttpMessage.touch(HttpObjectAggregator.java:359)</span></span><br><span class="line"><span class="string">  ......</span></span><br><span class="line"><span class="string">#3:</span></span><br><span class="line"><span class="string">  Hint: &#x27;</span>HttpServerExpectContinueHandler#<span class="number">0</span><span class="string">&#x27; will handle the message from this point.</span></span><br><span class="line"><span class="string">  io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.touch(AdvancedLeakAwareCompositeByteBuf.java:1028)</span></span><br><span class="line"><span class="string">  io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.touch(AdvancedLeakAwareCompositeByteBuf.java:36)</span></span><br><span class="line"><span class="string">  io.netty.handler.codec.http.HttpObjectAggregator$AggregatedFullHttpMessage.touch(HttpObjectAggregator.java:359)</span></span><br><span class="line"><span class="string">  ......</span></span><br><span class="line"><span class="string">#2:</span></span><br><span class="line"><span class="string">  Hint: &#x27;</span>HttpHeartbeatHandler#<span class="number">0</span><span class="string">&#x27; will handle the message from this point.</span></span><br><span class="line"><span class="string">  io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.touch(AdvancedLeakAwareCompositeByteBuf.java:1028)</span></span><br><span class="line"><span class="string">  io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.touch(AdvancedLeakAwareCompositeByteBuf.java:36)</span></span><br><span class="line"><span class="string">  io.netty.handler.codec.http.HttpObjectAggregator$AggregatedFullHttpMessage.touch(HttpObjectAggregator.java:359)</span></span><br><span class="line"><span class="string">  ......</span></span><br><span class="line"><span class="string">#1:</span></span><br><span class="line"><span class="string">  Hint: &#x27;</span>IdleStateHandler#<span class="number">0</span><span class="string">&#x27; will handle the message from this point.</span></span><br><span class="line"><span class="string">  io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.touch(AdvancedLeakAwareCompositeByteBuf.java:1028)</span></span><br><span class="line"><span class="string">  io.netty.buffer.AdvancedLeakAwareCompositeByteBuf.touch(AdvancedLeakAwareCompositeByteBuf.java:36)</span></span><br><span class="line"><span class="string">  io.netty.handler.codec.http.HttpObjectAggregator$AggregatedFullHttpMessage.touch(HttpObjectAggregator.java:359)</span></span><br><span class="line"><span class="string">  ......</span></span><br><span class="line"><span class="string">Created at:</span></span><br><span class="line"><span class="string">  io.netty.util.ResourceLeakDetector.track(ResourceLeakDetector.java:237)</span></span><br><span class="line"><span class="string">  io.netty.buffer.AbstractByteBufAllocator.compositeDirectBuffer(AbstractByteBufAllocator.java:217)</span></span><br><span class="line"><span class="string">  io.netty.buffer.AbstractByteBufAllocator.compositeBuffer(AbstractByteBufAllocator.java:195)</span></span><br><span class="line"><span class="string">  io.netty.handler.codec.MessageAggregator.decode(MessageAggregator.java:255)</span></span><br><span class="line"><span class="string">  ......</span></span><br></pre></td></tr></table></figure><p>开启高级的泄漏检测级别后，通过上面异常日志，我们可以看到内存泄漏的具体地方：com.jd.jr.keeplive.front.service.nettyServer.handler.LongRotationServerHandler.getClientMassageInfo(LongRotationServerHandler.java:169)</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-1623505/3725d1c2e97fadf24a1bdbd49d84fdda.png" alt="img"></p><p> <strong>如何回收泄漏的ByteBuf</strong></p><p>其实<code>Netty</code>官方也针对这个问题做了专门的讨论，一般的经验法则是，最后访问引用计数对象的一方负责销毁该引用计数对象，具体来说：</p><ul><li>如果一个[发送]组件将一个引用计数的对象传递给另一个[接收]组件，则发送组件通常不需要销毁它，而是由接收组件进行销毁。</li><li>如果一个组件使用了一个引用计数的对象，并且知道没有其他对象将再访问它（即，不会将引用传递给另一个组件），则该组件应该销毁它。</li></ul><p>总结起来主要三个方式： </p><p><strong>方式一：</strong></p><p>手动释放，哪里使用了，使用完就手动释放。</p><p><strong>方式二：</strong></p><p>升级ChannelHandler为SimpleChannelHandler，在SimpleChannelHandler中，Netty对收到的所有消息都调用了ReferenceCountUtil.release(msg)。</p><p><strong>方式三：</strong></p><p>如果处理过程中不确定ByteBuf是否应该被释放，那交给Netty的ReferenceCountUtil.release(msg)来释放，这个方法会判断上下文是否可以释放。</p><p>考虑到长连接前置应用使用的是<code>ChannelHandler</code>，如果升级<code>SimpleChannelHandler</code>对现有API接口变动比较大，同时如果手动释放，不确定是否应该释放风险也大，因此使用方式三，如下：</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-1623505/470281787e5db005b7cadef8bdc813d0.png" alt="img">****</p><p>问题修复后，线上服务正常，内存使用率也没有再出现因泄漏而增长，从线上我们增加的日志中看出，<code>FullHttpRequest</code>中<code>ByteBuf</code>内存释放成功。 从此长连接前置内存泄漏的问题彻底解决。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-1623505/c311b2ed479bc27b9b2e185ce3ae486c.png" alt="img"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>美团的这篇技术文章共 2w+ 字，详细介绍了 GC 基础，总结了 CMS GC 的一些常见问题分析与解决办法，出现线上问题时可以参考下思路：<a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">https://tech.meituan.com/2020/11/12/java-9-cms-gc.html</a></p><p>阿里也有一篇关于JVM内存问题排查的3W字长文，可以结合一起参考：<a href="https://mp.weixin.qq.com/s/zshcVuQreAB8YHwjBL0EmA">https://mp.weixin.qq.com/s/zshcVuQreAB8YHwjBL0EmA</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAT排查案例——BeanCopy的正确使用方式</title>
      <link href="/2025/01/23/MAT%E6%8E%92%E6%9F%A5%E6%A1%88%E4%BE%8B%E2%80%94%E2%80%94BeanCopy%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
      <url>/2025/01/23/MAT%E6%8E%92%E6%9F%A5%E6%A1%88%E4%BE%8B%E2%80%94%E2%80%94BeanCopy%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1 问题背景"></a>1 问题背景</h1><p>线上环境和测试环境均发现过应用卡死，频繁Full GC，原因是因为Metaspace空间（JVM参数为-XX:MaxMetaspaceSize为256m）不足导致OOM，一段时间后服务自动重启，重启后服务正常。因为有配置OOM dump文件生成记录，所以获取到了当时OOM dump文件。</p><p>项目频繁发生<code>metaspace</code>溢出，基于相关知识毫不犹豫的想到以下几点</p><ul><li>项目中使用过多反射</li><li>项目中使用过多的动态代理技术</li><li>项目中使用过多的<code>lambda</code></li></ul><h1 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2 问题分析"></a>2 问题分析</h1><h2 id="2-1-OOM-dump文件分析"><a href="#2-1-OOM-dump文件分析" class="headerlink" title="2.1 OOM dump文件分析"></a>2.1 OOM dump文件分析</h2><p>从MAT Leak Suspects分析来看：</p><ul><li>不存在占用内存大的对象。</li><li>整体看下来无明显异常情况。</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ff23793b6b744a2948a22c985c55731~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=957&h=812&s=45433&e=png&b=fdf9f8" alt="MAT Leak Suspects分析"></p><h2 id="2-2-结合资料分析"><a href="#2-2-结合资料分析" class="headerlink" title="2.2 结合资料分析"></a>2.2 结合资料分析</h2><p><strong>Metaspace空间使用</strong></p><ul><li>Metaspace 空间通过 mmap 来从操作系统申请内存，申请的内存会分成一个一个 Metachunk，以 Metachunk 为单位将内存分配给类加载器，每个 Metachunk 对应唯一一个类加载器，一个类加载器可以有多个 Metachunk。</li><li>通过监控可以发现，Metaspace空间使用率为：87%。可能的原因是给类加载器分配的chunk使用率太低，也就是<strong>创建了很多类加载器，而每个类加载器又加载了很少的类。</strong></li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2edcd1c1f2344050bb11cf30e8699771~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=746&h=265&s=32337&e=png&b=171a1e" alt="Metaspace空间使用情况"></p><p><strong>类加载器情况</strong></p><ul><li>通过arthas查看类加载器使用情况，命令：classloader</li><li>对应用程序执行情况如下，发现DelegatingClassLoader类加载器数量比较多。</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a773dee6f152401196e5d9a5bd159579~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=752&h=273&s=18991&e=png&b=000000" alt="类加载器情况"></p><p><strong>DelegatingClassLoader分析</strong></p><p>对dump文件进行分析</p><ul><li>发现dump文件中有较多的DelegatingClassLoader，且持有GeneratedMethodAccessorXXXX，该类是反射用于加载生成的Method类时，使用的加载器。</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab745d110924442698ba7c04945d43c3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1015&h=408&s=50413&e=png&b=fdfcfc" alt="DelegatingClassLoader分析"></p><ul><li>通过MAT工具查看GeneratedMethodAccessorXXXX对象（List objects with <strong>incoming</strong> refenrece），发现大部分都是业务DTO字段的set方法。</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b5653ef71184e049a788baf92408e9d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1341&h=169&s=22889&e=png&b=fefdfd" alt="业务字段"></p><h2 id="2-3-关于beanCopy"><a href="#2-3-关于beanCopy" class="headerlink" title="2.3 关于beanCopy"></a>2.3 关于beanCopy</h2><p>运行期间最有可能引起问题的地方无疑是我们大量的使用了<code>beanCopy</code>那么检查项目发现各种方式的<code>beanCopy</code>都有，有<code>apache</code>的<code>BeanUtils</code>，有<code>spring</code>的<code>BeanUtils</code>，有<code>cglib</code>的<code>BeanCopy</code>。并且我们的很多实体都有上百个字段。</p><h3 id="2-3-1-性能测试"><a href="#2-3-1-性能测试" class="headerlink" title="2.3.1 性能测试"></a>2.3.1 性能测试</h3><p>当我们开启阿里代码扫描插件时，如果你使用了 Apache BeanUtils.copyProperties 进行属性拷贝，它会给你一个<strong>非常严重的警告</strong>。因为，<strong>Apache BeanUtils性能较差，可以使用 Spring BeanUtils 或者 Cglib BeanCopier 来代替</strong>。</p><p>执行以下代码，测试这三种beanCopy方法的性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testCglibBeanCopier</span><span class="params">(OriginObject origin, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">Stopwatch</span> <span class="variable">stopwatch</span> <span class="operator">=</span> Stopwatch.createStarted();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;================cglib BeanCopier执行&quot;</span> + len + <span class="string">&quot;次================&quot;</span>);</span><br><span class="line">        <span class="type">DestinationObject</span> <span class="variable">destination3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DestinationObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">BeanCopier</span> <span class="variable">copier</span> <span class="operator">=</span> BeanCopier.create(OriginObject.class, DestinationObject.class, <span class="literal">false</span>);</span><br><span class="line">            copier.copy(origin, destination3, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stopwatch.stop();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;testCglibBeanCopier 耗时: &quot;</span> + stopwatch.elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testApacheBeanUtils</span><span class="params">(OriginObject origin, <span class="type">int</span> len)</span></span><br><span class="line">            <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line">        <span class="type">Stopwatch</span> <span class="variable">stopwatch</span> <span class="operator">=</span> Stopwatch.createStarted();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;================apache BeanUtils执行&quot;</span> + len + <span class="string">&quot;次================&quot;</span>);</span><br><span class="line">        <span class="type">DestinationObject</span> <span class="variable">destination2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DestinationObject</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            BeanUtils.copyProperties(destination2, origin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stopwatch.stop();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;testApacheBeanUtils 耗时: &quot;</span> + stopwatch.elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSpringFramework</span><span class="params">(OriginObject origin, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">Stopwatch</span> <span class="variable">stopwatch</span> <span class="operator">=</span> Stopwatch.createStarted();</span><br><span class="line">        System.out.println(<span class="string">&quot;================springframework执行&quot;</span> + len + <span class="string">&quot;次================&quot;</span>);</span><br><span class="line">        <span class="type">DestinationObject</span> <span class="variable">destination</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DestinationObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            org.springframework.beans.BeanUtils.copyProperties(origin, destination);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stopwatch.stop();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;testSpringFramework 耗时: &quot;</span> + stopwatch.elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testApacheBeanUtilsPropertyUtils</span><span class="params">(OriginObject origin, <span class="type">int</span> len)</span></span><br><span class="line">            <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">Stopwatch</span> <span class="variable">stopwatch</span> <span class="operator">=</span> Stopwatch.createStarted();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;================apache BeanUtils PropertyUtils执行&quot;</span> + len + <span class="string">&quot;次================&quot;</span>);</span><br><span class="line">        <span class="type">DestinationObject</span> <span class="variable">destination2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DestinationObject</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            PropertyUtils.copyProperties(destination2, origin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stopwatch.stop();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;testApacheBeanUtilsPropertyUtils 耗时: &quot;</span> + stopwatch.elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分别执行1000、10000、100000、1000000次耗时数(毫秒):</p><table><thead><tr><th><strong>工具名称</strong></th><th><strong>执行1000次耗时</strong></th><th>10000次</th><th><strong>100000次</strong></th><th><strong>1000000次</strong></th></tr></thead><tbody><tr><td>Apache BeanUtils</td><td>390ms</td><td>854ms</td><td>1763ms</td><td>8408ms</td></tr><tr><td>Apache PropertyUtils</td><td>26ms</td><td>221ms</td><td>352ms</td><td>2663ms</td></tr><tr><td>spring BeanUtils</td><td>39ms</td><td>315ms</td><td>373ms</td><td>949ms</td></tr><tr><td>Cglib BeanCopier</td><td>64ms</td><td>144ms</td><td>171ms</td><td>309ms</td></tr></tbody></table><p>结论:</p><ol><li>Apache BeanUtils主要集中了各种丰富的功能(日志、转换、解析等等),导致性能变差，不建议使用。</li><li>Apache PropertyUtils100000次以内性能还能接受,到百万级别性能就比较差了,可酌情考虑。</li><li>spring BeanUtils和BeanCopier性能较好,如果对性能有特别要求,可使用BeanCopier,不然spring BeanUtils也是可取的。</li></ol><h3 id="2-3-2-metaspace分析"><a href="#2-3-2-metaspace分析" class="headerlink" title="2.3.2 metaspace分析"></a>2.3.2 metaspace分析</h3><p>研究完了性能，确实如阿里代码扫描插件所说，使用 Spring BeanUtils 或者 Cglib BeanCopier 是最稳妥的。但是本次的metaspace溢出，又暴露出了另一个问题：项目中 beanCopy 的使用导致 classLoader 的数量骤增。</p><p>先测试下<code>spring</code>的<code>BeanUtils</code>：</p><p>使用<code>jcmd</code> 命令查看下<code>metaspace</code>的使用情况发现前<code>15</code>次调用情况如下<code>jcmd 23328 VM.classloader_stats</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Total = 3                                                     1276   7915520   7636416</span><br><span class="line">ChunkSz: Total size of all allocated metaspace chunks</span><br><span class="line">BlockSz: Total size of all allocated metaspace blocks (each chunk has several blocks)</span><br></pre></td></tr></table></figure><p>而在<code>15</code>次之后的情况如下<code>jcmd 23328 VM.classloader_stats</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Total = 1035                                                  2321  14387200  10678952</span><br><span class="line">ChunkSz: Total size of all allocated metaspace chunks</span><br><span class="line">BlockSz: Total size of all allocated metaspace blocks (each chunk has several blocks)</span><br></pre></td></tr></table></figure><p>可以看到在<code>15</code>次前<code>classloader</code>一直是<code>3</code>个，而<code>15</code>次之后增长到了<code>1035</code>个往后稳定在<code>1035</code>个</p><p>那么我们在同样的条件下测试下<code>spring</code>提供的另一个基于<code>cglib</code>的<code>BeanCopy</code>结果如下:</p><p>前<code>15</code>次调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Total = 3                                                      805   6180864   5358144</span><br><span class="line">ChunkSz: Total size of all allocated metaspace chunks</span><br><span class="line">BlockSz: Total size of all allocated metaspace blocks (each chunk has several blocks)</span><br></pre></td></tr></table></figure><p><code>15</code>次后调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Total = 4                                                      820   6187008   5439976</span><br><span class="line">ChunkSz: Total size of all allocated metaspace chunks</span><br><span class="line">BlockSz: Total size of all allocated metaspace blocks (each chunk has several blocks)</span><br></pre></td></tr></table></figure><p>我们发现<code>cglib</code>的<code>beanCopy</code>仅仅增加了一个<code>classloader</code>，并且对<code>metaspace</code>的使用增加幅度非常小。</p><p>意味着项目中如果大量使用了反射方式的<code>beancopy</code>就会创建大量的<code>DelegatingClassLoader</code>，那么这里为什么是15次之后才出现呢？我们顺着<a href="https://so.csdn.net/so/search?q=BeanUtils&spm=1001.2101.3001.7020">BeanUtils</a>.copyProperties方法点进去，在使用反射调用<code>method.Invoke()</code>的时候，当你的使用次数超过<code>15</code>次就会为每一个<code>method</code>生成一个<code>class</code>。就会导致<code>metaspace</code>极速膨胀。</p><p>而在<code>cglib</code>方式下则是以类为单位，所以同样也走到了相关的代码，但是它只生成了一个<code>DelegatingClassLoader</code>，所以它的<code>metaspace</code>内存占用比反射来的小很多。</p><h1 id="3-结论"><a href="#3-结论" class="headerlink" title="3 结论"></a>3 结论</h1><p>此处我们已经很明确这个问题出在项目中大量使用的反射的<code>beancopy</code>导致<code>metaspace</code>溢出，理论上来说这种情况可以通过调整-XX:MaxMetaspaceSize为512m解决问题，但是更好的解决方案是尽量使用<code>cglib</code>方式的<code>beancopy</code>。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> MAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存分析工具MAT的使用方式</title>
      <link href="/2025/01/16/JVM%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7MAT%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
      <url>/2025/01/16/JVM%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7MAT%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="MAT工具简介"><a href="#MAT工具简介" class="headerlink" title="MAT工具简介"></a>MAT工具简介</h1><p>MAT（全名：Memory Analyzer Tool），是一款快速便捷且功能强大丰富的 JVM 堆内存离线分析工具。其通过展现 JVM 异常时所记录的运行时堆转储快照（Heap dump）状态（正常运行时也可以做堆转储分析），帮助定位内存泄漏问题或优化大内存消耗逻辑。</p><p>一般来说，线上出现GC问题会有异常告警，此时应该做的是下线一个节点，导出dump文件保留事故现场，然后对线上服务做回滚&#x2F;灰度处理，或者调整堆内存大小，或者重启服务器&#x2F;手动触发FullGC快速回收内存，先保证服务正常运行，然后再用1天的时间对dump文件进行分析，排查出异常问题并进行修复。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="Heap-Dump"><a href="#Heap-Dump" class="headerlink" title="Heap Dump"></a>Heap Dump</h3><p>Heap Dump 是 Java 进程堆内存在一个时间点的快照，其主要结构包含：</p><ul><li>所有对象的实例信息：对象所属类名、基础类型和引用类型的属性等</li><li>所有类信息：类加载器、类名、继承关系、静态属性</li><li>GC Root：GC Root 代表通过可达性分析来判定 JVM 对象是否存活的起始集合。JVM 采用追踪式垃圾回收（Tracing GC）模式，<strong>从所有 GC Roots 出发通过引用关系可以关联的对象</strong>就是存活的（且不可回收），其余的不可达的对象（Unreachable object：如果无法从 GC Root 找到一条引用路径能到达某对象，则该对象为Unreachable object）可以回收。</li><li>线程栈及局部变量：快照生成时刻的所有线程的线程栈帧，以及每个线程栈的局部变量</li></ul><h3 id="Shallow-Heap"><a href="#Shallow-Heap" class="headerlink" title="Shallow Heap"></a>Shallow Heap</h3><p>Shallow Heap 代表一个<strong>对象结构自身</strong>所占用的内存大小，不包括其属性引用对象所占的内存。</p><h3 id="Retained-Heap"><a href="#Retained-Heap" class="headerlink" title="Retained Heap"></a>Retained Heap</h3><p>Retained Heap 是一个对象被 GC 回收后，可释放的内存大小。如果一个对象A同时被两个对象B和C引用，那么B回收后不能释放掉A，因为A也被C引用了。</p><h3 id="Dominator-tree"><a href="#Dominator-tree" class="headerlink" title="Dominator tree"></a>Dominator tree</h3><p>如果所有指向对象 Y 的路径都经过对象 X，则 X 支配（dominate） Y</p><h3 id="QQL"><a href="#QQL" class="headerlink" title="QQL"></a>QQL</h3><p>OQL 是类似于 SQL 的 MAT 专用统一查询语言，可以根据复杂的查询条件对 dump 文件中的类或者对象等数据进行查询筛选。</p><h3 id="references"><a href="#references" class="headerlink" title="references"></a>references</h3><p>outgoing references、incoming references 可以直击对象间依赖关系，MAT 也提供了链式快速操作。</p><ul><li>outgoing references：对象引用的外部对象（注意不包含对象的基本类型属性。基本属性内容可在 inspector 查看）。</li><li>incoming references：直接引用了当前对象的对象，每个对象的 incoming references 可能有 0 到多个。</li></ul><h1 id="MAT功能概述"><a href="#MAT功能概述" class="headerlink" title="MAT功能概述"></a>MAT功能概述</h1><p>熟练掌握 MAT 是 Java 高手的必备能力，但实践时大家往往需面对众多功能，可以根据这个脑图去寻找一些使用MAT的切入点，分析出异常点。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bb5e21bfb5a4a4d855e5e0ee80206d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>菜单-各功能的使用入口</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/822515f03c704e61ae8967048a36b4b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h2 id="1-内存分布详解及实战"><a href="#1-内存分布详解及实战" class="headerlink" title="1 内存分布详解及实战"></a>1 内存分布详解及实战</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><strong>功能：</strong>展现堆内存大小、对象数量、class 数量、class loader 数量、GC Root 数量、环境变量、线程概况等全局统计信息。</p><p><strong>使用入口</strong>：MAT 主界面 → Heap Dump Overview。</p><p><strong>举例</strong>：下面是对象数量、class loader 数量、GC Root 数量，可以看出 class loader 存在异常。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdfda3beda914ae288b96f261d0e58ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p><strong>使用入口</strong>：MAT 主界面 → Java Basics -&gt;  Thread Overview and stack。</p><p>下图是线程概况，可以查看每个线程名、线程的 Retained Heap、daemon 属性等。</p><p><img src="https://i0.hdslb.com/bfs/article/60d0bc0af37234d6bfadce5af151e50e171301454.png" alt="image-20250116142503899"></p><p><strong>使用场景</strong> 全局概览呈现全局统计信息，重点查看整体是否有异常数据，所以有效信息有限，下面几种场景有一定帮助：</p><ul><li>方法区溢出时（Java 8后不使用方法区，对应堆溢出），查看 class 数量异常多，可以考虑是否为动态代理类异常载入过多或类被反复重复加载。</li><li>方法区溢出时，查看 class loader 数量过多，可以考虑是否为自定义 class loader 被异常循环使用。</li><li>GC Root 过多，可以查看 GC Root 分布，理论上这种情况极少会遇到，笔者只在 JNI 使用一个存在 BUG 的库时遇到过。</li><li>线程数过多，一般是频繁创建线程但无法执行结束，从概览可以了解异常表象，具体原因可以参考本文线程分析部分内容，此处不展开。</li></ul><h3 id="Dominator-tree-1"><a href="#Dominator-tree-1" class="headerlink" title="Dominator tree"></a>Dominator tree</h3><p><em>使用频率top 1，是高效分析 Dump 必看的功能</em></p><p><strong>功能</strong></p><ul><li>展现对象的支配关系图，并给出对象支配内存的大小（支配内存等同于 Retained Heap，即其被 GC 回收可释放的内存大小）</li><li>支持排序、支持按 package、class loader、super class、class 聚类统计</li></ul><p><strong>使用入口</strong>：全局支配树： MAT 主界面 → Dominator tree。</p><p><strong>举例：</strong> 下图中查看 Dominator tree</p><p><img src="https://i0.hdslb.com/bfs/article/f2517439a70d3c760d94697717f279f9171301454.png" alt="image-20250116142731886"></p><p>有些情况下可能看不太出来支配起点对象的 Reatained Heap 占用很大内存，这时可以按 class、package、class loader做聚合，进而定位目标。</p><p><img src="https://i0.hdslb.com/bfs/article/3263fc79d9be243a86d76e2aa51c08c0171301454.png" alt="image-20250116142918095"></p><p>可以定位到String对象支配内存较多，然后结合代码进一步分析具体原因。</p><p><img src="https://i0.hdslb.com/bfs/article/d4955f9a8d6ec4b684188d7f94027556171301454.png" alt="image-20250116143212144"></p><p>在一些操作后定位到异常持有 Retained Heap 对象后（如从代码看对象应该被回收），可以获取对象的直接支配者，操作方式如下。</p><p><img src="https://i0.hdslb.com/bfs/article/2439777d8f5871a529422f5e2818ffe3171301454.png" alt="image-20250116143524870"></p><h3 id="Histogram-直方图"><a href="#Histogram-直方图" class="headerlink" title="Histogram 直方图"></a>Histogram 直方图</h3><p><em>使用概率 Top 2</em></p><p><strong>功能</strong></p><ul><li>罗列每个类实例的数量、类实例累计内存占比，包括自身内存占用量（Shallow Heap）及支配对象的内存占用量（Retain Heap）。</li><li>支持按对象数量、Retained Heap、Shallow Heap（默认排序）等指标排序；支持按正则过滤；支持按 package、class loader、super class、class 聚类统计，</li></ul><p><strong>使用入口</strong>：MAT 主界面 → Histogram；注意 Histogram 默认不展现 Retained Heap，可以使用计算器图标计算，如下图所示。</p><p><img src="https://i0.hdslb.com/bfs/article/d9802f9a77d226c351fefcf3138bdbf0171301454.png" alt="image-20250116144018648"></p><p>使用技巧</p><ul><li><p>Integer，String 和 Object[] 一般不直接导致内存问题。为更好的组织视图，可以通过 class loader 或 package 分组进一步聚焦，如下图。</p><p><img src="https://i0.hdslb.com/bfs/article/61bcd368a76d272a9aa68cd335481a20171301454.png" alt="image-20250116144148218"></p></li><li><p>可以在 Histogram 的某个类继续使用 outgoing reference 查看对象分布，进而定位哪些对象是大头</p><p><img src="https://i0.hdslb.com/bfs/article/dc1bde161a10e1bd7e03fa100c23c294171301454.png" alt="image-20250116144429449"></p></li></ul><p>List objects找到大对象后，可以点击Path To GC Roots或incoming reference，查看大数组的引用路径。</p><h3 id="Leak-Suspects"><a href="#Leak-Suspects" class="headerlink" title="Leak Suspects"></a>Leak Suspects</h3><p><strong>功能</strong>：具备自动检测内存泄漏功能，罗列可能存在内存泄漏的问题点。</p><p><strong>使用入口</strong>：一般当存在明显的内存泄漏时，分析完Dump文件后就会展现，也可以如下图在 MAT 主页 → Leak Suspects。</p><p><strong>使用场景</strong>：需要查看引用链条上占用内存较多的可疑对象。这个功能可解决一些基础问题，但复杂的问题往往帮助有限。</p><p><img src="https://i0.hdslb.com/bfs/article/3d3661a118e2908ac681243b6c9d7386171301454.png" alt="image-20250116144654696"></p><p>点击Keywords中的“Details”，获取实例到GC Root的最短路径、dominator路径的详细信息</p><p><img src="https://i0.hdslb.com/bfs/article/3ff950b85e0d87dd149507e2da5f0c86171301454.png" alt="image-20250116144804972"></p><p><img src="https://i0.hdslb.com/bfs/article/519d151488ec3dd0b22144a4b0772cc6171301454.png" alt="image-20250116144819555"></p><h3 id="Top-Consumers"><a href="#Top-Consumers" class="headerlink" title="Top Consumers"></a>Top Consumers</h3><p><strong>功能</strong>：最大对象报告，可以展现哪些类、哪些 class loader、哪些 package 占用最高比例的内存，其功能 Histogram 及 Dominator tree 也都支持。</p><p><strong>使用场景</strong>：应用程序发生内存泄漏时，查看哪些泄漏的对象通常在 Dump 快照中会占很大的比重。因此，对简单的问题具有较高的价值。</p><h3 id="综合案例一"><a href="#综合案例一" class="headerlink" title="综合案例一"></a>综合案例一</h3><p>首先进入 Dominator tree，可以看出是 SameContentWrapperContainerProxy 对象与 main 线程两者持有99%内存不能释放导致 OOM。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fe24e47a05042b7b61a103e3c7dbf4b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d953a502fdf40c6ad95a5a992ec33fb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>先来看方向一，在 Heap Dump Overview 中可以快速定位到 Number of class loaders 数达50万以上，这种基本属于异常情况，如下图所示。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc64b31b8e484ca88e02590b42f82c74~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>使用 Class Loader Explorer 分析工具，此时会展现类加载详情，可以看到有524061个 class loader。我们的案例中仅有ClassLoaderOOMOps 这样的自定义类加载器，所以很快可以定位到问题。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf60312fd4894df98ccd7573a1c0c5c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9309e3ecfa4e48dc8b98ab2f1e4e08d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>如果类加载器较多，不能确定是哪个引发问题，则可以将所有的 class loader对象按类做聚类，如下图所示。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dad1e14bad84ced8f906bf162dad4c5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>Histogram 会根据 class 聚合，并展现对象数量级其 Shallow Heap 及 Retained Heap（如Retained Heap项目为空，可以点击下图中计算机的图标并计算 Retained Heap），可以看到 ClassLoaderOOMOps 有524044个对象，其 Retain Heap 占据了370M以上（上述代码是100M左右）。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09f7a1ecbe1d495cb144c16f676f9888~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>使用 incoming references，可以找到创建的代码位置。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8128a34a4fb42a7a28d4f7c69313e12~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>再来看方向二，同样在占据319M内存的 Obejct 数组采用 incoming references 查看引用路径，也很容易定位到具体代码位置。并且从下图中我们看出，Dominator tree 的起点并不一定是 GC根，且通过 Dominator tree 可能无法获取到最开始的创建路径，但 incoming references 是可以的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64fac354fd204b3f93c43d48a25c0646~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h2 id="2-对象间依赖详解及实战"><a href="#2-对象间依赖详解及实战" class="headerlink" title="2 对象间依赖详解及实战"></a>2 对象间依赖详解及实战</h2><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><em><strong>注：笔者使用频率 Top2</strong></em></p><p><strong>功能</strong>：在对象引用图中查看某个特定对象的所有引用关系（提供对象对其他对象或基本类型的引用关系，以及被外部其他对象的引用关系）。通过任一对象的直接引用及间接引用详情（主要是属性值及内存占用），提供完善的依赖链路详情。</p><p><strong>使用入口</strong>：目标域右键 → List objects → with outgoing references&#x2F;with incoming references.</p><p><strong>使用场景</strong></p><ul><li>outgoing reference：查看对象所引用的对象，并支持链式传递操作。如查看一个大对象持有哪些内容，当一个复杂对象的 Retained Heap 较大时，通过 outgoing reference 可以查看由哪个属性引发。下图中 A 支配 F，且 F 占据大量内存，但优化时 F 的直接支配对象 A 无法修改。可通过 outgoing reference 看关系链上 D、B、E、C，并结合业务逻辑优化中间环节，这依托 dominator tree 是做不到的。</li><li>incoming reference：查看对象被哪些对象引用，并支持链式传递操作。如查看一个大对象都被哪些对象引用，下图中 K 占内存大，所以 J 的 Retained Heap 较大，目标是从 GC Roots 摘除 J 引用，但在 Dominator tree 上 J 是树根，无法获取其被引用路径，可通过 incoming reference 查看关系链上的 H、X、Y ，并结合业务逻辑将 J 从 GC Root 链摘除。 <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bde68d299620415cb34f5d6cbbeeeae7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></li></ul><h3 id="Thread-overview"><a href="#Thread-overview" class="headerlink" title="Thread overview"></a>Thread overview</h3><p><strong>功能</strong>：展现转储 dump 文件时线程执行栈、线程栈引用的对象等详细状态，也提供各线程的 Retained Heap 等关联内存信息。</p><p><strong>使用入口</strong>：MAT 主页 → Thread overview</p><p><strong>使用场景</strong></p><ul><li>查看不同线程持有的内存占比，定位高内存消耗线程（开发技巧：不要直接使用 Thread 或 Executor 默认线程名避免全部混合在一起，使用线程尽量自命名方便识别，如下图中 ThreadAndListHolder-thread 是自定义线程名，可以很容易定位到具体代码）</li><li>查看线程的执行栈及变量，结合业务代码了解线程阻塞在什么地方，以及无法继续运行释放内存，如下图中 ThreadAndListHolder-thread 阻塞在 sleep 方法。 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfcded48fb234e0682bdc6d872f03717~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></li></ul><h3 id="Path-To-GC-Roots"><a href="#Path-To-GC-Roots" class="headerlink" title="Path To GC Roots"></a>Path To GC Roots</h3><p><strong>功能</strong>：提供任一对象到 GC Root 的路径详情。</p><p><strong>使用入口</strong>：目标域右键 → Path To GC Roots</p><p><strong>使用场景</strong>：有时你确信已经处理了大的对象集合但依然无法回收，该功能能快速定位异常对象不能被 GC 回收的原因，直击异常对象到 GC Root 的引用路径。比 incoming reference 的优势是屏蔽掉很多不需关注的引用关系，比 Dominator tree 的优势是可以得到更全面的信息。</p><p><em>小技巧：在排查内存泄漏时，建议选择 exclude all phantom&#x2F;weak&#x2F;soft etc.references 排除虚引用&#x2F;弱引用&#x2F;软引用等的引用链，因为被虚引用&#x2F;弱引用&#x2F;软引用的对象可以直接被 GC 给回收，聚焦在对象否还存在 Strong 引用链即可。</em></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3919a0973e6f4ac0b4fe3460e24fec75~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h3 id="class-loader-分析"><a href="#class-loader-分析" class="headerlink" title="class loader 分析"></a>class loader 分析</h3><p><strong>功能</strong></p><ul><li>查看堆中所有 class loader 的使用情况（入口：MAT 主页菜单蓝色桶图标 → Java Basics → Class Loader Explorer）。</li><li>查看堆中被不同class loader 重复加载的类（入口：MAT 主页菜单蓝色桶图标 → Java Basics → Duplicated Classes）。</li></ul><p><strong>使用场景</strong></p><ul><li>当从 Heap dump overview 了解到系统中 class loader 过多，导致占用内存异常时进入更细致的分析定位根因时使用。</li><li>解决 NoClassDefFoundError 问题或检测 jar 包是否被重复加载</li></ul><p>具体使用方法在 2.6 及 3.5 两节的案例中有介绍。</p><h3 id="综合案例二"><a href="#综合案例二" class="headerlink" title="综合案例二"></a>综合案例二</h3><p><strong>使用工具项</strong>：class loader（重复类检测）、inspector、正则检索。</p><p><strong>异常现象</strong> ：运行时报 NoClassDefFoundError，在 classpath 中有两个不同版本的同名类。</p><p><strong>分析过程</strong></p><ol><li><p>进入 MAT 已加载的重复类检测功能，方式如下图。 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60fbe324fe9d416c90c2e659b4f971c7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p></li><li><p>可以看到所有重复的类，以及相关的类加载器，如下图。 <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cdae3fc7b614c01a8047e3c024b4680~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p></li><li><p>根据类名，在<code>&lt;Regex&gt;</code>框中输入类名可以过滤无效信息。</p></li><li><p>选中目标类，通过Inspector视图，可以看到被加载的类具体是在哪个jar包里。（本例中重复的类是被 URLClassloader 加载的，右键点击 “_context” 属性，最后点击 “Go Into”，在弹出的窗口中的属性 “_war” 值是被加载类的具体包位置）</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db89543ca6b544cf8e36252aa08a60be~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3be497af48b4c5b9ea96b2ae2a9c967~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p></li></ol><h2 id="3-对象状态详解及实战"><a href="#3-对象状态详解及实战" class="headerlink" title="3 对象状态详解及实战"></a>3 对象状态详解及实战</h2><h3 id="inspector"><a href="#inspector" class="headerlink" title="inspector"></a>inspector</h3><p><strong>功能</strong>：MAT 通过 inspector 面板展现对象的详情信息，如静态属性值及实例属性值、内存地址、类继承关系、package、class loader、GC Roots 等详情数据。</p><p><strong>使用场景</strong></p><ul><li>当内存使用量与业务逻辑有较强关联的场景，通过 inspector 可以通过查看对象具体属性值。比如：社交场景中某个用户对象的好友列表异常，其 List 长度达到几亿，通过  inspector 面板获取到异常用户 ID，进而从业务视角继续排查属于哪个用户，本例可能有系统账号，与所有用户是好友。</li><li>集合等类型的使用会较多，如查看 ArrayList 的 size 属性也就了解其大小。</li></ul><p><strong>举例</strong>：下图中左边的 Inspector 窗口展现了地址 0x125754cf8 的 ArrayList 实例详情，包括 modCount 等并不会在 outgoing references 展现的基本属性。 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5067f8c3bc94397ad829ae9ee882b34~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h3 id="集合状态"><a href="#集合状态" class="headerlink" title="集合状态"></a>集合状态</h3><p><strong>功能</strong>：帮助更直观的了解系统的内存使用情况，查找浪费的内存空间。</p><p><strong>使用入口</strong>：MAT 主页 → Java Collections → 填充率&#x2F;Hash冲突等功能。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/409f4fd84bef43dfabdd9f6337615917~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p><strong>使用场景</strong></p><ul><li>通过对 ArrayList 或数组等集合类对象按填充率聚类，定位稀疏或空集合类对象造成的内存浪费。</li><li>通过 HashMap 冲突率判定 hash 策略是否合理。</li></ul><p>具体使用方法在 4.3 节案例详细介绍。</p><h3 id="综合案例三"><a href="#综合案例三" class="headerlink" title="综合案例三"></a>综合案例三</h3><p><strong>使用工具项</strong>：Dominator tree、Histogram、集合 ratio。</p><p><strong>异常现象</strong> ：程序 OOM，且 Dominator tree 无大对象，通过 Histogram 了解到多个 ArrayList 占据大量内存，期望通过减少 ArrayList 优化程序。</p><p><strong>分析过程</strong></p><ol><li>使用 Dominator tree 查看并无高占比起点。 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2f44f9216f94b08bc3bdf7107d5a737~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></li><li>使用 Histogram 定位到 ListHolder 及 ArrayList 占比过高，经过业务分析很多 List 填充率很低浪费内存。 <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de3c98f88cf14561ae1117e2f8e55cd2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></li><li>查看 ArrayList 的填充率，MAT 首页 → Java Collections → Collection Fill Ratio。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44000e6e5c2946e18ed1703d68aec244~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></li><li>查看类型填写 java.util.ArrayList。 <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad7db951d8254ebaa9c85f07e799f887~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></li><li>从结果可以看出绝大部分 ArrayList 初始申请长度过大。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe6c558fd665443c874d41c920a64018~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> MAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用arthas及插件故障排查实践</title>
      <link href="/2025/01/15/%E4%BD%BF%E7%94%A8arthas%E5%8F%8A%E6%8F%92%E4%BB%B6%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%AE%9E%E8%B7%B5/"/>
      <url>/2025/01/15/%E4%BD%BF%E7%94%A8arthas%E5%8F%8A%E6%8F%92%E4%BB%B6%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Arthas-简介"><a href="#Arthas-简介" class="headerlink" title="Arthas 简介"></a>Arthas 简介</h1><p>Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。</p><p>当你遇到以下类似问题而束手无策时，<code>Arthas</code>可以帮助你解决：</p><ol><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到 JVM 的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li><li>怎样直接从 JVM 内查找某个类的实例？</li></ol><h1 id="常见的故障问题排查案例"><a href="#常见的故障问题排查案例" class="headerlink" title="常见的故障问题排查案例"></a>常见的故障问题排查案例</h1><h2 id="启动arthas"><a href="#启动arthas" class="headerlink" title="启动arthas"></a>启动arthas</h2><p>一般线上已经部署了arthas，可以直接用该命令启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br><span class="line">java -jar arthas-bin/arthas-boot.jar</span><br></pre></td></tr></table></figure><p>选择进入哪个process，此时控制台会出现下面几个选项，它通过不同序号标明不同的Java程序，我们看到我们的目标程序<code>app.jar</code>，序号为1，所以我们输入1按回车。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@jr-uhr-org-7fdd8589db-c9nj7 /]# java -jar arthas-bin/arthas-boot.jar</span><br><span class="line">[INFO] arthas-boot version: 3.5.5</span><br><span class="line">[INFO] Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.</span><br><span class="line">* [1]: 1 /app.jar</span><br><span class="line">1</span><br><span class="line">[INFO] arthas home: /arthas-bin</span><br><span class="line">[INFO] Try to attach process 1</span><br><span class="line">[INFO] Attach process 1 success.</span><br><span class="line">[INFO] arthas-client connect 127.0.0.1 3658</span><br><span class="line">  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           </span><br><span class="line"> /  O  \ |  .--. &#x27;&#x27;--.  .--&#x27;|  &#x27;--&#x27;  | /  O  \ &#x27;   .-&#x27;                          </span><br><span class="line">|  .-.  ||  &#x27;--&#x27;.&#x27;   |  |   |  .--.  ||  .-.  |`.  `-.                          </span><br><span class="line">|  | |  ||  |\  \    |  |   |  |  |  ||  | |  |.-&#x27;    |                         </span><br><span class="line">`--&#x27; `--&#x27;`--&#x27; &#x27;--&#x27;   `--&#x27;   `--&#x27;  `--&#x27;`--&#x27; `--&#x27;`-----&#x27;                          </span><br><span class="line"></span><br><span class="line">wiki       https://arthas.aliyun.com/doc                                        </span><br><span class="line">tutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  </span><br><span class="line">version    3.5.5                                                                </span><br><span class="line">main_class                                                                      </span><br><span class="line">pid        1                                                                    </span><br><span class="line">time       2025-01-15 17:34:22  </span><br></pre></td></tr></table></figure><h2 id="定位CPU-100-问题"><a href="#定位CPU-100-问题" class="headerlink" title="定位CPU 100%问题"></a>定位CPU 100%问题</h2><p>使用thread命令，可以看到所有的线程，查看他们的CPU占比。</p><p><img src="https://i0.hdslb.com/bfs/article/c4305b179bfa7b3a37a18e7a7cbf066a171301454.png" alt="image-20250115174050351"></p><p>找到CPU占比异常的线程，输入以下命令可以查看其堆栈信息，找到异常的代码段。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread [pid]</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/6ef23ee4d0e7099b6c7dd27343eb62e6171301454.png" alt="image-20250115174159409"></p><p>如果想使用arthas反编译查看源码，可以先在idea下载一个arthas idea plugin</p><p>在idea中找到出现异常的类，右键 <strong>Arthas Command -&gt; Decompile Class Jad</strong>，可以直接生成shell命令</p><p><img src="https://i0.hdslb.com/bfs/article/6e82c83cff8b1db047be821a867b11a8171301454.png" alt="image-20250115175113962"></p><p>反编译类的指令<code>jad --source-only 类的包路径</code></p><p>定位方法代码段的命令<code>jad --source-only 类的包路径 方法名</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad --source-only com.jr.uhr.org.service.impl.ContractRuleDetailServiceImpl </span><br></pre></td></tr></table></figure><h2 id="定位线程死锁问题"><a href="#定位线程死锁问题" class="headerlink" title="定位线程死锁问题"></a>定位线程死锁问题</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -b</span><br></pre></td></tr></table></figure><p>可以直接查看产生死锁的线程</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wic5BjMXGvIPibqCvB1gveoMmSNpxKCCmibTy8wZC6uto7wY7EM032mhnh1FMDNicmBTLcvxxSM6OjWH4n9A2SuKyg/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>由上述结果我们可知两个线程的id分别是65和66，所以使用<code>thread pid号</code>的命令直接定位到问题代码段并解决问题即可。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wic5BjMXGvIPibqCvB1gveoMmSNpxKCCmibNUwajkLib1OK6icwXDz6wCZic0Cma7OkAvy5RQt9bncBBRl7icTZkYOJ9w/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="定位字段详情"><a href="#定位字段详情" class="headerlink" title="定位字段详情"></a>定位字段详情</h2><p>我们希望看到某个类下所有字段的详情，我们就可以使用这条命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d -f 类的包路径</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/14b02bce930931ab5b865f90652adb1d171301454.png" alt="image-20250115175942543"></p><p>想查看<code>TestController</code>的字段详情，就可以键入这条命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d -f com.example.arthasExample.TestController</span><br></pre></td></tr></table></figure><p>可以看到这条指令不仅可以查看字段的定义和注解，还可以查看线程池的使用情况以及集合内部的<code>value</code>：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wic5BjMXGvIPibqCvB1gveoMmSNpxKCCmibibickjiabjRs5QQsOEGVlYTLchrqXxHBFIr4lj5119Pkk17exUbpUds7A/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="查看静态变量"><a href="#查看静态变量" class="headerlink" title="查看静态变量"></a>查看静态变量</h2><p>按照官网的说明，对于静态变量的监控更推荐使用 ognl 表达式</p><p><img src="https://i0.hdslb.com/bfs/article/2428134fdbb6543a16bc429eaf1ade7d171301454.png" alt="image-20250115180525605"></p><p>可以先使用sc命令查看hash值</p><p><img src="https://i0.hdslb.com/bfs/article/8c3ed4e9fc1b0d36d8c20bac13f030b1171301454.png" alt="image-20250115180630475"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wic5BjMXGvIPiawlrxvIuWoMj0BRuABFFtT4r3qxX8I1xDAw6Bexx57iaFDPibicA1rlJibjRAv4dor2jdibCq0Y2hrOA/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>得到classLoader的hash值以后，再把其粘贴到输入框中，点击copy command，这样ognl表达式就生成了</p><p><img src="https://i0.hdslb.com/bfs/article/6cab129a1fa3dcd2918f672457446c23171301454.png" alt="image-20250115180732331"></p><h2 id="运行耗时"><a href="#运行耗时" class="headerlink" title="运行耗时"></a>运行耗时</h2><p>使用trace命令可以直观地观察到这个接口运行最耗时的方法</p><p><img src="https://i0.hdslb.com/bfs/article/bda0db91da3d48e9dcc7984f540a6ca7171301454.png" alt="image-20250115181213513"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace com.jr.uhr.org.controller.SysPostController getByPostTreeList  -n 7 --skipJDKMethod false </span><br></pre></td></tr></table></figure><h2 id="方法执行情况监控"><a href="#方法执行情况监控" class="headerlink" title="方法执行情况监控"></a>方法执行情况监控</h2><p>我们希望查询单位时间内这个方法的执行成功、失败、以及平均耗时等情况，也就是<code>monitor</code>监控指令，也可以直接通过插件快速生成：</p><p><img src="https://i0.hdslb.com/bfs/article/6f912fb07e9026e250e00cfd582ccabf171301454.png" alt="image-20250115181428147"></p><p>默认情况下，生成的指令为会执行10次，每10s进行一次输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitor com.jr.uhr.org.controller.SysPostController getByPostTreeList  -n 10  --cycle 10 </span><br></pre></td></tr></table></figure><h2 id="监控方法出入参"><a href="#监控方法出入参" class="headerlink" title="监控方法出入参"></a>监控方法出入参</h2><p>生成指令的步骤还是一样的，对准方法然后右键通过插件快捷生成指令：</p><p><img src="https://i0.hdslb.com/bfs/article/951f551f5cda943f7465a4e22bc3a4f1171301454.png" alt="image-20250115181529055"></p><p>指令的会打印出入参和异常，然后执行次数为7，输出的结果属性的遍历深度为4，对应的指令和执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.jr.uhr.org.controller.SysPostController getByPostTreeList &#x27;&#123;params,returnObj,throwExp&#125;&#x27;  -n 7  -x 4 </span><br></pre></td></tr></table></figure><h2 id="监控方法调用路径"><a href="#监控方法调用路径" class="headerlink" title="监控方法调用路径"></a>监控方法调用路径</h2><p>使用stack指令：</p><p><img src="https://i0.hdslb.com/bfs/article/d5e7dd118822eb2e63790d06f7d1eba6171301454.png" alt="image-20250115181650035"></p><p>会给出我们选中的类的全路径和方法名，默认执行7次，这样我们就可以快速的得到当前调用的堆栈信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack com.jr.uhr.org.service.SysPostService getByPostTreeList  -n 7 </span><br></pre></td></tr></table></figure><h2 id="获取方法调用过程"><a href="#获取方法调用过程" class="headerlink" title="获取方法调用过程"></a>获取方法调用过程</h2><p>在开发测试过程中，如果遇到需要上游调用的情况，可能上游触发了一次后，没能观察到具体的问题，但又不好意思让上游配合多触发几次，这时候就得使用 tt 指令了。</p><p><img src="https://i0.hdslb.com/bfs/article/1c8a8e9ac3552e14387b9046f0293ba7171301454.png" alt="image-20250115182507946"></p><p>然后点击第一行复制这个指令，可以看到这个指令会指明我们要监控的类和方法，默认情况下执行7次：</p><p><img src="https://i0.hdslb.com/bfs/article/fbb57493d61fa184fb90ce868c7895be171301454.png" alt="image-20250115182539545"></p><p>查看监控结果可以看到，第二次执行报错：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wic5BjMXGvIPiawlrxvIuWoMj0BRuABFFtCOacibQuBP2TcT1TR7AgXYiasScy9XnbudMibZfeLdeFmo6UC9tMlQqhw/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>查看索引为1003，所以我们键入<code>tt -i 1003</code>,此时我们就可以直观的看到入参和错误详情：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wic5BjMXGvIPiawlrxvIuWoMj0BRuABFFtvLttZQKicVuWh93UeVzw84tsrDff4fciatnWlK8v9TvGWAyAdzXWFTYQ/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>同时这个插件的第二行列举了许多tt的指令，鼠标悬浮在上面可以看到相应的中文释义</p><p><img src="https://i0.hdslb.com/bfs/article/305851de9f7d10462548a800f23147a1171301454.png" alt="image-20250115182752577"></p><p>需要强调的是，tt 命令是将当前环境的对象引用保存起来，但仅仅也只能保存一个引用而已。如果方法内部对入参进行了变更，或者返回的对象经过了后续的处理，那么在 tt 查看的时候将无法看到当时最准确的值。这也是为什么 watch 命令存在的意义。</p><p>注意:tt 相关功能在使用完之后，需要手动释放内存，否则长时间可能导致<code>OOM</code>。退出 <code>arthas</code> 不会自动清除 tt 的缓存 <code>map</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt --delete-all</span><br></pre></td></tr></table></figure><h2 id="内存溢出问题"><a href="#内存溢出问题" class="headerlink" title="内存溢出问题"></a>内存溢出问题</h2><p>可以使用dashboard查看随着时间推移的内存变化情况</p><p><img src="https://i0.hdslb.com/bfs/article/af3bcb38657b6bc2318750b29de1ff0e171301454.png" alt="image-20250115183138681"></p><p>此时我们就可以借助插件快速生成<code>heapdump</code>指令：</p><p><img src="https://i0.hdslb.com/bfs/article/e508306c5099b5c7edb61bbf02e389ec171301454.png" alt="image-20250115183209418"></p><p>从指令上看，默认情况下，内存快照会被dump到tmp目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heapdump /tmp/dump.hprof</span><br></pre></td></tr></table></figure><p>同时也可以导出到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heapdump D://heap.hprof</span><br></pre></td></tr></table></figure><p>然后我们就可以通过MAT定位到出现问题的线程，然后根据名称取搜索问题线程和有相关threadLocal操作的变量即可。</p><h2 id="热更新代码"><a href="#热更新代码" class="headerlink" title="热更新代码"></a>热更新代码</h2><p>我们希望将线上环境这段代码条件由小于2改为小于等于0，对此我们可以通过<code>arthas</code>的jad反编译、mc编译以及redefine完成热点代码更新：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过postCode查询岗位信息列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> postCode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line">   <span class="meta">@GetMapping(&quot;/getByPostCode&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">getByPostCode</span><span class="params">(String postCode, String startDate)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sysPostService.getByPostCode(postCode, startDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们通过插件获取反编译指令</p><p><img src="https://i0.hdslb.com/bfs/article/278981939a6bcbab4257846e9bee068e171301454.png" alt="image-20250116094026761"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad --source-only com.jr.uhr.org.controller.SysPostController getByPostCode</span><br></pre></td></tr></table></figure><p>生成指令后，我们手动设置导出路径<code>/tmp/SysPostController.java</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad --source-only com.jr.uhr.org.controller.SysPostController &gt;&gt; /tmp/SysPostController.java</span><br></pre></td></tr></table></figure><p>然后通过<code>vim /tmp/SysPostController.java</code>修改代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过postCode查询岗位信息列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> postCode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">@Log(title = &quot;通过postCode查询岗位信息列表&quot;, businessType = BusinessType.SELECT)</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/getByPostCode&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">getByPostCode</span><span class="params">(String postCode, String startDate)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sysPostService.getByPostCode(postCode, startDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要通过<code>arthas</code>得到当前类的<code>hashCode</code></p><p><img src="https://i0.hdslb.com/bfs/article/a12c34743907207939c37b5744a5325e171301454.png" alt="image-20250116094511378"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d com.jr.uhr.org.controller.SysPostController</span><br></pre></td></tr></table></figure><p>基于上述的<code>hashCode</code>，我们通过<code>mc</code>指令将<code>tmp</code>下的<code>Java</code>文件编译为字节码文件到<code>/tmp</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc -c 68de145  /tmp/SysPostController.java -d /tmp</span><br></pre></td></tr></table></figure><p>最后我们通过redifine将这个class文件到JVM里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redefine /tmp/com/example/arthasExample/SysPostController.class</span><br></pre></td></tr></table></figure><p>如果看到<code>success</code>就说明我们的代码替换成功了，此时请求接口就有存储日志了。</p><h2 id="获取spring上下文的操作"><a href="#获取spring上下文的操作" class="headerlink" title="获取spring上下文的操作"></a>获取spring上下文的操作</h2><p>spring中有个上下文叫applicationContext，它记录着所有的bean的信息，通过该容器我们可以得到所有的bean进行各种操作。这意味着如果我们在spring项目中如果有什么特殊的执行操作，完全可以通过tt定位到包含上下文的类，然后获取其applicationContext完成特殊操作。</p><p>读过Spring MVC源码的读者可能都知道，每当又HTTP请求发送到web容器时请求进行映射转发处理时都会经过RequestMappingHandlerAdapter，所以我们通过插件生成<code>RequestMappingHandlerAdapter</code>的tt指令：</p><p><img src="https://i0.hdslb.com/bfs/article/2e5e03902832a6706564b3025e6b7136171301454.png" alt="image-20250116094814906"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter * -n 7 </span><br></pre></td></tr></table></figure><p>这个arthas插件甚至可以在设置里配置static spring context</p><p><img src="https://i0.hdslb.com/bfs/article/f6ab175d2ef81852c358c08be899ea74171301454.png" alt="image-20250116095805803"></p><p>然后等待用户请求后，定位到这个类，如下图对应1000索引就是笔者的请求：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Wic5BjMXGvIPiawlrxvIuWoMj0BRuABFFtykYZYfsd1gw8E8QP9r154teKaM8Wdkic6BMUYA2OyVhwYVArW8z7ekg/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>基于这个索引对应的target，其实就是我们的RequestMappingHandlerAdapter，我们通过-w 像写java代码一样获取到applicationContext从而得到testController最终完成调用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -i 1000 -w &#x27;target.getApplicationContext().getBean(&quot;testController&quot;).findUserById(3)&#x27;</span><br></pre></td></tr></table></figure><h2 id="使用火焰图实现性能优化"><a href="#使用火焰图实现性能优化" class="headerlink" title="使用火焰图实现性能优化"></a>使用火焰图实现性能优化</h2><p>Async-profiler 可以观测运行程序，每一段代码所占用的cpu的时间和比例,从而可以分析并找到项目中占用cpu时间最长的代码片段，优化热点代码，达到优化内存的效果。</p><p><strong>火焰图里，X轴越长,代表使用的越多,Y轴是调用堆栈信息</strong>。当前收集的是什么类型的数据，比如cpu 那么x轴长度越大,占用的cpu资源就越多~。</p><p><img src="https://i0.hdslb.com/bfs/article/0c5b4a4762404dd768cda6c105a16865171301454.png" alt="image-20250116103405101"></p><p>第一行可以选择监测的对象，这里选的是监测CPU资源，还能选择用户态&#x2F;内核态，点击不同线程分开统计</p><p><img src="https://i0.hdslb.com/bfs/article/5a17c26645a55df9bdd010c0f126d5af171301454.png" alt="image-20250116103339400"></p><p>开始监测命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler start --event cpu --interval 10000000</span><br></pre></td></tr></table></figure><p>结束监测命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler start --event cpu --interval 10000000 --format html --duration 30 </span><br></pre></td></tr></table></figure><p>结果如下图，此图俗称火焰图，主要看每个方法的横轴长度，占用横坐标越长的操作，其占用的 cpu 即最长，很直观的。</p><p><img src="https://upload-images.jianshu.io/upload_images/6393906-8756a436fb1cc406.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>分析x轴越长的方法，观察是否有优化空间，优化完以后再生成一次火焰图查看优化的结果。</p><p>如果生成的火焰图不太理想，当async-profiler全量采样导出的svg文件太大时，想要找到关键的调用点，就非常困难。</p><p><img src="https://user-images.githubusercontent.com/716461/89874894-1093a680-dbef-11ea-8c58-b6d56e6ecb3b.jpg" alt="1"></p><p>也可以换一种生成方式，生成jfr文件，使用jprofiler打开jfr文件，选择Open a snapshot, 打开之后选择CPU views</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler start --event cpu --interval 10000000 --threads --format jfr --duration 30 --threads</span><br></pre></td></tr></table></figure><p>View -&gt; Find 查找要分析的类和方法，然后选择 Analyze -&gt; Calculate Backtraces to Selected Method</p><p>修改Summation mode 为Total times，即可看到这个方法被哪些上游调用到，调用量和占比</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>arthas快速入门：<a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></p><p>arthas插件的使用文档链接：<a href="https://www.yuque.com/arthas-idea-plugin/help/pe6i45">https://www.yuque.com/arthas-idea-plugin/help/pe6i45</a></p><p>用户实操案例分享：<a href="https://github.com/alibaba/arthas/issues?q=label:user-case&page=1">https://github.com/alibaba/arthas/issues?q=label%3Auser-case&amp;page=1</a></p><p><img src="https://i0.hdslb.com/bfs/article/0445542edbbd9875cf9917526dfa68c6171301454.png" alt="image-20250116100449644"></p><p><img src="https://i0.hdslb.com/bfs/article/3db90d5f5f9d1c80534bcf641fce2c70171301454.png" alt="image-20250116100506901"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arthas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ消息发送常见错误及解决方案</title>
      <link href="/2025/01/07/RocketMQ%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2025/01/07/RocketMQ%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="No-route-info-of-this-topic"><a href="#No-route-info-of-this-topic" class="headerlink" title="No route info of this topic"></a>No route info of this topic</h1><p>通常情况下 <code>No route info of this topic</code> 这个错误一般是在刚搭建 RocketMQ、刚入门 RocketMQ 遇到的比较多。通常的排查思路如下。</p><p>可以通过 RocketMQ-Console 查询路由信息是否存在，或使用如下命令查询路由信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;ROCKETMQ_HOME&#125;</span>/bin</span><br><span class="line">sh ./mqadmin topicRoute -n 127.0.0.1:9876 -t dw_test_0003</span><br></pre></td></tr></table></figure><ol><li>如果通过命令无法查询到路由信息，则查看 Broker 是否开启了自动创建 Topic，参数为 autoCreateTopicEnable，该参数默认为 true。但在生产环境不建议开启。</li><li>如果开启了自动创建路由信息，但还是抛出这个错误，这个时候请检查客户端（Producer）连接的 NameServer 地址是否与 Broker 中配置的 NameServer 地址是否一致。</li></ol><p>经过上面的步骤，基本就能解决该错误。</p><h1 id="消息发送超时"><a href="#消息发送超时" class="headerlink" title="消息发送超时"></a>消息发送超时</h1><p>RemotingTimeoutException:wait response on the channel&lt;&gt; timeout,3000ms</p><p>首先我们执行如下命令查看 RocketMQ 消息写入的耗时分布情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /<span class="variable">$&#123;USER.HOME&#125;</span>/logs/rocketmqlogs/</span><br><span class="line">grep -n <span class="string">&#x27;PAGECACHERT&#x27;</span> store.log | more</span><br></pre></td></tr></table></figure><p>RocketMQ 会每一分钟打印前一分钟内消息发送的耗时情况分布，我们从这里就能窥探 RocketMQ 消息写入是否存在明细的性能瓶颈，其区间如下：</p><ul><li>[&lt;&#x3D;0ms] 小于 0ms，即微妙级别的</li><li>[0~10ms] 小于 10ms 的个数</li><li>[10~50ms] 大于 10ms 小于 50ms 的个数</li></ul><p>其他区间显示，绝大多数会落在微秒级别完成，如果 100~200ms 及以上的区间超过 20 个，说明 Broker 确实存在一定的瓶颈，如果只是少数几个，说明这个是内存或 PageCache 的抖动，问题不大。</p><p>若出现网络超时，有什么解决方法？</p><p><strong>减少消息发送的超时时间，增加重试次数，并增加快速失败的最大等待时长</strong>。具体措施如下。</p><ol><li>增加 Broker 端快速失败的时长，建议为 1000，在 Broker 的配置文件中增加如下配置：</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxWaitTimeMillsInQueue</span>=<span class="number">1000</span></span><br></pre></td></tr></table></figure><p><strong>如果 RocketMQ 的客户端版本为 4.3.0 以下版本（不含 4.3.0）：</strong></p><p>将超时时间设置消息发送的超时时间为 500ms，并将重试次数设置为 6 次（这个可以适当进行调整，尽量大于 3）</p><p>尽快超时，并进行重试，并且 RocketMQ 有故障规避机制，重试的时候会尽量选择不同的 Broker，相关的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;dw_test_producer_group&quot;</span>);</span><br><span class="line"> producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line"> producer.setRetryTimesWhenSendFailed(<span class="number">5</span>);<span class="comment">//　同步发送模式：重试次数</span></span><br><span class="line"> producer.setRetryTimesWhenSendAsyncFailed(<span class="number">5</span>);<span class="comment">// 异步发送模式：重试次数</span></span><br><span class="line"> producer.start();</span><br><span class="line"> producer.send(msg,<span class="number">500</span>);<span class="comment">//消息发送超时时间</span></span><br></pre></td></tr></table></figure><p><strong>如果 RocketMQ 的客户端版本为 4.3.0 及以上版本：</strong></p><p>由于其设置的消息发送超时时间为所有重试的总的超时时间，故不能直接通过设置 RocketMQ 的发送 API 的超时时间，而是需要对其 API 进行包装，重试需要在外层收到进行，例如示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SendResult <span class="title function_">send</span><span class="params">(DefaultMQProducer producer, Message msg, <span class="type">int</span> </span></span><br><span class="line"><span class="params">                              retryCount)</span> &#123;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; retryCount; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> producer.send(msg,<span class="number">500</span>); <span class="comment">//设置超时时间，为 500ms，内部有重试机制</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e2) &#123;</span><br><span class="line">            e = e2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;消息发送异常&quot;</span>,e);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="System-busy、Broker-busy"><a href="#System-busy、Broker-busy" class="headerlink" title="System busy、Broker busy"></a>System busy、Broker busy</h1><p>纵观 RocketMQ 与 System busy、Broker busy 相关的错误关键字，总共包含如下 5 个：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[REJECTREQUEST]system busy</span><br><span class="line">too many requests and system thread pool busy</span><br><span class="line">[PC_SYNCHRONIZED]broker busy</span><br><span class="line">[PCBUSY_CLEAN_QUEUE]broker busy</span><br><span class="line">[TIMEOUT_CLEAN_QUEUE]broker busy</span><br></pre></td></tr></table></figure><h2 id="异常原因"><a href="#异常原因" class="headerlink" title="异常原因"></a>异常原因</h2><p>根据上述 5 类错误日志，其触发的原由可以归纳为如下 3 种。</p><h3 id="PageCache-压力较大"><a href="#PageCache-压力较大" class="headerlink" title="PageCache 压力较大"></a>PageCache 压力较大</h3><p>其中如下三类错误属于此种情况：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">REJECTREQUEST</span>]system busy</span><br><span class="line">[<span class="meta">PC_SYNCHRONIZED</span>]broker busy</span><br><span class="line">[<span class="meta">PCBUSY_CLEAN_QUEUE</span>]broker busy</span><br></pre></td></tr></table></figure><p>判断 PageCache 是否忙的依据就是，在写入消息、向内存追加消息时加锁的时间，默认的判断标准是加锁时间超过 1s，就认为是 PageCache 压力大，向客户端抛出相关的错误日志。</p><h3 id="发送线程池挤压的拒绝策略"><a href="#发送线程池挤压的拒绝策略" class="headerlink" title="发送线程池挤压的拒绝策略"></a>发送线程池挤压的拒绝策略</h3><p>在 RocketMQ 中处理消息发送的，是一个只有一个线程的线程池，内部会维护一个有界队列，默认长度为 1W。如果当前队列中挤压的数量超过 1w，执行线程池的拒绝策略，从而抛出 [too many requests and system thread pool busy] 错误。</p><h3 id="Broker-端快速失败"><a href="#Broker-端快速失败" class="headerlink" title="Broker 端快速失败"></a>Broker 端快速失败</h3><p>[TIMEOUT_CLEAN_QUEUE]broker busy</p><p>默认情况下 Broker 端开启了快速失败机制，就是在 Broker 端还未发生 PageCache 繁忙（加锁超过 1s）的情况，但存在一些请求在消息发送队列中等待 200ms 的情况，RocketMQ 会不再继续排队，直接向客户端返回 System busy，但由于 RocketMQ 客户端目前对该错误没有进行重试处理，所以在解决这类问题的时候需要额外处理。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="PageCache-繁忙解决方案"><a href="#PageCache-繁忙解决方案" class="headerlink" title="PageCache 繁忙解决方案"></a>PageCache 繁忙解决方案</h3><p>一旦消息服务器出现大量 PageCache 繁忙（在向内存追加数据加锁超过 1s）的情况，这个是比较严重的问题，需要人为进行干预解决，解决的问题思路如下。</p><h4 id="1-transientStorePoolEnable"><a href="#1-transientStorePoolEnable" class="headerlink" title="1.transientStorePoolEnable"></a>1.transientStorePoolEnable</h4><p>开启 transientStorePoolEnable 机制，即在 Broker 中配置文件中增加如下配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">transientStorePoolEnable</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>引入 transientStorePoolEnable 能缓解 PageCache 的压力背后关键如下：</p><ul><li>消息先写入到堆外内存中，该内存由于启用了内存锁定机制，故消息的写入是接近直接操作内存，性能可以得到保证。</li><li>消息进入到堆外内存后，后台会启动一个线程，一批一批将消息提交到 PageCache，即写消息时对 PageCache 的写操作由单条写入变成了批量写入，降低了对 PageCache 的压力。</li></ul><p>引入 transientStorePoolEnable 会增加数据丢失的可能性，如果 Broker JVM 进程异常退出，提交到 PageCache 中的消息是不会丢失的，但存在堆外内存（DirectByteBuffer）中但还未提交到 PageCache 中的这部分消息，将会丢失。但通常情况下，RocketMQ 进程退出的可能性不大，通常情况下，如果启用了 transientStorePoolEnable，消息发送端需要有重新推送机制（补偿思想）。</p><h4 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2.扩容"></a>2.扩容</h4><p>如果在开启了 transientStorePoolEnable 后，还会出现 PageCache 级别的繁忙，那需要集群进行扩容，或者对集群中的 Topic 进行拆分，即将一部分 Topic 迁移到其他集群中，降低集群的负载。</p><p><em>温馨提示：在Broker扩容时候，可以复制集群中任意一台Broker服务下${ROCKETMQ_HOME}&#x2F;store&#x2F;config&#x2F;topics.json到新Broker服务器指定目录，避免在新Broker服务器上为Broker创建队列，然后消息发送者、消息消费者都能动态获取Topic的路由信息。</em></p><h3 id="TIMEOUT-CLEAN-QUEUE-解决方案"><a href="#TIMEOUT-CLEAN-QUEUE-解决方案" class="headerlink" title="TIMEOUT_CLEAN_QUEUE 解决方案"></a>TIMEOUT_CLEAN_QUEUE 解决方案</h3><p>由于如果出现 TIMEOUT_CLEAN_QUEUE 的错误，客户端暂时不会对其进行重试，故现阶段的建议是适当增加快速失败的判断标准，即在 Broker 的配置文件中增加如下配置：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">＃该值默认为 200，表示 200ms</span><br><span class="line">waitTimeMillsInSendQueue=1000</span><br></pre></td></tr></table></figure><h1 id="处理消息堆积"><a href="#处理消息堆积" class="headerlink" title="处理消息堆积"></a>处理消息堆积</h1><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>在使用云消息队列 RocketMQ 版实例时收到消息堆积告警，登录<a href="https://ons.console.aliyun.com/?regionId=mq-internet-access&_k=nb9s96">云消息队列 RocketMQ 版控制台</a>后发现了下列现象：</p><ul><li>在<strong>Group 详情</strong>页面，看到Group ID的<strong>实时消息堆积量</strong>的值高于预期。</li><li>导航栏中选择<strong>消息轨迹</strong>，单击<strong>创建查询任务</strong>，选择<strong>按 Message ID 查询</strong>，输入对应的信息，发现部分消息已发送至Broker节点，但未投递给下游消费者。</li></ul><h2 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h2><p>云消息队列 RocketMQ 版的消息发送至Broker节点后，配置了Group ID的客户端根据当前的消费位点，从Broker节点拉取部分消息到本地进行消费，拉取到的消息缓存到本地缓冲队列中。</p><p>一般情况下，客户端从Broker节点拉取消息的过程不会导致消息堆积，例如：1个单线程单分区的低规格机器（4C8GB）可以达到几万TPS，如果是多个分区可以达到几十万TPS。所以这一阶段一般不会成为消息堆积的瓶颈。</p><p>主要是客户端本地消费过程中，由于消费耗时过长或消费并发度较小等原因，导致客户端消费能力不足，出现消息堆积的问题。</p><p>消息出现堆积，可能原因如下：</p><ul><li>消费者消息处理逻辑异常，导致消息无法正常消费。</li><li>消息生产应用出现突发流量，消息生产速度远大于消费速度，消息来不及消费出现堆积。</li><li>消费者依赖的下游服务耗时变长，消费线程阻塞等。</li><li>消费线程不够，消费并发度较小，消费速度跟不上生产速度。</li></ul><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>若出现消息堆积，可参考以下措施进行定位和处理。</p><ol><li><p>判断消息堆积在云消息队列 RocketMQ 版服务端还是客户端。</p><p>查看客户端本地日志文件<code>ons.log</code>，搜索是否出现如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the cached message count exceeds the threshold</span><br></pre></td></tr></table></figure><ul><li>出现相关日志信息，说明客户端本地缓冲队列已满，消息堆积在客户端，请执行<a href="https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-4-x-series/use-cases/how-do-i-handle-accumulated-messages?spm=a2c4g.11186623.0.0.774e6c23DEw4cq#step-zbp-czw-m7t">步骤2</a>。</li><li>若未出现相关日志，说明消息堆积不在客户端，若出现这种特殊情况，请直接联系阿里云技术支持。</li></ul></li></ol><p>确认消息的消费耗时是否合理。</p><ul><li>若查看到消费耗时较长，则需要查看客户端堆栈信息排查具体业务逻辑，请执行<a href="https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-4-x-series/use-cases/how-do-i-handle-accumulated-messages?spm=a2c4g.11186623.0.0.774e6c23DEw4cq#step-8l0-fak-i8b">步骤3</a>。</li><li>若查看到消费耗时正常，则有可能是因为消费并发度不够导致消息堆积，需要逐步调大消费线程或扩容节点来解决。</li></ul><p>消息的消费耗时可以通过以下方式查看：</p><ul><li>登录<a href="https://ons.console.aliyun.com/?regionId=mq-internet-access&_k=nb9s96">云消息队列 RocketMQ 版控制台</a>查看消息的消费轨迹，在<strong>消费者</strong>区域中可以看到单条消息的<strong>消费耗时</strong>。</li></ul><p><img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/1037659361/p369325.png" alt="消费耗时"></p><ul><li><p>登录<a href="https://ons.console.aliyun.com/?regionId=mq-internet-access&_k=nb9s96">云消息队列 RocketMQ 版控制台</a>查看消费者状态，在客户端连接信息中查看<strong>业务处理时间</strong>，获取消费耗时的平均值。</p><p><img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/3999517061/p188533.png" alt="消费状态"></p></li></ul><ol start="3"><li>查看客户端堆栈信息。只需要关注线程名为ConsumeMessageThread的线程，这些都是业务消费消息的逻辑。</li></ol><p>客户端堆栈信息可以通过以下方式获取：</p><ul><li>登录<a href="https://ons.console.aliyun.com/?regionId=mq-internet-access&_k=nb9s96">云消息队列 RocketMQ 版控制台</a>查看消费者状态，在客户端连接信息中查看<strong>Java客户端堆栈信息</strong>。</li><li>使用Jstack工具打印堆栈信息。</li></ul><p>执行以下任意命令，查看并记录Java进程的PID。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef </span><br><span class="line">|grep javajps -lm</span><br></pre></td></tr></table></figure><p>执行以下命令，查看堆栈信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -l pid &gt; /tmp/pid.jstack</span><br></pre></td></tr></table></figure><p>执行以下命令，查看<code>ConsumeMessageThread</code>的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /tmp/pid.jstack|grep ConsumeMessageThread -A 10 --color</span><br></pre></td></tr></table></figure><ol><li><p>常见的异常堆栈信息如下：</p><ul><li><p>示例一：空闲无堆积的堆栈。</p><p>消费空闲情况下消费线程都会处于WAITING状态等待从消费任务队中获取消息。</p><p><img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/4634237061/p188690.png" alt="堆栈示例一"></p></li><li><p>示例二：消费逻辑有抢锁休眠等待等情况。</p><p>消费线程阻塞在内部的一个睡眠等待上，导致消费缓慢。<img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/4634237061/p188702.png" alt="堆栈示例二"></p></li><li><p>示例三：消费逻辑操作数据库等外部存储卡住。</p><p>消费线程阻塞在外部的HTTP调用上，导致消费缓慢。<img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/4634237061/p188705.png" alt="堆栈示例3"></p></li></ul></li><li><p>针对某些特殊业务场景，如果消息堆积已经影响到业务运行，且堆积的消息本身可以跳过不消费，您可以通过重置消费位点跳过这些堆积的消息从最新位点开始消费，快速恢复业务。（广播模式不支持重置消费位点，且消费者必须在线才能重置消费位点）</p></li></ol><ul><li><p><strong>最新位点开始消费</strong>：若选择此项，该Group ID在消费指定Topic下的消息时会跳过当前堆积（未被消费）的所有消息，从最新消息开始消费。</p><p><strong>警告</strong></p><p>若选择<strong>从最新位点开始消费</strong>，则Group ID在指定Topic中的堆积消息将被全部清除，该操作大概2<del>3分钟后生效，请勿重复操作。期间应用所有的消费者将暂停消费2</del>3分钟，对延迟敏感的业务请谨慎使用。</p></li><li><p><strong>从指定时间点的位点开始消费</strong>：选择此项后会出现时间选择控件。请指定一个时间点，消费者将从这个时间点之后发送的消息开始消费，不管之前的消息是否又被消费过。（通过重置消费位点最多可重新消费到3天前的消息）</p></li></ul><p>目前重置消息功能对重试中消息不生效，因此重置后仍然可能会有少量重试消息投递。</p><h2 id="若某个消费组下的机器宕机，机器重启期间，消息会不会丢失？"><a href="#若某个消费组下的机器宕机，机器重启期间，消息会不会丢失？" class="headerlink" title="若某个消费组下的机器宕机，机器重启期间，消息会不会丢失？"></a>若某个消费组下的机器宕机，机器重启期间，消息会不会丢失？</h2><p>云消息队列 RocketMQ 版的订阅是持久化订阅，ConsumerGroup下线或消费异常时，消息不会丢失。当消费者客户端重新上线后，直接从下线前的消费位点继续消费消息。</p><h2 id="创建新的消费分组订阅旧的Topic，如何设置消费起始位置？"><a href="#创建新的消费分组订阅旧的Topic，如何设置消费起始位置？" class="headerlink" title="创建新的消费分组订阅旧的Topic，如何设置消费起始位置？"></a>创建新的消费分组订阅旧的Topic，如何设置消费起始位置？</h2><p>消费者分组创建时不支持设置消费起始位置，不管是订阅新的Topic还是旧的Topic，消费者第一次启动时都会默认从Topic中的最早一条消息开始消费。</p><p>消费者首次启动后，可以重置消费位点。</p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识netty及整合SpringBoot实践</title>
      <link href="/2024/12/13/%E5%88%9D%E8%AF%86netty%E5%8F%8A%E6%95%B4%E5%90%88SpringBoot%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/12/13/%E5%88%9D%E8%AF%86netty%E5%8F%8A%E6%95%B4%E5%90%88SpringBoot%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Netty"><a href="#初识Netty" class="headerlink" title="初识Netty"></a>初识Netty</h1><p>Netty 是一个 NIO 客户端服务器框架，可快速轻松地开发网络应用程序，例如协议服务器和客户端。有了Netty，你可以实现自己的HTTP服务器，FTP服务器，UDP服务器，RPC服务器，WebSocket服务器，Redis的Proxy服务器，MySQL的Proxy服务器等等。  </p><p>Netty 的 I&#x2F;O 模型是基于非阻塞 I&#x2F;O 实现的，底层依赖的是 JDK NIO 框架的多路复用器 Selector。一个多路复用器 Selector 可以同时轮询多个 Channel，采用 epoll 模式后，只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。</p><p>Netty 所采用的主从 Reactor 多线程模型，所有的 I&#x2F;O 事件都注册到一个 I&#x2F;O 多路复用器上，当有 I&#x2F;O 事件准备就绪后，I&#x2F;O 多路复用器会将该 I&#x2F;O 事件通过事件分发器分发到对应的事件处理器中。该线程模型避免了同步问题以及多线程切换带来的资源开销，真正做到高性能、低延迟。</p><p><strong>NIO的特点：</strong></p><ol><li>一个线程可以处理多个通道，减少线程创建数量；</li><li>读写非阻塞，节约资源：没有可读／可写数据时，不会发生阻塞导致线程资源的浪费</li></ol><h2 id="为什么选择Netty"><a href="#为什么选择Netty" class="headerlink" title="为什么选择Netty"></a>为什么选择Netty</h2><p><strong>高性能低延迟</strong></p><ul><li><p><strong>异步非阻塞 I&#x2F;O 和事件驱动模型：</strong>Netty 能够在一个或少量线程下同时处理多个连接的读写事件，避免了大量线程因阻塞等待 I&#x2F;O 操作而导致的资源浪费，从而显著提高了系统的吞吐量和性能。</p></li><li><p><strong>零拷贝技术的有效利用</strong>：许多网络框架在数据传输过程中涉及多次数据复制，而 Netty 的零拷贝技术能够减少数据在内存中的复制次数。例如，在文件传输或大数据量的网络通信场景下，这可以极大地减少 CPU 开销，提高数据传输效率。</p></li></ul><p><strong>高度的灵活性和可定制性</strong></p><ul><li><strong>编解码框架的插件式设计</strong>：Netty 提供了灵活的编解码框架，支持用户轻松插入自定义的编解码器。允许针对不同的协议（如自定义的二进制协议、特殊的文本协议等）编写编解码器。</li><li><strong>管道（Pipeline）机制的强大功能</strong>：Netty 的管道机制允许构建一个由多个处理器（Handler）组成的处理链。</li></ul><p><strong>广泛的协议支持和良好的跨平台性</strong></p><ul><li><strong>多种协议支持</strong>：Netty 对多种常见的网络协议（如 HTTP、WebSocket、TCP、UDP 等）提供了很好的支持，并且能够方便地在不同协议之间切换或同时支持多种协议。</li><li><strong>跨平台性强</strong>：基于 Java 语言编写的 Netty 具有良好的跨平台特性，能够在不同的操作系统（如 Windows、Linux、Mac 等）上运行，并且保持性能和功能的一致性。</li></ul><p>如果不用netty，使用原生JDK的话，有如下问题：</p><p>1、API复杂，需要对多线程很熟悉：因为NIO涉及到Reactor模式</p><p>2、可定制化的线程模型，用户可以通过启动的配置参数选择 Reactor 线程模型；另一个是可扩展的事件驱动模型，将框架层和业务层的关注点分离。大部分情况下，开发者只需要关注 ChannelHandler 的业务逻辑实现。</p><p>3、Netty 更加可靠稳定，修复和完善了 JDK NIO 较多已知问题，例如臭名昭著的 select 空转导致 CPU 消耗 100%，TCP 断线重连，keep-alive 检测等问题。</p><p>而Netty来说，他的api简单、性能高而且社区活跃（dubbo、rocketmq等都使用了它）</p><h2 id="Netty组件"><a href="#Netty组件" class="headerlink" title="Netty组件"></a>Netty组件</h2><p><img src="https://i0.hdslb.com/bfs/article/1491a994eaf6ad6a1ef46002e87b297c171301454.png" alt="image-20250103181703382"></p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel是 Java NIO 的一个基本构造。可以看作是传入或传出数据的载体。因此，它可以被打开或关闭，连接或者断开连接。</p><h3 id="ServerBootstrap-与-Bootstrap"><a href="#ServerBootstrap-与-Bootstrap" class="headerlink" title="ServerBootstrap 与 Bootstrap"></a>ServerBootstrap 与 Bootstrap</h3><p>Bootstarp 和 ServerBootstrap 被称为引导类，指对应用程序进行配置，并使他运行起来的过程。Netty处理引导的方式是使你的应用程序和网络层相隔离。</p><p>Bootstrap 是客户端的引导类，Bootstrap 在调用 bind()（连接UDP）和 connect()（连接TCP）方法时，会新创建一个 Channel，仅创建一个单独的、没有父 Channel 的 Channel 来实现所有的网络交换。</p><p>ServerBootstrap 是服务端的引导类，ServerBootstarp 在调用 bind() 方法时会创建一个 ServerChannel 来接受来自客户端的连接，并且该 ServerChannel 管理了多个子 Channel 用于同客户端之间的通信。</p><h3 id="EventLoop与EventLoopGroup"><a href="#EventLoop与EventLoopGroup" class="headerlink" title="EventLoop与EventLoopGroup"></a>EventLoop与EventLoopGroup</h3><p>EventLoop 定义了Netty的核心抽象，用来处理连接的生命周期中所发生的事件，在内部，将会为每个Channel分配一个EventLoop。EventLoop 本身只是一个线程驱动，在其生命周期内只会绑定一个线程，让该线程处理一个 Channel 的所有 IO 事件。</p><p>一个 Channel 一旦与一个 EventLoop 相绑定，那么在 Channel 的整个生命周期内是不能改变的。一个 EventLoop 可以与多个 Channel 绑定。即 Channel 与 EventLoop 的关系是 n:1，而 EventLoop 与线程的关系是 1:1。</p><p>EventLoopGroup 是一个 EventLoop 池，包含很多的 EventLoop。</p><h3 id="ChannelHandler-与-ChannelPipeline"><a href="#ChannelHandler-与-ChannelPipeline" class="headerlink" title="ChannelHandler 与 ChannelPipeline"></a>ChannelHandler 与 ChannelPipeline</h3><p>ChannelHandler 是对 Channel 中数据的处理器，这些处理器可以是系统本身定义好的编解码器，也可以是用户自定义的。这些处理器会被统一添加到一个 ChannelPipeline 的对象中，然后按照添加的顺序对 Channel 中的数据进行依次处理。</p><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>Netty 中所有的 I&#x2F;O 操作都是异步的，即操作不会立即得到返回结果，所以 Netty 中定义了一个 ChannelFuture 对象作为这个异步操作的“代言人”，表示异步操作本身。如果想获取到该异步操作的返回值，可以通过该异步操作对象的addListener() 方法为该异步操作添加监 NIO 网络编程框架 Netty 听器，为其注册回调：当结果出来后马上调用执行。</p><p>Netty 的异步编程模型都是建立在 Future 与回调概念之上的。</p><h1 id="Netty-SpringBoot的使用"><a href="#Netty-SpringBoot的使用" class="headerlink" title="Netty+SpringBoot的使用"></a>Netty+SpringBoot的使用</h1><p>假设要搭建一个基于 Netty 的 WebSocket 服务端应用，这段代码就可以作为基础的配置启动部分。</p><p>例如，应用是一个在线聊天系统的后端服务端，通过 WebSocket 与前端的网页客户端或者移动端客户端建立长连接来实时收发聊天消息。</p><p>bossGroup 负责接收众多客户端发起的 WebSocket 连接请求，一旦连接建立成功，对应的客户端连接通道就会被交给 workerGroup 中的 EventLoop 来处理后续的消息收发等操作。</p><p>SO_BACKLOG 设置为 128 可以应对一定量的并发连接请求排队情况，SO_KEEPALIVE 开启保活机制确保长时间空闲的连接依然处于可用状态，</p><p>而 NettyWebsocketHandlerInit 中添加的各种 ChannelHandler 则会负责对客户端发送过来的聊天消息进行解码、按照业务逻辑处理（如将消息转发给对应的接收方等）以及编码后再回复给客户端等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">NioEventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">NioEventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">NettyWebsocketHandlerInit</span>());</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">9999</span>).sync();</span><br><span class="line">            log.info(<span class="string">&quot;***********Netty服务器启动成功**************&quot;</span>);</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">&quot;Netty启动异常:&#123;&#125;&quot;</span>,e.getMessage(),e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; <span class="keyword">new</span> <span class="title class_">NettyServer</span>().start();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对不同的协议，可以使用不同的Handler去处理，也支持自定义Handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyWebsocketHandlerInit</span>  <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1 -支持http协议</span></span><br><span class="line">        socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">        <span class="comment">// 2 -支持大数据</span></span><br><span class="line">        socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());</span><br><span class="line">        <span class="comment">// 3 -支持http消息整合</span></span><br><span class="line">        socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">10240</span>));</span><br><span class="line">        <span class="comment">// 4 -自定义handler 重新定义uri需要在WebSocketServerProtocolHandler之前</span></span><br><span class="line">        socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyWebsocketHandler</span>());</span><br><span class="line">        socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyServerIdleHandler</span>(<span class="number">15</span>,<span class="number">60</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 5 -支持websocket协议</span></span><br><span class="line">        socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">WebSocketServerProtocolHandler</span>(<span class="string">&quot;/ws&quot;</span>, <span class="literal">null</span>, <span class="literal">true</span>, <span class="number">10485760</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给出一个支持WebSocket协议的自定义Handler的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyWebsocketHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;WebSocket-连接成功：&#123;&#125;&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 首次连接是FullHttpRequest，处理参数</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FullHttpRequest) &#123;</span><br><span class="line">            <span class="comment">// 校验请求头、msg，根据不同的消息做不同的业务处理</span></span><br><span class="line">            <span class="comment">// 可以在其中根据消息类型进行分发，将TextWebSocketFrame类型的消息转发到专门的channelRead0 - 类似的处理方法中。</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;连接异常:&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">                ctx.channel().close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        channelCloseHandler(ctx.channel(), <span class="literal">true</span>, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        channelCloseHandler(ctx.channel(), <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, TextWebSocketFrame textWebSocketFrame)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">// 只接收 TextWebSocketFrame 类型的消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">channelCloseHandler</span><span class="params">(Channel channel, <span class="type">boolean</span> isError, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据不同的情况remove掉channel中的消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 channel.writeAndFlush() 可以实现发送消息，可以定义一个WebSocketContext去封装发消息的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TextWebSocketFrame <span class="title function_">sendMessage</span><span class="params">(String message,<span class="type">boolean</span> success)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(JSONObject.toJSONString(success ? R.ok(message) : R.fail(message)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(Long userId, WebsocketResponseEnum msgType, Object message, WebsocketSourceEnum sourceEnum)</span>&#123;</span><br><span class="line">       channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(JSONObject.toJSONString(R.restResult(message, msgType.getCode(), msgType.getDesc()))));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis发布订阅模型"><a href="#Redis发布订阅模型" class="headerlink" title="Redis发布订阅模型"></a>Redis发布订阅模型</h2><p>Netty虽然可以解决单实例通信的问题，但是如果线上一个服务有多个实例，可能会使得实例A发送的消息未能同步到实例B，可能会漏掉某些用户的消息。针对于这种情况，需要引入Redis发布订阅模型将消息广播到各个实例上去。</p><p><img src="https://i0.hdslb.com/bfs/article/15ec6b1ad9f64ff29ed1ce65da9416e2171301454.png" alt="image-20241231182153201"></p><p>配置一个 <code>RedisMessageListenerContainer</code>，用于监听 Redis 消息队列中的消息，并在接收到消息时调用指定的消息处理方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    RedisMessageListenerContainer <span class="title function_">container</span><span class="params">(RedisConnectionFactory connectionFactory,RedisMessageListener messageListener)</span> &#123;</span><br><span class="line">        <span class="type">MessageListenerAdapter</span> <span class="variable">listenerAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageListenerAdapter</span>(messageListener,<span class="string">&quot;onMessage&quot;</span>);</span><br><span class="line">        <span class="type">RedisMessageListenerContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisMessageListenerContainer</span>();</span><br><span class="line">        container.setConnectionFactory(connectionFactory);</span><br><span class="line">        container.addMessageListener(listenerAdapter, <span class="keyword">new</span> <span class="title class_">PatternTopic</span>(WebSocketContext.SOCKET_REDIS_TOPIC));</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装redis广播消息的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSubscribe</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(List&lt;MessageEntity&gt; message)</span> &#123;</span><br><span class="line">        redisTemplate.convertAndSend(WebSocketContext.SOCKET_REDIS_TOPIC, JSONObject.toJSONString(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听redis广播消息，并使用netty发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisMessageListener</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getChannel());</span><br><span class="line">        <span class="keyword">if</span>(WebSocketContext.SOCKET_REDIS_TOPIC.equals(channel))&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> mapper.readValue(message.getBody(), String.class);</span><br><span class="line">                log.info(<span class="string">&quot;Redis Received message on channel:&#123;&#125; body:&#123;&#125; &quot;</span>, channel, data);</span><br><span class="line">                List&lt;MessageEntity&gt; messageEntities = JSONObject.parseArray(data, MessageEntity.class);</span><br><span class="line">                <span class="keyword">for</span>(MessageEntity messageEntity:messageEntities)&#123;</span><br><span class="line">                    WebSocketContext.sendMessage(messageEntity);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                log.error(<span class="string">&quot;redis message error:&#123;&#125;&quot;</span>,e.getMessage(),e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>验签二三事</title>
      <link href="/2024/11/22/%E9%AA%8C%E7%AD%BE%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
      <url>/2024/11/22/%E9%AA%8C%E7%AD%BE%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="验签方法"><a href="#验签方法" class="headerlink" title="验签方法"></a>验签方法</h1><p>一般来说，为了避免各个业务系统分别实现验签方法，导致系统间对接成本过高、代码冗余重复造轮，增加不必要的工作量，企业一般会统一验签规则。</p><h2 id="APISIX-网关验签"><a href="#APISIX-网关验签" class="headerlink" title="APISIX 网关验签"></a>APISIX 网关验签</h2><p>APISIX 是一个动态、实时、高性能的API网关，如果想设置对外暴露的接口地址转发至相应的k8s服务，可以在 APISIX 中配置路由，在插件配置步骤中可开启 hmac-auth 验签（此插件可自定义），并实现验签功能。</p><p><img src="https://i0.hdslb.com/bfs/article/c2b9884cf656917f9e0cba47457c1bc9171301454.png" alt="image-20241125185558850"></p><p>hmac-auth 验签插件支持自定义请求头及一系列的 filter 规则，支持统一的正确&#x2F;错误响应体，也支持在 nacos 中读取限流配置信息。自定义好插件后，需要将插件启动，在容器中运行才可生效。</p><h3 id="nacos-限流配置"><a href="#nacos-限流配置" class="headerlink" title="nacos 限流配置"></a>nacos 限流配置</h3><p><img src="https://i0.hdslb.com/bfs/article/ff67482e4d956ed13c062afce115ec8e171301454.png" alt="image-20241125190110956"></p><h3 id="验签密钥"><a href="#验签密钥" class="headerlink" title="验签密钥"></a>验签密钥</h3><p>而只要开启了 APISIX 的 hmac-auth 验签，所有经过该路由的方法都需要用这个验签方法，怎么就能让业务系统接入这个验签规则呢？我们公司的 PAAS 系统就在创建应用的时候，为业务系统创建了相应的 APPKEY 和 secret，并且调用了APISIX的一个请求消费者的接口，将APPKEY 和 secret 推给了 APISIX，这才将业务系统的密钥传到了 APISIX 的网关验签，使得业务系统的验签规则可适用于APISIX的网关验签。至于如何使用，PAAS 只需要集成一套适用于APISIX网关的验签方法，做成组件让业务系统接入就可以使用了。</p><p><img src="https://i0.hdslb.com/bfs/article/6ec860f482a4add31a32013afadbec43171301454.png" alt="image-20241125185837008"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jr_paas_getway&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;paas层网关配置&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hmac-auth&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;access_key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1937e8e7-5c91-4023-bfc9-38b5d79f12d5&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;algorithm&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hmac-sha256&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;clock_skew&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;disable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;secret_key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a6063352-0abf-4697-b6b4-7eab40c88bdd&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;signed_headers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;appKey&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/c149ebe03205084627b4cb1f2ee569f6171301454.png" alt="image-20241124021232729"></p><h2 id="自定义验签"><a href="#自定义验签" class="headerlink" title="自定义验签"></a>自定义验签</h2><p>对于不需要经过网关的接口，即业务系统的接口，需要自定义一套验签方法，一般用于业务系统间对接调用。所以 PAAS 就定义了一套适用于客户端的验签方法。</p><p>调用方会在调其他业务系统接口时在请求头中携带相应的 APPKEY 和 secret 生成的签名，被调用方需要在配置文件中配置上调用方携带的 APPKEY 和 secret，然后在接口加上  @SignValidated 注解。</p><p>@SignValidated 注解作用：aop 获取请求头中的 APPKEY 和 SIGNATURE，与配置文件中的 APPKEY 和 secret 生成的签名比对，一致则验签通过。</p><p><img src="https://i0.hdslb.com/bfs/article/e370aa2e85505c2413882b107e096ac4171301454.png" alt="image-20241124023117896"></p><h2 id="供应商对接"><a href="#供应商对接" class="headerlink" title="供应商对接"></a>供应商对接</h2><p>而在对接供应商时开放给外网的接口，一般会接入供应商提供的验签方法。</p><p>而公司也有一个被外网调用的URL，统一按照<code>/paas/v1/callback/业务模块/**/**</code>提供给供应商，并在APISIX做好路由转发到相应的业务模块。</p><h3 id="IP白名单"><a href="#IP白名单" class="headerlink" title="IP白名单"></a>IP白名单</h3><p>有些供应商会提供IP给到我们，可以让公司运维为暴露到外网的接口配置IP白名单，仅允许该厂商调用。</p><h3 id="厂商定义验签"><a href="#厂商定义验签" class="headerlink" title="厂商定义验签"></a>厂商定义验签</h3><p>有些供应商也会制定一套验签规则，需要在对接过程中约定好传输的appKey和secret及验签方式。在项目中定义适用于该厂商的 @SignValidated 注解，并写一个aop切面用于处理该厂商的验签方法。</p><p>对接过程中需要与厂商多次联调测试，以确保加上验签后能成功解密出厂商传输到业务系统接口的数据。</p><h2 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h2><p>公司目前有两套验签方式，需注意这两者的区别和使用场景，在进行对接时需提前沟通好使用哪种验签方式。</p><ul><li>使用网关验签时，</li></ul><p>​被调用方：需在 APISIX 开启 hmac-auth 验签</p><p>​调用方：需使用 paas 的生成网关验签请求头方法。</p><ul><li>使用自定义验签时，</li></ul><p>​被调用方：1. 配置文件添加 appKey 和 secret 配置  2. 在接口加上  @SignValidated 注解</p><p>​调用方：使用 paas 的自定义生成验签请求头方法</p><p>​如果使用自定义验签时仍不生效，在检查配置正确、依赖正确、方法正确后，可以再在 APISIX 上检查该接口是否配置了路由转发，导致自定义验签获取不到真正的接口地址从而导致验签失败，也有在 APISIX 同时开启了网关验签而与自定义验签冲突的可能性。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 验签 </tag>
            
            <tag> APISIX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ的最佳实践</title>
      <link href="/2024/11/11/RocketMQ%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/11/11/RocketMQ%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="幂等性保证"><a href="#幂等性保证" class="headerlink" title="幂等性保证"></a>幂等性保证</h1><p>对于非幂等的请求，我们在业务里要做幂等性保证。</p><h2 id="在消息队列中的幂等性体现"><a href="#在消息队列中的幂等性体现" class="headerlink" title="在消息队列中的幂等性体现"></a>在消息队列中的幂等性体现</h2><p>消息队列中，很可能一条消息被冗余部署的多个消费者收到，对于非幂等的操作，比如用户的注册，就需要做幂等性保证，否则消息将会被重复消费。可以将情况概括为以下几种:</p><ul><li><p>生产者重复发送：由于网络抖动，导致生产者没有收到broker的ack而再次重发消息，实际上broker收到了多条重复的消息，造成消息重复</p></li><li><p>消费者重复消费：由于网络抖动，消费者没有返回ack给broker，导致消费者重试消费。</p></li><li><p>rebalance时的重复消费:由于网络抖动，在rebalance重分配时也可能出现消费者重复消费某条消息。</p></li></ul><h2 id="如何保证幂等性消费"><a href="#如何保证幂等性消费" class="headerlink" title="如何保证幂等性消费"></a>如何保证幂等性消费</h2><ul><li>mysql插入业务id作为主键，主键是唯一的，所以一次只能插入一条</li><li>使用redis或zk的分布式锁(主流的方案)</li><li>添加业务性的判断，过滤掉已修改状态的数据</li></ul><h1 id="消息顺序消费"><a href="#消息顺序消费" class="headerlink" title="消息顺序消费"></a>消息顺序消费</h1><h2 id="为什么要保证消息有序"><a href="#为什么要保证消息有序" class="headerlink" title="为什么要保证消息有序"></a>为什么要保证消息有序</h2><p>比如有这么一个物联网的应用场景，IOT中的设备在初始化时需要按顺序接收这样的消息:</p><ul><li>设置设备名称</li><li>设置设备的网络</li><li>重启设备使配置生效</li></ul><p>如果这个顺序颠倒了，可能就没有办法让设备的配置生效，因为只有重启设备才能让配置生效，但重启的消息却在设置设备消息之前被消费</p><h2 id="如何保证消息顺序消费"><a href="#如何保证消息顺序消费" class="headerlink" title="如何保证消息顺序消费"></a>如何保证消息顺序消费</h2><p><strong>全局有序：</strong>消费的所有消息都严格按照发送消息的顺序进行消费。在 RocketMQ 中，要实现全局有序，只能使用一个队列，并且由一个消费者进行消费。这意味着无论消息来自哪个业务场景，都必须按照顺序依次处理，对系统的性能和扩展性有很大的限制。</p><p><strong>局部有序：</strong>消费的部分消息按照发送消息的顺序进行消费。对于需要保证顺序的业务场景，将相关消息发送到同一个队列，然后由专门的消费者去处理这个队列。这样，不同业务场景的消息可以在不同的队列中并行处理，而同一业务场景下的消息则按照顺序被消费，既保证了特定业务的消息顺序，又提高了系统的整体性能。</p><h1 id="快速处理积压消息"><a href="#快速处理积压消息" class="headerlink" title="快速处理积压消息"></a>快速处理积压消息</h1><p>在RocketMQ中，如果消费者消费速度过慢，而生产者生产消息的速度又远超于消费者消费消息的速度，那么就会造成大量消息积压在MQ中。</p><h2 id="如何查看消息积压的情况"><a href="#如何查看消息积压的情况" class="headerlink" title="如何查看消息积压的情况"></a>如何查看消息积压的情况</h2><p>在console控制台中可以查看：</p><p><img src="https://i0.hdslb.com/bfs/article/f639109a5b76ffdb5b01dcd021b56d39171301454.png" alt="image-20241111170719497"></p><p>所谓的消息积压：就是 Broker 端当前队列有效数据最大的偏移量（brokerOffset）与消息消费端的当前处理进度（consumerOffset）之间的差值，即表示当前需要消费但没有消费的消息。</p><h2 id="问题分析与解决方案"><a href="#问题分析与解决方案" class="headerlink" title="问题分析与解决方案"></a>问题分析与解决方案</h2><h3 id="个别消费者组异常"><a href="#个别消费者组异常" class="headerlink" title="个别消费者组异常"></a>个别消费者组异常</h3><p>因为一个 Topic 通常会被多个消费端订阅，我们只要看看其他消费组是否也积压，例如如下图所示：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200823230907422.png" alt="2"></p><p>从上图看出，两个不同的消费组订阅了同一个 Topic，一个出现消息积压，一个却消费正常，从这里就可以将分析的重点定位到具体项目组。那如何具体分析这个问题呢？</p><p>在 RocketMQ 中每一客户端会单独创建一个线程 PullMessageService 会循环从 Broker 拉取一批消息，然后提交到消费端的线程池中进行消费，线程池中的线程消费完一条消息后会上服务端上报当前消费端的消费进度，而且在提交消费进度时是提交当前处理队列中消息消费偏移量最小的消息作为消费组的进度，即如果消息偏移量为 100 的消息，如果由于某种原因迟迟没有消费成功，那该消费组的进度则无法向前推进，久而久之，Broker 端的消息偏移量就会远远大于消费组当前消费的进度，从而造成消息积压现象。</p><p>可通过 <code>jps -m</code> 或者 <code>ps -ef | grep java</code> 命令获取当前正在运行的 Java 程序，通过启动主类即可获得应用的进程 id，然后可以通过 <code>jstack pid &gt; j.log</code> 命令获取线程的堆栈，在这里我建议大家连续运行 5 次该命令，分别获取 5 个线程堆栈文件，主要用于对比线程的状态是否在向前推进。</p><p>通过 jstack 获取堆栈信息后，可以重点搜索 ConsumeMessageThread_ 开头的线程状态，例如下图所示：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/2020082323094335.png" alt="5"></p><p>状态为 RUNABLE 的消费端线程正在等待网络读取，我们再去其他文件看该线程的状态，如果其状态一直是 RUNNABLE，表示线程一直在等待网络读取，及线程一直“阻塞”在网络读取上，一旦阻塞，那该线程正在处理的消息就一直处于消费中，消息消费进度就会卡在这里，不会继续向前推进，久而久之，就会出现消息积压情况。</p><p>从调用线程栈就可以找到阻塞的具体方法，从这里看出是在调用一个 HTTP 请求，跟踪到代码，截图如下：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200823230951248.png" alt="6"></p><p>定位到代码后再定位问题就比较简单的，通常的网络调用需要设置超时时间，这里由于没有设置超时时间，导致一直在等待对端的返回，从而消息消费进度无法向前推进，解决方案：设置超时时间。</p><p>通常会造成线程阻塞的场景如下：</p><ul><li>HTTP 请求未设置超时时间</li><li>数据库查询慢查询导致查询时间过长，一条消息消费延时过高</li></ul><h3 id="线程栈分析经验"><a href="#线程栈分析经验" class="headerlink" title="线程栈分析经验"></a>线程栈分析经验</h3><p>网上说分析线程栈，一般盯着 WAIT、Block、TIMEOUT_WAIT 等状态，其实不然，处于 RUNNABLE 状态的线程也不能忽略，因为 MySQL 的读写、HTTP 请求等网络读写，即在等待对端网络的返回数据时线程的状态是 RUNNABLE，并不是所谓的 BLOCK 状态。</p><p>如果处于下图所示的线程栈中的线程数量越多，说明消息消费端的处理能力很好，反而是拉取消息的速度跟不上消息消费的速度。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200823230959857.png" alt="7"></p><h3 id="RocketMQ-消费端限流机制"><a href="#RocketMQ-消费端限流机制" class="headerlink" title="RocketMQ 消费端限流机制"></a>RocketMQ 消费端限流机制</h3><p>RocketMQ 消息消费端会从 3 个维度进行限流：</p><ol><li>消息消费端队列中积压的消息超过 1000 条</li><li>消息处理队列中尽管积压没有超过 1000 条，但最大偏移量与最小偏移量的差值超过 2000</li><li>消息处理队列中积压的消息总大小超过 100M</li></ol><p>为了方便理解上述三条规则的设计理念，我们首先来看一下消费端的数据结构，如下图所示：</p><p><img src="https://i0.hdslb.com/bfs/article/b9422cd4f7f12b5569b63b4c515a0b6b171301454.png" alt="image-20250126152612620"></p><p>PullMessageService 线程会按照队列向 Broker 拉取一批消息，然后会存入到 ProcessQueue 队列中，即所谓的处理队列，然后再提交到消费端线程池中进行消息消费，消息消费完成后会将对应的消息从 ProcessQueue 中移除，然后向 Broker 端提交消费进度，提交的消费偏移量为 ProceeQueue 中的最小偏移量。</p><p><strong>规则一：消息消费端队列中积压的消息超过 1000 条值的就是 ProcessQueue 中存在的消息条数超过指定值</strong>，默认为 1000 条，就触发限流，限流的具体做法就是暂停向 Broker 拉取该队列中的消息，但并不会阻止其他队列的消息拉取。例如如果 q0 中积压的消息超过 1000 条，但 q1 中积压的消息不足 1000，那 q1 队列中的消息会继续消费。其目的就是担心积压的消息太多，如果再继续拉取，会造成内存溢出。</p><p><strong>规则二：消息在 ProcessQueue 中实际上维护的是一个 TreeMap</strong>，key 为消息的偏移量、vlaue 为消息对象，由于 TreeMap 本身是排序的，故很容易得出最大偏移量与最小偏移量的差值，即有可能存在处理队列中其实就只有 3 条消息，但偏移量确超过了 2000，例如如下图所示：</p><p><img src="https://i0.hdslb.com/bfs/article/eb7c5c66ead0eac15b049ff9ec16bcd0171301454.png" alt="image-20250126152725726"></p><p>出现这种情况也是非常有可能的，其主要原因就是消费偏移量为 100 的这个线程由于某种情况卡主了（“阻塞”了），其他消息却能正常消费，这种情况虽然不会造成内存溢出，但大概率会造成大量消息重复消费，究其原因与消息消费进度的提交机制有关，在 RocketMQ 中，例如消息偏移量为 2001 的消息消费成功后，向服务端汇报消费进度时并不是报告 2001，而是取处理队列中最小偏移量 100，这样虽然消息一直在处理，但消息消费进度始终无法向前推进，试想一下如果此时最大的消息偏移量为 1000，项目组发现出现了消息积压，然后重启消费端，那消息就会从 100 开始重新消费，会造成大量消息重复消费，RocketMQ 为了避免出现大量消息重复消费，故对此种情况会对其进行限制，超过 2000 就不再拉取消息了。</p><p><strong>规则三：消息处理队列中积压的消息总大小超过 100M。</strong></p><p>这个就更加直接了，不仅从消息数量考虑，再结合从消息体大小考虑，处理队列中消息总大小超过 100M 进行限流，这个显而易见就是为了避免内存溢出。</p><p>在了解了 RocketMQ 消息限流规则后，会在 rocketmq_client.log 中输出相关的限流日志，具体搜索“so do flow control”，详细如下图所示：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200823231023286.png" alt="10"></p><h3 id="扩充消息队列"><a href="#扩充消息队列" class="headerlink" title="扩充消息队列"></a>扩充消息队列</h3><p>如果生产者在10ms内发送了一万条消息，大量的消息都被推送到了现有的消息队列里，导致消息堆积，扩充消息队列和增加消费者都不能将已经在队列里排队的消息迅速消费完，此时应该如何解决呢？</p><p>解决方式如下图所示，可以增加一个消费组2，里面只有一个用于转发消息的消费者，将现有的3个队列里的消息全部转发到另外几个新建的topic，并在broker内新建几个消息队列，新建一个专门用来消费积压消息的消费组3，配置相应的消费者来消费这些积压消息。</p><p><img src="https://i0.hdslb.com/bfs/article/ca29e11e8dfd2a976dad92e2bddebef6171301454.png" alt="image-20241111173059635"></p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ存储方式探究</title>
      <link href="/2024/11/05/RocketMQ%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%A9%B6/"/>
      <url>/2024/11/05/RocketMQ%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>首先，在RocketMQ管理页面手动创建一个Topic，配置如下图：</p><p><img src="https://i0.hdslb.com/bfs/article/e9f0e8d4c0b43b9974882fd692501822171301454.png" alt="image-20241105135116773"></p><p>这里解释一下图中的几个参数：</p><p><strong>writeQueueNums</strong>：客户端在发送消息时，可以向多少个队列进行发送；</p><p><strong>readQueueNums</strong>：客户端在消费消息时，可以从多少个队列进行拉取；</p><p><strong>perm</strong>：当前 Topic 读写权限，2 只允许读、4 只允许写、6 允许读写，默认是 6。</p><p>RocketMQ 主要有 3 个消息相关的文件：commitlog、consumequeue 和 index。</p><p>writeQueueNums 参数控制 consumequeue 的文件数量。往 MyTestTopic 这个 Topic 发送了 100 条消息，这些消息保存在了 commitlog 文件。而 consumequeue 文件如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx MyTestTopic]# pwd</span><br><span class="line">/root/store/consumequeue/MyTestTopic</span><br><span class="line">[root@xxx MyTestTopic]# ls</span><br><span class="line">0  1  2  3  4  5  6  7</span><br></pre></td></tr></table></figure><p>可以看到，consumequeue 的保存是在 consumequeue 目录下为每个 Topic 建一个目录，用保存这个 Topic 的 consumequeue 文件。consumequeue 文件为每个 Topic 基于偏移量创建了一个索引。</p><p>index 文件保存的是消息基于 key 的 HASH 索引。</p><h1 id="commitlog"><a href="#commitlog" class="headerlink" title="commitlog"></a>commitlog</h1><p>commitlog 是 RocketMQ 保存消息的文件，保存了消息主体以及元数据的存储主体 。commitlog 并没有按照 Topic 来分割，Broker单个实例下所有的队列的消息都写入同一个 commitlog。</p><p>为了追求高效写入，RocketMQ 使用了磁盘顺序写，所有主题的消息按顺序存储在同一个文件中。同时为了避免消息在消息存储服务器中无限地累积，引入了消息文件过期机制与文件存储空间报警机制。</p><p>commitlog 单个文件大小默认是1G，可以通过参数 mappedFileSizeCommitLog 来修改。</p><p>下面是服务器磁盘上保存的 commitlog 文件（文件大小 1G）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx commitlog]# pwd</span><br><span class="line">/root/store/commitlog</span><br><span class="line">[root@xxx commitlog]# ls</span><br><span class="line">00000000000000000000  00000000001073741824</span><br></pre></td></tr></table></figure><p>可以看到：commitlog 文件的命名以保存在文件中的消息最小的偏移量来命名的，后一个文件的名字是前一个文件名加文件大小。这样通过偏移量查找消息时可以先用<strong>二分查找找到消息所在的文件，然后通过偏移量减去文件名就可以方便地找到消息在文件中的物理地址，定位消息位于那个文件中，并获取到消息实体数据</strong>。</p><p>为了让 commitlog 操作效率更高，RocketMQ 使用了 mmap 将磁盘上日志文件映射到用户态的内存地址中，减少日志文件从磁盘到用户态内存之间的数据拷贝。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AllocateMappedFileService 类 mmapOperation 方法</span></span><br><span class="line"><span class="comment">//是否开启堆外内存</span></span><br><span class="line"><span class="keyword">if</span> (messageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  mappedFile = ServiceLoader.load(MappedFile.class).iterator().next();</span><br><span class="line">  mappedFile.init(req.getFilePath(), req.getFileSize(), messageStore.getTransientStorePool());</span><br><span class="line"> &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">  log.warn(<span class="string">&quot;Use default implementation.&quot;</span>);</span><br><span class="line">  mappedFile = <span class="keyword">new</span> <span class="title class_">MappedFile</span>(req.getFilePath(), req.getFileSize(), messageStore.getTransientStorePool());</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> mappedFile = <span class="keyword">new</span> <span class="title class_">MappedFile</span>(req.getFilePath(), req.getFileSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入消息时，如果 isTransientStorePoolEnable 方法返回 true，则消息数据先写入堆外内存，然后异步线程把堆外内存数据刷到 PageCache，如果返回 false 则直接写入 PageCache。后面根据刷盘策略把 PageCache 中数据持久化到磁盘。如下图：</p><p><img src="https://i0.hdslb.com/bfs/article/3bb8a664381bf231fd31a3430fb9a0f4171301454.png" alt="image-20250108151804008"></p><p>通常有如下两种方式进行读写：</p><ol><li>第一种，Mmap+PageCache的方式，读写消息都走的是pageCache，这样子读写都在pagecache里面不可避免会有锁的问题，在并发的读写操作情况下，会出现缺页中断降低，内存加锁，污染页的回写。</li><li>第二种，DirectByteBuffer(堆外内存)+PageCache的两层架构方式，这样子可以实现读写消息分离，写入消息时候写到的是DirectByteBuffer——堆外内存中,读消息走的是PageCache(对于,DirectByteBuffer是两步刷盘，一步是刷到PageCache，还有一步是刷到磁盘文件中)，带来的好处就是，避免了内存操作的很多容易堵的地方，降低了时延，比如说缺页中断降低，内存加锁，污染页的回写。</li></ol><p>页缓存(PageCache)是OS对文件的缓存，用于加速对文件的读写。一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化，将一部分的内存用作PageCache。对于数据的写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。对于数据的读取，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取。</p><p>无论先写堆外内存还是直接写 PageCache，文件数据都会映射到 MappedByteBuffer。如下图：</p><p><img src="https://i0.hdslb.com/bfs/article/985f7c41b800443bf6e9418c14473f30171301454.png" alt="image-20241105151037955"></p><p>不同的是，如果消息先写入堆外内存，则 MappedByteBuffer 主要用来读消息，堆外内存用来写消息。这一定程度上实现了读写分离，减少 PageCache 写入压力。</p><p>再看一下文件映射的代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MappedFile 类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="type">int</span> fileSize)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"> <span class="built_in">this</span>.fileName = fileName;</span><br><span class="line"> <span class="built_in">this</span>.fileSize = fileSize;</span><br><span class="line"> <span class="built_in">this</span>.file = <span class="keyword">new</span> <span class="title class_">File</span>(fileName);</span><br><span class="line"> <span class="built_in">this</span>.fileFromOffset = Long.parseLong(<span class="built_in">this</span>.file.getName());</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.fileChannel = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="built_in">this</span>.file, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">  <span class="built_in">this</span>.mappedByteBuffer = <span class="built_in">this</span>.fileChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, fileSize);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"> &#125; <span class="comment">//省略 catch finally</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了 Java 中 FileChannel 的 map 方法来实现 mmap。</p><p>有一个细节需要注意：<strong>创建 MappedFile 后会进行文件预热</strong>，目的是为了预先将 PageCache 加载到内存，防止读写数据发生缺页中断时再加载，影响性能。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AllocateMappedFileService 类 mmapOperation 方法</span></span><br><span class="line"><span class="comment">// pre write mappedFile</span></span><br><span class="line"><span class="keyword">if</span> (mappedFile.getFileSize() &gt;= <span class="built_in">this</span>.messageStore.getMessageStoreConfig()</span><br><span class="line"> .getMappedFileSizeCommitLog()</span><br><span class="line"> &amp;&amp;</span><br><span class="line"> <span class="built_in">this</span>.messageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line"> mappedFile.warmMappedFile(<span class="built_in">this</span>.messageStore.getMessageStoreConfig().getFlushDiskType(),</span><br><span class="line">  <span class="built_in">this</span>.messageStore.getMessageStoreConfig().getFlushLeastPagesWhenWarmMapedFile());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RocketMQ主要通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中，<strong>这种Mmap的方式减少了传统IO将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销</strong>。将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率。正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存。</p><h1 id="consumequeue"><a href="#consumequeue" class="headerlink" title="consumequeue"></a>consumequeue</h1><p>所有 Topic 的消息都写到同一个 commitlog 文件，如果直接在 commitlog 文件中查找消息，只能从文件头开始查找，肯定会很慢。因此 RocketMQ 引入了 consumequeue，基于 Topic 来保存偏移量。</p><p>consumequeue 的文件结构如下图：</p><p><img src="https://i0.hdslb.com/bfs/article/a825087ba68baa53637abad617f6a299171301454.png" alt="image-20241105154157947"></p><p>其中前 8 个字节保存消息在 commitlog 中的偏移量，中间 4 个字节保存消息消息大小，最后 8 个字节保存消息中 tag 的 hashcode。</p><p><strong>这里为什么要保存一个 tag 的 hashcode 呢？</strong></p><p>如果一个 Consumer 订阅了 TopicA 这个 Topic 中的 Tag1 和 Tag2 这两个 tag，那这个 Consumer 的订阅关系如下图：</p><p><img src="https://i0.hdslb.com/bfs/article/311ed31552b5de2f046d9a9ed901c9b5171301454.png" alt="image-20241105160910796"></p><p>可以看到，订阅关系这个对象封装了 Topic、tag 以及所订阅 tag 的 hashcode 集合。</p><p>Consumer 发送拉取消息请求时，会把订阅关系传给 Broker（Broker 解析成 SubscriptionData 对象），Broker 使用 consumequeue 获取消息时，首先判断最后 8 个字节的 tag hashcode 是否在 SubscriptionData 的 codeSet 中，如果不在就跳过，如果存在就根据偏移量从 commitlog 中获取消息返回给 Consumer。如下图：</p><p><img src="https://i0.hdslb.com/bfs/article/7582d11892ce2e741db4987bdd2a4ab7171301454.png" alt="image-20241105162316898"></p><p>跟 commitlog 一样，consumequeue 也会使用 mmap 映射为 MappedFile 存储对象。</p><h1 id="index"><a href="#index" class="headerlink" title="index"></a>index</h1><p>每个消息在业务层面的唯一标识码要设置到 keys 字段，方便将来定位消息丢失问题。服务器为每个消息创建哈希索引，应用可以通过 topic、key 来查询这条消息内容，以及消息被谁消费。为了支持按照消息的某一个属性来查询，RocketMQ 引入了 index 索引文件。index 文件结构如下图：</p><p><img src="https://i0.hdslb.com/bfs/article/facad55232f1464ce9571d323eb23165171301454.png" alt="image-20241106181830135"></p><p>主要由三部分组成：IndexHeader、HashSlog 和 Index 条目。跟 commitlog 一样，Index 文件也会使用 mmap 映射为 MappedFile 存储对象。</p><h2 id="IndexHeader"><a href="#IndexHeader" class="headerlink" title="IndexHeader"></a>IndexHeader</h2><p>IndexHead 由如下 6 个属性组成，这些熟悉定义在类 IndexHeader：</p><p>1.beginTimestamp：index 文件中最小的消息存储时间；</p><p>2.endTimestamp：index 文件中最大的消息存储时间；</p><p>3.beginPhyoffset：index 文件中包含的消息中最小的 commitlog 偏移量；</p><p>4.endPhyoffset：index 文件中包含的消息中最大的 commitlog 偏移量；</p><p>5.hashSlotcount：index 文件中包含的 hash 槽的数量；</p><p>6.indexCount：index 文件中包含的 index 条目个数。</p><h2 id="HashSlog"><a href="#HashSlog" class="headerlink" title="HashSlog"></a>HashSlog</h2><p>HashSlot 就是 Java HashMap 中的 hash 槽，默认有 500 万个。每个 HashSlot 使用 4 个字节 int 类型保存<strong>最后一个 Index 条目的位置</strong>。</p><p><strong>为什么是保存的最后一个 index 条目呢？</strong></p><p>因为 index 条目保存的是 key 的 hashcode，存在 hash 冲突的情况下，Hashslog 使用链表法解决，在 Index 条目中<strong>会保存相同 Hash 值的前一个条目位置。</strong></p><p><img src="https://i0.hdslb.com/bfs/article/86687a3d5066cc42b0f614bce58a8d7c171301454.png" alt="image-20241106183853315"></p><h2 id="index-条目"><a href="#index-条目" class="headerlink" title="index 条目"></a>index 条目</h2><p>index 条目录由 4 个属性组成：</p><p>1.key hashcode：要查找消息的 key 的 hashcode；</p><p>2.phyOffset：消息在 commitlog 文件中的物理偏移量；</p><p>3.timediff：该消息存储时间与 beginTimestamp 的差值。通过 key 查找消息时，在 key 相同的情况下，还要看 timediff 是否在区间范围内 ，不在时间范围内的就不返回，参考下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IndexFile 类</span></span><br><span class="line"><span class="type">long</span> <span class="variable">timeRead</span> <span class="operator">=</span> <span class="built_in">this</span>.indexHeader.getBeginTimestamp() + timeDiff;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">timeMatched</span> <span class="operator">=</span> (timeRead &gt;= begin) &amp;&amp; (timeRead &lt;= end);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (keyHash == keyHashRead &amp;&amp; timeMatched) &#123;</span><br><span class="line"> phyOffsets.add(phyOffsetRead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.prevIndex：key 发生 hash 冲突后保存相同 hash code 的前一个 index 条目位置。</p><p>index 条目默认有 2000 万个。</p><h2 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h2><p><img src="https://i0.hdslb.com/bfs/article/a19c43f4ed094bce5ed263361df6fd9e171301454.png" alt="image-20241106201638352"></p><h1 id="文件构建"><a href="#文件构建" class="headerlink" title="文件构建"></a>文件构建</h1><p><strong>consumequeue 和 index 文件的内容是什么时候写入呢？</strong></p><p>在 MessageStore 初始化的时候会启动一个线程 ReputMessageService，这个线程的逻辑是死循环里面每个 1ms 执行一次，从 commitlog 中获取消息然后写入 consumequeue 和 index 文件。参考下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultMessageStore 类 doReput 方法</span></span><br><span class="line"><span class="type">DispatchRequest</span> <span class="variable">dispatchRequest</span> <span class="operator">=</span></span><br><span class="line"> DefaultMessageStore.<span class="built_in">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dispatchRequest.getBufferSize() == -<span class="number">1</span> ? dispatchRequest.getMsgSize() : dispatchRequest.getBufferSize();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123;</span><br><span class="line"> <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  DefaultMessageStore.<span class="built_in">this</span>.doDispatch(dispatchRequest);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(DispatchRequest req)</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (CommitLogDispatcher dispatcher : <span class="built_in">this</span>.dispatcherList) &#123;</span><br><span class="line">  dispatcher.dispatch(req);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 dispatcherList 的定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.dispatcherList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//CommitLogDispatcherBuildConsumeQueue 类用来写 consumequeue</span></span><br><span class="line"><span class="built_in">this</span>.dispatcherList.addLast(<span class="keyword">new</span> <span class="title class_">CommitLogDispatcherBuildConsumeQueue</span>());</span><br><span class="line"><span class="comment">//CommitLogDispatcherBuildIndex 类用来写 index 文件</span></span><br><span class="line"><span class="built_in">this</span>.dispatcherList.addLast(<span class="keyword">new</span> <span class="title class_">CommitLogDispatcherBuildIndex</span>());</span><br></pre></td></tr></table></figure><p>可以看到，即使 Broker 挂了，只要 commitlog 在，就可以重新构建出 consumequeue 和 index 文件。</p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一键解标功能需求分析</title>
      <link href="/2024/05/27/%E4%B8%80%E9%94%AE%E8%A7%A3%E6%A0%87/"/>
      <url>/2024/05/27/%E4%B8%80%E9%94%AE%E8%A7%A3%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h1 id="一键解标功能需求分析"><a href="#一键解标功能需求分析" class="headerlink" title="一键解标功能需求分析"></a>一键解标功能需求分析</h1><p>需求说明：</p><p>1.明月AI标讯平台导航栏新增菜单“招标解读”</p><p>2.用户上传招标文件（&lt;150页，且&lt;10万字），文件类型限制为（docx、doc、pdf），上传完成AI输出招标文件分析结果（关键指标），每条分析结果支持反向定位到原始依据页面</p><p>3.新增招标解读Agent，后端调用该Agent获取招标文件的分析结果</p><p>4.新增招标解读历史记录模块，支持用户查询自己历史解读的标讯结果</p><p><img src="https://i0.hdslb.com/bfs/article/f46da9b94916d8508d58315358e52657171301454.png" alt="image-20240527170616307"></p><p>最终产品效果图：</p><p><img src="https://i0.hdslb.com/bfs/article/08f376a603b51e8268b1c71a84cdb092171301454.png" alt="image-20240527182251434"></p><h2 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h2><h3 id="招标文件解析表"><a href="#招标文件解析表" class="headerlink" title="招标文件解析表"></a>招标文件解析表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `func_bid_doc_analysis` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `file_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;招标文件名称&#x27;</span>,</span><br><span class="line">  `file_url` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;招标文件url&#x27;</span>,</span><br><span class="line">  `original_content` longtext COMMENT <span class="string">&#x27;招标文件原始文本&#x27;</span>,</span><br><span class="line">  `analyze_content` json <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;解析内容&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;文件md5&#x27;</span>,</span><br><span class="line">  `created_at` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `created_by` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;创建用户&#x27;</span>,</span><br><span class="line">  `updated_at` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `updated_by` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;修改用户&#x27;</span>,</span><br><span class="line">  `is_deleted` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否已删除：0-未删除，其他表示已删除&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;招标文件解析表&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="接口功能设计"><a href="#接口功能设计" class="headerlink" title="接口功能设计"></a>接口功能设计</h2><h3 id="上传招标文件"><a href="#上传招标文件" class="headerlink" title="上传招标文件"></a>上传招标文件</h3><p>前置校验：</p><ul><li><p>文件不能为空</p></li><li><p>文件类型限制为（docx、doc、pdf）</p></li><li><p>招标文件（&lt;150页，且&lt;10万字）</p></li></ul><p>若文件类型为 docx 或 doc ，转换为 pdf</p><p>将 pdf 文件上传到cos </p><p>新增到招标文件表</p><p>返回结果：文件id、文件名称、文件url</p><p>异常结果：</p><ul><li>转换格式失败</li><li>检测文件页数和字数失败</li></ul><h3 id="解析招标文件"><a href="#解析招标文件" class="headerlink" title="解析招标文件"></a>解析招标文件</h3><p>Agent：参照已有的信息提取Agent，具体产品来写</p><p>前置校验：</p><ul><li>该招标文件是否为本人上传</li></ul><p>按页提取 pdf 文件文本</p><p>标识页码，调用一键解标 Agent ，返回解析结果（原始依据包含页码）</p><p>更新解析内容到招标文件解读表</p><p>返回解析结果</p><p>异常结果：</p><ul><li>按页提取文件文本失败</li><li>解析招标文件失败</li></ul><h3 id="查询该用户上传的招标文件列表"><a href="#查询该用户上传的招标文件列表" class="headerlink" title="查询该用户上传的招标文件列表"></a>查询该用户上传的招标文件列表</h3><p>根据上传人查询招标文件表</p><p>校验是否是该登录用户的招标文件</p><p>返回结果：</p><p>文件id、文件名称、文件url、创建时间（按创建日期倒序）</p><h3 id="查询该招标文件的解析结果"><a href="#查询该招标文件的解析结果" class="headerlink" title="查询该招标文件的解析结果"></a>查询该招标文件的解析结果</h3><p>根据文件id查询招标文件表</p><p>校验：</p><ul><li><p>该文件是否存在</p></li><li><p>校验是否是该登录用户的招标文件</p></li></ul><p>返回解析结果</p><h2 id="改进功能点"><a href="#改进功能点" class="headerlink" title="改进功能点"></a>改进功能点</h2><p>上文是初步的一个技术方案，在开发过程中，仍还有很多细节没有关注到，所以后面我们的重点放在如何对接口的功能设计进行改造上。</p><h3 id="解析文件异步处理"><a href="#解析文件异步处理" class="headerlink" title="解析文件异步处理"></a>解析文件异步处理</h3><p>最初的方案是前端做一个假的loading界面，调用解析文件接口，这个接口会同步返回解析结果。但是如果这时候，用户手动刷新了一下界面，前端调用的解析请求就没了，想要再次解析，只能手动发起。如果每次用户都在快解析结束的时候刷新，那调用 agent 的花销就是一笔大数目了。</p><p>综合前端、用户的体验，决定把解析文件的操作做异步处理。还有一个衍生的问题，产品认为流式传输比非流式要准确，所以建议我们后端接收流，把流式的结果拼接成完整的结果。</p><p>产品刚把 agent 写好，就提了这么些需求。而且更麻烦的是，产品需要我整合两个 agent 的信息。离上线还有一天，突然就得大改，内心慌得一批…</p><p>整理一下产品的需求：</p><ol><li>解析文件修改为异步</li><li>调用流式API，拼接结果</li><li>等待两个 agent 结果，组装成 json 存入数据库</li></ol><p>异步很好处理，使用 CompletableFuture 的 runAsync 方法，搞定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(()-&gt;dealWithContent());</span><br></pre></td></tr></table></figure><p>流式API需要就可以借助AI问问相关的API怎么用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">client.post()</span><br><span class="line">               .uri(agentChatUrl)</span><br><span class="line">               .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">               .body(BodyInserters.fromValue(JSON.toJSONString(request)))</span><br><span class="line">               .header(Constants.MOONAI_ACCOUNT_HEADER, userName)</span><br><span class="line">               .header(Constants.AUTHORIZATION_HEADER, token).retrieve()</span><br><span class="line">               .onStatus(HttpStatus::isError, response -&gt; response.bodyToMono(Result.class)</span><br><span class="line">                       .flatMap(errorBody -&gt; Mono.error(<span class="keyword">new</span> <span class="title class_">MingYueAiException</span>(errorBody.getCode(), errorBody.getMsg()))))</span><br><span class="line">               .bodyToFlux(String.class)</span><br><span class="line">               .doFinally((signalType) -&gt; countDownLatch.countDown())</span><br><span class="line">               .subscribe(data -&gt; &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!<span class="string">&quot;[DONE]&quot;</span>.equals(data)) &#123;</span><br><span class="line">                       <span class="comment">// data 转换成 ChatCompletionChunk</span></span><br><span class="line">                       <span class="type">ChatCompletionChunk</span> <span class="variable">chunk</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           chunk = objectMapper.readValue(data, ChatCompletionChunk.class);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> chunk.getChoices().get(<span class="number">0</span>).getMessage().getContent();</span><br><span class="line">                       <span class="comment">// 拼接 content</span></span><br><span class="line">                       <span class="keyword">if</span> (StringUtils.isNotEmpty(content)) &#123;</span><br><span class="line">                           stringBuilder.append(content);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;, error -&gt; &#123;</span><br><span class="line">                   isError.append(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">                   log.error(<span class="string">&quot;error:&quot;</span>, error);</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><p>可以在 subscribe 里对 data 进行聚合，只要没有结束，就可以把 content 拿出来拼接。</p><p>至于等待两个流式调用的结果，上面的代码也体现了。在 doFinally 里使用 countDownLatch，确保两个agent都被调用，最后将两个 content 都放进 List 里，作为 json 存入数据库。</p><p>既然解析文件的操作都是异步的了，其实也没必要把上传和解析分为两个接口来实现了，一开始上传时就自动解析，前端轮询查询解析内容的接口，拿到解析内容结果，这是最稳妥的办法。因为上传文件还涉及到 word 转 pdf 的过程，可能会花费10秒，如果在这期间，用户点击到别的页面，那前端就永远拿不到返回值，也永远不会主动调用解析文件的接口了，在用户的视角看就是他所上传的招标文件一直在解析中。</p><h3 id="幂等性问题"><a href="#幂等性问题" class="headerlink" title="幂等性问题"></a>幂等性问题</h3><p>解析文件这一步确实是异步了，但是如果在解析的过程中，我疯狂点击这个解析的接口，那就会有很多个调用 agent 的方法，这样就花了很多不必要的钱。</p><p>我们可以定义一个 ConcurrentHashMap，key存储招标文件id，value存储当前时间。在每次解析前，我都去内存里判断当前时间和 value 的间隔有没有超过一分钟，如果在一分钟以内，限制它的提交。最后解析完，把这次的key移除掉，允许它再次解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.CURRENT_ANALYSIS_DOC_MAP.put(funcBidDocAnalysis.getId(), System.currentTimeMillis());</span><br></pre></td></tr></table></figure><p>为什么要对时间做限制呢？因为实际上我们是允许用户<strong>重新解析</strong>的，如果解析内容有异常，在json里会有一个 isError 字段去标识，前端根据这个标识去给用户提供一个重新解析的按钮，后端也可以根据这个标识判断是否需要调用 agent。这样做比多加一个解析状态的字段要高效且简洁。</p><p>另外，我们还添加了一个文件md5的字段，约定了用户只要上传同一个招标文件，就可以复用其解析内容。用户体验上，可以无须等待就显示解析内容；产品花费上，对于同一个招标文件，可以少一次调用。</p><h3 id="重新解析"><a href="#重新解析" class="headerlink" title="重新解析"></a>重新解析</h3><p>发版上线了一段时间，突然有用户反馈说，点击页面上的“重新解析”不生效，赶紧看日志排查原因。</p><p>日志表明，该用户第一次异步解析，调用了 agent 失败了，他点击重新解析后，又调用失败了。他所看到的是点击“重新解析”后，页面没有任何变化，所以他反馈了这个问题。</p><p>确实，我们虽然允许用户重新解析了，但是重新解析的过程中，我们的页面没有任何变化，用户感知不到我们后台在重新解析。</p><p>这时候我们就和前端小伙伴看了这块逻辑，他说，一开始我们的解析内容为空，他就会在页面显示正在加载中，并轮询调用查询接口查解析内容，等待我们后端异步返回。所以，在重新解析的接口里，我们要先将这条标书文件的解析内容设置为空，更新数据库，并异步调用 agent。这样用户就能在页面直接感受到我们后台的运作了。</p><h3 id="自定义typeHandler"><a href="#自定义typeHandler" class="headerlink" title="自定义typeHandler"></a>自定义typeHandler</h3><p>解析内容实际上是聚合了两个 agent 的 json，为了存储方便，我们将两个 json 组装成一个 List<JSONObject>， 以 json 的形式存入数据库中。那这就引发了一个新的问题，我们需要从数据库中查到解析内容，以 List<JSONObject> 的形式返回给前端，且存入数据库时该字段为json。</JSONObject></JSONObject></p><p> 一开始我是手动实现这一过程的，每次从数据库中查出来的解析内容，都被自动判定为 String 类型，所以我要手动转换成 JsonArray 的形式，再返回给前端 or 存入数据库，否则它会以字符串的形式返回&#x2F;入库。</p><p>在这一步出过一次生产问题，因为逻辑删除的时候没有考虑到 String 转换的问题，删掉该文件后，顺便把解析内容篡改成了 String 类型，再次上传相同的文件，根据文件md5找到的解析内容（已经是篡改过的了），就没办法转换成 List<JSONObject> 再入库了。紧急措施就是在删除接口查出来的解析内容设置为Null，这样更新的时候不会篡改掉原有的解析内容字段。</JSONObject></p><p>但是更优雅的做法是自定义 typeHandler。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一定要加这两行注解</span></span><br><span class="line"><span class="meta">@MappedTypes(List.class)</span></span><br><span class="line"><span class="meta">@MappedJdbcTypes(JdbcType.VARCHAR)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonObjectListTypeHandler</span> <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;List&lt;JSONObject&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, List&lt;JSONObject&gt; parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(parameter);</span><br><span class="line">ps.setString(i, json);</span><br><span class="line">&#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;Error converting List&lt;JSONObject&gt; to json&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;JSONObject&gt; <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"><span class="keyword">return</span> parseJson(rs.getString(columnName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;JSONObject&gt; <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"><span class="keyword">return</span> parseJson(rs.getString(columnIndex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;JSONObject&gt; <span class="title function_">getNullableResult</span><span class="params">(CallableStatement cs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"><span class="keyword">return</span> parseJson(cs.getString(columnIndex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;JSONObject&gt; <span class="title function_">parseJson</span><span class="params">(String json)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isNotEmpty(json))&#123;</span><br><span class="line"><span class="keyword">return</span> mapper.readValue(json, List.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;Error converting json to List&lt;JSONObject&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再在实体类加上注解（注意这都是必须添加上的，缺一不可）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;func_bid_doc_analysis&quot;,autoResultMap = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FuncBidDocAnalysis</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(typeHandler = JsonObjectListTypeHandler.class)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;JSONObject&gt; analyzeContent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个小小的需求，就涵盖了很多的技术要点。把功能实现很容易，难得是怎么把功能完善合理，节省花销，创造更大的收益，让用户体验更佳。很少做这种 to C 的需求，希望借此机会多积累点经验值。</p>]]></content>
      
      
      <categories>
          
          <category> 场景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 场景设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket的使用场景</title>
      <link href="/2024/05/07/websocket%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2024/05/07/websocket%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>HTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。</p><p>优点：</p><ul><li><p>支持双向通信，实时性更强。</p></li><li><p>更好的二进制支持。</p></li><li><p>较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。</p></li><li><p>支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等</p></li></ul><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>websocket是前后端通过长连接通信的常用解决方案，相比于定时轮询的方式，突出的就是一个时效性，对于消息的接收和推送是实时的。</p><p>什么场景下会用到 websocket 呢？</p><h2 id="站内信"><a href="#站内信" class="headerlink" title="站内信"></a>站内信</h2><p>websocket 的双向通信能让我们迅速联想到实时聊天、点赞评论通知、站内信等等，那接下来就具体讲讲使用 websocket 实现站内信的设计思路。</p><p>分布式场景下，当服务端由于访问压力过高，启动两个服务的时候，那么客户端连接就会出现 session 不共享的问题，在服务端B上根本没有客户端a的session信息，那么必然是不能进行发送的：</p><p><img src="https://i0.hdslb.com/bfs/article/5310eac35d9d8bd4fd9e966cf7b0e010171301454.png" alt="image-20240507145005489"></p><h3 id="redis-websocket-springboot"><a href="#redis-websocket-springboot" class="headerlink" title="redis+websocket+springboot"></a>redis+websocket+springboot</h3><p>使用 redis 可以很好地解决这个问题，还记得登录时也遇到过 session 不共享地问题吗？那也是使用 redis + JWT 来解决的。</p><p><img src="https://i0.hdslb.com/bfs/article/c74cea2682aebf00947912ee97f94a6f171301454.png" alt="image-20240507150417178"></p><p>redis 监听配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>： redis监听配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：weirx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>：2021/3/22 14:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>：3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * description: 手动注册Redis监听到IOC</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisConnectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: org.springframework.data.redis.listener.RedisMessageListenerContainer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>: weirx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@time</span>: 2021/3/22 14:11</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisMessageListenerContainer <span class="title function_">redisMessageListenerContainer</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="type">RedisMessageListenerContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisMessageListenerContainer</span>();</span><br><span class="line">        container.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webSocket配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>： websocket配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：weirx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>：2021/3/22 14:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>：3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * description: 这个配置类的作用是要注入ServerEndpointExporter，</span></span><br><span class="line"><span class="comment">     * 这个bean会自动注册使用了<span class="doctag">@ServerEndpoint</span>注解声明的Websocket endpoint。</span></span><br><span class="line"><span class="comment">     * 如果是使用独立的servlet容器，而不是直接使用springboot的内置容器，</span></span><br><span class="line"><span class="comment">     * 就不要注入ServerEndpointExporter，因为它将由容器自己提供和管理。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: org.springframework.web.socket.server.standard.ServerEndpointExporter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>: weirx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@time</span>: 2021/3/22 14:12</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerEndpointExporter <span class="title function_">serverEndpointExporter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerEndpointExporter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        stringRedisTemplate.convertAndSend(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义SubscribeListener监听，实现MessageListener接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.ObjectUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.MessageListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>： redis监听</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：weirx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>：2021/3/22 14:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>：3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscribeListener</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前websocket的session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Session <span class="title function_">getSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSession</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.session = session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtil.isNotEmpty(session) &amp;&amp; session.isOpen()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.getBasicRemote().sendText(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;发送消息异常，msg = &#123;&#125; , e = &#123;&#125;&quot;</span>, msg, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebSocket服务提供类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description: <span class="doctag">@ServerEndpoint</span> 注解是一个类层次的注解，</span></span><br><span class="line"><span class="comment"> * 它的功能主要是将目前的类定义成一个websocket服务器端,注解的值将被用于监听用户连接的终端访问URL地址,</span></span><br><span class="line"><span class="comment"> * 客户端可以通过这个URL来连接到WebSocket服务器端使用springboot的唯一区别是要<span class="doctag">@Component</span>声明下，</span></span><br><span class="line"><span class="comment"> * 而使用独立容器是由容器自己管理websocket的，但在springboot中连容器都是spring管理的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: weirx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021/3/22 14:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/websocket/server/&#123;loginName&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为<span class="doctag">@ServerEndpoint</span>不支持注入，所以使用SpringUtils获取IOC实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RedisMessageListenerContainer</span> <span class="variable">redisMessageListenerContainer</span> <span class="operator">=</span></span><br><span class="line">            ApplicationContextProvider.getBean(RedisMessageListenerContainer.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">onlineCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * concurrent包的线程安全Set，用来存放每个客户端对应的webSocket对象。</span></span><br><span class="line"><span class="comment">     * 若要实现服务端与单一客户端通信的话，可以使用Map来存放，其中Key可以为用户标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;WebSocketServer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis监听</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SubscribeListener subscribeListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 可选的参数。session为与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(<span class="meta">@PathParam(&quot;loginName&quot;)</span> String loginName, Session session)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.session = session;</span><br><span class="line">        <span class="comment">//加入set中</span></span><br><span class="line">        webSocketSet.add(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//在线数加1</span></span><br><span class="line">        addOnlineCount();</span><br><span class="line">        log.info(<span class="string">&quot;有新连接[&quot;</span> + loginName + <span class="string">&quot;]加入！当前在线人数为&#123;&#125;&quot;</span>, getOnlineCount());</span><br><span class="line">        subscribeListener = <span class="keyword">new</span> <span class="title class_">SubscribeListener</span>();</span><br><span class="line">        subscribeListener.setSession(session);</span><br><span class="line">        <span class="comment">//设置订阅topic</span></span><br><span class="line">        redisMessageListenerContainer.addMessageListener(</span><br><span class="line">                subscribeListener, <span class="keyword">new</span> <span class="title class_">ChannelTopic</span>(Constants.TOPIC_PREFIX + loginName));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//从set中删除</span></span><br><span class="line">        webSocketSet.remove(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//在线数减1</span></span><br><span class="line">        subOnlineCount();</span><br><span class="line">        redisMessageListenerContainer.removeMessageListener(subscribeListener);</span><br><span class="line">        log.info(<span class="string">&quot;有一连接关闭！当前在线人数为&#123;&#125;&quot;</span>, getOnlineCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 可选的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;来自客户端的消息:&#123;&#125;&quot;</span>, message);</span><br><span class="line">        <span class="comment">//群发消息</span></span><br><span class="line">        <span class="keyword">for</span> (WebSocketServer item : webSocketSet) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                item.sendMessage(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;发送消息异常：msg = &#123;&#125;&quot;</span>, e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生错误时调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable error)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;发生错误，&#123;&#125;&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法与上面几个方法不一样。没有用注解，是根据自己需要添加的方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOnlineCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> onlineCount.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOnlineCount</span><span class="params">()</span> &#123;</span><br><span class="line">        WebSocketServer.onlineCount.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subOnlineCount</span><span class="params">()</span> &#123;</span><br><span class="line">        WebSocketServer.onlineCount.getAndDecrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis消息发布：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">send</span><span class="params">(String loginName, String msg)</span> &#123;</span><br><span class="line">    <span class="comment">//推送站内信webSocket</span></span><br><span class="line">    redisUtil.publish(<span class="string">&quot;TOPIC&quot;</span> + loginName, msg);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h3><p>springcloud gateway是目前在微服务当中使用较为广泛的网关，我们可以通过以下配置达到websocket的动态代理： 静态路由配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">websocket</span>  <span class="comment"># 路由 ID，保持唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb:ws://inbox-model</span> <span class="comment"># uri指目标服务地址，lb代表从注册中心获取服务</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/websocket/server/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=0</span></span><br></pre></td></tr></table></figure><p>动态路由配置：使用动态路由，需要网关支持且开放动态路由功能</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;:</span> <span class="string">&quot;websocket&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;order&quot;:</span> <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;predicates&quot;:</span> [&#123;</span><br><span class="line">        <span class="attr">&quot;args&quot;:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;pattern&quot;:</span> <span class="string">&quot;/websocket/server/**&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;Path&quot;</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="attr">&quot;uri&quot;:</span> <span class="string">&quot;lb:ws://inbox-model&quot;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>nginx 配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /websocket &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://gateway;</span><br><span class="line">    <span class="comment">#以下三项是官方指定配置</span></span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">    <span class="comment">#超时时间的配置，如果不配置，在一段时间内会导致客户端接收不到消息，根据登录session的超时时间保持一致就行</span></span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">3600s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h3><h4 id="系统通知-System-Notice"><a href="#系统通知-System-Notice" class="headerlink" title="系统通知(System Notice)"></a><strong>系统通知(System Notice)</strong></h4><p>系统通知一般是由后台管理员发出，然后指定某一类（全体，个人等）用户接收。基于此设想，可以把系统通知大致分为两张表：</p><ol><li><strong>t_manager_system_notice（管理员系统通知表）</strong> ：记录管理员发出的通知 ；</li><li><strong>t_user_system_notice（用户系统通知表）</strong> ： 存储用户接受的通知。</li></ol><p>t_manager_system_notice（管理员系统通知表）</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>system_notice_id</td><td>bigint</td><td>系统通知id</td></tr><tr><td>title</td><td>varchar</td><td>标题</td></tr><tr><td>content</td><td>text</td><td>内容</td></tr><tr><td>type</td><td>varchar</td><td>发送用户群体：single,all,vip</td></tr><tr><td>state</td><td>tinyint</td><td>是否被拉取过</td></tr><tr><td>recipient_id</td><td>bigint</td><td>接收通知的用户id，若type不是single，则该值为0</td></tr><tr><td>manager_id</td><td>bigint</td><td>发布通知的管理员id</td></tr><tr><td>publish_time</td><td>timestamp</td><td>发布时间</td></tr></tbody></table><p>t_user_system_notice（用户系统通知表）</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>user_notice_id</td><td>bigint</td><td>主键id</td></tr><tr><td>state</td><td>tinyint</td><td>是否已读</td></tr><tr><td>system_notice_id</td><td>bigint</td><td>系统通知的id</td></tr><tr><td>recipient_id</td><td>bigint</td><td>接收通知的用户id</td></tr><tr><td>pull_time</td><td>timstamp</td><td>拉取时间</td></tr></tbody></table><p><strong>当管理员发布一条通知后，将通知插入 t_manager_system_notice 表中，然后系统定时的从 t_manager_system_notice 表中拉取通知，然后根据通知的 type 将通知插入 t_user_system_notice 表中。</strong></p><p>如果通知的 type 是 single 的，那就只需要插入一条记录到 t_user_system_notice 中。如果是全体用户，那么就需要将一个通知批量根据不同的用户 ID 插入到 t_user_system_notice 中，这个数据量就需要根据平台的用户量来计算。</p><p>举个例子： 管理员 A 发布了一个活动的通知，他需要将这个通知发布给全体用户，当拉取时间到来时，系统会将这一条通知取出。随后系统到用户表中查询选取所有用户的 ID，然后将这一条通知的信息根据所有用户的 ID，批量插入 t_user_system_notice 中。用户需要查看系统通知时，从 t_user_system_notice 表中查询就行了。</p><p>注意：</p><ol><li>因为一次拉取的数据量可能很大，所以两次拉取的时间间隔可以设置的长一些。</li><li><strong>拉取 t_manager_system_notice 表中的通知时，需要判断 state，如果已经拉取过，就不需要重复拉取， 否则会造成重复消费。</strong></li></ol><h4 id="事件提醒-EventRemind"><a href="#事件提醒-EventRemind" class="headerlink" title="事件提醒(EventRemind)"></a><strong>事件提醒(EventRemind)</strong></h4><p>之所以称提醒类型的消息为事件提醒，是因为此类消息均是通过用户的行为产生的，如下：</p><ul><li>xxx 在某个评论中@了你；</li><li>xxx 点赞了你的文章；</li><li>xxx 点赞了你的评论；</li><li>xxx 回复了你的文章；</li><li>xxx 回复了你的评论。</li></ul><p>事件提醒表 t_event_remind</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>event_remind_id</td><td>bigint</td><td>消息id</td></tr><tr><td>action</td><td>varchar</td><td>动作类型，如点赞、艾特、回复等</td></tr><tr><td>source_id</td><td>bigint</td><td>事件源id，如评论id、文章id</td></tr><tr><td>source_type</td><td>varchar</td><td>事件源类型：comment、post等</td></tr><tr><td>source_content</td><td>varchar</td><td>事件源内容，比如回复的内容、评论等</td></tr><tr><td>url</td><td>varchar</td><td>事件所发生的地点链接 url</td></tr><tr><td>state</td><td>tinyint</td><td>是否已读</td></tr><tr><td>sender_id</td><td>bigint</td><td>操作者id，即谁关注了你、at了你</td></tr><tr><td>recipient_id</td><td>bigint</td><td>接受通知的用户id</td></tr><tr><td>remind_time</td><td>timestatmp</td><td>提醒时间</td></tr></tbody></table><h5 id="消息聚合"><a href="#消息聚合" class="headerlink" title="消息聚合"></a><strong>消息聚合</strong></h5><p>消息聚合只适用于事件提醒，以聚合之后的点赞消息来说：</p><ul><li>100 人 {点赞} 了你的 {文章 ID &#x3D; 1} ：《A》；</li><li>100 人 {点赞} 了你的 {文章 ID &#x3D; 2} ：《B》；</li><li>100 人 {点赞} 了你的 {评论 ID &#x3D; 3} ：《C》；</li></ul><p>聚合之后的消息明显有两个特征，即：action 和 source type，这是系统消息和私信都不具备的， 所以我个人认为事件提醒的设计要稍微比系统消息和私信复杂。</p><p><strong>如何聚合？</strong></p><p>稍稍观察下聚合的消息就可以发现：某一类的聚合消息之间是按照 source type 和 source id 来分组的， 因此我们可以得出以下伪 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_event_remind <span class="keyword">WHERE</span> recipient_id <span class="operator">=</span> 用户ID</span><br><span class="line"><span class="keyword">AND</span> action <span class="operator">=</span> 点赞 <span class="keyword">AND</span> state <span class="operator">=</span> <span class="literal">FALSE</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> source_id , source_type;</span><br></pre></td></tr></table></figure><p>SQL 层面的结果集处理还是很麻烦的，所以我的想法先把用户所有的点赞消息先查出来， 然后在程序里面进行分组，这样会简单不少。</p><h5 id="站内消息系统的设计"><a href="#站内消息系统的设计" class="headerlink" title="站内消息系统的设计"></a>站内消息系统的设计</h5><p>聊天室表 t_private_chat</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>private_chat_id</td><td>bigint</td><td>聊天室id</td></tr><tr><td>user1_id</td><td>bigint</td><td>用户1的id</td></tr><tr><td>user2_id</td><td>bigint</td><td>用户2的id</td></tr><tr><td>last_message</td><td>varchar</td><td>最后一条消息的内容</td></tr></tbody></table><p>私信表 t_private_message</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>private_message_id</td><td>bigint</td><td>私信id</td></tr><tr><td>content</td><td>text</td><td>私信内容</td></tr><tr><td>state</td><td>tinyint</td><td>是否已读</td></tr><tr><td>sender_remove</td><td>tinyint</td><td>发送消息的人是否删除掉了这条消息</td></tr><tr><td>recipient_remove</td><td>tinyint</td><td>接受人是否把这条消息从聊天记录删除</td></tr><tr><td>sender_id</td><td>bigint</td><td>发送者id</td></tr><tr><td>recipent_id</td><td>bigint</td><td>接收者id</td></tr><tr><td>send_time</td><td>timestamp</td><td>发送时间</td></tr></tbody></table><h5 id="消息设置"><a href="#消息设置" class="headerlink" title="消息设置"></a>消息设置</h5><p>可以看到 b 站还添加了陌生人选项，也就是说如果给你发送私信的用户不是你关注的用户，那么视之为陌生人私信，就不接受。</p><p>以下是我对于消息设置的设计：</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>user_id</td><td>bigint</td><td>用户id</td></tr><tr><td>like_message</td><td>tinyint</td><td>是否接收点赞消息</td></tr><tr><td>reply_message</td><td>tinyint</td><td>是否接收回复消息</td></tr><tr><td>at_message</td><td>tinyint</td><td>是否接收at消息</td></tr><tr><td>stranger_message</td><td>tinyint</td><td>是否接收陌生人私信</td></tr></tbody></table><h3 id="扩展性设计"><a href="#扩展性设计" class="headerlink" title="扩展性设计"></a>扩展性设计</h3><p>实现了站内信功能以后，要是以后需要实现邮件、短信呢？拿到一个需求进行功能设计的时候，往往需要考虑其扩展性。</p><p>为了给这个需求后续的扩展附加功能，同时代码的改动最小化，我们可以引入策略模式来实现。</p><ul><li>消息类型分为：站内信，短信，邮件</li><li>推送范围分为：个人，组织机构，地域，用户组</li></ul><p>定义抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ISendMessageService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description: 发送</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: com.botany.spore.core.result.Result</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: weirx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021/3/18 13:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inboxMessageTemplateDOMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> personMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inboxBusinessConfigDO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> claimUser</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Result <span class="title function_">send</span><span class="params">(InboxMessageTemplateDO inboxMessageTemplateDOMap, Map&lt;String, Object&gt; personMap,</span></span><br><span class="line"><span class="params">                            InboxBusinessConfigDO inboxBusinessConfigDO, String claimUser)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用发消息时，如何使用？又如何确定我发送的是何种消息，走哪个实现类？看如下调用位置代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String messageType, Map&lt;String, InboxMessageTemplateDO&gt; templateDOMap,</span></span><br><span class="line"><span class="params">                         Map&lt;String, Object&gt; personListByPushRange, InboxBusinessConfigDO inboxBusinessConfigDO, String username)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (String msgType : messageType.split(Constants.COMMA)) &#123;</span><br><span class="line">        <span class="type">ISendMessageService</span> <span class="variable">sendMessageService</span> <span class="operator">=</span></span><br><span class="line">                SendMessageTypeEnum.newInstance(SendMessageTypeEnum.getEnum(msgType));</span><br><span class="line">        sendMessageService.send(templateDOMap.get(msgType), personListByPushRange, inboxBusinessConfigDO, username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类内部：根据不同的code会返回不同的bean实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 站内信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MESSAGE(<span class="string">&quot;sendMessageService&quot;</span>, <span class="string">&quot;站内信&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ISendMessageService <span class="title function_">create</span><span class="params">(String code)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (ISendMessageService) ApplicationContextProvider.getBean(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到上面为止，一个简单的策略模式就完成了。假如我们后面扩展微信，那么只需要新增实现类，同时在枚举中添加新的枚举就好了，不需要修改整个发送消息业务代码。同理，推送范围也是如此。</p><h2 id="平台与客户端通信"><a href="#平台与客户端通信" class="headerlink" title="平台与客户端通信"></a>平台与客户端通信</h2><p>RPA项目中，启动一个RPA应用实际上是通过xxl-job的executor执行器，而xxl-job内定位到的执行器都是内网ip，那平台侧是怎么找到指定的执行器的呢？</p><p>这其中就存在平台侧和客户端侧的通信了。实际上，只要在xxl-job上建立一个与客户端通信的长链接，那么客户端的回调、注册等操作都能被监测到，而且平台也能指使客户端去做一些操作，不需要将平台和客户端放到同一个网段下。</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * websocket 服务端处理类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rpa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/15 13:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ServerEndpoint(path = &quot;$&#123;websocket.path&#125;&quot;, port = &quot;$&#123;websocket.port&#125;&quot;, maxFramePayloadLength = &quot;$&#123;websocket.maxFramePayloadLength&#125;&quot;, bossLoopGroupThreads = &quot;$&#123;websocket.bossLoopGroupThreads&#125;&quot;, workerLoopGroupThreads = &quot;$&#123;websocket.workerLoopGroupThreads&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerWebSocketEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 握手前调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@BeforeHandshake</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handshake</span><span class="params">(Session session, HttpHeaders headers)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> headers.get(ExecutorConstant.WEBSOCKET_HEADER_CLIENT_ID);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(clientId))&#123;</span><br><span class="line">            <span class="comment">// 校验 token</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> headers.get(ExecutorConstant.WEBSOCKET_HEADER_AUTHORIZATION);</span><br><span class="line">            <span class="type">String</span> <span class="variable">tenantCode</span> <span class="operator">=</span> headers.get(ExecutorConstant.WEBSOCKET_HEADER_TENANT_CODE);</span><br><span class="line"></span><br><span class="line">            ReturnT&lt;String&gt; t = JwtRsaUtil.verifyToken(token, tenantCode);</span><br><span class="line">            <span class="keyword">if</span>(t.getCode() == ReturnT.SUCCESS_CODE)&#123;</span><br><span class="line">                <span class="comment">// 缓存 clientId、username</span></span><br><span class="line">                session.setAttribute(AdminConstant.WEBSOCKET_ATTR_CLIENT_ID, clientId);</span><br><span class="line">                session.setAttribute(AdminConstant.WEBSOCKET_ATTR_USERNAME, t.getContent());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接成功后调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> session.getAttribute(AdminConstant.WEBSOCKET_ATTR_CLIENT_ID);</span><br><span class="line">        log.info(<span class="string">&quot;websocket连接建立，连接管理器加入对应连接：clientId:&#123;&#125;&quot;</span>, clientId);</span><br><span class="line">        ServerSessionManager.add(clientId, session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> payload 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Session session, String payload)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> session.getAttribute(AdminConstant.WEBSOCKET_ATTR_CLIENT_ID);</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">decrypt</span> <span class="operator">=</span> AesUtil.decrypt(payload, clientId);</span><br><span class="line">        <span class="keyword">if</span>(decrypt != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> JSON.parseObject(decrypt, Message.class);</span><br><span class="line">            <span class="keyword">if</span>(message.isAnswer())&#123;</span><br><span class="line">                <span class="built_in">this</span>.handleResponse(message);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.handleRequest(message, session);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">eventId</span> <span class="operator">=</span> message.getEventId();</span><br><span class="line">        <span class="keyword">if</span>(eventId != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">MessageContext</span> <span class="variable">messageContext</span> <span class="operator">=</span> ServerSessionManager.messageContextMap.get(eventId);</span><br><span class="line">            <span class="keyword">if</span>(messageContext != <span class="literal">null</span>)&#123;</span><br><span class="line">                messageContext.setResponse(message.getBody());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                log.warn(<span class="string">&quot;收到响应时，请求已断开：message:&#123;&#125;&quot;</span>, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;响应消息缺少事件id：message:&#123;&#125;&quot;</span>, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Message message, Session session)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> message.getPath(), eventId = message.getEventId(), body = message.getBody();</span><br><span class="line">        <span class="type">ReturnT</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (AdminConstant.INTERFACE_URL_CALLBACK.equals(uri)) &#123;</span><br><span class="line">                List&lt;HandleCallbackParam&gt; callbackParamList = GsonTool.fromJson(body, List.class, HandleCallbackParam.class);</span><br><span class="line">                t = XxlJobAdminConfig.getAdminConfig().getAdminBiz().callback(callbackParamList);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AdminConstant.INTERFACE_URL_REGISTRY.equals(uri)) &#123;</span><br><span class="line">                <span class="type">RegistryParam</span> <span class="variable">registryParam</span> <span class="operator">=</span> GsonTool.fromJson(body, RegistryParam.class);</span><br><span class="line">                t = XxlJobAdminConfig.getAdminConfig().getAdminBiz().registry(registryParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AdminConstant.INTERFACE_URL_REGISTRY_REMOVE.equals(uri)) &#123;</span><br><span class="line">                <span class="type">RegistryParam</span> <span class="variable">registryParam</span> <span class="operator">=</span> GsonTool.fromJson(body, RegistryParam.class);</span><br><span class="line">                t = XxlJobAdminConfig.getAdminConfig().getAdminBiz().registryRemove(registryParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AdminConstant.INTERFACE_URL_TASK_LIST.equals(uri))&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> GsonTool.fromJson(body, String.class);</span><br><span class="line">                t = XxlJobAdminConfig.getAdminConfig().getAdminBiz().taskList(clientId);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                t = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;invalid request, uri-mapping(&quot;</span>+ uri +<span class="string">&quot;) not found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;websocket请求处理异常：message:&#123;&#125;; error:&#123;&#125;&quot;</span>, message, e.getMessage());</span><br><span class="line">            t = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> session.getAttribute(AdminConstant.WEBSOCKET_ATTR_CLIENT_ID);</span><br><span class="line">        ServerSessionManager.response(clientId, eventId, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwable 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> session.getAttribute(AdminConstant.WEBSOCKET_ATTR_CLIENT_ID);</span><br><span class="line">        log.warn(<span class="string">&quot;websocket连接发生异常：clientId:&#123;&#125;; error:&#123;&#125;&quot;</span>, clientId, throwable.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> session.getAttribute(AdminConstant.WEBSOCKET_ATTR_CLIENT_ID);</span><br><span class="line">        <span class="keyword">if</span>(clientId != <span class="literal">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;websocket连接关闭，连接管理器移除对应连接：clientId:&#123;&#125;&quot;</span>, clientId);</span><br><span class="line">            ServerSessionManager.remove(clientId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * websocket 客户端处理类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rpa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/15 13:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketClientHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractWebSocketHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 执行器 */</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorBiz executorBiz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WebSocketClientHandler</span><span class="params">(ExecutorBiz executorBiz)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executorBiz = executorBiz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接成功后调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span>&#123;</span><br><span class="line">        <span class="comment">// 设置传入的文本最大限制</span></span><br><span class="line">        session.setTextMessageSizeLimit(ExecutorConstant.WEBSOCKET_INCOMING_TEXT_MAXIMUM_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到文本消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> textMessage 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage textMessage)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> session.getHandshakeHeaders().getFirst(ExecutorConstant.WEBSOCKET_HEADER_CLIENT_ID);</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> textMessage.getPayload();</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">decrypt</span> <span class="operator">=</span> AesUtil.decrypt(payload, clientId);</span><br><span class="line">        <span class="keyword">if</span>(decrypt != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> JSON.parseObject(decrypt, Message.class);</span><br><span class="line">            <span class="keyword">if</span>(message.isAnswer())&#123;</span><br><span class="line">                <span class="built_in">this</span>.handleResponse(message);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.handleRequest(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">eventId</span> <span class="operator">=</span> message.getEventId();</span><br><span class="line">        <span class="keyword">if</span>(eventId != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">MessageContext</span> <span class="variable">messageContext</span> <span class="operator">=</span> WebSocketClient.messageContextMap.get(eventId);</span><br><span class="line">            <span class="keyword">if</span>(messageContext != <span class="literal">null</span>)&#123;</span><br><span class="line">                messageContext.setResponse(message.getBody());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                log.warn(<span class="string">&quot;收到响应时，请求已断开：message:&#123;&#125;&quot;</span>, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;响应消息缺少事件id：message:&#123;&#125;&quot;</span>, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> message.getPath(), eventId = message.getEventId(), body = message.getBody();</span><br><span class="line">        <span class="type">ReturnT</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ExecutorConstant.INTERFACE_URL_BEAT.equals(uri)) &#123;</span><br><span class="line">                t = executorBiz.beat();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorConstant.INTERFACE_URL_IDLE_BEAT.equals(uri)) &#123;</span><br><span class="line">                <span class="type">IdleBeatParam</span> <span class="variable">idleBeatParam</span> <span class="operator">=</span> GsonTool.fromJson(body, IdleBeatParam.class);</span><br><span class="line">                t = executorBiz.idleBeat(idleBeatParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorConstant.INTERFACE_URL_GLOBAL_IDLE_BEAT.equals(uri)) &#123;</span><br><span class="line">                <span class="type">IdleBeatParam</span> <span class="variable">idleBeatParam</span> <span class="operator">=</span> GsonTool.fromJson(body, IdleBeatParam.class);</span><br><span class="line">                t = executorBiz.globalIdleBeat(idleBeatParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorConstant.INTERFACE_URL_RUN.equals(uri)) &#123;</span><br><span class="line">                <span class="type">TriggerParam</span> <span class="variable">triggerParam</span> <span class="operator">=</span> GsonTool.fromJson(body, TriggerParam.class);</span><br><span class="line">                t = executorBiz.run(triggerParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorConstant.INTERFACE_URL_KILL.equals(uri)) &#123;</span><br><span class="line">                <span class="type">KillParam</span> <span class="variable">killParam</span> <span class="operator">=</span> GsonTool.fromJson(body, KillParam.class);</span><br><span class="line">                t = executorBiz.kill(killParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorConstant.INTERFACE_URL_LOG.equals(uri)) &#123;</span><br><span class="line">                <span class="type">LogParam</span> <span class="variable">logParam</span> <span class="operator">=</span> GsonTool.fromJson(body, LogParam.class);</span><br><span class="line">                t = executorBiz.log(logParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;invalid request, uri-mapping(&quot;</span>+ uri +<span class="string">&quot;) not found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;websocket请求处理异常：message:&#123;&#125;; error:&#123;&#125;&quot;</span>, message, e.getMessage());</span><br><span class="line">            t = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        WebSocketClient.response(eventId, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwable 异常信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleTransportError</span><span class="params">(WebSocketSession session, Throwable throwable)</span>&#123;</span><br><span class="line">        log.warn(<span class="string">&quot;websocket连接发生异常：sessionId:&#123;&#125;; error:&#123;&#125;&quot;</span>, session.getId(), throwable.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> closeStatus 关闭状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus closeStatus)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;websocket连接关闭：sessionId:&#123;&#125;&quot;</span>, session.getId());</span><br><span class="line">        WebSocketClient.removeSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否支持分片消息（不支持）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsPartialMessages</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定时任务清除长连接"><a href="#定时任务清除长连接" class="headerlink" title="定时任务清除长连接"></a>定时任务清除长连接</h2><p>如果项目中引用了 websocket，往往需要有个定时任务定期清除websocket的长链接。原因就是，比如用户直接关掉了浏览器，这样后端没有办法知道这个长链接已经关闭了，所以需要定期清除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * websocket会话缓存管理</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@author</span> heshengsheng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardSessionCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会话缓存，可以多开窗口，即一个用户可以同时有多个websocket连接，存储结构是ConcurrentMap中存放Set，map的key是一个用户，set集合中是一个用户的多个websocket连接</span></span><br><span class="line"><span class="comment">     * 用非线程安全的set原因：即使用线程安全的set，也无法保证set和map跨集合操作的数据一致性（即线程安全的set仅保证单个集合操作的线程安全），多个集合操作的数据一致性需要自己加锁实现，既然自己要加更大粒度的锁保证数据的一致性，就无需用线程安全的set（普通set性能更高）</span></span><br><span class="line"><span class="comment">     * 关于synchronized的性能：set是每个key（用户）一个，对每个key的set加锁竞争极小，synchronized有一个锁升级的过程，没有竞争的时候是偏向锁（偏向锁是在对象头上做标记，不会产生系统调用），不影响性能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;String, Set&lt;Session&gt;&gt; sessionSetMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Set&lt;Session&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sessionSetMap中key的拼装规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getUserKey</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加会话到缓存，多线程安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addSession</span><span class="params">(Long userId, Session session)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getUserKey(userId);</span><br><span class="line">        addSession(key, session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addSession</span><span class="params">(String key, Session session)</span> &#123;</span><br><span class="line">        addSession(key, session, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addSession</span><span class="params">(String key, Session session, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="type">Set</span> <span class="variable">sessionSet</span> <span class="operator">=</span> sessionSetMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (sessionSet == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//没有key</span></span><br><span class="line">            sessionSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">            sessionSet.add(session);</span><br><span class="line">            <span class="comment">//新增成功返回null，失败返回原来的Set（前面虽然读取到没有key，但是可能有多个线程同时新增，所以要用putIfAbsent）</span></span><br><span class="line">            <span class="type">Set</span> <span class="variable">putSet</span> <span class="operator">=</span> sessionSetMap.putIfAbsent(key, sessionSet);</span><br><span class="line">            <span class="keyword">if</span> (putSet != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//存在key，加锁添加会话到set中（被其他线程先新增key的情况）</span></span><br><span class="line">                addSessionLock(putSet, key, session, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//存在key，加锁添加会话到set中</span></span><br><span class="line">            addSessionLock(sessionSet, key, session, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁添加会话到set中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addSessionLock</span><span class="params">(Set sessionSet, String key, Session session, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="comment">//用set对象加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (sessionSet) &#123;</span><br><span class="line">            <span class="comment">//双重检测（加锁成功之前，set可能被其他线程remove）</span></span><br><span class="line">            <span class="keyword">if</span> (sessionSet == sessionSetMap.get(key)) &#123;</span><br><span class="line">                <span class="comment">//set没有变化，添加session</span></span><br><span class="line">                sessionSet.add(session);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//set有变化，重试操作（避免意外问题，最多操作10次）</span></span><br><span class="line">                <span class="keyword">if</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                    addSession(key, session, ++count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存中的会话，多线程安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeSession</span><span class="params">(Long userId, Session session)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getUserKey(userId);</span><br><span class="line">        removeSession(key, session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeSession</span><span class="params">(String key, Session session)</span> &#123;</span><br><span class="line">        <span class="type">Set</span> <span class="variable">sessionSet</span> <span class="operator">=</span> sessionSetMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (sessionSet != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//存在key，用set对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (sessionSet) &#123;</span><br><span class="line">                <span class="comment">//删除session</span></span><br><span class="line">                sessionSet.remove(session);</span><br><span class="line">                <span class="keyword">if</span> (sessionSet.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//set大小为0，删除key</span></span><br><span class="line">                    sessionSetMap.remove(key, sessionSet);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按key发送信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendByKey</span><span class="params">(Long userId, String msg)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getUserKey(userId);</span><br><span class="line">        sendByKey(key, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendByKey</span><span class="params">(String key, String msg)</span> &#123;</span><br><span class="line">        Set&lt;Session&gt; sessionSet = sessionSetMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (sessionSet != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//读取的时候加锁（synchronized没有竞争的时候是偏向锁，不影响性能）</span></span><br><span class="line">            <span class="keyword">synchronized</span> (sessionSet) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Session session : sessionSet) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                            session.getAsyncRemote().sendText(msg);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.warn(<span class="string">&quot;sendByKey error, key:&#123;&#125;, session:&#123;&#125;, msg:&#123;&#125;&quot;</span>, key, session, msg, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除缓存中已关闭的会话（定时任务调用，避免缓存中有未删除的已关闭会话，可以半小时到1小时调用一次）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clearClosedSession</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;clearClosedSession 执行前map size:&#123;&#125;&quot;</span>, sessionSetMap.size());</span><br><span class="line">        <span class="keyword">for</span> (String key : sessionSetMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Set&lt;Session&gt; sessionSet = sessionSetMap.get(key);</span><br><span class="line">                <span class="keyword">if</span> (sessionSet != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//读取的时候加锁（synchronized没有竞争的时候是偏向锁，不影响性能）</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (sessionSet) &#123;</span><br><span class="line">                        <span class="comment">//没有数据就清除</span></span><br><span class="line">                        <span class="keyword">if</span> (sessionSet.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                            sessionSetMap.remove(key, sessionSet);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Iterator&lt;Session&gt; it = sessionSet.iterator();</span><br><span class="line">                        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                            <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> it.next();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//用isOpen还是isActive判断</span></span><br><span class="line">                                <span class="keyword">if</span> (!session.isOpen()) &#123;</span><br><span class="line">                                    <span class="comment">//删除session</span></span><br><span class="line">                                    it.remove();</span><br><span class="line">                                    <span class="keyword">if</span> (sessionSet.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                                        <span class="comment">//set大小为0，删除key</span></span><br><span class="line">                                        sessionSetMap.remove(key, sessionSet);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                log.warn(<span class="string">&quot;clearClosedSession error, key:&#123;&#125;, session:&#123;&#125;&quot;</span>, key, session, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;clearClosedSession error, key:&#123;&#125;&quot;</span>, key, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;clearClosedSession 执行后map size:&#123;&#125;&quot;</span>, sessionSetMap.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WebSocket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化</title>
      <link href="/2024/04/30/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2024/04/30/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><p>序列化是指把对象转换为字节序列的过程，我们称之为对象的序列化，就是把内存中的这些对象变成一连串的字节(bytes)描述的过程。</p><p>而反序列化则相反，就是把持久化的字节文件数据恢复为对象的过程。</p><p><strong>序列化场景：</strong></p><ul><li>需要把内存中的对象状态数据保存到一个文件或者数据库中的时候，这个场景是比较常见的，例如我们利用mybatis框架编写持久层insert对象数据到数据库中时;</li><li>网络通信时需要用套接字在网络中传送对象时，如我们使用RPC协议进行网络通信时;</li></ul><h1 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h1><p>对于JVM来说，要进行持久化的类必须要有一个标记，只有持有这个标记JVM才允许类创建的对象可以通过其IO系统转换为字节数据，从而实现持久化，而这个标记就是Serializable接口。而在反序列化的过程中则需要使用serialVersionUID来确定由那个类来加载这个对象，所以我们在实现Serializable接口的时候，一般还会要去尽量显示地定义serialVersionUID，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; </span><br></pre></td></tr></table></figure><p>在反序列化的过程中，如果接收方为对象加载了一个类，如果该对象的serialVersionUID与对应持久化时的类不同，那么反序列化的过程中将会导致InvalidClassException异常。例如，在之前反序列化的例子中，我们故意将User类的serialVersionUID改为2L，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2L</span>; </span><br></pre></td></tr></table></figure><p>那么此时，在反序例化时就会导致异常，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException: cn.wudimanong.serializable.User; local <span class="keyword">class</span> <span class="title class_">incompatible</span>: stream <span class="type">classdesc</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1</span>, local <span class="keyword">class</span> <span class="title class_">serialVersionUID</span> = <span class="number">2</span> </span><br><span class="line">    at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class="number">687</span>) </span><br><span class="line">    at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class="number">1880</span>) </span><br><span class="line">    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="number">1746</span>) </span><br><span class="line">    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="number">2037</span>) </span><br><span class="line">    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="number">1568</span>) </span><br><span class="line">    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="number">428</span>) </span><br><span class="line">    at cn.wudimanong.serializable.SerializableTest.readObj(SerializableTest.java:<span class="number">31</span>) </span><br><span class="line">    at cn.wudimanong.serializable.SerializableTest.main(SerializableTest.java:<span class="number">44</span>) </span><br></pre></td></tr></table></figure><p>如果我们在序列化中没有显示地声明serialVersionUID，则序列化运行时将会根据该类的各个方面计算该类默认的serialVersionUID值。但是，Java官方强烈建议所有要序列化的类都显示地声明serialVersionUID字段，因为如果高度依赖于JVM默认生成serialVersionUID，可能会导致其与编译器的实现细节耦合，这样可能会导致在反序列化的过程中发生意外的InvalidClassException异常。因此，为了保证跨不同Java编译器实现的serialVersionUID值的一致，实现Serializable接口的必须显示地声明serialVersionUID字段。</p><p>此外serialVersionUID字段地声明要尽可能使用private关键字修饰，这是因为该字段的声明只适用于声明的类，该字段作为成员变量被子类继承是没有用处的!有个特殊的地方需要注意的是，数组类是不能显示地声明serialVersionUID的，因为它们始终具有默认计算的值，不过数组类反序列化过程中也是放弃了匹配serialVersionUID值的要求。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx的使用</title>
      <link href="/2024/02/18/nginx%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/02/18/nginx%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>nginx进阶：</p><p>·    正向代理和反向代理</p><p>正向代理指的是代理客户端， 代替用户向服务器发送请求， 从而隐藏用户的信息。</p><p>反向代理指的是代理服务器， 通过反向代理，服务器可以分流请求， 而且实际执行请求的服务器处于内网时， 通过反向代理服务器，也能将请求从公网转到内网。 同时隐藏了内网服务器的信息。</p><p>keepAlive</p><p>busybox</p><p>Docker desktop — 搭一个 nginx 验证</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解Quartz</title>
      <link href="/2024/02/18/%E4%BA%86%E8%A7%A3quartz/"/>
      <url>/2024/02/18/%E4%BA%86%E8%A7%A3quartz/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h1><p><strong>Quartz</strong>是一款轻量级且特性丰富的任务调度库，它是基于<strong>Java</strong>实现的调度框架，本文会针对日常任务调度的使用场景来演示<strong>Quartz</strong>的使用姿势。</p><h1 id="源码角度分析"><a href="#源码角度分析" class="headerlink" title="源码角度分析"></a>源码角度分析</h1><p>都说<strong>Quartz</strong>是任务调度框架，从源码就可以看出其本质也就是工作线程轮询并执行继续的调度任务。</p><p><strong>Quartz</strong>将任务定义为<strong>Job</strong>，Job是工作任务调度的接口，该接口定义了<strong>execute</strong>方法，所以当我们需要提交任务给<strong>Quartz</strong>时，就需要继承<strong>Job</strong>接口并在<strong>execute</strong>方法里告知要执行的任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now()</span><br><span class="line">                .format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        log.info(<span class="string">&quot;任务执行时间:&#123;&#125;&quot;</span>, dateTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了<strong>Job</strong>，就需要安排调度计划，在<strong>Quartz</strong>这个框架中，<strong>Trigger</strong>就是告知调度器如何进行任务触发的触发器，使用代码如下所示:</p><ol><li>基于<strong>JobBuilder</strong>创建job，并声称<strong>job</strong>的名称。</li><li>定义触发器，该触发器立即启动并设置名称为<strong>testTrigger</strong>，触发器属于<strong>testTriggerGroup</strong>分组中，执行计划为1秒1次。</li></ol><p>最后就是声明<strong>scheduler</strong>将触发器和任务关联，通过<strong>scheduler</strong>的<strong>scheduleJob</strong>方法关联，就会形成一个以<strong>Job</strong>为工作内容，并按照触发器的安排进行任务的调度的任务定时被调度器执行。 注意该方法还会返回第一次执行的时间，一旦调用<strong>start</strong>，当前方法调度工作就正式开始了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">// 获取任务调度的实例</span></span><br><span class="line">       <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 定义任务调度实例, 并与TestJob绑定</span></span><br><span class="line">       <span class="type">JobDetail</span> <span class="variable">job</span> <span class="operator">=</span> JobBuilder.newJob(MyJob.class)</span><br><span class="line">               .withIdentity(<span class="string">&quot;myJob&quot;</span>, <span class="string">&quot;myJobGroup&quot;</span>)</span><br><span class="line">               .build();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 定义触发器, 会马上执行一次, 接着1秒执行一次</span></span><br><span class="line">       <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">               .withIdentity(<span class="string">&quot;testTrigger&quot;</span>, <span class="string">&quot;testTriggerGroup&quot;</span>)</span><br><span class="line">               .startNow()</span><br><span class="line">               .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(<span class="number">1</span>))</span><br><span class="line">               .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用触发器调度任务的执行 获取任务调度时间</span></span><br><span class="line">       <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span>scheduler.scheduleJob(job, trigger);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 开启任务</span></span><br><span class="line">       scheduler.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看出<strong>Quartz</strong>的工作核心就是，通过<strong>Job</strong>来指定任务的详情，结合触发器<strong>Trigger</strong>指定任务的执行时间和间隔还有次数等信息，再让调度器<strong>scheduler</strong>定期去执行前两者关联而生成的定时任务。</p><h1 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h1><h2 id="Quartz横向扩展带来的问题"><a href="#Quartz横向扩展带来的问题" class="headerlink" title="Quartz横向扩展带来的问题"></a>Quartz横向扩展带来的问题</h2><p>虽说<strong>Quartz</strong>支持集群模式实现横向扩展，也就是我们常说的分布式调度，但需要业务方面通过一些手段实现节点任务执行的互斥和安全，从而避免任务重复执行等一些问题，常见的解决方案分别由数据库锁和分布式锁两种:</p><p>在调度进行任务争抢时先对数据库表上锁，只有拿到锁的节点才可以进行获取任务并调度，这种是常规情况下的解决方案，但这种实现方式有着很强的侵入性，且在高并发的场景性能表现也不是很出色，所以大部分情况下，我们不是很推荐通过数据表的形式实现分布式任务调度一致性。</p><p>通常情况下，采用<strong>redis分布式锁</strong>是针对<strong>Quartz</strong>框架分布式任务调度的较好解决方案，通过在内存中进行任务争抢，大大提分布式调度性能，但还是存在调度空跑问题，即先抢到锁的节点获取仅有的任务，而其他节点随后得锁后却没有执行任务，造成一次空跑。</p><h2 id="任务分片问题"><a href="#任务分片问题" class="headerlink" title="任务分片问题"></a>任务分片问题</h2><p>试想一个场景，原本一个节点负责调度全国系统的所有任务，随着业务激增我们将<strong>Quartz</strong>设置为集群模式，希望各个节点负责执行不同省份的任务。其他调度框架例如<strong>XXL-JOB</strong>，可以通过配置中心决定这个调度规则例如工具任务的编号知晓省份通过hash取模分配给不同的省份。</p><p><img src="https://qiniuyun.sharkchili.com/img202401081220268.png" alt="在这里插入图片描述"></p><p>而<strong>Quartz</strong>因为没有对应的页面和配置中心，所以实现任务分片需要通过硬编码的形式来实现，有着很强的代码侵入以及实现的复杂性。</p><h1 id="横向对比其他方案"><a href="#横向对比其他方案" class="headerlink" title="横向对比其他方案"></a>横向对比其他方案</h1><p>所以对于简单且较为轻量的任务调度场景，我们可优先考虑<strong>Quartz</strong>，若希望在集群环境下实现分布式调度以及任务分片等复杂的需求时，可参照下面酌情考虑这些更高效中心化的任务调度中心<strong>xxl-job</strong>或者<strong>elastic-job</strong>：</p><table><thead><tr><th>对比项</th><th align="center">Quartz</th><th align="center">elastic-job</th><th align="center">xxl-job</th></tr></thead><tbody><tr><td>集群、弹性扩容</td><td align="center">多节点，部署，通过竞争数据库锁来保证只有一个节点执行任务</td><td align="center">通过zookeeper的注册与发现，可以动态的添加服务器。支持水平扩容</td><td align="center">使用Quartz基于数据库的分布式功能，服务器超出一定数量会给数据库造成一定的压力</td></tr><tr><td>任务分片</td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td>管理界面</td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td>高级功能</td><td align="center">❌</td><td align="center">弹性扩容，多种作业模式，失效转移，运行状态收集，多线程处理数据，幂等性，容错处理，spring命名空间支持</td><td align="center">弹性扩容，分片广播，故障转移，Rolling实时日志，GLUE（支持在线编辑代码，免发布），任务进度监控，任务依赖，数据加密，邮件报警，运行报表，国际化</td></tr><tr><td>缺点</td><td align="center">没有管理界面，以及不支持任务分片等。不适用于分布式场景</td><td align="center">需要引入zookeeper，mesos，增加系统复杂度，学习成本较高</td><td align="center">调度中心通过获取DB锁来保证集群中执行任务的唯一性，如果短任务很多，随着调度中心集群数量增加，那么数据库的锁竞争会比较厉害，性能不好。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> xxl-job </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
            <tag> quartz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxl-job的策略解析</title>
      <link href="/2024/02/09/xxl-job%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/"/>
      <url>/2024/02/09/xxl-job%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="阻塞处理策略"><a href="#阻塞处理策略" class="headerlink" title="阻塞处理策略"></a>阻塞处理策略</h2><h3 id="单机串行（默认）"><a href="#单机串行（默认）" class="headerlink" title="单机串行（默认）"></a>单机串行（默认）</h3><p>调度进入单机执行器后，调度请求进入FIFO队列中并以串行方式运行</p><h3 id="丢弃后续调度（推荐）"><a href="#丢弃后续调度（推荐）" class="headerlink" title="丢弃后续调度（推荐）"></a>丢弃后续调度（推荐）</h3><p>调度请求进入单机执行器，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败</p><h3 id="覆盖之前调度（不推荐）"><a href="#覆盖之前调度（不推荐）" class="headerlink" title="覆盖之前调度（不推荐）"></a>覆盖之前调度（不推荐）</h3><p>调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度</p><h2 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h2><h3 id="调用核心"><a href="#调用核心" class="headerlink" title="调用核心"></a>调用核心</h3><p>要想了解路由策略在何时执行的，我们不妨从入口触发器的代码开始研究。我们找到XxlJobTrigger的trigger方法。我们在代码中看到这么一段关于路由的逻辑，我们不妨步入查看一下processTrigger做了些什么。</p><p>源码如下，由于代码比较长，笔者将代码核心部分贴出来，如下所示，它的整体步骤为:</p><ol><li>根据传入的job获取路由策略参数。</li><li>如果是分片广播则for循环调用外部传入的index获取执行器地址并调用执行器。</li><li>反之根据参数获取路由策略调用获取对应地址并调用即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processTrigger</span><span class="params">(XxlJobGroup group, XxlJobInfo jobInfo, <span class="type">int</span> finalFailRetryCount, TriggerTypeEnum triggerType, <span class="type">int</span> index, <span class="type">int</span> total)</span>&#123;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">       <span class="comment">//根据传入job获取配置的路由策略</span></span><br><span class="line">       <span class="type">ExecutorRouteStrategyEnum</span> <span class="variable">executorRouteStrategyEnum</span> <span class="operator">=</span> ExecutorRouteStrategyEnum.match(jobInfo.getExecutorRouteStrategy(), <span class="literal">null</span>);    <span class="comment">// route strategy</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3、根据路由策略找到对应执行器的地址</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       ReturnT&lt;String&gt; routeAddressResult = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (group.getRegistryList()!=<span class="literal">null</span> &amp;&amp; !group.getRegistryList().isEmpty()) &#123;</span><br><span class="line">           <span class="comment">//如果是分片广播的路由策略，则调用所有执行器执行一遍</span></span><br><span class="line">           <span class="keyword">if</span> (ExecutorRouteStrategyEnum.SHARDING_BROADCAST == executorRouteStrategyEnum) &#123;</span><br><span class="line">               <span class="keyword">if</span> (index &lt; group.getRegistryList().size()) &#123;</span><br><span class="line">                   address = group.getRegistryList().get(index);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   address = group.getRegistryList().get(<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//根据job配置信息找到对应路由策略类获取对应执行器的地址</span></span><br><span class="line">               routeAddressResult = executorRouteStrategyEnum.getRouter().route(triggerParam, group.getRegistryList());</span><br><span class="line">               <span class="keyword">if</span> (routeAddressResult.getCode() == ReturnT.SUCCESS_CODE) &#123;</span><br><span class="line">                   address = routeAddressResult.getContent();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           routeAddressResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, I18nUtil.getString(<span class="string">&quot;jobconf_trigger_address_empty&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4、trigger remote executor</span></span><br><span class="line">       ReturnT&lt;String&gt; triggerResult = <span class="literal">null</span>;</span><br><span class="line">       <span class="comment">//如果地址不为空则直接执行任务</span></span><br><span class="line">       <span class="keyword">if</span> (address != <span class="literal">null</span>) &#123;</span><br><span class="line">           triggerResult = runExecutor(triggerParam, address);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           triggerResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="literal">null</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="第一个"><a href="#第一个" class="headerlink" title="第一个"></a>第一个</h3><p>执行器地址表中的第一个</p><p>第一个：选择adressList中第一个的机器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteFirst</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(addressList.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>心跳的机制和频率</strong>：每隔30s更新一次注册表内的机器信息，删除超过90s未更新的机器，新增更新时间&gt;当前时间+90s的机器</p><blockquote><p>每5s起一个任务，该任务30s运行完毕，在第一个路由策略下如何运行？</p></blockquote><p>始终是执行器地址表中的第一个机器执行任务。</p><blockquote><p>并发任务在第一个策略和在轮询策略是怎么分配执行机器的？</p></blockquote><p>一个任务执行完成的时间超过任务调度的间隔时间， 那么就会出现并发任务的问题。</p><p>如果使用的是第一个策略， </p><p>那么，调度每次都会发往第一个机器， 当第一次任务调度还在进行中，收到第二次任务调度， 则会根据阻塞处理策略处理第二次调度， 可以单机串行， 丢弃后续调度或者覆盖当前调度。</p><p>如果使用的是轮询策略，</p><p>那么， 第一次调度和第二次调度会落在不同的机器上，任务就会并行执行。当操作相同的数据时就会遇到并发的问题。</p><p>常用的解决并发任务的方案是：单机路由策略（如：第一个、一致性哈希） + 阻塞策略（如：单机串行、丢弃后续调度或覆盖当前调度）来处理。</p><h3 id="最后一个"><a href="#最后一个" class="headerlink" title="最后一个"></a>最后一个</h3><p>执行器地址表中的最后一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteLast</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(addressList.get(addressList.size()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>每5s起一个任务，该任务30s运行完毕，在最后一个路由策略下如何运行？</p></blockquote><p>始终是执行器地址表中的最后一个机器执行任务。</p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>如果有n个执行器，轮询执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteRound</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;Integer, AtomicInteger&gt; routeCountEachJob = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">CACHE_VALID_TIME</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> jobId)</span> &#123;</span><br><span class="line">        <span class="comment">// cache clear</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &gt; CACHE_VALID_TIME) &#123;</span><br><span class="line">            routeCountEachJob.clear();</span><br><span class="line">            CACHE_VALID_TIME = System.currentTimeMillis() + <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> routeCountEachJob.get(jobId);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="literal">null</span> || count.get() &gt; <span class="number">1000000</span>) &#123;</span><br><span class="line">            <span class="comment">// 初始化时主动Random一次，缓解首次压力</span></span><br><span class="line">            count = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// count++</span></span><br><span class="line">            count.addAndGet(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        routeCountEachJob.put(jobId, count);</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> addressList.get(count(triggerParam.getJobId())%addressList.size());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>本来有两台机器，此时有一台停止了，在轮询路由策略下如何执行？</p></blockquote><p>还是在轮询，每次轮到这个节点执行失败不插入数据，周期不正常。</p><h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>如果有n个执行器，随机执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteRandom</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">localRandom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> addressList.get(localRandom.nextInt(addressList.size()));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本来有两台机器，此时有一台停止了，在随机路由策略下如何执行？</p></blockquote><p>还是在随机，不会自动剔除掉故障的节点，周期不正常。</p><h3 id="忙碌转移"><a href="#忙碌转移" class="headerlink" title="忙碌转移"></a>忙碌转移</h3><p>下发任务前向执行器节点发起rpc心跳请求查询是否忙碌，如果执行器节点返回忙碌则转移到其他执行器节点执行</p><p>具体步骤如下：</p><ol><li>遍历执行器地址。</li><li>调用执行器的idle方法查看是否忙碌。</li><li>如果忙碌则打个日志，继续遍历下一个。</li><li>找到不忙碌的直接调用执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteBusyover</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">idleBeatResultSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">//遍历执行器地址</span></span><br><span class="line">        <span class="keyword">for</span> (String address : addressList) &#123;</span><br><span class="line">            <span class="comment">// beat</span></span><br><span class="line">            ReturnT&lt;String&gt; idleBeatResult = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ExecutorBiz</span> <span class="variable">executorBiz</span> <span class="operator">=</span> XxlJobScheduler.getExecutorBiz(address);</span><br><span class="line">                <span class="comment">//调用执行器的idle方法查看是否忙碌</span></span><br><span class="line">                idleBeatResult = executorBiz.idleBeat(<span class="keyword">new</span> <span class="title class_">IdleBeatParam</span>(triggerParam.getJobId()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//如果忙碌则打个日志，继续遍历下一个</span></span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">                idleBeatResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;&quot;</span>+e );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到不忙碌的直接调用执行</span></span><br><span class="line">            idleBeatResultSB.append( (idleBeatResultSB.length()&gt;<span class="number">0</span>)?<span class="string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span>:<span class="string">&quot;&quot;</span>)</span><br><span class="line">                    .append(I18nUtil.getString(<span class="string">&quot;jobconf_idleBeat&quot;</span>) + <span class="string">&quot;：&quot;</span>)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;address：&quot;</span>).append(address)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;code：&quot;</span>).append(idleBeatResult.getCode())</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;msg：&quot;</span>).append(idleBeatResult.getMsg());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// beat success</span></span><br><span class="line">            <span class="keyword">if</span> (idleBeatResult.getCode() == ReturnT.SUCCESS_CODE) &#123;</span><br><span class="line">                idleBeatResult.setMsg(idleBeatResultSB.toString());</span><br><span class="line">                idleBeatResult.setContent(address);</span><br><span class="line">                <span class="keyword">return</span> idleBeatResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, idleBeatResultSB.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到idleBeat的逻辑就是通过loadJobThread判断执行器是否忙碌，如果忙碌则返回失败，反之返回成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">idleBeat</span><span class="params">(IdleBeatParam idleBeatParam)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isRunningOrHasQueue</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isRunningOrHasQueue</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">JobThread</span> <span class="variable">jobThread</span> <span class="operator">=</span> XxlJobExecutor.loadJobThread(idleBeatParam.getJobId());</span><br><span class="line">    <span class="keyword">if</span> (jobThread != <span class="literal">null</span> &amp;&amp; jobThread.isRunningOrHasQueue()) &#123;</span><br><span class="line">        isRunningOrHasQueue = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRunningOrHasQueue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;job thread is running or has trigger queue.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadJobThread方法逻辑也很简单，每一个执行的任务都会存到jobThreadRepository 中，以任务id为key，线程为value，如果map中存在则说明该任务还在执行，说明执行器忙碌。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;Integer, JobThread&gt; jobThreadRepository = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Integer, JobThread&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> JobThread <span class="title function_">loadJobThread</span><span class="params">(<span class="type">int</span> jobId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobThreadRepository.get(jobId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>在主节点或主服务器故障时，自动切换到备份节点或备份服务器，以保证服务的可用性和连续性。</p><p>具体步骤如下：</p><ol><li>遍历执行器地址。</li><li>调用执行器的beat方法查看是否故障。</li><li>如果故障则打个日志，继续遍历下一个。</li><li>找到不故障的直接调用执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteFailover</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">beatResultSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (String address : addressList) &#123;</span><br><span class="line">            <span class="comment">// beat</span></span><br><span class="line">            ReturnT&lt;String&gt; beatResult = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ExecutorBiz</span> <span class="variable">executorBiz</span> <span class="operator">=</span> XxlJobScheduler.getExecutorBiz(address);</span><br><span class="line">                beatResult = executorBiz.beat();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">                beatResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;&quot;</span>+e );</span><br><span class="line">            &#125;</span><br><span class="line">            beatResultSB.append( (beatResultSB.length()&gt;<span class="number">0</span>)?<span class="string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span>:<span class="string">&quot;&quot;</span>)</span><br><span class="line">                    .append(I18nUtil.getString(<span class="string">&quot;jobconf_beat&quot;</span>) + <span class="string">&quot;：&quot;</span>)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;address：&quot;</span>).append(address)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;code：&quot;</span>).append(beatResult.getCode())</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;msg：&quot;</span>).append(beatResult.getMsg());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// beat success</span></span><br><span class="line">            <span class="keyword">if</span> (beatResult.getCode() == ReturnT.SUCCESS_CODE) &#123;</span><br><span class="line"></span><br><span class="line">                beatResult.setMsg(beatResultSB.toString());</span><br><span class="line">                beatResult.setContent(address);</span><br><span class="line">                <span class="keyword">return</span> beatResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, beatResultSB.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最近最久未使用"><a href="#最近最久未使用" class="headerlink" title="最近最久未使用"></a>最近最久未使用</h3><p>选择最近最久未使用的节点来处理请求。这种算法根据节点上一次使用的时间戳，选择最长时间未使用的节点来分配请求。</p><ol><li>用jobLRUMap 来缓存每一个地址的使用情况。</li><li>如果缓存时间过期，则将jobLRUMap 清空。</li><li>根据jobId从jobLRUMap 获取对应的地址列表。</li><li>获取第一个(因为linkHashMap)取一次元素，该元素就会排到末尾，所以第一个永远是最近最少使用的。</li><li>调用linkHashMap的get方法获取最近最少使用的address。</li><li>返回地址值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteLRU</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;Integer, LinkedHashMap&lt;String, String&gt;&gt; jobLRUMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Integer, LinkedHashMap&lt;String, String&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">CACHE_VALID_TIME</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">route</span><span class="params">(<span class="type">int</span> jobId, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cache clear</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &gt; CACHE_VALID_TIME) &#123;</span><br><span class="line">            jobLRUMap.clear();</span><br><span class="line">            CACHE_VALID_TIME = System.currentTimeMillis() + <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init lru</span></span><br><span class="line">        LinkedHashMap&lt;String, String&gt; lruItem = jobLRUMap.get(jobId);</span><br><span class="line">        <span class="keyword">if</span> (lruItem == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * LinkedHashMap</span></span><br><span class="line"><span class="comment">             *      a、accessOrder：true=访问顺序排序（get/put时排序）；false=插入顺序排期；</span></span><br><span class="line"><span class="comment">             *      b、removeEldestEntry：新增元素时将会调用，返回true时会删除最老元素；可封装LinkedHashMap并重写该方法，比如定义最大容量，超出是返回true即可实现固定长度的LRU算法；</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            lruItem = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">            jobLRUMap.putIfAbsent(jobId, lruItem);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put new</span></span><br><span class="line">        <span class="keyword">for</span> (String address: addressList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lruItem.containsKey(address)) &#123;</span><br><span class="line">                lruItem.put(address, address);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove old</span></span><br><span class="line">        List&lt;String&gt; delKeys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String existKey: lruItem.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!addressList.contains(existKey)) &#123;</span><br><span class="line">                delKeys.add(existKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delKeys.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String delKey: delKeys) &#123;</span><br><span class="line">                lruItem.remove(delKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">eldestKey</span> <span class="operator">=</span> lruItem.entrySet().iterator().next().getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">eldestValue</span> <span class="operator">=</span> lruItem.get(eldestKey);</span><br><span class="line">        <span class="keyword">return</span> eldestValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> route(triggerParam.getJobId(), addressList);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最不经常使用"><a href="#最不经常使用" class="headerlink" title="最不经常使用"></a>最不经常使用</h3><p>选择最不经常使用的节点来处理请求。这种算法根据节点上一次使用的次数，选择最不经常使用的节点来分配请求。</p><ol><li>用 jobLfuMap 来缓存每一个地址的使用情况。</li><li>如果缓存时间过期，则将 jobLfuMap 清空。</li><li>根据 jobId 从 jobLfuMap 获取对应的地址列表。</li><li>获取第一个(因为linkHashMap)取一次元素，该元素就会排到末尾，所以第一个永远是最不经常使用的。</li><li>调用linkHashMap的get方法获取最不经常使用的address。</li><li>返回地址值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteLFU</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;Integer, HashMap&lt;String, Integer&gt;&gt; jobLfuMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Integer, HashMap&lt;String, Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">CACHE_VALID_TIME</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">route</span><span class="params">(<span class="type">int</span> jobId, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cache clear</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &gt; CACHE_VALID_TIME) &#123;</span><br><span class="line">            jobLfuMap.clear();</span><br><span class="line">            CACHE_VALID_TIME = System.currentTimeMillis() + <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lfu item init</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; lfuItemMap = jobLfuMap.get(jobId);     <span class="comment">// Key排序可以用TreeMap+构造入参Compare；Value排序暂时只能通过ArrayList；</span></span><br><span class="line">        <span class="keyword">if</span> (lfuItemMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            lfuItemMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">            jobLfuMap.putIfAbsent(jobId, lfuItemMap);   <span class="comment">// 避免重复覆盖</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put new</span></span><br><span class="line">        <span class="keyword">for</span> (String address: addressList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lfuItemMap.containsKey(address) || lfuItemMap.get(address) &gt;<span class="number">1000000</span> ) &#123;</span><br><span class="line">                lfuItemMap.put(address, <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(addressList.size()));  <span class="comment">// 初始化时主动Random一次，缓解首次压力</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove old</span></span><br><span class="line">        List&lt;String&gt; delKeys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String existKey: lfuItemMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!addressList.contains(existKey)) &#123;</span><br><span class="line">                delKeys.add(existKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delKeys.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String delKey: delKeys) &#123;</span><br><span class="line">                lfuItemMap.remove(delKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load least userd count address</span></span><br><span class="line">        List&lt;Map.Entry&lt;String, Integer&gt;&gt; lfuItemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;(lfuItemMap.entrySet());</span><br><span class="line">        Collections.sort(lfuItemList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getValue().compareTo(o2.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Map.Entry&lt;String, Integer&gt; addressItem = lfuItemList.get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">minAddress</span> <span class="operator">=</span> addressItem.getKey();</span><br><span class="line">        addressItem.setValue(addressItem.getValue() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> addressItem.getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> route(triggerParam.getJobId(), addressList);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><p>根据jobId和执行器地址列表来做路由。</p><ul><li>执行器地址（ip:port) hash到TreeMap</li><li>为了避免增减节点时负载不均衡，加入虚拟节点。每个物理节点虚拟为100个虚拟节点分散到TreeMap中</li><li>重写Hash算法避免原生hash算法不均衡问题</li><li>采用TreeMap的tailMap功能找到大于等于当前hash值的节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteConsistentHash</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">VIRTUAL_NODE_NUM</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get hash code on 2^32 ring (md5散列的方式计算hash值)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">hash</span><span class="params">(String key)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// md5 byte</span></span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;MD5 not supported&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.reset();</span><br><span class="line">        <span class="type">byte</span>[] keyBytes = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            keyBytes = key.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown string :&quot;</span> + key, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        md5.update(keyBytes);</span><br><span class="line">        <span class="type">byte</span>[] digest = md5.digest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hash code, Truncate to 32-bits</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> ((<span class="type">long</span>) (digest[<span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (digest[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">truncateHashCode</span> <span class="operator">=</span> hashCode &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">        <span class="keyword">return</span> truncateHashCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hashJob</span><span class="params">(<span class="type">int</span> jobId, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------A1------A2-------A3------</span></span><br><span class="line">        <span class="comment">// -----------J1------------------</span></span><br><span class="line">        TreeMap&lt;Long, String&gt; addressRing = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String address: addressList) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; VIRTUAL_NODE_NUM; i++) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">addressHash</span> <span class="operator">=</span> hash(<span class="string">&quot;SHARD-&quot;</span> + address + <span class="string">&quot;-NODE-&quot;</span> + i);</span><br><span class="line">                addressRing.put(addressHash, address);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">jobHash</span> <span class="operator">=</span> hash(String.valueOf(jobId));</span><br><span class="line">        SortedMap&lt;Long, String&gt; lastRing = addressRing.tailMap(jobHash);</span><br><span class="line">        <span class="keyword">if</span> (!lastRing.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> lastRing.get(lastRing.firstKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addressRing.firstEntry().getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> hashJob(triggerParam.getJobId(), addressList);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分片广播"><a href="#分片广播" class="headerlink" title="分片广播"></a>分片广播</h3><p>广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务。</p><p>要取出要更新的id，然后判断取模是不是本台机器处理，如果是本台机器需要处理的，再根据id查询数据，处理数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分片广播任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@XxlJob(&quot;shardingJobHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shardingJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分片参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line"></span><br><span class="line">    XxlJobHelper.log(<span class="string">&quot;分片参数：当前分片序号 = &#123;&#125;, 总分片数 = &#123;&#125;&quot;</span>, shardIndex, shardTotal);</span><br><span class="line">    <span class="comment">//获取需要处理的所有门店列表</span></span><br><span class="line">    List&lt;StoreInfo&gt; storeInfoList = storeInfoMapper.selectList(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;StoreInfo&gt;().lambda().orderByDesc(StoreInfo::getStoreCode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前分片需要处理的门店列表</span></span><br><span class="line">    List&lt;StoreInfo&gt; shardStoreInfoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; storeInfoList.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % shardTotal == shardIndex) &#123;</span><br><span class="line">            <span class="comment">//将当前分片需要处理的门店加入list</span></span><br><span class="line">            shardStoreInfoList.add(storeInfoList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理业务逻辑...</span></span><br><span class="line">    service.doBusiness(shardStoreInfoList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由策略适用场景"><a href="#路由策略适用场景" class="headerlink" title="路由策略适用场景"></a>路由策略适用场景</h2><table><thead><tr><th>路由策略</th><th>适用场景</th></tr></thead><tbody><tr><td>第一个</td><td>当只有一台机器注册</td></tr><tr><td>最后一个</td><td>当只有一台机器注册</td></tr><tr><td>轮询</td><td>有多台机器， 且希望每台机器平等的享有被调度的可能</td></tr><tr><td>随机</td><td>有多台机器， 且不关心哪台机器执行任务</td></tr><tr><td>忙碌转移</td><td>有多台机器， 希望第一次检测到空闲的机器执行任务。</td></tr><tr><td>故障转移</td><td>有多台机器，希望第一次检测到存活的机器执行任务， 且不关心该机器是否正在处理任务</td></tr><tr><td>最近最久未使用</td><td>有多台机器， 希望闲置最久的机器优先被使用</td></tr><tr><td>最不经常使用</td><td>有多台机器， 希望使用频率低的机器优先被使用</td></tr><tr><td>一致性哈希</td><td>有多台机器， 希望均匀地分布请求， 且在机器的数量变化时， 还能有很好的扩展性和容错性， 拥有相同jobId的任务调度请求， 大概率会落在相同的机器上。</td></tr><tr><td>分片广播</td><td>有多台机器，且对于执行时间长的任务，希望能分散到各个节点上执行，从而加快完成的速度</td></tr></tbody></table><h3 id="rpa分发任务到执行器的策略"><a href="#rpa分发任务到执行器的策略" class="headerlink" title="rpa分发任务到执行器的策略"></a>rpa分发任务到执行器的策略</h3><p>单机只运行一个任务策略。在RPA情景下， 一般只会有一个执行器注册执行调度中心， 为了防止用户电脑上执行的程序中断， 应该单机串行， 调度请求排队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorRouteGlobalBusyover</span> <span class="keyword">extends</span> <span class="title class_">ExecutorRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">route</span><span class="params">(TriggerParam triggerParam, List&lt;String&gt; addressList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">idleBeatResultSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String address : addressList) &#123;</span><br><span class="line">            <span class="comment">// beat</span></span><br><span class="line">            ReturnT&lt;String&gt; idleBeatResult = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ExecutorBiz</span> <span class="variable">executorBiz</span> <span class="operator">=</span> XxlJobScheduler.getExecutorBiz(address);</span><br><span class="line">                <span class="comment">// 单机只运行一个任务策略 检测</span></span><br><span class="line">                idleBeatResult = executorBiz.globalIdleBeat(<span class="keyword">new</span> <span class="title class_">IdleBeatParam</span>(triggerParam.getJobId()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">                idleBeatResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;&quot;</span>+e );</span><br><span class="line">            &#125;</span><br><span class="line">            idleBeatResultSB.append( (idleBeatResultSB.length()&gt;<span class="number">0</span>)?<span class="string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span>:<span class="string">&quot;&quot;</span>)</span><br><span class="line">                    .append(I18nUtil.getString(<span class="string">&quot;jobconf_idleBeat&quot;</span>) + <span class="string">&quot;：&quot;</span>)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;address：&quot;</span>).append(address)</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;code：&quot;</span>).append(idleBeatResult.getCode())</span><br><span class="line">                    .append(<span class="string">&quot;&lt;br&gt;msg：&quot;</span>).append(idleBeatResult.getMsg());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// beat success</span></span><br><span class="line">            <span class="keyword">if</span> (idleBeatResult.getCode() == ReturnT.SUCCESS_CODE) &#123;</span><br><span class="line">                idleBeatResult.setMsg(idleBeatResultSB.toString());</span><br><span class="line">                idleBeatResult.setContent(address);</span><br><span class="line">                <span class="keyword">return</span> idleBeatResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, idleBeatResultSB.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中检测是否存在一个运行中的任务逻辑如下：</p><ol><li>获取所有的正在运行中的任务线程</li><li>再挨个遍历，如果任务线程没有在运行，则直接返回成功</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">globalIdleBeat</span><span class="params">(IdleBeatParam idleBeatParam)</span> &#123;</span><br><span class="line"></span><br><span class="line">       logger.info(<span class="string">&quot;globalIdleBeat check&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// get all job thread</span></span><br><span class="line">       ConcurrentMap&lt;Integer, JobThread&gt; jobThreadRepository = XxlJobExecutor.getJobThreadRepository();</span><br><span class="line">       <span class="keyword">if</span> (jobThreadRepository.size() == <span class="number">0</span>) &#123;</span><br><span class="line">           logger.info(<span class="string">&quot;globalIdleBeat empty&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// isRunningOrHasQueue</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">isRunningOrHasQueue</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// check is job status</span></span><br><span class="line">       <span class="keyword">for</span> (Integer jobid : jobThreadRepository.keySet()) &#123;</span><br><span class="line">           <span class="type">JobThread</span> <span class="variable">jobThread</span> <span class="operator">=</span> XxlJobExecutor.loadJobThread(jobid);</span><br><span class="line">           <span class="keyword">if</span> (jobThread != <span class="literal">null</span> &amp;&amp; jobThread.isRunningOrHasQueue()) &#123;</span><br><span class="line">               isRunningOrHasQueue = <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (isRunningOrHasQueue) &#123;</span><br><span class="line">               logger.info(<span class="string">&quot;job thread [&quot;</span> + jobThread.getName() + <span class="string">&quot;] is running or has trigger queue.&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;job thread [&quot;</span> + jobThread.getHandler() + <span class="string">&quot;] is running or has trigger queue.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           logger.info(<span class="string">&quot;job thread [&quot;</span> + jobThread.getName() + <span class="string">&quot;] is empty&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="分布式组件负载均衡策略"><a href="#分布式组件负载均衡策略" class="headerlink" title="分布式组件负载均衡策略"></a>分布式组件负载均衡策略</h2><p>Spring Cloud Gateway中负载均衡使用了路由策略。在微服务架构中，通常存在多个相同或相似的微服务实例，每个实例都提供相同的服务接口，但可能运行在不同的主机或容器上。</p><p>负载策略有： </p><ul><li>Path Route Predicate：基于请求的路径进行匹配，支持Ant风格的路径表达式，如<code>/foo/**</code>。</li><li>Query Route Predicate：基于请求的查询参数进行匹配，支持正则表达式，如<code>name=foo.*</code>。</li><li>Method Route Predicate：基于请求的方法进行匹配，如<code>GET</code>、<code>POST</code>等。</li><li>Header Route Predicate：基于请求头进行匹配，如<code>Host</code>、<code>User-Agent</code>等。</li><li>Cookie Route Predicate：基于请求的Cookie进行匹配，如<code>SESSIONID=123456</code>。</li><li>RemoteAddr Route Predicate：基于请求的IP地址进行匹配，如<code>192.168.1.100</code>。</li><li>Host Route Predicate：基于请求的Host头进行匹配，如<code>example.com</code>。</li><li>Cloud Foundry Route Service Route Predicate：用于支持Cloud Foundry的路由服务。</li><li>Weight Route Predicate：根据服务的权重进行<a href="https://cloud.tencent.com/product/clb?from_column=20065&from=20065">负载均衡</a>路由。</li></ul><p>Nginx的upstream支持如下六种方式的负载均衡算法</p><ul><li>轮询：默认方式</li><li>weight：加权轮询</li><li>ip_hash：依据发出请求的 客户端IP 的hash值来分配服务器，可以保证同IP发出的请求路由到同一服务器。<strong>与“一致性hash”路由相似</strong></li><li>url_hash：根据请求的 URL 的hash值来分配服务器。<strong>与“一致性hash”路由相似</strong></li><li>least_conn：最少连接，把请求转发给连接数较少的后端服务器。<strong>与“忙碌转移”路由相似</strong></li><li>fair：由第三方模块提供，可以根据页面大小、加载时间长短智能的进行负载均衡。<strong>与“忙碌转移”路由相似</strong><br>此外，可以用backup将某服务器标记为备用，当主服务器不可用时，将用它处理请求。<strong>与“故障转移”路由相似</strong></li></ul><h2 id="xxl-job如何实现调度器集群任务不重复执行的"><a href="#xxl-job如何实现调度器集群任务不重复执行的" class="headerlink" title="xxl-job如何实现调度器集群任务不重复执行的"></a>xxl-job如何实现调度器集群任务不重复执行的</h2><p>从定时任务处理器中可以看到，在真正调度任务之前，当前的触发器会对xxl_job_lock表上个写锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preparedStatement = conn.prepareStatement(  <span class="string">&quot;select * from xxl_job_lock where lock_name = &#x27;schedule_lock&#x27; for update&quot;</span> );</span><br><span class="line">preparedStatement.execute();</span><br></pre></td></tr></table></figure><p>xxl_job_lock仅仅是作为定时任务调度的锁，正是因为写锁的存在，保证一个触发器触发任务时，别的触发器会被阻塞。</p><p>最后将事务提交完成任务的触发，然后休眠，其他触发可以抢占后续工作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commit</span></span><br><span class="line">   <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 事务提交</span></span><br><span class="line">       conn.commit();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!scheduleThreadToStop) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         conn.setAutoCommit(connAutoCommit);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!scheduleThreadToStop) &#123;</span><br><span class="line">         logger.error(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 休眠</span></span><br><span class="line">          conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!scheduleThreadToStop) &#123;</span><br><span class="line">          logger.error(e.getMessage(), e);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> xxl-job </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxl-job原理与实践</title>
      <link href="/2024/02/06/xxl-job%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/02/06/xxl-job%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="xxl-job-的概念"><a href="#xxl-job-的概念" class="headerlink" title="xxl-job 的概念"></a>xxl-job 的概念</h1><h2 id="诞生背景"><a href="#诞生背景" class="headerlink" title="诞生背景"></a>诞生背景</h2><p>我们在日常项目开发中，可能会用到分布式调度，在这期间我们可能会遇到这些问题:</p><ol><li>同一个服务中可能存在多个互斥的任务，需要统一调度和协调。</li><li>定时任务运行期间，为了确保任务能够稳定运行，我们希望能够做到高可用、监控运维、故障告警。</li><li>需要统一管理和追踪个个服务节点定时任务的情况，以及任务属性信息，比如:任务所属服务、所属责任人等信息。</li></ol><p>所以我们这里就需要用到xxl-job这个轻量级框架。</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><ul><li><strong>调度模块（调度中心）</strong>：<br>负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块；<br>支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。</li><li><strong>执行模块（执行器）</strong>：<br>负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；<br>接收“调度中心”的执行请求、终止请求和日志请求等。</li></ul><p>这里放一张官网的系统架构图：</p><p><img src="https://www.xuxueli.com/doc/static/xxl-job/images/img_Qohm.png" alt="输入图片说明"></p><p>在真正了解 xxl-job 之前，可以带着以下的问题去进行系统性的学习：</p><ul><li>执行器是如何自动注册到调度中心的？</li><li>调度中心是如何管理执行器的？</li><li>调度中心是如何触发任务的？</li><li>任务是怎么回调jobHandler的？</li><li>任务执行超时会有什么应对策略吗？</li></ul><h1 id="服务端启动流程"><a href="#服务端启动流程" class="headerlink" title="服务端启动流程"></a>服务端启动流程</h1><p><img src="https://qiniuyun.sharkchili.com/img202304260835617.png" alt="在这里插入图片描述"></p><p>要想设计一个分布式任务调度中心，我们需要下面几个东西:</p><ol><li>注册服务</li><li>RPC通信框架</li><li>调度服务</li><li>日志服务</li><li>告警服务</li></ol><h2 id="整体过程概述"><a href="#整体过程概述" class="headerlink" title="整体过程概述"></a>整体过程概述</h2><p>在 <code>xxl-job-admin</code> 的 XxlJobAdminConfig 中，可以看到它在 bean 完成初始化之后通过 InitializingBean 进行了一些特殊操作。</p><p>它继承InitializingBean所实现的afterPropertiesSet方法执行了下面的操作。代码很简单创建一个调度器之后就调用init进行初始化。我们不妨查看init做了什么操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       adminConfig = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">       xxlJobScheduler = <span class="keyword">new</span> <span class="title class_">XxlJobScheduler</span>();</span><br><span class="line">       xxlJobScheduler.init();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 步入了init我们看到了各种helper类的启动操作。从注释中我们也可以看出这些操作分别是:</p><ol><li>初始化i18n。</li><li>JobTriggerPoolHelper这里面会完成一些线程池初始化的操作。</li><li>初始化注册监控相关，在这个操作里面，会每隔30秒进行一次注册表维护。</li><li>初始化失败处理监控器，对失败的情况进行监控，这里面会涉及一些失败发送邮箱或者重试的操作。</li><li>初始化任务完成器，将一些长时间没有响应的任务进行结束处理。</li><li>初始化报表统计，会进行一些成功失败的报表统计。</li><li>初始化调度器，执行任务调度处理。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// init i18n</span></span><br><span class="line">        initI18n();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// admin trigger pool start</span></span><br><span class="line">        JobTriggerPoolHelper.toStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// admin registry monitor run</span></span><br><span class="line">        JobRegistryHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// admin fail-monitor run</span></span><br><span class="line">        JobFailMonitorHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// admin lose-monitor run ( depend on JobTriggerPoolHelper )</span></span><br><span class="line">        JobCompleteHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// admin log report start</span></span><br><span class="line">        JobLogReportHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start-schedule  ( depend on JobTriggerPoolHelper )</span></span><br><span class="line">        JobScheduleHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin success.&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="初始化触发器"><a href="#初始化触发器" class="headerlink" title="初始化触发器"></a>初始化触发器</h2><p>我们先来看看JobTriggerPoolHelper.toStart();这段代码内部的逻辑，非常简单，无非就是初始化两个线程池，一个线程池是名为快触发线程池，另一个则是慢触发线程池。</p><p>从配置参数中我们可以看到这两个线程池的区别:</p><ol><li>快线程池的最大线程数默认为200，慢线程池为100。</li><li>快线程池最多容纳1000个任务，慢线程池默认容纳2000个任务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        fastTriggerPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax(),</span><br><span class="line">                <span class="number">60L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">1000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;xxl-job, admin JobTriggerPoolHelper-fastTriggerPool-&quot;</span> + r.hashCode());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        slowTriggerPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax(),</span><br><span class="line">                <span class="number">60L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;xxl-job, admin JobTriggerPoolHelper-slowTriggerPool-&quot;</span> + r.hashCode());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题来了，什么时候使用快触发线程池，什么时候使用慢触发线程池呢？</p></blockquote><p>从添加触发器的代码中可以看到如果一分钟执行超过10次的任务就会通过 slowTriggerPool 执行，反之就通过 fastTriggerPool 执行。</p><p>这也是设计者执行的巧妙所在，将那些可以快速执行的任务放到快线程池中快速执行完成。</p><p>而将那些耗时且频繁的任务放到慢线程池中堆着慢慢消化，合理分配避免某些快任务因为慢任务而导致执行频率低下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTrigger</span><span class="params">(......)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// choose thread pool</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">triggerPool_</span> <span class="operator">=</span> fastTriggerPool;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">jobTimeoutCount</span> <span class="operator">=</span> jobTimeoutCountMap.get(jobId);</span><br><span class="line">        <span class="keyword">if</span> (jobTimeoutCount!=<span class="literal">null</span> &amp;&amp; jobTimeoutCount.get() &gt; <span class="number">10</span>) &#123;      <span class="comment">// job-timeout 10 times in 1 min</span></span><br><span class="line">            triggerPool_ = slowTriggerPool;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// trigger</span></span><br><span class="line">        triggerPool_.execute(......)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="维护注册表信息"><a href="#维护注册表信息" class="headerlink" title="维护注册表信息"></a>维护注册表信息</h2><p>接下来就是 JobRegistryHelper 的start方法。</p><p>该方法首先会声明一个线程池，从语义上可以猜测出这个线程池是负责注册或者删除执行器的线程池。而且这个线程池的拒绝策略也很特殊，会将任务再次执行一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for registry or remove</span></span><br><span class="line">registryOrRemoveThreadPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line"><span class="number">2</span>,</span><br><span class="line"><span class="number">10</span>,</span><br><span class="line"><span class="number">30L</span>,</span><br><span class="line">TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2000</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;xxl-job, admin JobRegistryMonitorHelper-registryOrRemoveThreadPool-&quot;</span> + r.hashCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">r.run();</span><br><span class="line">logger.warn(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, registry or remove too fast, match threadpool rejected handler(run now).&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后续我们又会看到这样一个守护线程，它做的事情很简单:</p><ol><li>将超过90s的注册器删除。</li><li>从xxl_job_registry查找出更新时间大于现在+90s的执行器，即可能是最新注册的执行器，以appname作为key，相关地址作为value并将其存放到appAddressMap中。</li><li>从appAddressMap取出所有appName对应的地址,更新xxl_job_group执行器地址列表,组装成 addressListStr生成一个group并将其保存到xxl_job_group表中。</li><li>休眠30s后继续1-3的操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for monitor</span></span><br><span class="line">registryMonitorThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 从xxl_job_group找到所有的注册器的信息</span></span><br><span class="line">List&lt;XxlJobGroup&gt; groupList = XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().findByAddressType(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (groupList!=<span class="literal">null</span> &amp;&amp; !groupList.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove dead address (admin/executor)   将超过90s的注册器删除</span></span><br><span class="line">List&lt;Integer&gt; ids = XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().findDead(RegistryConfig.DEAD_TIMEOUT, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="keyword">if</span> (ids!=<span class="literal">null</span> &amp;&amp; ids.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().removeDead(ids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从xxl_job_registry查找出更新时间大于现在+90s的执行器，以appname作为key，相关地址作为value并将其存放到appAddressMap中</span></span><br><span class="line">HashMap&lt;String, List&lt;String&gt;&gt; appAddressMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">List&lt;XxlJobRegistry&gt; list = XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().findAll(RegistryConfig.DEAD_TIMEOUT, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (XxlJobRegistry item: list) &#123;</span><br><span class="line"><span class="keyword">if</span> (RegistryConfig.RegistType.EXECUTOR.name().equals(item.getRegistryGroup())) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">appname</span> <span class="operator">=</span> item.getRegistryKey();</span><br><span class="line">List&lt;String&gt; registryList = appAddressMap.get(appname);</span><br><span class="line"><span class="keyword">if</span> (registryList == <span class="literal">null</span>) &#123;</span><br><span class="line">registryList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!registryList.contains(item.getRegistryValue())) &#123;</span><br><span class="line">registryList.add(item.getRegistryValue());</span><br><span class="line">&#125;</span><br><span class="line">appAddressMap.put(appname, registryList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fresh group address</span></span><br><span class="line"><span class="keyword">for</span> (XxlJobGroup group: groupList) &#123;</span><br><span class="line"><span class="comment">//从appAddressMap取出所有appName对应的地址,更新xxl_job_group执行器地址列表,组装成 addressListStr</span></span><br><span class="line">List&lt;String&gt; registryList = appAddressMap.get(group.getAppname());</span><br><span class="line"><span class="type">String</span> <span class="variable">addressListStr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (registryList!=<span class="literal">null</span> &amp;&amp; !registryList.isEmpty()) &#123;</span><br><span class="line">Collections.sort(registryList);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">addressListSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (String item:registryList) &#123;</span><br><span class="line">addressListSB.append(item).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">addressListStr = addressListSB.toString();</span><br><span class="line">addressListStr = addressListStr.substring(<span class="number">0</span>, addressListStr.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基于addressListStr生成group</span></span><br><span class="line">group.setAddressList(addressListStr);</span><br><span class="line">group.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">//更新group更新时间</span></span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().update(group);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//休眠30s</span></span><br><span class="line">TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread stop&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="失败管理监视器"><a href="#失败管理监视器" class="headerlink" title="失败管理监视器"></a>失败管理监视器</h2><p>我们再来看看JobFailMonitorHelper的start代码。大体步骤为:</p><ol><li>从xxl_job_log找到执行失败的任务。</li><li>lock log 将xxl_job_log表中这些任务alarm_status设置为-1，意为上锁，如果没锁成功下次循环继续上锁。</li><li>从xxl_job_log获取这些job的id。</li><li>根据xxl_job_log的id从xxl_job_info获取到这个任务的信息。</li><li>查看xxl_job_info失败的任务重试次数是否大于0，大于0则继续重试执行。</li><li>对于失败的任务，判断info是否为空，如果不为空，则进行告警，然后基于乐观锁更新xxl_job_log告警信息。</li><li>休眠10s，继续1-6的操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">monitorThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// monitor</span></span><br><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//从xxl_job_log找到执行失败的任务</span></span><br><span class="line">List&lt;Long&gt; failLogIds = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findFailJobLogIds(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">if</span> (failLogIds!=<span class="literal">null</span> &amp;&amp; !failLogIds.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> failLogId: failLogIds) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lock log 将xxl_job_log表中这些任务alarm_status设置为-1，意为上锁，如果没锁成功下次循环继续</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lockRet</span> <span class="operator">=</span> XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (lockRet &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从xxl_job_log获取日志信息</span></span><br><span class="line"><span class="type">XxlJobLog</span> <span class="variable">log</span> <span class="operator">=</span> XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().load(failLogId);</span><br><span class="line"><span class="comment">//根据xxl_job_log的id从xxl_job_info获取到这个任务的信息</span></span><br><span class="line"><span class="type">XxlJobInfo</span> <span class="variable">info</span> <span class="operator">=</span> XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().loadById(log.getJobId());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、fail retry monitor 查看失败的任务重试次数是否大于0，大于0则继续重试</span></span><br><span class="line"><span class="keyword">if</span> (log.getExecutorFailRetryCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">JobTriggerPoolHelper.trigger(log.getJobId(), TriggerTypeEnum.RETRY, (log.getExecutorFailRetryCount()-<span class="number">1</span>), log.getExecutorShardingParam(), log.getExecutorParam(), <span class="literal">null</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">retryMsg</span> <span class="operator">=</span> <span class="string">&quot;&lt;br&gt;&lt;br&gt;&lt;span style=\&quot;color:#F39C12;\&quot; &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>+ I18nUtil.getString(<span class="string">&quot;jobconf_trigger_type_retry&quot;</span>) +<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; &lt;/span&gt;&lt;br&gt;&quot;</span>;</span><br><span class="line">log.setTriggerMsg(log.getTriggerMsg() + retryMsg);</span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateTriggerInfo(log);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、fail alarm monitor</span></span><br><span class="line"><span class="type">int</span> <span class="variable">newAlarmStatus</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 告警状态：0-默认、-1=锁定状态、1-无需告警、2-告警成功、3-告警失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果info不为空，则进行告警</span></span><br><span class="line"><span class="keyword">if</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">alarmResult</span> <span class="operator">=</span> XxlJobAdminConfig.getAdminConfig().getJobAlarmer().alarm(info, log);</span><br><span class="line">newAlarmStatus = alarmResult?<span class="number">2</span>:<span class="number">3</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">newAlarmStatus = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基于乐观锁更新xxl_job_log告警信息</span></span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, -<span class="number">1</span>, newAlarmStatus);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job fail monitor thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job fail monitor thread stop&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="任务结束处理器"><a href="#任务结束处理器" class="headerlink" title="任务结束处理器"></a>任务结束处理器</h2><p>我们继续前进查看 JobCompleteHelper 的源码。第一步也还是创建一个回调线程池，参数如下，可以看到拒绝策略任然是再次执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for callback</span></span><br><span class="line">callbackThreadPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line"><span class="number">2</span>,</span><br><span class="line"><span class="number">20</span>,</span><br><span class="line"><span class="number">30L</span>,</span><br><span class="line">TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">3000</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;xxl-job, admin JobLosedMonitorHelper-callbackThreadPool-&quot;</span> + r.hashCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">r.run();</span><br><span class="line">logger.warn(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, callback too fast, match threadpool rejected handler(run now).&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再往后查看代码，我们会发现一个守护线程monitorThread，查看它的核心工作代码如下，具体步骤为:</p><ol><li>找到运行中状态超过10min的任务id。</li><li>拿着这个任务id组装出一个log对象</li><li>基于这个表对象将任务结果通过updateHandleInfoAndFinish设置为结束。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// monitor</span></span><br><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 任务结果丢失处理：调度记录停留在 &quot;运行中&quot; 状态超过10min，且对应执行器心跳注册失败不在线，则将本地调度主动标记失败；</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">losedTime</span> <span class="operator">=</span> DateUtil.addMinutes(<span class="keyword">new</span> <span class="title class_">Date</span>(), -<span class="number">10</span>);</span><br><span class="line"><span class="comment">//找到丢失的任务id</span></span><br><span class="line">List&lt;Long&gt; losedJobIds  = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findLostJobIds(losedTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (losedJobIds!=<span class="literal">null</span> &amp;&amp; losedJobIds.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Long logId: losedJobIds) &#123;</span><br><span class="line"><span class="comment">//基于logId组装XxlJobLog</span></span><br><span class="line"><span class="type">XxlJobLog</span> <span class="variable">jobLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobLog</span>();</span><br><span class="line">jobLog.setId(logId);</span><br><span class="line"></span><br><span class="line">jobLog.setHandleTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">jobLog.setHandleCode(ReturnT.FAIL_CODE);</span><br><span class="line">jobLog.setHandleMsg( I18nUtil.getString(<span class="string">&quot;joblog_lost_fail&quot;</span>) );</span><br><span class="line"><span class="comment">//基于jobLog将任务结果结束</span></span><br><span class="line">XxlJobCompleter.updateHandleInfoAndFinish(jobLog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job fail monitor thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">60</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>再来看看updateHandleInfoAndFinish的代码，逻辑也很简单，根据log对象的code值组装对应的msg到xxlJobLog中，然后更新到xxl_job_log表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">updateHandleInfoAndFinish</span><span class="params">(XxlJobLog xxlJobLog)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据xxlJobLog任务的code得到对应的msg并将其设置到xxlJobLog中</span></span><br><span class="line">        finishJob(xxlJobLog);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// text最大64kb 避免长度过长</span></span><br><span class="line">        <span class="keyword">if</span> (xxlJobLog.getHandleMsg().length() &gt; <span class="number">15000</span>) &#123;</span><br><span class="line">            xxlJobLog.setHandleMsg( xxlJobLog.getHandleMsg().substring(<span class="number">0</span>, <span class="number">15000</span>) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新xxl_job_log中这个任务的信息</span></span><br><span class="line">        <span class="keyword">return</span> XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateHandleInfo(xxlJobLog);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="报表处理"><a href="#报表处理" class="headerlink" title="报表处理"></a>报表处理</h2><p>还记得我们登录xxl-job-admin时，哪个报表界面吗？这个页面的数据就是通过JobLogReportHelper进行处理的。对此，我们不妨打开源码一探究竟。</p><p>核心逻辑为:</p><ol><li>获取今天、昨天、前天的任务总数、正在运行数、成功数，得出统计信息更新到表中。</li><li>查看日志保留天数，如果到期则将过期日志删除。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 1、log-report refresh: refresh log report in 3 days</span></span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                          <span class="comment">// 获取Calendar都西昂</span></span><br><span class="line">                          <span class="type">Calendar</span> <span class="variable">itemDay</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">                          <span class="comment">//查看今天-i天时的数据，按照循环3次我们可以得出回查看今天、昨天、前天的数据</span></span><br><span class="line">                          itemDay.add(Calendar.DAY_OF_MONTH, -i);</span><br><span class="line">                          itemDay.set(Calendar.HOUR_OF_DAY, <span class="number">0</span>);</span><br><span class="line">                          itemDay.set(Calendar.MINUTE, <span class="number">0</span>);</span><br><span class="line">                          itemDay.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">                          itemDay.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                          <span class="type">Date</span> <span class="variable">todayFrom</span> <span class="operator">=</span> itemDay.getTime();</span><br><span class="line"></span><br><span class="line">                          itemDay.set(Calendar.HOUR_OF_DAY, <span class="number">23</span>);</span><br><span class="line">                          itemDay.set(Calendar.MINUTE, <span class="number">59</span>);</span><br><span class="line">                          itemDay.set(Calendar.SECOND, <span class="number">59</span>);</span><br><span class="line">                          itemDay.set(Calendar.MILLISECOND, <span class="number">999</span>);</span><br><span class="line"></span><br><span class="line">                          <span class="type">Date</span> <span class="variable">todayTo</span> <span class="operator">=</span> itemDay.getTime();</span><br><span class="line"></span><br><span class="line">                          <span class="comment">// 初始化一个xxlJobLogReport对象</span></span><br><span class="line">                          <span class="type">XxlJobLogReport</span> <span class="variable">xxlJobLogReport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobLogReport</span>();</span><br><span class="line">                          xxlJobLogReport.setTriggerDay(todayFrom);</span><br><span class="line">                          xxlJobLogReport.setRunningCount(<span class="number">0</span>);</span><br><span class="line">                          xxlJobLogReport.setSucCount(<span class="number">0</span>);</span><br><span class="line">                          xxlJobLogReport.setFailCount(<span class="number">0</span>);</span><br><span class="line">                          <span class="comment">//查出当天触发的任务数、正在运行数、成功数</span></span><br><span class="line">                          Map&lt;String, Object&gt; triggerCountMap = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findLogReport(todayFrom, todayTo);</span><br><span class="line">                          <span class="keyword">if</span> (triggerCountMap!=<span class="literal">null</span> &amp;&amp; triggerCountMap.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="type">int</span> <span class="variable">triggerDayCount</span> <span class="operator">=</span> triggerCountMap.containsKey(<span class="string">&quot;triggerDayCount&quot;</span>)?Integer.valueOf(String.valueOf(triggerCountMap.get(<span class="string">&quot;triggerDayCount&quot;</span>))):<span class="number">0</span>;</span><br><span class="line">                              <span class="type">int</span> <span class="variable">triggerDayCountRunning</span> <span class="operator">=</span> triggerCountMap.containsKey(<span class="string">&quot;triggerDayCountRunning&quot;</span>)?Integer.valueOf(String.valueOf(triggerCountMap.get(<span class="string">&quot;triggerDayCountRunning&quot;</span>))):<span class="number">0</span>;</span><br><span class="line">                              <span class="type">int</span> <span class="variable">triggerDayCountSuc</span> <span class="operator">=</span> triggerCountMap.containsKey(<span class="string">&quot;triggerDayCountSuc&quot;</span>)?Integer.valueOf(String.valueOf(triggerCountMap.get(<span class="string">&quot;triggerDayCountSuc&quot;</span>))):<span class="number">0</span>;</span><br><span class="line">                              <span class="type">int</span> <span class="variable">triggerDayCountFail</span> <span class="operator">=</span> triggerDayCount - triggerDayCountRunning - triggerDayCountSuc;</span><br><span class="line"></span><br><span class="line">                              xxlJobLogReport.setRunningCount(triggerDayCountRunning);</span><br><span class="line">                              xxlJobLogReport.setSucCount(triggerDayCountSuc);</span><br><span class="line">                              xxlJobLogReport.setFailCount(triggerDayCountFail);</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          <span class="comment">// 将上述结果更新到xxl_job_log_report表中</span></span><br><span class="line">                          <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> XxlJobAdminConfig.getAdminConfig().getXxlJobLogReportDao().update(xxlJobLogReport);</span><br><span class="line">                          <span class="keyword">if</span> (ret &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                              XxlJobAdminConfig.getAdminConfig().getXxlJobLogReportDao().save(xxlJobLogReport);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                          logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job log report thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 2、log-clean: switch open &amp; once each day</span></span><br><span class="line">                  <span class="comment">//设置了保留日志天数且日志保留了24小时，则进入if逻辑内部</span></span><br><span class="line">                  <span class="keyword">if</span> (XxlJobAdminConfig.getAdminConfig().getLogretentiondays()&gt;<span class="number">0</span></span><br><span class="line">                          &amp;&amp; System.currentTimeMillis() - lastCleanLogTime &gt; <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>) &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 通过日志保留天数算出清除log时间</span></span><br><span class="line">                      <span class="type">Calendar</span> <span class="variable">expiredDay</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">                      expiredDay.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span> * XxlJobAdminConfig.getAdminConfig().getLogretentiondays());</span><br><span class="line">                      expiredDay.set(Calendar.HOUR_OF_DAY, <span class="number">0</span>);</span><br><span class="line">                      expiredDay.set(Calendar.MINUTE, <span class="number">0</span>);</span><br><span class="line">                      expiredDay.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">                      expiredDay.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br><span class="line">                      <span class="type">Date</span> <span class="variable">clearBeforeTime</span> <span class="operator">=</span> expiredDay.getTime();</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// clean expired log</span></span><br><span class="line">                      List&lt;Long&gt; logIds = <span class="literal">null</span>;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          logIds = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findClearLogIds(<span class="number">0</span>, <span class="number">0</span>, clearBeforeTime, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">                          <span class="keyword">if</span> (logIds!=<span class="literal">null</span> &amp;&amp; logIds.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="comment">//删除过期日期数据</span></span><br><span class="line">                              XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().clearLog(logIds);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> (logIds!=<span class="literal">null</span> &amp;&amp; logIds.size()&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// update clean time</span></span><br><span class="line">                      lastCleanLogTime = System.currentTimeMillis();</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                          logger.error(e.getMessage(), e);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure><h2 id="任务调度处理器-重点"><a href="#任务调度处理器-重点" class="headerlink" title="任务调度处理器(重点)"></a>任务调度处理器(重点)</h2><p>接下来就是xxl-job工作调度的核心源码 JobScheduleHelper，我们还是分两段来查看这其中的逻辑。先来看看第一段逻辑，这段逻辑是由 scheduleThread 这个守护线程处理的，它的逻辑主要是负责安排任务的执行时间的:</p><ol><li>查出未来5s要执行的任务。</li><li>如果发现这个任务执行时间距离现在已经过期5s，则根据策略要么立即触发要么安排下次处理时间。</li><li>如果发现这个任务在过期时间小于5s要么现在立刻执行，要么安排下次一次执行时间，并将这个时间。</li><li>剩下的都是未过期即将被执行的任务则全部存到一个ringdata的线程安全map中，这个map以秒为key，所有这个时间点执行的任务构成的list为value。</li><li>将job的时间安排结果更新到xxl_job_info表中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// schedule thread</span></span><br><span class="line">        scheduleThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">5000</span> - System.currentTimeMillis()%<span class="number">1000</span> );</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!scheduleThreadToStop) &#123;</span><br><span class="line">                        logger.error(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success.&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//查出可以读取的任务数，这里为6000，也就是说这个线程一次可以处理6000个任务信息</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">preReadCount</span> <span class="operator">=</span> (XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax() + XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax()) * <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!scheduleThreadToStop) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Scan Job</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="type">Boolean</span> <span class="variable">connAutoCommit</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">preReadSuc</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        conn = XxlJobAdminConfig.getAdminConfig().getDataSource().getConnection();</span><br><span class="line">                        connAutoCommit = conn.getAutoCommit();</span><br><span class="line">                        conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">//上写锁，然后操作xxl_job_info表</span></span><br><span class="line">                        preparedStatement = conn.prepareStatement(  <span class="string">&quot;select * from xxl_job_lock where lock_name = &#x27;schedule_lock&#x27; for update&quot;</span> );</span><br><span class="line">                        preparedStatement.execute();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// tx start</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 1、查出未来5s要执行的任务</span></span><br><span class="line">                        <span class="type">long</span> <span class="variable">nowTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                        List&lt;XxlJobInfo&gt; scheduleList = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleJobQuery(nowTime + PRE_READ_MS, preReadCount);</span><br><span class="line">                        <span class="keyword">if</span> (scheduleList!=<span class="literal">null</span> &amp;&amp; scheduleList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 2、push time-ring</span></span><br><span class="line">                            <span class="keyword">for</span> (XxlJobInfo jobInfo: scheduleList) &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 如果现在时间大于任务下次处理时间+5s，即当前任务到期了还没执行则进入if逻辑</span></span><br><span class="line">                                <span class="keyword">if</span> (nowTime &gt; jobInfo.getTriggerNextTime() + PRE_READ_MS) &#123;</span><br><span class="line">                                    <span class="comment">// 2.1、trigger-expire &gt; 5s：pass &amp;&amp; make next-trigger-time</span></span><br><span class="line">                                    logger.warn(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule misfire, jobId = &quot;</span> + jobInfo.getId());</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 如果任务的处理策略是FIRE_ONCE_NOW则立刻执行</span></span><br><span class="line">                                    <span class="type">MisfireStrategyEnum</span> <span class="variable">misfireStrategyEnum</span> <span class="operator">=</span> MisfireStrategyEnum.match(jobInfo.getMisfireStrategy(), MisfireStrategyEnum.DO_NOTHING);</span><br><span class="line">                                    <span class="keyword">if</span> (MisfireStrategyEnum.FIRE_ONCE_NOW == misfireStrategyEnum) &#123;</span><br><span class="line">                                        <span class="comment">// FIRE_ONCE_NOW 》 trigger</span></span><br><span class="line">                                        JobTriggerPoolHelper.trigger(jobInfo.getId(), TriggerTypeEnum.MISFIRE, -<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                                        logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule push trigger : jobId = &quot;</span> + jobInfo.getId() );</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 如果任务不是要求FIRE_ONCE_NOW则更新一下下次处理的时间</span></span><br><span class="line">                                    refreshNextValidTime(jobInfo, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nowTime &gt; jobInfo.getTriggerNextTime()) &#123;<span class="comment">//过期时间小于5s</span></span><br><span class="line">                                    <span class="comment">// 2.2、trigger-expire &lt; 5s：direct-trigger &amp;&amp; make next-trigger-time</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 1、则提交到线程池中等待执行</span></span><br><span class="line">                                    JobTriggerPoolHelper.trigger(jobInfo.getId(), TriggerTypeEnum.CRON, -<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                                    logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule push trigger : jobId = &quot;</span> + jobInfo.getId() );</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 2、设置下一次处理时间</span></span><br><span class="line">                                    refreshNextValidTime(jobInfo, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//如果下次处理时间还在5s内再次更新一下时间</span></span><br><span class="line">                                    <span class="keyword">if</span> (jobInfo.getTriggerStatus()==<span class="number">1</span> &amp;&amp; nowTime + PRE_READ_MS &gt; jobInfo.getTriggerNextTime()) &#123;</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">// 1、make ring second</span></span><br><span class="line">                                        <span class="type">int</span> <span class="variable">ringSecond</span> <span class="operator">=</span> (<span class="type">int</span>)((jobInfo.getTriggerNextTime()/<span class="number">1000</span>)%<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">// 2、push time ring将任务存到ringData这个ConcurrentHashMap中</span></span><br><span class="line">                                        pushTimeRing(ringSecond, jobInfo.getId());</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">// 3、设置下次执行时间</span></span><br><span class="line">                                        refreshNextValidTime(jobInfo, <span class="keyword">new</span> <span class="title class_">Date</span>(jobInfo.getTriggerNextTime()));</span><br><span class="line"></span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">// 2.3、trigger-pre-read：time-ring trigger &amp;&amp; make next-trigger-time</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 1、make ring second</span></span><br><span class="line">                                    <span class="type">int</span> <span class="variable">ringSecond</span> <span class="operator">=</span> (<span class="type">int</span>)((jobInfo.getTriggerNextTime()/<span class="number">1000</span>)%<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 2、push time ring</span></span><br><span class="line">                                    pushTimeRing(ringSecond, jobInfo.getId());</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 3、fresh next</span></span><br><span class="line">                                    refreshNextValidTime(jobInfo, <span class="keyword">new</span> <span class="title class_">Date</span>(jobInfo.getTriggerNextTime()));</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 3、update trigger info</span></span><br><span class="line">                            <span class="keyword">for</span> (XxlJobInfo jobInfo: scheduleList) &#123;</span><br><span class="line">                                XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleUpdate(jobInfo);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            preReadSuc = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// tx stop</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!scheduleThreadToStop) &#123;</span><br><span class="line">                            logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#scheduleThread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">........</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>接下来就是任务调度的逻辑了，这里的处理也很简单，从上文创建的rindData取出当前时间前2s的任务，然后提交到线程池中执行，避免没必要的延迟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ringThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!ringThreadToStop) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// align second</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span> - System.currentTimeMillis() % <span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!ringThreadToStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 提前2s获取即将执行的任务存到ringItemData中</span></span><br><span class="line">                        List&lt;Integer&gt; ringItemData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">nowSecond</span> <span class="operator">=</span> Calendar.getInstance().get(Calendar.SECOND);   <span class="comment">// 避免处理耗时太长，跨过刻度，向前校验一个刻度；</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                            List&lt;Integer&gt; tmpData = ringData.remove( (nowSecond+<span class="number">60</span>-i)%<span class="number">60</span> );</span><br><span class="line">                            <span class="keyword">if</span> (tmpData != <span class="literal">null</span>) &#123;</span><br><span class="line">                                ringItemData.addAll(tmpData);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// ring trigger</span></span><br><span class="line">                        logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, time-ring beat : &quot;</span> + nowSecond + <span class="string">&quot; = &quot;</span> + Arrays.asList(ringItemData) );</span><br><span class="line">                        <span class="keyword">if</span> (ringItemData.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// ringItemData中的任务全部提交到线程池中执行</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> jobId: ringItemData) &#123;</span><br><span class="line">                                <span class="comment">// do trigger</span></span><br><span class="line">                                JobTriggerPoolHelper.trigger(jobId, TriggerTypeEnum.CRON, -<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// clear</span></span><br><span class="line">                            ringItemData.clear();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!ringThreadToStop) &#123;</span><br><span class="line">                            logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#ringThread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#ringThread stop&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h1 id="客户端启动流程"><a href="#客户端启动流程" class="headerlink" title="客户端启动流程"></a>客户端启动流程</h1><h2 id="基于配置类了解作业执行器"><a href="#基于配置类了解作业执行器" class="headerlink" title="基于配置类了解作业执行器"></a>基于配置类了解作业执行器</h2><p>现在来探寻一下 xxl-job 客户端，源码项目在：xxl-job-executor-sample-springboot</p><p>要想了解spring boot项目，我们都可以从项目中的配置类中看到核心类或者操作，于是我们找到了XxlJobConfig。</p><p>XxlJobConfig有个方法xxlJobExecutor，这就是创建执行器的方法，可以看到这里面所作的操作非常简单，你拿着配置文件中配置文件中的adminAddresses、appname、address等各种信息创建一个执行器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述appname、address等信息都是来自于配置文件中。</p><h2 id="基于XxlJobSpringExecutor了解客户端初始化流程"><a href="#基于XxlJobSpringExecutor了解客户端初始化流程" class="headerlink" title="基于XxlJobSpringExecutor了解客户端初始化流程"></a>基于XxlJobSpringExecutor了解客户端初始化流程</h2><p>从类图中我们不难看出它继承了和xxl-job相关的XxlJobExecutor以及一个和spring相关的SmartInitializingSingleton接口。</p><p><img src="https://qiniuyun.sharkchili.com/img202304271422230.png" alt="在这里插入图片描述"></p><h3 id="SmartInitializingSingleton的概念"><a href="#SmartInitializingSingleton的概念" class="headerlink" title="SmartInitializingSingleton的概念"></a>SmartInitializingSingleton的概念</h3><p>该接口也是SpringBoot的一个扩展点，它会在spring将所有的单例bean初始化之后，执行afterSingletonsInstantiated这个方法。所以查看我们的XxlJobSpringExecutor这个方法实现。</p><p>可以看到这个类主要做了以下三件事:</p><ol><li>初始化JobHandler的方法。</li><li>刷新GlueFactory这个工厂。</li><li>调用XxlJobExecutor的start方法。</li></ol><h2 id="基于afterSingletonsInstantiated了解执行器启动流程"><a href="#基于afterSingletonsInstantiated了解执行器启动流程" class="headerlink" title="基于afterSingletonsInstantiated了解执行器启动流程"></a>基于afterSingletonsInstantiated了解执行器启动流程</h2><h3 id="初始化所有-JobHandler-方法"><a href="#初始化所有-JobHandler-方法" class="headerlink" title="初始化所有 JobHandler 方法"></a>初始化所有 JobHandler 方法</h3><p>接下来我们开始了解每一个方法的具体逻辑，我们首先步入initJobHandlerMethodRepository(applicationContext);方法查看一下详情。</p><p>代码如下，具体含义笔者以及详细注释，整体来说分为3步:</p><ol><li>获取spring容器中所有bean。</li><li>过滤出懒加载的bean。</li><li>看看这个bean的方法是否包含XxlJob这个注解。</li><li>将带有XxlJob注解的方法注册到xxl-job-admin上。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initJobHandlerMethodRepository</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取容器中所有的bean</span></span><br><span class="line">        String[] beanDefinitionNames = applicationContext.getBeanNamesForType(Object.class, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拿到所有懒加载的bean</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Lazy</span> <span class="variable">onBean</span> <span class="operator">=</span> applicationContext.findAnnotationOnBean(beanDefinitionName, Lazy.class);</span><br><span class="line">            <span class="keyword">if</span> (onBean!=<span class="literal">null</span>)&#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;xxl-job annotation scan, skip @Lazy Bean:&#123;&#125;&quot;</span>, beanDefinitionName);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                bean = applicationContext.getBean(beanDefinitionName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查看这个懒加载的bean是否有XxlJob注解，如果有则继续往后走</span></span><br><span class="line">            Map&lt;Method, XxlJob&gt; annotatedMethods = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                annotatedMethods = MethodIntrospector.selectMethods(bean.getClass(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">MethodIntrospector</span>.MetadataLookup&lt;XxlJob&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> XxlJob <span class="title function_">inspect</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> AnnotatedElementUtils.findMergedAnnotation(method, XxlJob.class);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;xxl-job method-jobhandler resolve error for bean[&quot;</span> + beanDefinitionName + <span class="string">&quot;].&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (annotatedMethods==<span class="literal">null</span> || annotatedMethods.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成并将该处理器的方法注册到xxl-job-admin上</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Method, XxlJob&gt; methodXxlJobEntry : annotatedMethods.entrySet()) &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">executeMethod</span> <span class="operator">=</span> methodXxlJobEntry.getKey();</span><br><span class="line">                <span class="type">XxlJob</span> <span class="variable">xxlJob</span> <span class="operator">=</span> methodXxlJobEntry.getValue();</span><br><span class="line">                <span class="comment">// 注册xxl-job-admin上</span></span><br><span class="line">                registJobHandler(xxlJob, bean, executeMethod);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="刷新GlueFactory"><a href="#刷新GlueFactory" class="headerlink" title="刷新GlueFactory"></a>刷新GlueFactory</h3><p>我们继续查看refreshInstance方法，没有什么特殊逻辑，无非是将glueFactory 指向一个全新的工厂而已。最终代码会new SpringGlueFactory();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">refreshInstance</span><span class="params">(<span class="type">int</span> type)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">glueFactory = <span class="keyword">new</span> <span class="title class_">GlueFactory</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">glueFactory = <span class="keyword">new</span> <span class="title class_">SpringGlueFactory</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="了解XxlJobExecutor的start方法-重点"><a href="#了解XxlJobExecutor的start方法-重点" class="headerlink" title="了解XxlJobExecutor的start方法(重点)"></a>了解XxlJobExecutor的start方法(重点)</h3><p>终于我们来到的最核心的不妨，在XxlJobSpringExecutor的afterSingletonsInstantiated中调用了一个super.start();，这个super就是我们的XxlJobExecutor，具体逻辑如下。</p><p>可以看到它整体分为以下几个步骤:</p><ol><li>初始化日志文件存放路径。</li><li>初始化xxl-job-admin地址列表。</li><li>初始化过期日志文件清理线程。</li><li>初始化回调结果通知xxl-job-admin线程。</li><li>初始化 executor-server监听调度器的请求器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化日志路径</span></span><br><span class="line">        XxlJobFileAppender.initLogPath(logPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化admin地址列表</span></span><br><span class="line">        initAdminBizList(adminAddresses, accessToken);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化日志文件清理线程</span></span><br><span class="line">        JobLogFileCleanThread.getInstance().start(logRetentionDays);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化回调线程</span></span><br><span class="line">        TriggerCallbackThread.getInstance().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 executor-server监听调度器的请求器</span></span><br><span class="line">        initEmbedServer(address, ip, port, appname, accessToken);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="XxlJobExecutor的start方法流程详解"><a href="#XxlJobExecutor的start方法流程详解" class="headerlink" title="XxlJobExecutor的start方法流程详解"></a>XxlJobExecutor的start方法流程详解</h2><h3 id="初始化日志"><a href="#初始化日志" class="headerlink" title="初始化日志"></a>初始化日志</h3><p>首先是initLogPath方法，逻辑其实很简单就是通过配置文件获取路径然后进行拼接，最后设置到glueSrcPath 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">logBasePath</span> <span class="operator">=</span> <span class="string">&quot;/data/applogs/xxl-job/jobhandler&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">glueSrcPath</span> <span class="operator">=</span> logBasePath.concat(<span class="string">&quot;/gluesource&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initLogPath</span><span class="params">(String logPath)</span>&#123;</span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="keyword">if</span> (logPath!=<span class="literal">null</span> &amp;&amp; logPath.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">logBasePath = logPath;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mk base dir</span></span><br><span class="line"><span class="type">File</span> <span class="variable">logPathDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(logBasePath);</span><br><span class="line"><span class="keyword">if</span> (!logPathDir.exists()) &#123;</span><br><span class="line">logPathDir.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">logBasePath = logPathDir.getPath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// mk glue dir</span></span><br><span class="line"><span class="type">File</span> <span class="variable">glueBaseDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(logPathDir, <span class="string">&quot;gluesource&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!glueBaseDir.exists()) &#123;</span><br><span class="line">glueBaseDir.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">glueSrcPath = glueBaseDir.getPath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化-admin-地址"><a href="#初始化-admin-地址" class="headerlink" title="初始化 admin 地址"></a>初始化 admin 地址</h3><p>然后是initAdminBizList方法,逻辑也很简单，将我们的配置文件中配置的adminAddresses通过逗号进行切割，然后存放到adminBizList中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;AdminBiz&gt; adminBizList;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initAdminBizList</span><span class="params">(String adminAddresses, String accessToken)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="keyword">if</span> (adminAddresses!=<span class="literal">null</span> &amp;&amp; adminAddresses.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//adminAddresses以逗号切割遍历存到adminBizList中</span></span><br><span class="line">           <span class="keyword">for</span> (String address: adminAddresses.trim().split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (address!=<span class="literal">null</span> &amp;&amp; address.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="type">AdminBiz</span> <span class="variable">adminBiz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdminBizClient</span>(address.trim(), accessToken);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (adminBizList == <span class="literal">null</span>) &#123;</span><br><span class="line">                       adminBizList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;AdminBiz&gt;();</span><br><span class="line">                   &#125;</span><br><span class="line">                   adminBizList.add(adminBiz);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="清除过期日志"><a href="#清除过期日志" class="headerlink" title="清除过期日志"></a>清除过期日志</h3><p>该方法时JobLogFileCleanThread的start方法，逻辑比较长，我们分为两段来说</p><p>首先判断日志保留天数，这个logRetentionDays 的值是从配置文件中来的，如果发现小于3天则直接返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果日志保留天数小于3天直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (logRetentionDays &lt; <span class="number">3</span> ) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>然后这个方法创建了一个localThread线程，其run方法核心逻辑如下：</p><ol><li>得到所有文件位置。</li><li>算出今天的时间。</li><li>计算出这个文件的时间。</li><li>如果创建时间至今超过logRetentionDays (这里配置为30天)，则将通过递归的方式删除这些日志文件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 得到所有文件路径</span></span><br><span class="line">                        File[] childDirs = <span class="keyword">new</span> <span class="title class_">File</span>(XxlJobFileAppender.getLogPath()).listFiles();</span><br><span class="line">                        <span class="keyword">if</span> (childDirs!=<span class="literal">null</span> &amp;&amp; childDirs.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 算出今天的时间</span></span><br><span class="line">                            <span class="type">Calendar</span> <span class="variable">todayCal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">                            todayCal.set(Calendar.HOUR_OF_DAY,<span class="number">0</span>);</span><br><span class="line">                            todayCal.set(Calendar.MINUTE,<span class="number">0</span>);</span><br><span class="line">                            todayCal.set(Calendar.SECOND,<span class="number">0</span>);</span><br><span class="line">                            todayCal.set(Calendar.MILLISECOND,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="type">Date</span> <span class="variable">todayDate</span> <span class="operator">=</span> todayCal.getTime();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (File childFile: childDirs) &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// valid</span></span><br><span class="line">                                <span class="keyword">if</span> (!childFile.isDirectory()) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (childFile.getName().indexOf(<span class="string">&quot;-&quot;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 得到文件创建时间</span></span><br><span class="line">                                <span class="type">Date</span> <span class="variable">logFileCreateDate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">                                    logFileCreateDate = simpleDateFormat.parse(childFile.getName());</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                                    logger.error(e.getMessage(), e);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (logFileCreateDate == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//如果这个文件创建时间至今超过30天则直接递归删除文件及其子文件</span></span><br><span class="line">                                <span class="keyword">if</span> ((todayDate.getTime()-logFileCreateDate.getTime()) &gt;= logRetentionDays * (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>) ) &#123;</span><br><span class="line">                                    FileUtil.deleteRecursively(childFile);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.DAYS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><h3 id="初始化回调线程回调结果给admin"><a href="#初始化回调线程回调结果给admin" class="headerlink" title="初始化回调线程回调结果给admin"></a>初始化回调线程回调结果给admin</h3><p>继续查看start方法中TriggerCallbackThread的start，我们查看其run方法，它的主要作用是将当前任务的执行结果告诉给xxl-job-admin，步骤也很简单:</p><ol><li>从队列中取出一个任务的执行结果HandleCallbackParam。</li><li>将结果存到callbackParamList中。</li><li>调用doCallback将结果发送给xxl-job-admin。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!toStop)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//从callBackQueue获取到对应jobId的执行结果</span></span><br><span class="line">                        <span class="type">HandleCallbackParam</span> <span class="variable">callback</span> <span class="operator">=</span> getInstance().callBackQueue.take();</span><br><span class="line">                        <span class="keyword">if</span> (callback != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            </span><br><span class="line">                            List&lt;HandleCallbackParam&gt; callbackParamList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HandleCallbackParam&gt;();</span><br><span class="line">                            <span class="type">int</span> <span class="variable">drainToNum</span> <span class="operator">=</span> getInstance().callBackQueue.drainTo(callbackParamList);</span><br><span class="line">                            <span class="comment">//将回调结果存到callbackParamList</span></span><br><span class="line">                            callbackParamList.add(callback);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 将结果回调给xxl-job-admin</span></span><br><span class="line">                            <span class="keyword">if</span> (callbackParamList!=<span class="literal">null</span> &amp;&amp; callbackParamList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                                doCallback(callbackParamList);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>查看doCallback的实现细节，它的工作过程也很简单，遍历出对应的xxl-job实例，发送结果某一个发送失败，则遍历下一个实例继续发送，直到成功为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doCallback</span><span class="params">(List&lt;HandleCallbackParam&gt; callbackParamList)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">callbackRet</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 遍历xxl-job-admin服务所对应的对象adminBiz</span></span><br><span class="line">        <span class="keyword">for</span> (AdminBiz adminBiz: XxlJobExecutor.getAdminBizList()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//调用adminBiz的回调接口将结果发送给xxl-job-admin服务</span></span><br><span class="line">                ReturnT&lt;String&gt; callbackResult = adminBiz.callback(callbackParamList);</span><br><span class="line">                <span class="comment">//如果成功记录一个日志并退出循环，如果失败，则继续遍历其他实例发送回调结果</span></span><br><span class="line">                <span class="keyword">if</span> (callbackResult!=<span class="literal">null</span> &amp;&amp; ReturnT.SUCCESS_CODE == callbackResult.getCode()) &#123;</span><br><span class="line">                    callbackLog(callbackParamList, <span class="string">&quot;&lt;br&gt;----------- xxl-job job callback finish.&quot;</span>);</span><br><span class="line">                    callbackRet = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果回调失败，则打个日志</span></span><br><span class="line">                    callbackLog(callbackParamList, <span class="string">&quot;&lt;br&gt;----------- xxl-job job callback fail, callbackResult:&quot;</span> + callbackResult);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                callbackLog(callbackParamList, <span class="string">&quot;&lt;br&gt;----------- xxl-job job callback error, errorMsg:&quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!callbackRet) &#123;</span><br><span class="line">            appendFailCallbackFile(callbackParamList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="注册内嵌服务等待服务端调用-重点"><a href="#注册内嵌服务等待服务端调用-重点" class="headerlink" title="注册内嵌服务等待服务端调用(重点)"></a>注册内嵌服务等待服务端调用(重点)</h3><p>到了最关键的一步initEmbedServer(address, ip, port, appname, accessToken);，这一步就是可以确保我们的执行器可以收到调度器的关键所在。 它的工作流程就是组装端口等参数，通过netty的方式将服务开启并等待调度器的调用。现在不妨我们自顶向下查看一下它的实现细节。</p><p>从调用我们可以看到它的步骤也很清晰:</p><ol><li>获取端口号以及ip地址。于端口号和ip地址组装服务地址。</li><li>获取token。</li><li>基于上述所有参数调用embedServer的start启动内嵌服务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initEmbedServer</span><span class="params">(String address, String ip, <span class="type">int</span> port, String appname, String accessToken)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取端口号和ip地址</span></span><br><span class="line">        port = port&gt;<span class="number">0</span>?port: NetUtil.findAvailablePort(<span class="number">9999</span>);</span><br><span class="line">        ip = (ip!=<span class="literal">null</span>&amp;&amp;ip.trim().length()&gt;<span class="number">0</span>)?ip: IpUtil.getIp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于端口号和ip地址生成当前服务地址</span></span><br><span class="line">        <span class="keyword">if</span> (address==<span class="literal">null</span> || address.trim().length()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ip_port_address</span> <span class="operator">=</span> IpUtil.getIpPort(ip, port);   <span class="comment">// registry-address：default use address to registry , otherwise use ip:port if address is null</span></span><br><span class="line">            address = <span class="string">&quot;http://&#123;ip_port&#125;/&quot;</span>.replace(<span class="string">&quot;&#123;ip_port&#125;&quot;</span>, ip_port_address);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取token</span></span><br><span class="line">        <span class="keyword">if</span> (accessToken==<span class="literal">null</span> || accessToken.trim().length()==<span class="number">0</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job accessToken is empty. To ensure system security, please set the accessToken.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于上述服务初始化内嵌服务，并将其启动</span></span><br><span class="line">        embedServer = <span class="keyword">new</span> <span class="title class_">EmbedServer</span>();</span><br><span class="line">        embedServer.start(address, port, appname, accessToken);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>了解了整体流程之后，我们再来看看细节。即embedServer的start的具体实现。</p><p>我们步入start方法会看到一个名为thread的线程，代码比较长，我们分段来解读。首先它会创建两个NIO group。然后再创建一个业务线程池，初始为0，最大线程数为200，队列中可以容纳2000个任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">            <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">            <span class="type">ThreadPoolExecutor</span> <span class="variable">bizThreadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                    <span class="number">0</span>,</span><br><span class="line">                    <span class="number">200</span>,</span><br><span class="line">                    <span class="number">60L</span>,</span><br><span class="line">                    TimeUnit.SECONDS,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2000</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;xxl-job, EmbedServer bizThreadPool-&quot;</span> + r.hashCode());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;xxl-job, EmbedServer bizThreadPool is EXHAUSTED!&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure><p>基于上述的参数启动ServerBootstrap，并将配置文件中appName和当前应用地址信息作为参数，将服务注册到xxl-job-admin上。然后就是调用 future.channel().closeFuture().sync()等待调度器调用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ServerBootstrap</span></span><br><span class="line">                    <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">                    bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                            .channel(NioServerSocketChannel.class)</span><br><span class="line">                            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    channel.pipeline()</span><br><span class="line">                                            .addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">30</span> * <span class="number">3</span>, TimeUnit.SECONDS))  <span class="comment">// beat 3N, close if idle</span></span><br><span class="line">                                            .addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>())</span><br><span class="line">                                            .addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>))  <span class="comment">// merge request &amp; reponse to FULL</span></span><br><span class="line">                                            .addLast(<span class="keyword">new</span> <span class="title class_">EmbedHttpServerHandler</span>(executorBiz, accessToken, bizThreadPool));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">                            .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 绑定端口号</span></span><br><span class="line">                    <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(port).sync();</span><br><span class="line"></span><br><span class="line">                    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job remoting server start success, nettype = &#123;&#125;, port = &#123;&#125;&quot;</span>, EmbedServer.class, port);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 注册到xxl-job上</span></span><br><span class="line">                    startRegistry(appname, address);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 等待调用</span></span><br><span class="line">                    future.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure><p>上文提到一个注册服务到xxl-job-admin的操作，我们查看startRegistry源码，我们查看其内部源码也是基于一个线程的带有while循环的run方法来实现的，核心逻辑如下，很简单，获取xxl-job-admin实例，调用其注册方法将当前服务注册上去，如果成功就结束循环，如果失败就遍历其他实例继续尝试注册，这一点和上文的回调处理器工作流程差不多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RegistryParam</span> <span class="variable">registryParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryParam</span>(RegistryConfig.RegistType.EXECUTOR.name(), appname, address);</span><br><span class="line">                        <span class="comment">//遍历xxl-job-admin对象，注册当前服务，只要成功就结束循环</span></span><br><span class="line">                        <span class="keyword">for</span> (AdminBiz adminBiz: XxlJobExecutor.getAdminBizList()) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                ReturnT&lt;String&gt; registryResult = adminBiz.registry(registryParam);</span><br><span class="line">                                <span class="keyword">if</span> (registryResult!=<span class="literal">null</span> &amp;&amp; ReturnT.SUCCESS_CODE == registryResult.getCode()) &#123;</span><br><span class="line">                                    registryResult = ReturnT.SUCCESS;</span><br><span class="line">                                    logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job registry success, registryParam:&#123;&#125;, registryResult:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;registryParam, registryResult&#125;);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job registry fail, registryParam:&#123;&#125;, registryResult:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;registryParam, registryResult&#125;);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job registry error, registryParam:&#123;&#125;&quot;</span>, registryParam, e);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure><p>上述操作完成之后，线程会休眠30s，然后继续向xxl-job-admin注册当前服务信息，起到一个保持心跳的作用。自此我们的客户端启动流程就结束了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                           <span class="comment">//休眠30s之后继续注册，起到一个保持心跳的效果</span></span><br><span class="line">                           TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                           logger.warn(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, executor registry thread interrupted, error msg:&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure><h3 id="EmbedHttpServerHandler详解"><a href="#EmbedHttpServerHandler详解" class="headerlink" title="EmbedHttpServerHandler详解"></a>EmbedHttpServerHandler详解</h3><p>还记得我们上文注册内嵌服务时候的逻辑吗？这一步中它们组装了一个处理器，这个就是处理调度器请求的核心所在。</p><p><img src="https://qiniuyun.sharkchili.com/img202304271422498.png" alt="在这里插入图片描述"></p><p>我们不妨找到这个类，对其channelRead0方法打个断点。</p><p><img src="https://qiniuyun.sharkchili.com/img202304271422608.png" alt="在这里插入图片描述"></p><p>从断点参数中我们可以看到这个方法收到调取器的参数之后，会将其提交到业务线程中，调用process方法调用当前服务的方法完成请求。</p><p>自此，一次完整的job调度就完成了。</p><h1 id="编写任务自动注册组件"><a href="#编写任务自动注册组件" class="headerlink" title="编写任务自动注册组件"></a>编写任务自动注册组件</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>使用 xxl-job 时会存在一个问题，编写好任务后，虽然@XxlJob注解会将方法注册到xxl-job-admin，但是任务需要我们手动添加。此时，我们希望有这样一个工具，可以让我们只需一个注解即可将执行器和任务直接注册到xxl-job-admin上，这样我们只需在编码阶段写好任务将项目启动，就可以将任务注册到xxl-job-admin中。</p><p><img src="https://qiniuyun.sharkchili.com/img202304211256304.png" alt="在这里插入图片描述"></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>我们可以借由spring-boot自动装配机制，并定义一个注解，扫描容器中所有执行器和带有这个注解的任务，然后调用xxl-job的api将这些任务注册到xxl-job-admin中。</p><h2 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h2><p>在正式编写组件前，先引入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- xxl-job-core --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;xxl-job.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hutool.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先我们从xxl-job-admin中将这两个类拷过来。</p><p><img src="https://qiniuyun.sharkchili.com/img202304211256957.png" alt="在这里插入图片描述"></p><p>我们在web界面操作xxl-job-admin时发现所有操作都需要基于一个cookie，而这个cookie是需要登录才能得到的。所以我们要定义一个接口，后续将登录和获取cookie保存到内存的操作补充上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JobLoginService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录xxl-job-admin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取登录后的cookie</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getCookie</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理然后编写一个接口，定义所有关于执行器的bean的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JobGroupService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询执行器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;XxlJobGroup&gt; <span class="title function_">getJobGroup</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动注册执行器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">autoRegisterGroup</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精确查询执行器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">preciselyCheck</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文提到我们也需要将任务注册到xxl-job上，所以在这里我们也把这个接口定义上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JobInfoService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询xxl-job-admin上是否有这个任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobGroupId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executorHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;XxlJobInfo&gt; <span class="title function_">getJobInfo</span><span class="params">(Integer jobGroupId, String executorHandler)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加任务到xxl-job-admin上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xxlJobInfo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Integer <span class="title function_">addJobInfo</span><span class="params">(XxlJobInfo xxlJobInfo)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此所有我们需要的行为都有了，我们就需要开始将逻辑补充上了。首先是登录和获取cookie的方法。代码含义都详细注释了，读者可以自行查阅，这里简单说明一下登录进行的操作就是:</p><ol><li>调用xxl-job登录接口</li><li>成功后获取cookie</li><li>将cookie缓存到map中</li></ol><p>而获取cookie的方式也很简单，从map中取出来返回出去就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobLoginServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">JobLoginService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置文件获取的xxl-job地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置文件获取的登录用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从xxl-job获取的登录密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存cookie的密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; loginCookie = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用登录接口将XXL_JOB_LOGIN_IDENTITY缓存下来后续使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//调用登录接口</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> adminAddresses + <span class="string">&quot;/login&quot;</span>;</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .form(<span class="string">&quot;userName&quot;</span>, username)</span><br><span class="line">                .form(<span class="string">&quot;password&quot;</span>, password)</span><br><span class="line">                .execute();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取登录后的cookie</span></span><br><span class="line">        List&lt;HttpCookie&gt; cookies = response.getCookies();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//尝试获得XXL_JOB_LOGIN_IDENTITY</span></span><br><span class="line">        Optional&lt;HttpCookie&gt; cookieOpt = cookies.stream()</span><br><span class="line">                .filter(cookie -&gt; cookie.getName().equals(<span class="string">&quot;XXL_JOB_LOGIN_IDENTITY&quot;</span>))</span><br><span class="line">                .findFirst();</span><br><span class="line">        <span class="keyword">if</span> (!cookieOpt.isPresent()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;get xxl-job cookie error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果存在这个cookie则将其缓存起来</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cookieOpt.get().getValue();</span><br><span class="line">        loginCookie.put(<span class="string">&quot;XXL_JOB_LOGIN_IDENTITY&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试从内存中获取cookie，如果没有则尝试3次登录即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCookie</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cookieStr</span> <span class="operator">=</span> loginCookie.get(<span class="string">&quot;XXL_JOB_LOGIN_IDENTITY&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (cookieStr != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;XXL_JOB_LOGIN_IDENTITY=&quot;</span> + cookieStr;</span><br><span class="line">            &#125;</span><br><span class="line">            login();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;get xxl-job cookie error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是执行器注册的逻辑了，整体来说有两个方法，分别是精确查询执行器和注册执行器的方法，含义都详尽注释在代码上，读者可自行参阅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobGroupServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">JobGroupService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.title&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行器地址类型：0=自动注册、1=手动录入</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.addressType:0&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer addressType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行器地址列表，多地址逗号分隔(手动录入)</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.addressList:&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String addressList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobLoginService jobLoginService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精确查询执行器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preciselyCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//调用xxl-job模糊查询job的api</span></span><br><span class="line">        List&lt;XxlJobGroup&gt; jobGroup = getJobGroup();</span><br><span class="line">        <span class="comment">//精确匹配执行器名称</span></span><br><span class="line">        Optional&lt;XxlJobGroup&gt; has = jobGroup.stream()</span><br><span class="line">                .filter(xxlJobGroup -&gt; xxlJobGroup.getAppname().equals(appName)</span><br><span class="line">                        &amp;&amp; xxlJobGroup.getTitle().equals(title))</span><br><span class="line">                .findAny();</span><br><span class="line">        <span class="comment">//返回该执行器是否存在</span></span><br><span class="line">        <span class="keyword">return</span> has.isPresent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询执行器列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;XxlJobGroup&gt; <span class="title function_">getJobGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> adminAddresses + <span class="string">&quot;/jobgroup/pageList&quot;</span>;</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .form(<span class="string">&quot;appname&quot;</span>, appName)</span><br><span class="line">                .form(<span class="string">&quot;title&quot;</span>, title)</span><br><span class="line">                .cookie(jobLoginService.getCookie())</span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> response.body();</span><br><span class="line">        <span class="type">JSONArray</span> <span class="variable">array</span> <span class="operator">=</span> JSONUtil.parse(body).getByPath(<span class="string">&quot;data&quot;</span>, JSONArray.class);</span><br><span class="line">        List&lt;XxlJobGroup&gt; list = array.stream()</span><br><span class="line">                .map(o -&gt; JSONUtil.toBean((JSONObject) o, XxlJobGroup.class))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用xxl-job保存执行器的api，将执行器保存到xxl-job上</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">autoRegisterGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//组装请求地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> adminAddresses + <span class="string">&quot;/jobgroup/save&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//组装表单参数</span></span><br><span class="line">        <span class="type">HttpRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .form(<span class="string">&quot;appname&quot;</span>, appName)</span><br><span class="line">                .form(<span class="string">&quot;title&quot;</span>, title);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组装地址类型和注册地址</span></span><br><span class="line">        httpRequest.form(<span class="string">&quot;addressType&quot;</span>, addressType);</span><br><span class="line">        <span class="keyword">if</span> (addressType.equals(<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Strings.isBlank(addressList)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;手动录入模式下,执行器地址列表不能为空&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            httpRequest.form(<span class="string">&quot;addressList&quot;</span>, addressList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行请求，带上我们之前缓存的cookie</span></span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpRequest.cookie(jobLoginService.getCookie())</span><br><span class="line">                .execute();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">code</span> <span class="operator">=</span> JSONUtil.parse(response.body()).getByPath(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回200就说明注册成功</span></span><br><span class="line">        <span class="keyword">return</span> code.equals(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是任务注册的接口实现了，核心方法也是模糊查询任务列表和注册任务两个方法，读者参阅注释即可理解，这里不多赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobInfoServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">JobInfoService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//xxl-job地址</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobLoginService jobLoginService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模糊查询任务列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobGroupId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executorHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;XxlJobInfo&gt; <span class="title function_">getJobInfo</span><span class="params">(Integer jobGroupId, String executorHandler)</span> &#123;</span><br><span class="line">        <span class="comment">//组装查询url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> adminAddresses + <span class="string">&quot;/jobinfo/pageList&quot;</span>;</span><br><span class="line">        <span class="comment">//调用查询接口</span></span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .form(<span class="string">&quot;jobGroup&quot;</span>, jobGroupId)</span><br><span class="line">                .form(<span class="string">&quot;executorHandler&quot;</span>, executorHandler)</span><br><span class="line">                .form(<span class="string">&quot;triggerStatus&quot;</span>, -<span class="number">1</span>)</span><br><span class="line">                .cookie(jobLoginService.getCookie())</span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> response.body();</span><br><span class="line">        <span class="type">JSONArray</span> <span class="variable">array</span> <span class="operator">=</span> JSONUtil.parse(body).getByPath(<span class="string">&quot;data&quot;</span>, JSONArray.class);</span><br><span class="line">        List&lt;XxlJobInfo&gt; list = array.stream()</span><br><span class="line">                .map(o -&gt; JSONUtil.toBean((JSONObject) o, XxlJobInfo.class))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回任务列表</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个任务到任务列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xxlJobInfo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">addJobInfo</span><span class="params">(XxlJobInfo xxlJobInfo)</span> &#123;</span><br><span class="line">        <span class="comment">//组装查询url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> adminAddresses + <span class="string">&quot;/jobinfo/add&quot;</span>;</span><br><span class="line">        <span class="comment">//执行添加逻辑</span></span><br><span class="line">        Map&lt;String, Object&gt; paramMap = BeanUtil.beanToMap(xxlJobInfo);</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.post(url)</span><br><span class="line">                .form(paramMap)</span><br><span class="line">                .cookie(jobLoginService.getCookie())</span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理并返回结果</span></span><br><span class="line">        <span class="type">JSON</span> <span class="variable">json</span> <span class="operator">=</span> JSONUtil.parse(response.body());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">code</span> <span class="operator">=</span> json.getByPath(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (code.equals(<span class="number">200</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Convert.toInt(json.getByPath(<span class="string">&quot;content&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;add jobInfo error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此所有核心工作方法都完成了。我们就可以基于spring-boot的自动装配自动调用这些方法完成执行器和任务的注册。</p><p>首先我们定义一个注解，用于要注册到xxl-job的任务的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于实现任务自动注册</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> XxlRegister &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务执行的cron表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">cron</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务描述</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">jobDesc</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default jobDesc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务作者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">author</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default Author&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 默认为 ROUND 轮询方式</span></span><br><span class="line"><span class="comment">     * 可选： FIRST 第一个</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    String <span class="title function_">executorRouteStrategy</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;ROUND&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果是1则自动注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">triggerStatus</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们要编写一个XxlJobAutoRegister扫描容器中带有XxlJob、XxlRegister的方法，并通过xxl-job-admin的api将其注册上去。</p><p>代码逻辑很简单，通过ApplicationContextAware获取容器中的bean，然后基于ApplicationListener监听容器加载情况，在容器准备好提供服务时，做下面这几件事:</p><ol><li>通过ApplicationContextAware找到所有的bean</li><li>遍历bean，找到带有XxlJob的方法。</li><li>查看带有XxlJob的方法是否有XxlRegister，如果有则将其注册到xxl-job-admin</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobAutoRegister</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationReadyEvent&gt;,</span><br><span class="line">        ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobGroupService jobGroupService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobInfoService jobInfoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationReadyEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">//注册执行器</span></span><br><span class="line">        addJobGroup();</span><br><span class="line">        <span class="comment">//注册任务</span></span><br><span class="line">        addJobInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动注册执行器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addJobGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果存在执行器，则直接返回，说明已经注册过了</span></span><br><span class="line">        <span class="keyword">if</span> (jobGroupService.preciselyCheck())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//否则手动注册一下执行器</span></span><br><span class="line">        <span class="keyword">if</span> (jobGroupService.autoRegisterGroup())</span><br><span class="line">            log.info(<span class="string">&quot;auto register xxl-job group success!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将带有XxlRegister的注解的方法提交到xxl-job-admin中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addJobInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;XxlJobGroup&gt; jobGroups = jobGroupService.getJobGroup();</span><br><span class="line">        <span class="type">XxlJobGroup</span> <span class="variable">xxlJobGroup</span> <span class="operator">=</span> jobGroups.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//拿到所有的bean名称</span></span><br><span class="line">        String[] beanDefinitionNames = applicationContext.getBeanNamesForType(Object.class, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(beanDefinitionName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到这个bean中带有XxlJob的方法</span></span><br><span class="line">            Map&lt;Method, XxlJob&gt; methodWithXxlJob = MethodIntrospector.selectMethods(bean.getClass(),</span><br><span class="line">                    (MethodIntrospector.MetadataLookup&lt;XxlJob&gt;) method -&gt; AnnotatedElementUtils.findMergedAnnotation(method, XxlJob.class));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Method, XxlJob&gt; methodXxlJobEntry : methodWithXxlJob.entrySet()) &#123;</span><br><span class="line">                <span class="comment">//带有XxlJob的方法名</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">executeMethod</span> <span class="operator">=</span> methodXxlJobEntry.getKey();</span><br><span class="line">                <span class="comment">//XxlJob注解配置的值</span></span><br><span class="line">                <span class="type">XxlJob</span> <span class="variable">xxlJob</span> <span class="operator">=</span> methodXxlJobEntry.getValue();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果executeMethod带有XxlRegister注解</span></span><br><span class="line">                <span class="keyword">if</span> (executeMethod.isAnnotationPresent(XxlRegister.class)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    List&lt;XxlJobInfo&gt; jobInfo = jobInfoService.getJobInfo(xxlJobGroup.getId(), xxlJob.value());</span><br><span class="line">                    <span class="keyword">if</span> (!jobInfo.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">//因为是模糊查询，需要再判断一次</span></span><br><span class="line">                        Optional&lt;XxlJobInfo&gt; first = jobInfo.stream()</span><br><span class="line">                                .filter(xxlJobInfo -&gt; xxlJobInfo.getExecutorHandler().equals(xxlJob.value()))</span><br><span class="line">                                .findFirst();</span><br><span class="line">                        <span class="comment">//如果任务已经存在则不管了</span></span><br><span class="line">                        <span class="keyword">if</span> (first.isPresent())</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//创建任务并注册</span></span><br><span class="line">                    <span class="type">XxlRegister</span> <span class="variable">xxlRegister</span> <span class="operator">=</span> executeMethod.getAnnotation(XxlRegister.class);</span><br><span class="line">                    <span class="type">XxlJobInfo</span> <span class="variable">xxlJobInfo</span> <span class="operator">=</span> createXxlJobInfo(xxlJobGroup, xxlJob, xxlRegister);</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">jobInfoId</span> <span class="operator">=</span> jobInfoService.addJobInfo(xxlJobInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于XxlRegister封装成一个xxlJobInfo对象提交到xxl-job-admin中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xxlJobGroup</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xxlJob</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xxlRegister</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> XxlJobInfo <span class="title function_">createXxlJobInfo</span><span class="params">(XxlJobGroup xxlJobGroup, XxlJob xxlJob, XxlRegister xxlRegister)</span> &#123;</span><br><span class="line">        <span class="type">XxlJobInfo</span> <span class="variable">xxlJobInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobInfo</span>();</span><br><span class="line">        xxlJobInfo.setJobGroup(xxlJobGroup.getId());</span><br><span class="line">        xxlJobInfo.setJobDesc(xxlRegister.jobDesc());</span><br><span class="line">        xxlJobInfo.setAuthor(xxlRegister.author());</span><br><span class="line">        xxlJobInfo.setScheduleType(<span class="string">&quot;CRON&quot;</span>);</span><br><span class="line">        xxlJobInfo.setScheduleConf(xxlRegister.cron());</span><br><span class="line">        xxlJobInfo.setGlueType(<span class="string">&quot;BEAN&quot;</span>);</span><br><span class="line">        xxlJobInfo.setExecutorHandler(xxlJob.value());</span><br><span class="line">        xxlJobInfo.setExecutorRouteStrategy(xxlRegister.executorRouteStrategy());</span><br><span class="line">        xxlJobInfo.setMisfireStrategy(<span class="string">&quot;DO_NOTHING&quot;</span>);</span><br><span class="line">        xxlJobInfo.setExecutorBlockStrategy(<span class="string">&quot;SERIAL_EXECUTION&quot;</span>);</span><br><span class="line">        xxlJobInfo.setExecutorTimeout(<span class="number">0</span>);</span><br><span class="line">        xxlJobInfo.setExecutorFailRetryCount(<span class="number">0</span>);</span><br><span class="line">        xxlJobInfo.setGlueRemark(<span class="string">&quot;GLUE代码初始化&quot;</span>);</span><br><span class="line">        xxlJobInfo.setTriggerStatus(xxlRegister.triggerStatus());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xxlJobInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>自此我们的组件开发完成了，为了让上面的XxlJobAutoRegister，我们需要编写一个配置类XxlJobPlusConfig，他会扫描XxlJobAutoRegister的包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.xxl.job.plus.executor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobPlusConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写一个spring.factories，将XxlJobPlusConfig路径写入，确保其他引入该组件时会自动装配XxlJobAutoRegister将指定的xxl-job注册上去。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span></span><br><span class="line">  <span class="string">com.xxl.job.plus.executor.config.XxlJobPlusConfig</span></span><br></pre></td></tr></table></figure><h2 id="引入组件并进行测试"><a href="#引入组件并进行测试" class="headerlink" title="引入组件并进行测试"></a>引入组件并进行测试</h2><p>首先将上述组件打包，然后在需要使用这个组件的应用中引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.cn.hydra&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;xxljob-autoregister-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这里直接使用xxl源码自带的spring-boot项目。</p><p><img src="https://qiniuyun.sharkchili.com/img202304211256822.png" alt="在这里插入图片描述"></p><p>编写一个自定义的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(TestService.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XxlJob(value = &quot;testJob&quot;)</span></span><br><span class="line">    <span class="meta">@XxlRegister(cron = &quot;0 0 0 * * ? *&quot;,</span></span><br><span class="line"><span class="meta">            author = &quot;shark-chili&quot;,</span></span><br><span class="line"><span class="meta">            jobDesc = &quot;测试job&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJob</span><span class="params">()</span>&#123;</span><br><span class="line">       logger.info(<span class="string">&quot;testJob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@XxlJob(value = &quot;hello&quot;)</span></span><br><span class="line">    <span class="meta">@XxlRegister(cron = &quot;0 0 0 * * ? *&quot;,</span></span><br><span class="line"><span class="meta">            triggerStatus = 1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;hello this is shark-chili&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后新增如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增配置项，必须项</span></span><br><span class="line"><span class="comment"># admin用户名</span></span><br><span class="line"><span class="string">xxl.job.admin.username=admin</span></span><br><span class="line"><span class="comment"># admin 密码</span></span><br><span class="line"><span class="string">xxl.job.admin.password=123456</span></span><br><span class="line"><span class="comment"># 执行器名称</span></span><br><span class="line"><span class="string">xxl.job.executor.title=shark-chili</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增配置项，可选项</span></span><br><span class="line"><span class="comment"># 执行器地址类型：0=自动注册、1=手动录入，默认为0</span></span><br><span class="line"><span class="string">xxl.job.executor.addressType=0</span></span><br><span class="line"><span class="comment"># 在上面为1的情况下，手动录入执行器地址列表，多地址逗号分隔</span></span><br><span class="line"><span class="string">xxl.job.executor.addressList=http://127.0.0.1:9999</span></span><br></pre></td></tr></table></figure><p>最后将xxl-job-admin和xxl-job启动，打开xxl-job的管理页面，可以看到我们的任务都注册进来了。</p><p><img src="https://qiniuyun.sharkchili.com/img202304211256178.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> xxl-job </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步动态导出功能设计</title>
      <link href="/2024/02/06/%E5%BC%82%E6%AD%A5%E5%8A%A8%E6%80%81%E5%AF%BC%E5%87%BA%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/02/06/%E5%BC%82%E6%AD%A5%E5%8A%A8%E6%80%81%E5%AF%BC%E5%87%BA%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h1><p>想实现一个导出功能，可以很简单，也可以很复杂。简单做法，无脑用 EasyExcel + 注解，实现起来简便快捷。</p><p>easyexcel能大大减少占用内存的主要原因是：在解析Excel时没有将文件数据<code>一次性全部加载到内存中</code>，而是从磁盘上一行行读取数据，逐个解析。</p><p>但是如果想要指定导出字段呢？如果要一次性导出上百万条数据呢？</p><p>那可能会面临下面的问题：</p><ol><li>如果同步导数据，接口很容易超时。</li><li>如果把所有数据一次性装载到内存，很容易引起OOM。</li><li>数据量太大sql语句必定很慢。</li><li>相同商品编号的数据要放到一起。</li><li>如果走异步，如何通知用户导出结果？</li><li>如果excel文件太大，目标用户打不开怎么办？</li></ol><h1 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h1><p>要把导出这一功能异步，意味着需要有一张异步任务表来存储这些导出任务。</p><p>导入导出任务表如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `excel_import_process` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键id&#x27;</span>,</span><br><span class="line">  `import_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;导出名称&#x27;</span>,</span><br><span class="line">  `import_detail` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;导出详情&#x27;</span>,</span><br><span class="line">  `import_status` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;导出状态 1-处理中 2-处理完成 3-处理失败&#x27;</span>,</span><br><span class="line">  `error_file_url` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;错误文件链接&#x27;</span>,</span><br><span class="line">  `source_url` <span class="type">varchar</span>(<span class="number">1000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;源文件地址&#x27;</span>,</span><br><span class="line">  `import_total` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;导出成功数量&#x27;</span>,</span><br><span class="line">  `task_type` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;任务类型（1：导入 2：导出）&#x27;</span>,</span><br><span class="line">  `import_type` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;导入类型&#x27;</span>,</span><br><span class="line">  `status` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;数据状态 1-启用 2-停用&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;租户id&#x27;</span>,</span><br><span class="line">  `create_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建者&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新者&#x27;</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`) <span class="keyword">USING</span> BTREE COMMENT <span class="string">&#x27;租户ID&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;导出进度表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>一般来讲，导出接口会调用一个导出方法，简单的异步处理可以开启一个线程去实现导出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolManager.getInstance().execute(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">               export(fileName, exportParams, <span class="literal">null</span>, <span class="literal">null</span>, exportFieldList, <span class="literal">null</span>, importType, sysUser.getId(), sysUser.getTenantId(), excelImportProcess, getPayrollDetailsMap);</span><br><span class="line">           &#125;));</span><br></pre></td></tr></table></figure><p>完整的异步导出代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态字段，无法直接依赖注入</span></span><br><span class="line">        ExcelExportUtil.sysDictDataService = applicationContext.getBean(ISysDictDataService.class);</span><br><span class="line">        ExcelExportUtil.contextAwareExecutor = applicationContext.getBean(<span class="string">&quot;contextAwareExecutor&quot;</span>, ThreadPoolTaskExecutor.class);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exportDynamicExcel</span><span class="params">(List&lt;ExcelExportEntity&gt; exportFieldList, Class&lt;?&gt; serviceImpl, Method method, Object dto, String fileName, Integer importType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollUtil.isEmpty(exportFieldList)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;请选择需要导出的字段&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SysUser</span> <span class="variable">sysUser</span> <span class="operator">=</span> UserCacheUtils.getSysUser();</span><br><span class="line">        Class&lt;?&gt; exportClass = getMethodType(method);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; fieldNames = Arrays.stream(FieldUtils.getAllFields(exportClass)).map(Field::getName).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">for</span> (ExcelExportEntity excelExportEntity : exportFieldList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!fieldNames.contains((String) excelExportEntity.getKey())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;需要导出的字段不存在: &quot;</span> + (String) excelExportEntity.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExportParams</span> <span class="variable">exportParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportParams</span>();</span><br><span class="line">        <span class="type">ExportParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportParams</span>(fileName, fileName, ExcelType.XSSF);</span><br><span class="line"></span><br><span class="line">        contextAwareExecutor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="type">ExcelImportProcess</span> <span class="variable">excelImportProcess</span> <span class="operator">=</span> createExcelImportProcess(exportParams.getTitle(), sysUser.getTenantId(), importType, sysUser.getId());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cacheDict(exportClass);</span><br><span class="line">                export(fileName, exportParams, serviceImpl, dto, exportFieldList, method, importType, sysUser.getId(), sysUser.getTenantId(), excelImportProcess, <span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="type">String</span> <span class="variable">fullStackTrace</span> <span class="operator">=</span> ExceptionUtils.getFullStackTrace(e);</span><br><span class="line">                excelImportProcess.setImportStatus(ExcelProcessStatusEnum.PROCESS_FAILED.getCode());</span><br><span class="line">                excelImportProcess.setImportDetail(fullStackTrace.substring(<span class="number">0</span>, <span class="number">150</span>));</span><br><span class="line">                excelImportProcess.updateById();</span><br><span class="line">                log.error(<span class="string">&quot;导出发生错误: &#123;&#125;&quot;</span>, fullStackTrace);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p>我们调用的导出方法示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">export</span><span class="params">(String fileName, ExportParams exportParams, Class&lt;?&gt; excelExportTaskImpl, Object queryParams,</span></span><br><span class="line"><span class="params">                              List&lt;ExcelExportEntity&gt; excelExportEntityList, Method method, Integer importType, Integer userId,</span></span><br><span class="line"><span class="params">                              Long tenantId, ExcelImportProcess excelImportProcess, List&lt;Map&lt;String, Object&gt;&gt; dataMap)</span> &#123;</span><br><span class="line">       <span class="type">Field</span> <span class="variable">tenantIdField</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (!Objects.isNull(queryParams)) &#123;</span><br><span class="line">           tenantIdField = ReflectionUtils.findField(queryParams.getClass(), <span class="string">&quot;tenantId&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!Objects.isNull(tenantIdField)) &#123;</span><br><span class="line">           tenantIdField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">           ReflectionUtils.setField(tenantIdField, queryParams, tenantId);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Workbook workbook;</span><br><span class="line">       <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           stopWatch.start();</span><br><span class="line">           log.info(<span class="string">&quot;---开始执行excel导出---&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (Objects.isNull(dataMap)) &#123;</span><br><span class="line">               <span class="type">Object</span> <span class="variable">excelExportTask</span> <span class="operator">=</span> SpringUtils.getBean(excelExportTaskImpl);</span><br><span class="line">               workbook = cn.afterturn.easypoi.excel.ExcelExportUtil.exportBigExcel(exportParams, excelExportEntityList, (queryParam, page) -&gt; dataList(excelExportTask, method, excelImportProcess, queryParam, page), queryParams);  <span class="comment">// 导出-分页查询</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               excelImportProcess.setImportTotal(dataMap.size());</span><br><span class="line">               <span class="type">ExportParams</span> <span class="variable">exportParams2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExportParams</span>(<span class="literal">null</span>, fileName);</span><br><span class="line">               exportParams2.setType(ExcelType.XSSF);</span><br><span class="line">               workbook = cn.afterturn.easypoi.excel.ExcelExportUtil.exportExcel(exportParams2, excelExportEntityList, dataMap);</span><br><span class="line">           &#125;</span><br><span class="line">           downloadExcel(fileName, workbook, excelImportProcess);</span><br><span class="line">           stopWatch.stop();</span><br><span class="line">           log.info(<span class="string">&quot;---excel导出结束---, 成功导出:&#123;&#125;行, 总共耗时:&#123;&#125;秒, 导出记录id: &#123;&#125;&quot;</span>, excelImportProcess.getImportDetail(), stopWatch.getTotalTimeSeconds(), excelImportProcess.getId());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">fullStackTrace</span> <span class="operator">=</span> ExceptionUtils.getFullStackTrace(e);</span><br><span class="line">           excelImportProcess.setImportStatus(ExcelProcessStatusEnum.PROCESS_FAILED.getCode());</span><br><span class="line">           excelImportProcess.setImportDetail(fullStackTrace.substring(<span class="number">0</span>, <span class="number">150</span>));</span><br><span class="line">           excelImportProcess.updateById();</span><br><span class="line">           log.error(<span class="string">&quot;导出发生错误: &#123;&#125;&quot;</span>, fullStackTrace);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到，exportBigExcel 方法可以指定表头，只需要传入excelExportEntityList即可，其中的dataList方法为分页方法，在这里指定了分页和总数信息，通过反射+动态代理查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">dataList</span><span class="params">(Object excelExportTask, Method method, ExcelImportProcess excelImportProcess, Object queryParam, <span class="type">int</span> page)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(queryParam <span class="keyword">instanceof</span> PageParam)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;参数不是PageParam类型&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 设置分页和租户id信息</span></span><br><span class="line">      ((PageParam) queryParam).setPageNum(page);</span><br><span class="line">      ((PageParam) queryParam).setPageSize(sliceSize); <span class="comment">// 默认为 20000 条</span></span><br><span class="line">      log.info(<span class="string">&quot;pageNum: &#123;&#125;&quot;</span>, page);</span><br><span class="line">      List&lt;Object&gt; data = (List&lt;Object&gt;) ReflectionUtils.invokeMethod(method, excelExportTask, queryParam);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!Objects.isNull(data)) &#123;</span><br><span class="line">          data = serializeDataList(data);</span><br><span class="line">          <span class="type">Integer</span> <span class="variable">importTotal</span> <span class="operator">=</span> excelImportProcess.getImportTotal();</span><br><span class="line">          <span class="keyword">if</span> (Objects.isNull(importTotal)) &#123;</span><br><span class="line">              importTotal = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          excelImportProcess.setImportTotal(importTotal + data.size());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>exportBigExcel的遍历分页代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Workbook <span class="title function_">exportBigExcel</span><span class="params">(IExcelExportServer server, Object queryParams)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       List&lt;Object&gt; list = server</span><br><span class="line">               .selectListForExcelExport(queryParams, page++);</span><br><span class="line">       <span class="keyword">while</span> (list != <span class="literal">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           write(list);</span><br><span class="line">           list = server.selectListForExcelExport(queryParams, page++);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看到这里你肯定会有个疑问，都支持导出百万级数据了，这样随便把查询条件放到 while 里去循环查询，数据量越大，偏移量越多，不会有深分页问题吗？</p><p>但是再仔细看看，这个方法只传了个页数，实际上，它不关心你怎么分页的。深分页这个问题其实是需要自己在业务代码里解决，easypoi只负责我们告诉分页以后的数据。</p><h1 id="多个-sheet"><a href="#多个-sheet" class="headerlink" title="多个 sheet"></a>多个 sheet</h1><p>我们知道，excel对一个sheet存放的最大数据量，是有做限制的，一个sheet最多可以保存<code>1048576</code>行数据。否则在保存数据时会直接报错：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">invalid</span> <span class="string">row</span> <span class="string">number</span> <span class="string">(1048576)</span> <span class="string">outside</span> <span class="string">allowable</span> <span class="string">range</span> <span class="string">(0..1048575)</span></span><br></pre></td></tr></table></figure><p>如果你想导出一百万以上的数据，excel的一个sheet肯定是存放不下的，因此我们需要把数据保存到多个sheet中。</p><p>之前说过，我们一般是通过<code>limit</code>语句来实现分页查询功能的，其中的pagetStart参数，是通过pageNo和pageSize动态计算出来的。如果只有一个sheet可以这么玩，但如果有多个sheet就会有问题。因此，我们需要重新计算<code>limit</code>的起始位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExcelWriter</span> <span class="variable">excelWriter</span> <span class="operator">=</span> EasyExcelFactory.write(out).build();</span><br><span class="line"><span class="type">int</span> <span class="variable">totalPage</span> <span class="operator">=</span> searchUserTotalPage(searchModel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(totalPage &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   Page&lt;User&gt; page = Page.create(searchModel);</span><br><span class="line">   <span class="type">int</span> <span class="variable">sheet</span> <span class="operator">=</span> (totalPage % maxSheetCount == <span class="number">0</span>) ? totalPage / maxSheetCount: (totalPage / maxSheetCount) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sheet;i++) &#123;</span><br><span class="line">      <span class="type">WriterSheet</span> <span class="variable">writeSheet</span> <span class="operator">=</span> buildSheet(i,<span class="string">&quot;sheet&quot;</span>+i);</span><br><span class="line">      <span class="type">int</span> <span class="variable">startPageNo</span> <span class="operator">=</span> i*(maxSheetCount/pageSize)+<span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">endPageNo</span> <span class="operator">=</span> (i+<span class="number">1</span>)*(maxSheetCount/pageSize);</span><br><span class="line">      <span class="keyword">while</span>(page.getPageNo()&gt;=startPageNo &amp;&amp; page.getPageNo()&lt;=endPageNo) &#123;</span><br><span class="line">        page = searchUser(searchModel);</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isEmpty(page.getList())) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        excelWriter.write(page.getList(),writeSheet);</span><br><span class="line">        page.setPageNo(page.getPageNo()+<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="流式查询"><a href="#流式查询" class="headerlink" title="流式查询"></a>流式查询</h1><p>可以使用MapReduce思想并利用流式API来处理</p><p>mybatis有提供cursor流式接口，然后就不用数据的join和order by那些耗性能的操作了，流式1 条条的取出数据在内存中去关联和排序，最终组合数据写到一个文档里面</p><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>由于现在我们导出excel数据的方案改成了<code>异步</code>，所以没法直接将excel文件，同步返回给用户。</p><p>因此我们需要先将excel文件存放到一个地方，当用户有需要时，可以访问到。</p><p>这时，我们可以直接将文件上传到<code>COS</code>文件服务器上。</p><p>所以你会发现，我们在异步任务表的设计上添加上了文件链接地址（细节！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">downloadExcel</span><span class="params">(String fileName, Workbook workbook, ExcelImportProcess excelImportProcess)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    workbook.write(outputStream);</span><br><span class="line">    fileName = fileName + ToolUtil.serialNumber();</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> FileUploadUtil.upload(outputStream.toByteArray(), fileName + <span class="string">&quot;.xlsx&quot;</span>, FileUploadConstant.EXPORT);  <span class="comment">// 上传到 cos</span></span><br><span class="line">    excelImportProcess.setSourceUrl(url);</span><br><span class="line"></span><br><span class="line">    excelImportProcess.setImportName(fileName);</span><br><span class="line">    excelImportProcess.setImportDetail(<span class="string">&quot;成功导出&quot;</span> + excelImportProcess.getImportTotal() + <span class="string">&quot;条&quot;</span>);</span><br><span class="line">    excelImportProcess.setImportStatus(ExcelProcessStatusEnum.PROCESS_COMPLETE.getCode());</span><br><span class="line">    excelImportProcess.updateById();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="功能优化"><a href="#功能优化" class="headerlink" title="功能优化"></a>功能优化</h1><p>写过一些 crud 代码就清楚，导出方法一般和查询的接口一样，需要在导出前调用查询的方法把 List 查出来，然后再进行后续的导出操作，把文件输出流传给前端。</p><p>但是如果需要导出一些带有字典值的字段呢？查询接口一般都是把表里的枚举值查出来，前端再通过查询字典表把这些枚举值替换成对应的中文字段。但是导出就没办法通过前端来转换了，这种转换字典的操作只能让后端做。</p><p>但是更加高级的做法可以使用注解，只需要在返回的VO里给某些需要转换的字段上加一个注解，就可以省去繁琐的替换操作了。优雅，太优雅了。</p><p>导出时检测字典类型的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cacheDict</span><span class="params">(Class&lt;?&gt; exportClass)</span> &#123;</span><br><span class="line">       List&lt;String&gt; dictTypeList = Lists.newArrayList();</span><br><span class="line">       <span class="keyword">for</span> (Field field : FieldUtils.getAllFields(exportClass)) &#123;</span><br><span class="line">           <span class="type">DictCode</span> <span class="variable">dictCode</span> <span class="operator">=</span> field.getAnnotation(DictCode.class);</span><br><span class="line">           <span class="keyword">if</span> (ToolUtil.isNotEmpty(dictCode)) &#123;</span><br><span class="line">               <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> dictCode.type();</span><br><span class="line">               <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> dictCode.value();</span><br><span class="line">               <span class="keyword">if</span> (ToolUtil.isNotEmpty(value) &amp;&amp; <span class="string">&quot;dict&quot;</span>.equals(type)) &#123;</span><br><span class="line">                   dictTypeList.add(value);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Map&lt;String, Map&lt;String, String&gt;&gt; dictMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (ToolUtil.isNotEmpty(dictTypeList)) &#123;</span><br><span class="line">           dictMap = sysDictDataService.selectEmpDictData(dictTypeList);</span><br><span class="line">       &#125;</span><br><span class="line">       RedisUtil.hmSet(<span class="string">&quot;sys:dict:&quot;</span>, dictMap);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过查询字典表，替换掉字典键值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Map&lt;String, Map&lt;String, String&gt;&gt; <span class="title function_">selectEmpDictData</span><span class="params">(List&lt;String&gt; dictTypeList)</span> &#123;</span><br><span class="line">       <span class="type">Long</span> <span class="variable">tenantId</span> <span class="operator">=</span> UserCacheUtils.getByTenantId();</span><br><span class="line">       List&lt;SysDictDataVO&gt; list = dictDataMapper.selectEmpDictData(dictTypeList, tenantId);</span><br><span class="line">       <span class="keyword">return</span> list.stream().collect(Collectors.groupingBy(SysDictDataVO::getDictType, TreeMap::<span class="keyword">new</span>, Collectors.toMap(SysDictDataVO::getDictValue, SysDictDataVO::getDictLabel, (existing, replacement) -&gt; existing, <span class="comment">// 如果遇到相同的键，保留现有的</span></span><br><span class="line">               LinkedHashMap::<span class="keyword">new</span>)));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 场景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 场景设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security的使用</title>
      <link href="/2024/01/25/SpringSecurity%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/01/25/SpringSecurity%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>基本上，在所有的开发的系统中，都必须做认证(authentication)和授权(authorization)，以保证系统的安全性。</p><ul><li>认证是确认声明者的本身身份，其作为授权的上游衔接而存在</li><li>鉴权是对声明者所声明的真实性进行确认的过程，其作为授权的下游衔接而存在</li></ul><p>Spring Security 是一个功能强大且高度可定制的身份验证和访问控制框架。它是用于保护基于 Spring 的应用程序。</p><h1 id="认证链路"><a href="#认证链路" class="headerlink" title="认证链路"></a>认证链路</h1><p>1 用户名和密码被过滤器获取到，封装成<code>Authentication</code>,通常情况下是<code>UsernamePasswordAuthenticationToken</code>这个实现类。</p><p>2 <code>AuthenticationManager</code> 身份管理器负责验证这个<code>Authentication</code></p><p>3 认证成功后，<code>AuthenticationManager</code>身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）<code>Authentication</code>实例。</p><p>4 <code>SecurityContextHolder</code>安全上下文容器将第3步填充了信息的<code>Authentication</code>，通过SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。</p><p><img src="https://i0.hdslb.com/bfs/article/88a3aba0385efc8a25fbb26638fabc16171301454.png" alt="image-20240208155803862"></p><p><img src="http://kirito.iocoder.cn/2011121410543010.jpg" alt="http://kirito.iocoder.cn/2011121410543010.jpg"></p><h2 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h2><p>AuthenticationManager（接口）是认证相关的核心接口，也是发起认证的出发点。AuthenticationManager一般不直接认证，AuthenticationManager接口的常用实现类<code>ProviderManager</code> 内部会维护一个<code>List&lt;AuthenticationProvider&gt;</code>列表，存放多种认证方式，实际上这是委托者模式的应用（Delegate）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderManager</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationManager</span>, MessageSourceAware,</span><br><span class="line">InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护一个AuthenticationProvider列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AuthenticationProvider&gt; providers = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line">          <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">       Class&lt;? <span class="keyword">extends</span> <span class="title class_">Authentication</span>&gt; toTest = authentication.getClass();</span><br><span class="line">       <span class="type">AuthenticationException</span> <span class="variable">lastException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Authentication</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 依次认证</span></span><br><span class="line">       <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">             result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                copyDetails(authentication, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">             lastException = e;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果有Authentication信息，则直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">&amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">               <span class="comment">//移除密码</span></span><br><span class="line">((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">&#125;</span><br><span class="line">             <span class="comment">//发布登录成功事件</span></span><br><span class="line">eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">       <span class="comment">//执行到此，说明没有认证成功，包装异常信息</span></span><br><span class="line">       <span class="keyword">if</span> (lastException == <span class="literal">null</span>) &#123;</span><br><span class="line">          lastException = <span class="keyword">new</span> <span class="title class_">ProviderNotFoundException</span>(messages.getMessage(</span><br><span class="line">                <span class="string">&quot;ProviderManager.providerNotFound&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; toTest.getName() &#125;,</span><br><span class="line">                <span class="string">&quot;No AuthenticationProvider found for &#123;0&#125;&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       prepareException(lastException, authentication);</span><br><span class="line">       <span class="keyword">throw</span> lastException;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ProviderManager</code> 中的List，会依照次序去认证，认证成功则立即返回，若认证失败则返回null，下一个AuthenticationProvider会继续尝试认证，如果所有认证器都无法认证成功，则<code>ProviderManager</code> 会抛出一个ProviderNotFoundException异常。</p><p>DaoAuthenticationProvider：它获取用户提交的用户名和密码，比对其正确性，如果正确，返回一个数据库中的用户信息（假设用户信息被保存在数据库中）。</p><h1 id="核心配置解读"><a href="#核心配置解读" class="headerlink" title="核心配置解读"></a>核心配置解读</h1><h2 id="WebSecurityConfigurerAdapter"><a href="#WebSecurityConfigurerAdapter" class="headerlink" title="WebSecurityConfigurerAdapter"></a>WebSecurityConfigurerAdapter</h2><p>拿 ruoyi 的 SecurityConfig 举例，它继承了 WebSecurityConfigurerAdapter。</p><p>适配器模式在spring中被广泛的使用，在配置中使用Adapter的好处便是，我们可以选择性的配置想要修改的那一部分配置，而不用覆盖其他不相关的配置。WebSecurityConfigurerAdapter中我们可以选择自己想要修改的内容，来进行重写，而其提供了三个configure重载方法。</p><ul><li>configure(HttpSecurity)</li><li>configure(WebSecurity)</li><li>configure(AuthenticationManagerBuilder)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring security配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ruoyi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义用户认证逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证失败处理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationEntryPointImpl unauthorizedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退出处理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogoutSuccessHandlerImpl logoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * token认证过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationTokenFilter authenticationTokenFilter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跨域过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CorsFilter corsFilter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许匿名访问的地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PermitAllUrlProperties permitAllUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解决 无法直接注入 AuthenticationManager</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * anyRequest          |   匹配所有请求路径</span></span><br><span class="line"><span class="comment">     * access              |   SpringEl表达式结果为true时可以访问</span></span><br><span class="line"><span class="comment">     * anonymous           |   匿名可以访问</span></span><br><span class="line"><span class="comment">     * denyAll             |   用户不能访问</span></span><br><span class="line"><span class="comment">     * fullyAuthenticated  |   用户完全认证可以访问（非remember-me下自动登录）</span></span><br><span class="line"><span class="comment">     * hasAnyAuthority     |   如果有参数，参数表示权限，则其中任何一个权限可以访问</span></span><br><span class="line"><span class="comment">     * hasAnyRole          |   如果有参数，参数表示角色，则其中任何一个角色可以访问</span></span><br><span class="line"><span class="comment">     * hasAuthority        |   如果有参数，参数表示权限，则其权限可以访问</span></span><br><span class="line"><span class="comment">     * hasIpAddress        |   如果有参数，参数表示IP地址，如果用户IP和参数匹配，则可以访问</span></span><br><span class="line"><span class="comment">     * hasRole             |   如果有参数，参数表示角色，则其角色可以访问</span></span><br><span class="line"><span class="comment">     * permitAll           |   用户可以任意访问</span></span><br><span class="line"><span class="comment">     * rememberMe          |   允许通过remember-me登录的用户访问</span></span><br><span class="line"><span class="comment">     * authenticated       |   用户登录后可访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity httpSecurity)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注解标记允许匿名访问的url</span></span><br><span class="line">        ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.<span class="type">ExpressionInterceptUrlRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> httpSecurity.authorizeRequests();</span><br><span class="line">        permitAllUrl.getUrls().forEach(url -&gt; registry.antMatchers(url).permitAll());</span><br><span class="line"></span><br><span class="line">        httpSecurity</span><br><span class="line">                <span class="comment">// CSRF禁用，因为不使用session</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">// 禁用HTTP响应标头</span></span><br><span class="line">                .headers().cacheControl().disable().and()</span><br><span class="line">                <span class="comment">// 认证失败处理类</span></span><br><span class="line">                .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and()</span><br><span class="line">                <span class="comment">// 基于token，所以不需要session</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                <span class="comment">// 过滤请求</span></span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 对于登录login 注册register 验证码captchaImage 允许匿名访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/captchaImage&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 静态资源，可匿名访问</span></span><br><span class="line">                .antMatchers(HttpMethod.GET, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;/*.html&quot;</span>, <span class="string">&quot;/**/*.html&quot;</span>, <span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>, <span class="string">&quot;/profile/**&quot;</span>).permitAll()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/swagger-ui.html&quot;</span>, <span class="string">&quot;/swagger-resources/**&quot;</span>, <span class="string">&quot;/webjars/**&quot;</span>, <span class="string">&quot;/*/api-docs&quot;</span>, <span class="string">&quot;/druid/**&quot;</span>).permitAll()</span><br><span class="line">.antMatchers(<span class="string">&quot;/test/*&quot;</span>,<span class="string">&quot;/policy/*&quot;</span>,<span class="string">&quot;/type/*&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .headers().frameOptions().disable();</span><br><span class="line">        <span class="comment">// 添加Logout filter</span></span><br><span class="line">        httpSecurity.logout().logoutUrl(<span class="string">&quot;/logout&quot;</span>).logoutSuccessHandler(logoutSuccessHandler);</span><br><span class="line">        <span class="comment">// 添加JWT filter</span></span><br><span class="line">        httpSecurity.addFilterBefore(authenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        <span class="comment">// 添加CORS filter</span></span><br><span class="line">        httpSecurity.addFilterBefore(corsFilter, JwtAuthenticationTokenFilter.class);</span><br><span class="line">        httpSecurity.addFilterBefore(corsFilter, LogoutFilter.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 强散列哈希加密实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">bCryptPasswordEncoder</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份认证接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HttpSecurity常用配置"><a href="#HttpSecurity常用配置" class="headerlink" title="HttpSecurity常用配置"></a>HttpSecurity常用配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomWebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/resources/**&quot;</span>, <span class="string">&quot;/signup&quot;</span>, <span class="string">&quot;/about&quot;</span>).permitAll()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/db/**&quot;</span>).access(<span class="string">&quot;hasRole(&#x27;ADMIN&#x27;) and hasRole(&#x27;DBA&#x27;)&quot;</span>)</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">                .usernameParameter(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .failureForwardUrl(<span class="string">&quot;/login?error&quot;</span>)</span><br><span class="line">                .loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">            .logout()</span><br><span class="line">                .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">                .logoutSuccessUrl(<span class="string">&quot;/index&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">            .httpBasic()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是一个使用Java Configuration配置HttpSecurity的典型配置，其中http作为根开始配置，每一个and()对应了一个模块的配置（等同于xml配置中的结束标签），并且and()返回了HttpSecurity本身，于是可以连续进行配置。他们配置的含义也非常容易通过变量本身来推测，</p><ul><li>authorizeRequests()配置路径拦截，表明路径访问所对应的权限，角色，认证信息。</li><li>formLogin()对应表单认证相关的配置</li><li>logout()对应了注销相关的配置</li><li>httpBasic()可以配置basic登录</li><li>etc</li></ul><h3 id="WebSecurity常用配置"><a href="#WebSecurity常用配置" class="headerlink" title="WebSecurity常用配置"></a>WebSecurity常用配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        web</span><br><span class="line">            .ignoring()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/resources/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AuthenticationManagerBuilder"><a href="#AuthenticationManagerBuilder" class="headerlink" title="AuthenticationManagerBuilder"></a>AuthenticationManagerBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth</span><br><span class="line">            .inMemoryAuthentication()</span><br><span class="line">            .withUser(<span class="string">&quot;admin&quot;</span>).password(<span class="string">&quot;admin&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在WebSecurityConfigurerAdapter中进行认证相关的配置，可以使用configure(AuthenticationManagerBuilder auth)暴露一个AuthenticationManager的建造器：AuthenticationManagerBuilder 。如上所示，我们便完成了内存中用户的配置。</p><p>除了以上的示例代码，还有另外一种配置方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureGlobal</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth</span><br><span class="line">            .inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="string">&quot;admin&quot;</span>).password(<span class="string">&quot;admin&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的应用只有唯一一个WebSecurityConfigurerAdapter，那么他们之间的差距可以被忽略，从方法名可以看出两者的区别：</p><ul><li>使用@Autowired注入的AuthenticationManagerBuilder是全局的身份认证器，作用域可以跨越多个WebSecurityConfigurerAdapter，以及影响到基于Method的安全控制；</li><li>而 <code>protected configure()</code>的方式则类似于一个匿名内部类，它的作用域局限于一个WebSecurityConfigurerAdapter内部。</li></ul><h1 id="授权链路"><a href="#授权链路" class="headerlink" title="授权链路"></a>授权链路</h1><p><img src="https://i0.hdslb.com/bfs/article/4a5465473ec1db95c8fd8cc85ecf18a2171301454.png" alt="image-20240208154120807"></p><h2 id="UsernamePasswordAuthenticationFilter"><a href="#UsernamePasswordAuthenticationFilter" class="headerlink" title="UsernamePasswordAuthenticationFilter"></a>UsernamePasswordAuthenticationFilter</h2><p>整个调用流程是，先调用其父类 AbstractAuthenticationProcessingFilter.doFilter() 方法，然后再执行 UsernamePasswordAuthenticationFilter.attemptAuthentication() 方法进行验证；</p><p>AbstractAuthenticationProcessingFilter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line"><span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line">#<span class="number">1.</span>判断当前的filter是否可以处理当前请求，不可以的话则交给下一个filter处理</span><br><span class="line"><span class="keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Request is to process authentication&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Authentication authResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">#<span class="number">2.</span>抽象方法由子类UsernamePasswordAuthenticationFilter实现</span><br><span class="line">authResult = attemptAuthentication(request, response);</span><br><span class="line"><span class="keyword">if</span> (authResult == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// return immediately as subclass has indicated that it hasn&#x27;t completed</span></span><br><span class="line"><span class="comment">// authentication</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">2.</span>认证成功后，处理一些与session相关的方法 </span><br><span class="line">sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">logger.error(</span><br><span class="line"><span class="string">&quot;An internal error occurred while trying to authenticate the user.&quot;</span>,</span><br><span class="line">failed);</span><br><span class="line">#<span class="number">3.</span>认证失败后的的一些操作</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AuthenticationException failed) &#123;</span><br><span class="line"><span class="comment">// Authentication failed</span></span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Authentication success</span></span><br><span class="line"><span class="keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">3.</span> 认证成功后的相关回调方法 主要将当前的认证放到SecurityContextHolder中</span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个程序的执行流程如下:</p><ol><li>判断filter是否可以处理当前的请求，如果不可以则放行交给下一个filter</li><li>调用抽象方法<code>attemptAuthentication</code>进行验证，该方法由子类<code>UsernamePasswordAuthenticationFilter</code>实现</li><li>认证成功以后，回调一些与 session 相关的方法；</li><li>认证成功以后，认证成功后的相关回调方法；认证成功以后，认证成功后的相关回调方法；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">successfulAuthentication</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Authentication success. Updating SecurityContextHolder to contain: &quot;</span></span><br><span class="line">+ authResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line"></span><br><span class="line">rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fire event</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.eventPublisher != <span class="literal">null</span>) &#123;</span><br><span class="line">eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">InteractiveAuthenticationSuccessEvent</span>(</span><br><span class="line">authResult, <span class="built_in">this</span>.getClass()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将当前认证成功的 Authentication 放置到 SecurityContextHolder 中；</li><li>调用其它可扩展的 handlers 继续处理该认证成功以后的回调事件；（实现<code>AuthenticationSuccessHandler</code>接口即可）</li></ol><p>UsernamePasswordAuthenticationFilter: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">#<span class="number">1.</span>判断请求的方法必须为POST请求</span><br><span class="line"><span class="keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationServiceException</span>(</span><br><span class="line"><span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">2.</span>从request中获取username和password</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> obtainUsername(request);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> obtainPassword(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (username == <span class="literal">null</span>) &#123;</span><br><span class="line">username = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (password == <span class="literal">null</span>) &#123;</span><br><span class="line">password = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">username = username.trim();</span><br><span class="line">#<span class="number">3.</span>构建UsernamePasswordAuthenticationToken（两个参数的构造方法setAuthenticated(<span class="literal">false</span>)）</span><br><span class="line"><span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(</span><br><span class="line">username, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow subclasses to set the &quot;details&quot; property</span></span><br><span class="line">setDetails(request, authRequest);</span><br><span class="line">#<span class="number">4.</span> 调用 AuthenticationManager 进行验证（子类ProviderManager遍历所有的AuthenticationProvider认证）</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>认证请求的方法必须为<code>POST</code></li><li>从request中获取 username 和 password</li><li>封装<code>Authenticaiton</code>的实现类<code>UsernamePasswordAuthenticationToken</code>，（<code>UsernamePasswordAuthenticationToken</code>调用两个参数的构造方法setAuthenticated(false)）</li><li>调用 <code>AuthenticationManager</code> 的 <code>authenticate</code> 方法进行验证；可参考<a href="https://longfeizheng.github.io/2018/01/02/Spring-Security%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80-Spring-Security%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/#providermanager-1">ProviderManager</a>部分</li></ol><h2 id="AnonymousAuthenticationFilter"><a href="#AnonymousAuthenticationFilter" class="headerlink" title="AnonymousAuthenticationFilter"></a>AnonymousAuthenticationFilter</h2><p>从上图中过滤器的执行顺序图中可以看出<code>AnonymousAuthenticationFilter</code>过滤器是在<code>UsernamePasswordAuthenticationFilter</code>等过滤器之后，如果它前面的过滤器都没有认证成功，<code>Spring Security</code>则为当前的<code>SecurityContextHolder</code>中添加一个<code>Authenticaiton</code> 的匿名实现类<code>AnonymousAuthenticationToken</code>;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">#<span class="number">1.</span>如果前面的过滤器都没认证通过，则SecurityContextHolder中Authentication为空</span><br><span class="line"><span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">#<span class="number">2.</span>为当前的SecurityContextHolder中添加一个匿名的AnonymousAuthenticationToken</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(</span><br><span class="line">createAuthentication((HttpServletRequest) req));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Populated SecurityContextHolder with anonymous token: &#x27;&quot;</span></span><br><span class="line">+ SecurityContextHolder.getContext().getAuthentication() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;SecurityContextHolder not populated with anonymous token, as it already contained: &#x27;&quot;</span></span><br><span class="line">+ SecurityContextHolder.getContext().getAuthentication() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chain.doFilter(req, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span>创建匿名的AnonymousAuthenticationToken</span><br><span class="line"><span class="keyword">protected</span> Authentication <span class="title function_">createAuthentication</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line"><span class="type">AnonymousAuthenticationToken</span> <span class="variable">auth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnonymousAuthenticationToken</span>(key,</span><br><span class="line">principal, authorities);</span><br><span class="line">auth.setDetails(authenticationDetailsSource.buildDetails(request));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> auth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a filter with a principal named &quot;anonymousUser&quot; and the single authority</span></span><br><span class="line"><span class="comment"> * &quot;ROLE_ANONYMOUS&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key to identify tokens created by this filter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> #.创建一个用户名为anonymousUser 授权为ROLE_ANONYMOUS</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnonymousAuthenticationFilter</span><span class="params">(String key)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(key, <span class="string">&quot;anonymousUser&quot;</span>, AuthorityUtils.createAuthorityList(<span class="string">&quot;ROLE_ANONYMOUS&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>判断<code>SecurityContextHolder中Authentication</code>为否为空；</li><li>如果空则为当前的<code>SecurityContextHolder</code>中添加一个匿名的<code>AnonymousAuthenticationToken</code>（用户名为 anonymousUser 的<code>AnonymousAuthenticationToken</code>）</li></ol><h2 id="ExceptionTranslationFilter"><a href="#ExceptionTranslationFilter" class="headerlink" title="ExceptionTranslationFilter"></a>ExceptionTranslationFilter</h2><p>异常处理过滤器,该过滤器用来处理在系统认证授权过程中抛出的异常（也就是下一个过滤器<code>FilterSecurityInterceptor</code>）,主要是 处理 <code>AuthenticationException</code> 和 <code>AccessDeniedException</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line"><span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&quot;Chain processed normally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="comment">// Try to extract a SpringSecurityException from the stacktrace</span></span><br><span class="line">#.判断是不是AuthenticationException</span><br><span class="line">Throwable[] causeChain = throwableAnalyzer.determineCauseChain(ex);</span><br><span class="line"><span class="type">RuntimeException</span> <span class="variable">ase</span> <span class="operator">=</span> (AuthenticationException) throwableAnalyzer</span><br><span class="line">.getFirstThrowableOfType(AuthenticationException.class, causeChain);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ase == <span class="literal">null</span>) &#123;</span><br><span class="line">#. 判断是不是<span class="type">AccessDeniedException</span></span><br><span class="line"><span class="variable">ase</span> <span class="operator">=</span> (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType(</span><br><span class="line">AccessDeniedException.class, causeChain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ase != <span class="literal">null</span>) &#123;</span><br><span class="line">handleSpringSecurityException(request, response, chain, ase);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Rethrow ServletExceptions and RuntimeExceptions as-is</span></span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> ServletException) &#123;</span><br><span class="line"><span class="keyword">throw</span> (ServletException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line"><span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrap other Exceptions. This shouldn&#x27;t actually happen</span></span><br><span class="line"><span class="comment">// as we&#x27;ve already covered all the possibilities for doFilter</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FilterSecurityInterceptor"><a href="#FilterSecurityInterceptor" class="headerlink" title="FilterSecurityInterceptor"></a>FilterSecurityInterceptor</h2><p>此过滤器为认证授权过滤器链中最后一个过滤器，该过滤器之后就是请求真正的<code>/persons</code> 服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="type">FilterInvocation</span> <span class="variable">fi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterInvocation</span>(request, response, chain);</span><br><span class="line">invoke(fi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(FilterInvocation fi)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="keyword">if</span> ((fi.getRequest() != <span class="literal">null</span>)</span><br><span class="line">&amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) != <span class="literal">null</span>)</span><br><span class="line">&amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line"><span class="comment">// filter already applied to this request and user wants us to observe</span></span><br><span class="line"><span class="comment">// once-per-request handling, so don&#x27;t re-do security checking</span></span><br><span class="line">fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// first time this request being called, so perform security checking</span></span><br><span class="line"><span class="keyword">if</span> (fi.getRequest() != <span class="literal">null</span>) &#123;</span><br><span class="line">fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">1.</span> before invocation重要</span><br><span class="line"><span class="type">InterceptorStatusToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">super</span>.beforeInvocation(fi);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">#<span class="number">2.</span> 可以理解开始请求真正的 /persons 服务</span><br><span class="line">fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.finallyInvocation(token);</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">3.</span> after Invocation</span><br><span class="line"><span class="built_in">super</span>.afterInvocation(token, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>before invocation重要</li><li>请求真正的 &#x2F;persons 服务</li><li>after Invocation</li></ol><p>三个部分中，最重要的是 #1，该过程中会调用 <code>AccessDecisionManager</code> 来验证当前已认证成功的用户是否有权限访问该资源；</p><h3 id="before-invocation-AccessDecisionManager"><a href="#before-invocation-AccessDecisionManager" class="headerlink" title="before invocation: AccessDecisionManager"></a>before invocation: AccessDecisionManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> InterceptorStatusToken <span class="title function_">beforeInvocation</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Collection&lt;ConfigAttribute&gt; attributes = <span class="built_in">this</span>.obtainSecurityMetadataSource()</span><br><span class="line">.getAttributes(object);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="type">Authentication</span> <span class="variable">authenticated</span> <span class="operator">=</span> authenticateIfRequired();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attempt authorization</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">#<span class="number">1.</span>重点</span><br><span class="line"><span class="built_in">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">publishEvent(<span class="keyword">new</span> <span class="title class_">AuthorizationFailureEvent</span>(object, attributes, authenticated,accessDeniedException));</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>authenticated</code>就是当前认证的<code>Authentication</code>，<code>object</code>为当前请求的 <code>url:/persons</code>, getAttributes方法就是使用当前的访问资源路径去<code>匹配</code>我们自己定义的匹配规则。</p><blockquote><p>AccessDecisionManager 是如何授权的？</p></blockquote><p><code>Spring Security</code>默认使用<code>AffirmativeBased</code>实现<code>AccessDecisionManager</code> 的 <code>decide</code> 方法来实现授权</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decide</span><span class="params">(Authentication authentication, Object object,</span></span><br><span class="line"><span class="params">Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">deny</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">#<span class="number">1.</span>调用AccessDecisionVoter 进行vote(投票)</span><br><span class="line"><span class="keyword">for</span> (AccessDecisionVoter voter : getDecisionVoters()) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> voter.vote(authentication, object, configAttributes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Voter: &quot;</span> + voter + <span class="string">&quot;, returned: &quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (result) &#123;</span><br><span class="line">#<span class="number">1.1</span>只要有voter投票为ACCESS_GRANTED，则通过 直接返回</span><br><span class="line"><span class="keyword">case</span> AccessDecisionVoter.ACCESS_GRANTED:<span class="comment">//1</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">@#<span class="number">1.2</span>只要有voter投票为ACCESS_DENIED，则记录一下</span><br><span class="line"><span class="keyword">case</span> AccessDecisionVoter.ACCESS_DENIED:<span class="comment">//-1</span></span><br><span class="line">deny++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (deny &gt; <span class="number">0</span>) &#123;</span><br><span class="line">#<span class="number">2.</span>如果有一个及以上AccessDecisionVoter(姑且称之为投票者吧)都投ACCESS_DENIED，则直接就不通过了</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(messages.getMessage(</span><br><span class="line"><span class="string">&quot;AbstractAccessDecisionManager.accessDenied&quot;</span>, <span class="string">&quot;Access is denied&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// To get this far, every AccessDecisionVoter abstained</span></span><br><span class="line">checkAllowIfAllAbstainDecisions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用AccessDecisionVoter 进行vote(投票)</li><li>只要有投通过（ACCESS_GRANTED）票，则直接判为通过。</li><li>如果没有投通过则 <code>deny++</code> ,最后判断<code>if（deny&gt;0</code> 抛出<code>AccessDeniedException</code>（未授权）</li></ol><h1 id="SpringSecurityFilterChain过滤器加载流程"><a href="#SpringSecurityFilterChain过滤器加载流程" class="headerlink" title="SpringSecurityFilterChain过滤器加载流程"></a>SpringSecurityFilterChain过滤器加载流程</h1><h2 id="DelegatingFilterProxy"><a href="#DelegatingFilterProxy" class="headerlink" title="DelegatingFilterProxy"></a>DelegatingFilterProxy</h2><p>它的包结构：org.springframework.web.filter，它本身是 Spring Web 包中的类，并不是 SpringSecurity 中的类。因为 Spring 考虑到了多种使用场景，自然希望将侵入性降到最低，所以使用了这个委托代理类来代理真正的 SpringSecurityFilterChain。</p><p>DelegatingFilterProxy 实现了 javax.servlet.Filter 接口，使得它可以作为一个 java web 的标准过滤器，其职责也很简单，只负责调用真正的 SpringSecurityFilterChain。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegatingFilterProxy</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> WebApplicationContext webApplicationContext;</span><br><span class="line">   <span class="comment">// springSecurityFilterChain</span></span><br><span class="line">   <span class="keyword">private</span> String targetBeanName;</span><br><span class="line">   <span class="comment">// &lt;1&gt; 关键点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> Filter delegate;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">delegateMonitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">DelegatingFilterProxy</span><span class="params">(String targetBeanName, WebApplicationContext wac)</span> &#123;</span><br><span class="line">      Assert.hasText(targetBeanName, <span class="string">&quot;Target Filter bean name must not be null or empty&quot;</span>);</span><br><span class="line">      <span class="built_in">this</span>.setTargetBeanName(targetBeanName);</span><br><span class="line">      <span class="built_in">this</span>.webApplicationContext = wac;</span><br><span class="line">      <span class="keyword">if</span> (wac != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="built_in">this</span>.setEnvironment(wac.getEnvironment());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.delegateMonitor) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">this</span>.delegate == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.targetBeanName == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="built_in">this</span>.targetBeanName = getFilterName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Fetch Spring root application context and initialize the delegate early,</span></span><br><span class="line">            <span class="comment">// if possible. If the root application context will be started after this</span></span><br><span class="line">            <span class="comment">// filter proxy, we&#x27;ll have to resort to lazy initialization.</span></span><br><span class="line">            <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> findWebApplicationContext();</span><br><span class="line">            <span class="keyword">if</span> (wac != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="built_in">this</span>.delegate = initDelegate(wac);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><br><span class="line">         <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 过滤器代理支持懒加载</span></span><br><span class="line">      <span class="type">Filter</span> <span class="variable">delegateToUse</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">      <span class="keyword">if</span> (delegateToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="built_in">this</span>.delegateMonitor) &#123;</span><br><span class="line">            delegateToUse = <span class="built_in">this</span>.delegate;</span><br><span class="line">            <span class="keyword">if</span> (delegateToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> findWebApplicationContext();</span><br><span class="line">               delegateToUse = initDelegate(wac);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.delegate = delegateToUse;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 让代理过滤器执行实际的过滤行为</span></span><br><span class="line">      invokeDelegate(delegateToUse, request, response, filterChain);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化过滤器代理</span></span><br><span class="line">   <span class="comment">// &lt;2&gt;</span></span><br><span class="line">   <span class="keyword">protected</span> Filter <span class="title function_">initDelegate</span><span class="params">(WebApplicationContext wac)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">      <span class="type">Filter</span> <span class="variable">delegate</span> <span class="operator">=</span> wac.getBean(getTargetBeanName(), Filter.class);</span><br><span class="line">      <span class="keyword">if</span> (isTargetFilterLifecycle()) &#123;</span><br><span class="line">         delegate.init(getFilterConfig());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> delegate;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用代理过滤器</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeDelegate</span><span class="params">(</span></span><br><span class="line"><span class="params">         Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><br><span class="line">         <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">      delegate.doFilter(request, response, filterChain);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;1&gt; 可以发现整个 DelegatingFilterProxy 的逻辑就是为了调用 <code>private volatile Filter delegate;</code></p><p>&lt;2&gt; 可以看到，DelegatingFilterProxy 尝试去容器中获取名为 targetBeanName 的类，而 targetBeanName 的默认值便是 Filter 的名称，也就是 springSecurityFilterChain</p><p>DelegatingFilterProxy 只是名称和 targetBeanName 叫 springSecurityFilterChain，真正容器中的 Bean(name&#x3D;”springSecurityFilterChain”) 其实另有其人——通过 debug，我们发现了真正的 springSecurityFilterChain — FilterChainProxy。</p><blockquote><p>SpringSecurityFilterChain 是什么时候被放进去的？</p></blockquote><p>这就得说到老朋友 WebSecurity 了，还记得一般我们都会选择使用 @EnableWebSecurity 和 WebSecurityConfigurerAdapter 来进行 web 安全配置吗，来到 WebSecurity 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WebSecurity</span> <span class="keyword">extends</span></span><br><span class="line">      <span class="title class_">AbstractConfiguredSecurityBuilder</span>&lt;Filter, WebSecurity&gt; <span class="keyword">implements</span></span><br><span class="line">      <span class="title class_">SecurityBuilder</span>&lt;Filter&gt;, ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Filter <span class="title function_">performBuild</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">chainSize</span> <span class="operator">=</span> ignoredRequests.size() + securityFilterChainBuilders.size();</span><br><span class="line">List&lt;SecurityFilterChain&gt; securityFilterChains = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SecurityFilterChain&gt;(</span><br><span class="line">chainSize);</span><br><span class="line"><span class="keyword">for</span> (RequestMatcher ignoredRequest : ignoredRequests) &#123;</span><br><span class="line">securityFilterChains.add(<span class="keyword">new</span> <span class="title class_">DefaultSecurityFilterChain</span>(ignoredRequest));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (SecurityBuilder&lt;? <span class="keyword">extends</span> <span class="title class_">SecurityFilterChain</span>&gt; securityFilterChainBuilder : securityFilterChainBuilders) &#123;</span><br><span class="line">securityFilterChains.add(securityFilterChainBuilder.build());</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// &lt;1&gt; FilterChainProxy 由 WebSecurity 构建</span></span><br><span class="line"><span class="type">FilterChainProxy</span> <span class="variable">filterChainProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterChainProxy</span>(securityFilterChains);</span><br><span class="line"><span class="keyword">if</span> (httpFirewall != <span class="literal">null</span>) &#123;</span><br><span class="line">filterChainProxy.setFirewall(httpFirewall);</span><br><span class="line">&#125;</span><br><span class="line">filterChainProxy.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line"><span class="type">Filter</span> <span class="variable">result</span> <span class="operator">=</span> filterChainProxy;</span><br><span class="line">postBuildAction.run();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;1&gt; 最终定位到 WebSecurity 的 performBuild 方法，我们之前配置了一堆参数的 WebSecurity 最终帮助我们构建了 FilterChainProxy。</p><p>并且，最终在 <code>org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration</code>中被注册为默认名称为 SpringSecurityFilterChain。</p><h2 id="FilterChainProxy"><a href="#FilterChainProxy" class="headerlink" title="FilterChainProxy"></a>FilterChainProxy</h2><p>它才是真正的 springSecurityFilterChain，我们来看看它的源码（有删减，不影响理解）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterChainProxy</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line">   <span class="comment">// &lt;1&gt; 包含了多个SecurityFilterChain</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;SecurityFilterChain&gt; filterChains;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">FilterChainProxy</span><span class="params">(SecurityFilterChain chain)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>(Arrays.asList(chain));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">FilterChainProxy</span><span class="params">(List&lt;SecurityFilterChain&gt; filterChains)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.filterChains = filterChains;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">      filterChainValidator.validate(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">         FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">         doFilterInternal(request, response, chain);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">         FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">FirewalledRequest</span> <span class="variable">fwRequest</span> <span class="operator">=</span> firewall</span><br><span class="line">            .getFirewalledRequest((HttpServletRequest) request);</span><br><span class="line">      <span class="type">HttpServletResponse</span> <span class="variable">fwResponse</span> <span class="operator">=</span> firewall</span><br><span class="line">            .getFirewalledResponse((HttpServletResponse) response);</span><br><span class="line">  <span class="comment">// &lt;1&gt;</span></span><br><span class="line">      List&lt;Filter&gt; filters = getFilters(fwRequest);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (filters == <span class="literal">null</span> || filters.size() == <span class="number">0</span>) &#123;</span><br><span class="line">         fwRequest.reset();</span><br><span class="line">         chain.doFilter(fwRequest, fwResponse);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">VirtualFilterChain</span> <span class="variable">vfc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualFilterChain</span>(fwRequest, chain, filters);</span><br><span class="line">      vfc.doFilter(fwRequest, fwResponse);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &lt;1&gt; 可能会有多个过滤器链，返回第一个和请求URL匹配的过滤器链</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;Filter&gt; <span class="title function_">getFilters</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (SecurityFilterChain chain : filterChains) &#123;</span><br><span class="line">         <span class="keyword">if</span> (chain.matches(request)) &#123;</span><br><span class="line">            <span class="keyword">return</span> chain.getFilters();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看 FilterChainProxy 的名字就可以发现，它依旧不是真正实施过滤的类，它内部维护了一个 SecurityFilterChain，这个过滤器链才是请求真正对应的过滤器链，并且同一个 Spring 环境下，可能同时存在多个安全过滤器链，如 private List filterChains 所示，需要经过 chain.matches(request) 判断到底哪个过滤器链匹配成功，每个 request 最多只会经过一个 SecurityFilterChain。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加签和验签</title>
      <link href="/2024/01/23/%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/"/>
      <url>/2024/01/23/%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="密码学概念"><a href="#密码学概念" class="headerlink" title="密码学概念"></a>密码学概念</h1><h2 id="明文、密文、密钥、加密、解密"><a href="#明文、密文、密钥、加密、解密" class="headerlink" title="明文、密文、密钥、加密、解密"></a>明文、密文、密钥、加密、解密</h2><ul><li>明文：指没有经过加密的信息&#x2F;数据。</li><li>密文：明文被加密算法加密之后，会变成密文，以确保数据安全。</li><li>密钥：是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。</li><li>加密：将明文变成密文的过程。</li><li>解密：将密文还原为明文的过程。</li></ul><h2 id="对称加密、非对称加密"><a href="#对称加密、非对称加密" class="headerlink" title="对称加密、非对称加密"></a>对称加密、非对称加密</h2><ul><li>对称加密：加密和解密使用相同密钥的加密算法。</li><li>非对称加密：非对称加密算法需要两个密钥（公开密钥和私有密钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。</li></ul><h2 id="什么是公钥私钥？"><a href="#什么是公钥私钥？" class="headerlink" title="什么是公钥私钥？"></a>什么是公钥私钥？</h2><ul><li>公钥与私钥是成对存在的密钥，如果用公钥对数据进行加密，只有用对应的私钥才能解密。</li><li>其实，公钥就是公开的秘钥，私钥就是要你私自保存好的秘钥。</li><li>非对称加密算法需要有一对公私钥~</li></ul><h1 id="加签验签概念"><a href="#加签验签概念" class="headerlink" title="加签验签概念"></a>加签验签概念</h1><p><strong>「加签」</strong>：用Hash函数把原始报文生成报文摘要，然后用私钥对这个摘要进行加密，就得到这个报文对应的数字签名。通常来说呢，请求方会把<strong>「数字签名和报文原文」</strong>一并发送给接收方。</p><p><img src="https://i0.hdslb.com/bfs/article/3afa1614473420ae859db75b5844ebfb171301454.png" alt="image-20240123194037932"></p><p><strong>「验签」</strong>：接收方拿到原始报文和数字签名后，用<strong>「同一个Hash函数」</strong>从报文中生成摘要A。另外，用对方提供的公钥对数字签名进行解密，得到摘要B，对比A和B是否相同，就可以得知报文有没有被篡改过。</p><p><img src="https://i0.hdslb.com/bfs/article/d5e65c2f233576edd445aafe8ad2c148171301454.png" alt="image-20240123194253661"></p><h2 id="为什么需要加签和验签"><a href="#为什么需要加签和验签" class="headerlink" title="为什么需要加签和验签"></a>为什么需要加签和验签</h2><blockquote><p>为什么需要加签和验签呢？我们不是用<strong>「公钥加密，私钥解密」</strong>就好了嘛？</p></blockquote><p><img src="https://i0.hdslb.com/bfs/article/c01f928b38175b2862215b74d1717d1d171301454.png" alt="image-20240123194922845"></p><p>假设现在有A公司，要接入C公司的转账系统。</p><p>在一开始，C公司把自己的公钥寄给A公司，自己收藏好私钥。</p><p>A公司这边的商户，发起转账时，A公司先用C公司的公钥，对请求报文加密，加密报文到达C公司的转账系统时，C公司就用自己的私钥把报文解开。</p><p>假设在加密的报文在传输过程中，被入侵者获取了，他也郁闷，因为他没有私钥，本来想修改报文，给自己账号转一个亿的，哈哈。这个实现方式看起来是天衣无缝，稳得一匹的。</p><p>但是呢，如果一开始，C公司把公钥发给公司A的时候，就被入侵者获取到呢？</p><p>入侵者截取了C的公钥，他把自己的公钥发给了A公司，A误以为这就是C公司的公钥。A在发起转账时，用入侵者的公钥，对请求报文加密，加密报文到在传输过程，入侵者又截取了，这时候，他用自己的私钥解密，然后修改了报文（给自己转一个亿），再用C的公钥加密，发给C公司，C公司收到报文后，继续用自己的私钥解密。最后是不是A公司的转账账户损失了一个亿呢~</p><p><img src="https://i0.hdslb.com/bfs/article/c4e21e133c29eaaec66f0fb0153887c2171301454.png" alt="image-20240123195714790"></p><p>C公司是怎么区分报文是不是来自A呢，还是被入侵者修改过呢？为了表明身份和报文真实性，这就需要<strong>「加签验签」</strong>啦！</p><p>A公司把自己的公钥也发送给C公司，私钥自己保留着。在发起转账时，先用自己的私钥对请求报文加签，于是得到自己的数字签名。再把数字签名和请求报文一起发送给C公司。C公司收到报文后，拿A的公钥进行验签，如果原始报文和数字签名的摘要内容不一致，那就是报文被篡改啦~</p><p><img src="https://i0.hdslb.com/bfs/article/78eb7169a6300b247e60765ce5483e1a171301454.png" alt="image-20240123200041173"></p><p>假设A在发自己的公钥给C公司的时候，也被入侵者截取了呢？</p><p>假设入侵者截取到A的公钥后，随后也截取了到A发往C的报文。他截取到报文后，第一件想做的事肯定是修改报文内容。但是如果单单修改原始报文是不可以的，因为发过去C公司肯定验签不过啦。但是呢，数字签名似乎解不开，因为消息摘要算法（hash算法）无法逆向解开的，只起验证的作用呢….</p><p>所以呢，公钥与私钥是用来加密与解密的，<strong>「加签与验签是用来证明身份」</strong>，以免被篡改的。</p><h2 id="消息摘要算法"><a href="#消息摘要算法" class="headerlink" title="消息摘要算法"></a>消息摘要算法</h2><ul><li>相同的明文数据经过相同的消息摘要算法会得到相同的密文结果值。</li><li>数据经过消息摘要算法处理，得到的摘要结果值，是无法还原为处理前的数据的。</li><li>数据摘要算法也被称为哈希（Hash）算法或散列算法。</li><li>消息摘要算法一般用于签名验签。</li></ul><p>消息摘要算法主要分三类：MD（Message Digest，消息摘要算法）、SHA（Secure Hash Algorithm，安全散列算法）和MAC（Message Authentication Code，消息认证码算法）。</p><h3 id="MD家族算法"><a href="#MD家族算法" class="headerlink" title="MD家族算法"></a>MD家族算法</h3><p>MD（Message Digest，消息摘要算法）家族，包括MD2，MD4，MD5。</p><ul><li>MD2，MD4，MD5 计算的结果都是是一个128位（即16字节）的散列值，用于确保信息传输完整一致。</li><li>MD2的算法较慢但相对安全，MD4速度很快，但安全性下降，MD5则比MD4更安全、速度更快。</li><li>MD5被广泛应用于数据完整性校验、数据（消息）摘要、数据加密等。</li><li>MD5，可以被破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞攻击，因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。</li></ul><p><strong>MD5破解方式：</strong>把常用的密码先MD5处理，并将数据存储起来，然后跟需要查询的MD5结果匹配，这时就有可能通过匹配的MD5得到明文，所以有些简单的MD5码是反查到加密前原文的。</p><p>为了让MD5码更加安全，涌现了很多其他方法，如加盐。 盐要足够长足够乱，得到的MD5码就很难查到。</p><blockquote><p>MD5 算加密算法吗？</p></blockquote><p>MD5 算法和加密算法都可以将信息转换为另外一种内容，但是，<strong>MD5 算法对比 加密算法缺少了解密过程。</strong></p><p>使用 <strong>加密算法</strong> 加密后的消息是完整的，并且基于解密算法后，可以恢复原始数据。而 <strong>MD5 算法</strong> 得到的消息是不完整的，并且通过摘要的数据也无法得到原始数据。</p><p>所以严格意义上来讲，<strong>MD5 称为摘要&#x2F;散列算法更合适，而不是加密算法</strong>！</p><h3 id="SHA家族算法"><a href="#SHA家族算法" class="headerlink" title="SHA家族算法"></a>SHA家族算法</h3><p>SHA（Secure Hash Algorithm，安全散列算法，它是在MD算法基础上实现的，与MD算法区别在于<strong>「摘要长度」</strong>，SHA 算法的摘要<strong>「长度更长，安全性更高」</strong>。</p><h3 id="MAC算法家族"><a href="#MAC算法家族" class="headerlink" title="MAC算法家族"></a>MAC算法家族</h3><p>MAC算法 MAC（Message Authentication Code，消息认证码算法），是带密钥的Hash函数。输入密钥和消息，输出一个消息摘要。它集合了MD和SHA两大系列消息摘要算法。</p><h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>加密和解密使用<strong>「相同密钥」</strong>的加密算法就是对称加密算法。常见的对称加密算法有AES、3DES、DES、RC5、RC6等。</p><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p>数据加密标准（英语：Data Encryption Standard，缩写为 DES）是一种对称密钥加密块密码算法。DES算法的入口参数有三个：Key、Data、Mode。</p><ul><li>Key: 7个字节共56位，是DES算法的工作密钥；</li><li>Data: 8个字节64位，是要被加密或被解密的数据；</li><li>Mode: 加密或解密。</li></ul><p>虽然，现在仍有许多老项目使用了 DES 算法，但我不推荐使用。在 1999 年的 DES 挑战赛 3 中，DES 密码破解耗时不到一天，而现在 DES 密码破解更快，使用 DES 来加密数据非常不安全。因此，在业务代码中要避免使用 DES 加密。</p><h3 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h3><p>三重数据加密算法（英语：Triple Data Encryption Algorithm，又称3DES（Triple DES），是一种对称密钥加密块密码，相当于是对每个数据块应用三次数据加密标准（DES）算法。</p><p>3DES 算法，是使用不同的密钥进行三次 DES 串联调用，虽然解决了 DES 不够安全的问题，但是比 AES 慢，也不太推荐。</p><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>AES，高级加密标准（英语：Advanced Encryption Standard），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。</p><ul><li>采用对称分组密码体制，密钥长度为 128 位、 192 位、256 位，分组长度128位</li><li>相对于DES ，AES具有更好的 安全性、效率 和 灵活性。</li></ul><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><p>非对称加密算法需要两个密钥：公钥和私钥。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有用对应的私钥才能解密。主要的非对称加密算法有：RSA、Elgamal、DSA、D-H、ECC。</p><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><ul><li>RSA加密算法是一种非对称加密算法,广泛应用于加密和<strong>数字签名</strong></li><li>RSA算法原理：两个大素数的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</li><li>RSA是被研究得最广泛的公钥算法，从提出到现在，经历了各种攻击的考验，普遍认为是目前最优秀的公钥方案之一。</li></ul><h3 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h3><ul><li>DSA(Digital Signature Algorithm,数字签名算法),也是一种非对称加密算法。</li><li>DSA和RSA区别在，DSA仅用于数字签名，不能用于数据加密解密。其安全性和RSA相当，但其性能要比RSA好。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 验签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven入门到实战</title>
      <link href="/2024/01/18/Maven%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"/>
      <url>/2024/01/18/Maven%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven-的安装与配置"><a href="#Maven-的安装与配置" class="headerlink" title="Maven 的安装与配置"></a>Maven 的安装与配置</h1><p>下载地址：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>使用 <code>win + r</code> 打开运行框，输入<code>control system</code>，回车进入设置界面后，创建一个环境变量<code>MAVEN_HOME</code>（maven的安装地址）。</p><p>创建好后，找到系统变量中的<code>path</code>，将<code>MAVEN_HOME</code>这个变量配置进去：%MAVEN_HOME%\bin</p><p>打开<code>cmd</code>命令行输入<code>mvn -v</code>，打印出版本号表示安装成功。</p><h2 id="修改-settings-xml"><a href="#修改-settings-xml" class="headerlink" title="修改 settings.xml"></a>修改 settings.xml</h2><p>修改 conf 下的 settings.xml，将 localRepository 替换成本地的 maven 仓库地址。</p><p>至此，maven 就能正常使用了！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">Licensed to the Apache Software Foundation (ASF) under one</span></span><br><span class="line"><span class="comment">or more contributor license agreements.  See the NOTICE file</span></span><br><span class="line"><span class="comment">distributed with this work for additional information</span></span><br><span class="line"><span class="comment">regarding copyright ownership.  The ASF licenses this file</span></span><br><span class="line"><span class="comment">to you under the Apache License, Version 2.0 (the</span></span><br><span class="line"><span class="comment">&quot;License&quot;); you may not use this file except in compliance</span></span><br><span class="line"><span class="comment">with the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Unless required by applicable law or agreed to in writing,</span></span><br><span class="line"><span class="comment">software distributed under the License is distributed on an</span></span><br><span class="line"><span class="comment">&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span></span><br><span class="line"><span class="comment">KIND, either express or implied.  See the License for the</span></span><br><span class="line"><span class="comment">specific language governing permissions and limitations</span></span><br><span class="line"><span class="comment">under the License.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> | This is the configuration file for Maven. It can be specified at two levels:</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |  1. User Level. This settings.xml file provides configuration for a single user,</span></span><br><span class="line"><span class="comment"> |                 and is normally provided in $&#123;user.home&#125;/.m2/settings.xml.</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 <span class="doctag">NOTE:</span> This location can be overridden with the CLI option:</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 -s /path/to/user/settings.xml</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |  2. Global Level. This settings.xml file provides configuration for all Maven</span></span><br><span class="line"><span class="comment"> |                 users on a machine (assuming they&#x27;re all using the same Maven</span></span><br><span class="line"><span class="comment"> |                 installation). It&#x27;s normally provided in</span></span><br><span class="line"><span class="comment"> |                 $&#123;maven.conf&#125;/settings.xml.</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 <span class="doctag">NOTE:</span> This location can be overridden with the CLI option:</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |                 -gs /path/to/global/settings.xml</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> | The sections in this sample file are intended to give you a running start at</span></span><br><span class="line"><span class="comment"> | getting the most out of your Maven installation. Where appropriate, the default</span></span><br><span class="line"><span class="comment"> | values (values used when the setting is not specified) are provided.</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> |--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">   | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\mvnrepository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- interactiveMode</span></span><br><span class="line"><span class="comment">   | This will determine whether maven prompts you when it needs input. If set to false,</span></span><br><span class="line"><span class="comment">   | maven will use a sensible default value, perhaps based on some other setting, for</span></span><br><span class="line"><span class="comment">   | the parameter in question.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: true</span></span><br><span class="line"><span class="comment">  &lt;interactiveMode&gt;true&lt;/interactiveMode&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- offline</span></span><br><span class="line"><span class="comment">   | Determines whether maven should attempt to connect to the network when executing a build.</span></span><br><span class="line"><span class="comment">   | This will have an effect on artifact downloads, artifact deployment, and others.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: false</span></span><br><span class="line"><span class="comment">  &lt;offline&gt;false&lt;/offline&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- pluginGroups</span></span><br><span class="line"><span class="comment">   | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.</span></span><br><span class="line"><span class="comment">   | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers</span></span><br><span class="line"><span class="comment">   | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- pluginGroup</span></span><br><span class="line"><span class="comment">     | Specifies a further group identifier to use for plugin lookup.</span></span><br><span class="line"><span class="comment">    &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- proxies</span></span><br><span class="line"><span class="comment">   | This is a list of proxies which can be used on this machine to connect to the network.</span></span><br><span class="line"><span class="comment">   | Unless otherwise specified (by system property or command-line switch), the first proxy</span></span><br><span class="line"><span class="comment">   | specification in this list marked as active will be used.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- proxy</span></span><br><span class="line"><span class="comment">     | Specification for one proxy, to be used in connecting to the network.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;proxy&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;optional&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;active&gt;true&lt;/active&gt;</span></span><br><span class="line"><span class="comment">      &lt;protocol&gt;http&lt;/protocol&gt;</span></span><br><span class="line"><span class="comment">      &lt;username&gt;proxyuser&lt;/username&gt;</span></span><br><span class="line"><span class="comment">      &lt;password&gt;proxypass&lt;/password&gt;</span></span><br><span class="line"><span class="comment">      &lt;host&gt;proxy.host.net&lt;/host&gt;</span></span><br><span class="line"><span class="comment">      &lt;port&gt;80&lt;/port&gt;</span></span><br><span class="line"><span class="comment">      &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;</span></span><br><span class="line"><span class="comment">    &lt;/proxy&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- servers</span></span><br><span class="line"><span class="comment">   | This is a list of authentication profiles, keyed by the server-id used within the system.</span></span><br><span class="line"><span class="comment">   | Authentication profiles can be used whenever maven must make a connection to a remote server.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- server</span></span><br><span class="line"><span class="comment">     | Specifies the authentication information to use when connecting to a particular server, identified by</span></span><br><span class="line"><span class="comment">     | a unique name within the system (referred to by the &#x27;id&#x27; attribute below).</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | <span class="doctag">NOTE:</span> You should either specify username/password OR privateKey/passphrase, since these pairings are</span></span><br><span class="line"><span class="comment">     |       used together.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;server&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;deploymentRepo&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;username&gt;repouser&lt;/username&gt;</span></span><br><span class="line"><span class="comment">      &lt;password&gt;repopwd&lt;/password&gt;</span></span><br><span class="line"><span class="comment">    &lt;/server&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Another sample, using keys to authenticate.</span></span><br><span class="line"><span class="comment">    &lt;server&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;siteServer&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt;</span></span><br><span class="line"><span class="comment">      &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt;</span></span><br><span class="line"><span class="comment">    &lt;/server&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- mirrors</span></span><br><span class="line"><span class="comment">   | This is a list of mirrors to be used in downloading artifacts from remote repositories.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | It works like this: a POM may declare a repository to use in resolving certain artifacts.</span></span><br><span class="line"><span class="comment">   | However, this repository may have problems with heavy traffic at times, so people have mirrored</span></span><br><span class="line"><span class="comment">   | it to several places.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | That repository definition will have a unique id, so we can create a mirror reference for that</span></span><br><span class="line"><span class="comment">   | repository, to be used as an alternate download site. The mirror site will be the preferred</span></span><br><span class="line"><span class="comment">   | server for that repository.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- mirror</span></span><br><span class="line"><span class="comment">&lt;mirrors&gt;</span></span><br><span class="line"><span class="comment">     | Specifies a repository mirror site to use instead of a given repository. The repository that</span></span><br><span class="line"><span class="comment">     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span></span><br><span class="line"><span class="comment">     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;mirrorId&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span></span><br><span class="line"><span class="comment">      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;</span></span><br><span class="line"><span class="comment">    &lt;/mirror&gt;</span></span><br><span class="line"><span class="comment"> &lt;/mirrors&gt;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 阿里云仓库 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">&lt;id&gt;nexus-aliyun&lt;/id&gt;</span></span><br><span class="line"><span class="comment">&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">&lt;name&gt;Nexus aliyun&lt;/name&gt;</span></span><br><span class="line"><span class="comment">&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span></span><br><span class="line"><span class="comment">&lt;/mirror&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- profiles</span></span><br><span class="line"><span class="comment">   | This is a list of profiles which can be activated in a variety of ways, and which can modify</span></span><br><span class="line"><span class="comment">   | the build process. Profiles provided in the settings.xml are intended to provide local machine-</span></span><br><span class="line"><span class="comment">   | specific paths and repository locations which allow the build to work in the local environment.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | For example, if you have an integration testing plugin - like cactus - that needs to know where</span></span><br><span class="line"><span class="comment">   | your Tomcat instance is installed, you can provide a variable here such that the variable is</span></span><br><span class="line"><span class="comment">   | dereferenced during the build process to configure the cactus plugin.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles</span></span><br><span class="line"><span class="comment">   | section of this document (settings.xml) - will be discussed later. Another way essentially</span></span><br><span class="line"><span class="comment">   | relies on the detection of a system property, either matching a particular value for the property,</span></span><br><span class="line"><span class="comment">   | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a</span></span><br><span class="line"><span class="comment">   | value of &#x27;1.4&#x27; might activate a profile when the build is executed on a JDK version of &#x27;1.4.2_07&#x27;.</span></span><br><span class="line"><span class="comment">   | Finally, the list of active profiles can be specified directly from the command line.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | <span class="doctag">NOTE:</span> For profiles defined in the settings.xml, you are restricted to specifying only artifact</span></span><br><span class="line"><span class="comment">   |       repositories, plugin repositories, and free-form properties to be used as configuration</span></span><br><span class="line"><span class="comment">   |       variables for plugins in the POM.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- profile</span></span><br><span class="line"><span class="comment">&lt;profiles&gt;</span></span><br><span class="line"><span class="comment">     | Specifies a set of introductions to the build process, to be activated using one or more of the</span></span><br><span class="line"><span class="comment">     | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt;</span></span><br><span class="line"><span class="comment">     | or the command line, profiles have to have an ID that is unique.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | An encouraged best practice for profile identification is to use a consistent naming convention</span></span><br><span class="line"><span class="comment">     | for profiles, such as &#x27;env-dev&#x27;, &#x27;env-test&#x27;, &#x27;env-production&#x27;, &#x27;user-jdcasey&#x27;, &#x27;user-brett&#x27;, etc.</span></span><br><span class="line"><span class="comment">     | This will make it more intuitive to understand what the set of introduced profiles is attempting</span></span><br><span class="line"><span class="comment">     | to accomplish, particularly when you only have a list of profile id&#x27;s for debug.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo.</span></span><br><span class="line"><span class="comment">    &lt;profile&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;jdk-1.4&lt;/id&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;activation&gt;</span></span><br><span class="line"><span class="comment">        &lt;jdk&gt;1.4&lt;/jdk&gt;</span></span><br><span class="line"><span class="comment">      &lt;/activation&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;repositories&gt;</span></span><br><span class="line"><span class="comment">        &lt;repository&gt;</span></span><br><span class="line"><span class="comment">          &lt;id&gt;jdk14&lt;/id&gt;</span></span><br><span class="line"><span class="comment">          &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt;</span></span><br><span class="line"><span class="comment">          &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt;</span></span><br><span class="line"><span class="comment">          &lt;layout&gt;default&lt;/layout&gt;</span></span><br><span class="line"><span class="comment">          &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt;</span></span><br><span class="line"><span class="comment">        &lt;/repository&gt;</span></span><br><span class="line"><span class="comment">      &lt;/repositories&gt;</span></span><br><span class="line"><span class="comment">    &lt;/profile&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     | Here is another profile, activated by the system property &#x27;target-env&#x27; with a value of &#x27;dev&#x27;,</span></span><br><span class="line"><span class="comment">     | which provides a specific path to the Tomcat instance. To use this, your plugin configuration</span></span><br><span class="line"><span class="comment">     | might hypothetically look like:</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | ...</span></span><br><span class="line"><span class="comment">     | &lt;plugin&gt;</span></span><br><span class="line"><span class="comment">     |   &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">     |   &lt;artifactId&gt;myplugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     |   &lt;configuration&gt;</span></span><br><span class="line"><span class="comment">     |     &lt;tomcatLocation&gt;$&#123;tomcatPath&#125;&lt;/tomcatLocation&gt;</span></span><br><span class="line"><span class="comment">     |   &lt;/configuration&gt;</span></span><br><span class="line"><span class="comment">     | &lt;/plugin&gt;</span></span><br><span class="line"><span class="comment">     | ...</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | <span class="doctag">NOTE:</span> If you just wanted to inject this configuration whenever someone set &#x27;target-env&#x27; to</span></span><br><span class="line"><span class="comment">     |       anything, you could just leave off the &lt;value/&gt; inside the activation-property.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;profile&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;env-dev&lt;/id&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;activation&gt;</span></span><br><span class="line"><span class="comment">        &lt;property&gt;</span></span><br><span class="line"><span class="comment">          &lt;name&gt;target-env&lt;/name&gt;</span></span><br><span class="line"><span class="comment">          &lt;value&gt;dev&lt;/value&gt;</span></span><br><span class="line"><span class="comment">        &lt;/property&gt;</span></span><br><span class="line"><span class="comment">      &lt;/activation&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;properties&gt;</span></span><br><span class="line"><span class="comment">        &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt;</span></span><br><span class="line"><span class="comment">      &lt;/properties&gt;</span></span><br><span class="line"><span class="comment">    &lt;/profile&gt;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- activeProfiles</span></span><br><span class="line"><span class="comment">   | List of profiles that are active for all builds.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">  &lt;activeProfiles&gt;</span></span><br><span class="line"><span class="comment">    &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt;</span></span><br><span class="line"><span class="comment">    &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;</span></span><br><span class="line"><span class="comment">  &lt;/activeProfiles&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Maven-配置详解"><a href="#Maven-配置详解" class="headerlink" title="Maven 配置详解"></a>Maven 配置详解</h1><p>pom.xml 的基本结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ls.mavendemo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-world<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hello-world<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先看一下各个标签的含义：</p><p><project> ：POM 的根元素，定义了一些POM相关的规范。<br><modelVersion>: POM版本号，我们用的是 Maven3 这里只能是4.0.0<br><groupId> <artifactId> <version>：项目的坐标，用于确定一个唯一的项目</version></artifactId></groupId></modelVersion></project></p><ul><li><code>&lt;groupId&gt;</code>：指的是当前构建隶属的实际项目，一般是 公司的网址倒序 + 项目名</li><li><code>&lt;artifactId&gt;</code>：一般是指的当前项目中的其中一个模块</li><li><code>&lt;version&gt;</code>：当前项目的版本号</li></ul><p>Maven 的版本号规则实际上也是业界的通过规则，它的定义方式如下：</p><p><code>&#123;主版本号&#125;.&#123;次版本号&#125;.&#123;增量版本号&#125;-&#123;里程碑版本&#125;</code><br><strong>主版本号：</strong>一般是指的当前的项目有了重大的架构变动，版本之间几乎完全不兼容，例如：最近出的 SpringBoot3 就已经放弃了Java8，如果不升级 JDK的话，还是只能使用SpringBoot2<br><strong>次版本号：</strong>一般是指的项目的迭代版本，这种版本会修复大量的bug，带来一些小的新特性等，但是没有什么架构上的重大变化。<br><strong>增量版本号：</strong>一般是用于修复一些紧急bug，改动量很小时，可以使用增量版本号。<br><strong>里程碑版本：</strong>就是项目的当前版本处于一个什么样的阶段了，常见的里程碑版本有 SNAPSHOT，alpha，beta，release，GA 等。</p><ul><li>SNAPSHOT：开发版，此时会存在大量的代码变动</li><li>alpha和beta分别对应的是内测版与公测版，属于不稳定版本，使用的时候非常容易踩坑，所以一般只用于demo体验，在正式环境中不能使用。</li><li>release和GA都属于是稳定的正式版本，可以在正式环境中使用。</li></ul><p><name>：当前项目的名称<br><dependencies>：当前项目引入的依赖<br><dependency>：单个需要引入的具体的依赖包<br><scope>：依赖的范围，常见的有 compile 和 test，不同的范围起到包隔离的作用</scope></dependency></dependencies></name></p><h2 id="Maven-的依赖"><a href="#Maven-的依赖" class="headerlink" title="Maven 的依赖"></a>Maven 的依赖</h2><p>来看一下完整的依赖配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--type 指的的当前引入的构件类型，默认为 jar --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span><span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span><span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>通过<code>pom.xml</code> 分别描述 A、B 构建的依赖关系：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A 依赖 B --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ls.mavendemo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- B 依赖 C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ls.mavendemo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，A 可以使用 C 里面打包的代码。</p><p>在上面的依赖配置基础上，如果我们不想将 C 传递给 A，则可以在 B 引入 C 的时候，将其设置为可选依赖：</p><p>引入的依赖如果标记为 <code>optional</code> 则不再向上传递，此时 A 不能再直接使用 C中的代码，可以选依赖在 <code>pom.xml</code> 中表示为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- B 依赖 C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ls.mavendemo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>为什么会需要禁止依赖传递？</p></blockquote><p>举个简单的开发例子，我们在一个 WEB 项目的开发中，将 service 层与 dao 分别拆成了两个构件，service 包依赖 dao 包，但是 service 中只需要使用我们写的主代码，而不需要使用例如数据库驱动、JDBC、ORM框架等依赖，我们就可以在 dao 中使用<optional>禁止这些持久化相关的包向上传递到service。</optional></p><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>依赖范围在 pom.xml 中使用 <scope></scope> 来表示，有5种选项：</p><ul><li>compile：默认选项，也是最常用的选项，在编译、运行、测试的classpath中有引入；依赖范围在向上传递的时候，间接依赖于直接依赖的范围一致</li><li>provided：只在编译、测试引入，运行时不引入，例如：lombok；依赖范围不会向上传递</li><li>runtime：只在运行、测试引入，编译期不引入，例如：mysql-connector-java；依赖范围可向上传递，直接依赖为<code>compile</code>时，间接依赖的范围依然是<code>runtime</code></li><li>test：只在测试中有效，例如：JUnit；依赖范围不会向上传递</li><li>system：与provided相同，但是需要手动指定依赖文件路径（system会破坏可移植性，不推荐使用）</li></ul><h3 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h3><p><strong>直接依赖：</strong>在同一个 pom.xml 下，后声明的依赖会覆盖先声明的依赖。</p><p><strong>间接依赖：</strong>在不同的 pom.xml 下，依赖路径最短的那个依赖会生效，也就是<strong>就近原则</strong>。</p><p>有时候我们需要手动的排除一部分传递性的依赖，然后再定义我们需要的依赖，举个简单的例子：</p><p>我们在 spring-boot 的项目中使用 redis，首先需要引入一个 starter，这个 starter 中又依赖了 <code>lettuce</code> 这个客户端，此时，我们不想使用这个客户端，想切换成 <code>jedis</code>，那么我们就可以使用<code>exclusions</code> 将 <code>lettuce</code> 排除掉。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注：这里的exclusion 中不需要使用版本号。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后再引入 <code>jedis</code> 的依赖就可以了。</p><h1 id="Maven-的继承与聚合"><a href="#Maven-的继承与聚合" class="headerlink" title="Maven 的继承与聚合"></a>Maven 的继承与聚合</h1><h2 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h2><p>所有的 pom.xml 文件都会默认继承 super pom，在 super pom 中定义了这么几个配置：</p><ul><li><p>构件与插件仓库的地址</p></li><li><p>源码、测试代码以及资源文件resources的默认路径</p></li><li><p>编译及打包后的文件路径</p></li></ul><p>这也是为什么我们创建一个Maven项目之后，只要在 Maven 约定好的路径中编写我们的代码，其他的几乎什么都不用配置，就可以直接进行构建，也是一种约定优于配置的思想体现。</p><p>super pom 的位置在Maven主目录的lib文件夹下面，找到一个叫maven-model-builder.jar 的文件，在这个 jar 包的\org\apache\maven\model\pom-4.0.0.xml 路径下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>never<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/test-classes<span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/scripts<span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/test/java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/test/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="手动引入自定义父POM"><a href="#手动引入自定义父POM" class="headerlink" title="手动引入自定义父POM"></a>手动引入自定义父POM</h3><p>父 <code>pom</code> 的引入语法很简单，在<code>parent</code>标签中添加构件坐标即可，类似于<code>dependency</code>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- relativePath 指的是父 pom.xml 所在的相对路径，默认值是 ../pom.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span><span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子模块会优先从上级目录中查找<code>pom.xml</code>，如果查不到则到<strong>本地仓库</strong>中查找，如果还是查不到则会从远程仓库中查找。</p><h2 id="模块的聚合"><a href="#模块的聚合" class="headerlink" title="模块的聚合"></a>模块的聚合</h2><p>demo-a 依赖 demo-b， demo-b 依赖 demo-c , 在这种情况下，我们需要先 install c ，再 install b ，最后再构建 a，执行起来非常麻烦，为了处理这个问题，Maven 引入了聚合机制，可以将这三个模块聚合在一起，一次性完成构建。</p><p>聚合的语法也非常简单，只需要在父目录的 <code>pom.xml</code> 中添加 <code>&lt;modules&gt;</code> 即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-a<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-b<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-c<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;module&gt;</code> 中填写的并不是 <code>artifactId</code>，而是需要被聚合的模块的名称。</p><h3 id="反应堆-reactor"><a href="#反应堆-reactor" class="headerlink" title="反应堆(reactor)"></a>反应堆(reactor)</h3><p>Maven 的反应堆是将多个模块的项目按照一定的顺序进行构建。</p><p>当我们执行install或package语句时，maven先构建的是配置了聚合关系的<strong>聚合模块</strong>，然后才是子模块。子模块构建的时候会按照被依赖的顺序，由底层向上层进行构建。因此，我们的模块之间不能出现循环依赖的情况，假如在<code>demo-c</code>中引入<code>demo-a</code>的依赖，此时构建就会报错。</p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>Maven配置会把子模块中使用到的<strong>依赖</strong>以及<strong>版本号</strong>等，抽取到父模块中由子模块直接继承。</p><p>父pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql-connector-java.verison</span>&gt;</span>8.0.29<span class="tag">&lt;/<span class="name">mysql-connector-java.verison</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector-java.verison&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子pom.xml可不声明依赖版本，直接继承父pom.xml的版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Maven-的生命周期"><a href="#Maven-的生命周期" class="headerlink" title="Maven 的生命周期"></a>Maven 的生命周期</h1><p>Maven 的生命周期有三个，分别是<code>clean</code>、<code>default</code>、<code>site</code>。</p><ul><li>clean：默认是清除target目录中的所有文件，避免将历史版本打到新的包中造成一些不在预期中的问题</li><li>process-resources：将资源文件src&#x2F;main&#x2F;resources下的文件复制到target&#x2F;classes目录中。</li><li>compile：将src&#x2F;main&#x2F;java下的代码编译成 class 文件，也放到target&#x2F;classes目录中。</li><li>process-test-resources：将资源文件src&#x2F;test&#x2F;resources下的文件复制到target&#x2F;test-classes目录中。</li><li>test-compile：将src&#x2F;test&#x2F;java下的代码编译成 class 文件，也放到target&#x2F;test-classes目录中。</li><li>test：运行单元测试并在target&#x2F;surefire-reports中生成测试报告。</li><li>package：将资源文件、class文件、pom文件打包成一个jar包。</li><li>install：将生成的jar包推送到本地仓库中。</li><li>deploy：将生成的jar包推送到远程仓库中。</li></ul><p>执行构建时，会按照<strong>阶段</strong>顺序从上到下的执行，但只有绑定了<strong>插件目标</strong>的<strong>阶段</strong>才会执行</p><p>可以在通过<code>&lt;plugin&gt;</code>标签引入插件，通过<code>&lt;excutions&gt;</code>来定义执行计划，通过<code>&lt;phase&gt;</code>与<code>&lt;goal&gt;</code>绑定<strong>阶段</strong>与<strong>插件模板</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--源码插件引入--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--执行计划--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--在哪个生命周期阶段执行--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--执行别名--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>build-source<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件目标--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Maven-私服"><a href="#Maven-私服" class="headerlink" title="Maven 私服"></a>Maven 私服</h1><p>Maven 的仓库只有两种类型：<strong>本地仓库</strong>、<strong>远程仓库</strong>。</p><p>对于 远程仓库 来说，有几种特殊的子类型，最特殊的就是 Maven 的 中央仓库，这个是 Maven 提供的官方仓库，我们可以在里面找到市面上的几乎任何一个开源构件。除了中央仓库之前，还有其他的公共仓库，例如：JBoss的仓库，阿里云、腾讯云的镜像仓库等。</p><p>另外一种就是我们接下来要讲到的私服了，私服是假设在局域网中的仓库服务，也可以看作是对公用远程仓库的代理。</p><h2 id="私服-Nexus"><a href="#私服-Nexus" class="headerlink" title="私服 Nexus"></a>私服 Nexus</h2><p>本地的开发电脑在引入某个依赖的时候，可以<strong>先从私服查找</strong>，如果私服没有找到再去<strong>公用仓库</strong>下载，同时，也允许我们将开发好的某些构件上传到私服中，供其他的开发者下载使用。</p><p>私服有以下优势：</p><ul><li>节省带宽，增加构件的下载速度，同时也增加了仓库的稳定性。<br>在同一个局域网中，只要有一个开发者引入了某个构件，触发了私服从公用仓库中下载构件后，私服就会将这构件缓存到私服所在的服务器中。此时，再有其他的开发者要使用这个构件，就能够直接从局域网下载了，局域网相对于公网，更快更稳定。</li><li>可以上传公共仓库中没有的构件，与同一局域网中的其他开发者共享。</li></ul><h2 id="Docker-安装私服"><a href="#Docker-安装私服" class="headerlink" title="Docker 安装私服"></a>Docker 安装私服</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>在 docker-desktop 中找到 sonatype&#x2F;nexus3 这个镜像，拉取一个版本下来。</p><p>打开 powershell，执行以下命令启动：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker volume create <span class="literal">--name</span> nexus<span class="literal">-data</span></span><br><span class="line"><span class="comment"># 将容器的8081端口映射到宿主机的8082端口</span></span><br><span class="line">docker run <span class="literal">-dp</span> <span class="number">8082</span>:<span class="number">8081</span> <span class="literal">--name</span> nexus <span class="literal">-v</span> nexus<span class="literal">-data</span>:/nexus<span class="literal">-data</span> sonatype/nexus3</span><br></pre></td></tr></table></figure><p>打开 nexus 管理台</p><p><img src="https://i0.hdslb.com/bfs/article/4dd60622c59e64e007a2075e55c20cfe171301454.png" alt="image-20240119094827382"></p><p>进入到 nexus 容器里，进入<code>sonatype-work/nexus3</code>文件夹，找到 admin.password，里面保存着初始密码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec <span class="literal">-it</span> nexus bash</span><br></pre></td></tr></table></figure><p>获取到密码之后，回到网页上，点击右上角的 sign in ，使用 admin 登录，接下来会进入一个引导流程，会做下面两个配置：</p><p>修改密码：这里直接改成admin123<br>配置是否允许匿名登录：即后面使用Maven连接私服的时候是否需要使用密码<br>安全的配置一般都是不允许使用匿名登录的，这里我们选择Disable anonymous access。</p><h3 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h3><p>登录成功之后，我们需要在私服中配置国内的公用仓库作为私服下载构件的下载源，在这之前，我们先看一下默认的仓库配置。打开<code>Server administration and configuration</code>进行配置，也就是标题栏上面那个齿轮，然后打开<code>Repositores</code>：</p><p><img src="https://i0.hdslb.com/bfs/article/c8dd78d0ecd1cfbca8df0f18771a397d171301454.png" alt="image-20240119105708923"></p><p><strong>Type:</strong></p><ul><li>proxy：代理仓库，用来代理中央仓库或其他的远程公用仓库。</li><li>hosted：用来保存我们在局域网中发布的构件，也就是私有仓库。</li><li>group：仓库分组，里面可以配置多个仓库，并指定仓库访问的优先级。</li></ul><p><strong>Name:</strong></p><ul><li>maven-release：存放非SNAPSHOT的构件。</li><li>maven-snapshots：用于存放里程碑版本为SNAPSHOT的构件。</li><li>maven-central：代理Maven中央仓库，这里会缓存从中央仓库下载的构件。</li><li>maven-public：是仓库的分组，这个仓库中配置了上面三个仓库的访问顺序。</li></ul><p>回到仓库列表页面，点击左上角的<code>Create repository</code>，然后选择&#96;maven2(proxy)</p><p><img src="https://i0.hdslb.com/bfs/article/5406b6aa45b35982e0ea5db44dc3a7b6171301454.png" alt="image-20240119111324927"></p><p>ali_repo 配置如下：</p><p><img src="https://i0.hdslb.com/bfs/article/baa1125bb3ca91494e5186f3dabbd3c6171301454.png" alt="image-20240119111757956"></p><p>然后打开<code>maven_public</code>，将<code>ali_repo</code>配置上去：</p><p><img src="https://i0.hdslb.com/bfs/article/b51abb55934afd94a004482f6740e411171301454.png" alt="image-20240119112013042"></p><p>将ali_repo放到 <code>snapshots</code> 与 <code>maven-central</code> 之间</p><p><img src="https://i0.hdslb.com/bfs/article/671f04680c99606e665a25f9884b86c5171301454.png" alt="image-20240119151424667"></p><p>如果是正式环境使用的话，还需要对新建角色<code>role</code>，并针对每一个开发者都创建一个用户<code>user</code></p><h3 id="私服的使用"><a href="#私服的使用" class="headerlink" title="私服的使用"></a>私服的使用</h3><h4 id="修改Maven配置"><a href="#修改Maven配置" class="headerlink" title="修改Maven配置"></a>修改Maven配置</h4><p>先修改<code>setting.xml</code>的两个配置，让Maven可以连接上私服</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后是镜像配置，这里的<code>url</code>配置成上面所说的<code>maven-public</code>地址：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8082/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：两个配置中的<code>id</code>需要保持一致</p><h4 id="从私服中下载构件"><a href="#从私服中下载构件" class="headerlink" title="从私服中下载构件"></a>从私服中下载构件</h4><p>尝试引入一个<code>spring-core</code>的jar包（一定本地仓库中没有的，不然不会触发从私服中拉取），去查看私服中是否进行了下载：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以在私服上成功看到下载下来的依赖</p><p><img src="https://i0.hdslb.com/bfs/article/5c06d75e2d708a28cc854c893a4dd827171301454.png" alt="image-20240119151253203"></p><h4 id="推送构件到私服"><a href="#推送构件到私服" class="headerlink" title="推送构件到私服"></a>推送构件到私服</h4><p>如果要把自定义的构件发布到仓库中，需要使用以下两个指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发布到本地仓库</span></span><br><span class="line">mvn clean install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发布到远程仓库</span></span><br><span class="line">mvn clean deploy</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要忽略<span class="built_in">test</span></span> </span><br><span class="line">mvn clean deploy -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>在 pom.xml 中配置将构件推送到哪个仓库中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8082/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8082/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>成功在私服上看到我们自定义的构件</p><p><img src="https://i0.hdslb.com/bfs/article/22a28009beb63ae94afd773eaf10e214171301454.png" alt="image-20240119153656855"></p><h4 id="打包源码"><a href="#打包源码" class="headerlink" title="打包源码"></a>打包源码</h4><p>在开发协作中，有时候还需要将源码发布到私服中以便其他开发者下载，源码中包含了注释和接口说明，更有利于协作，例如：api包、封装的工具包、基础架构包等。</p><p>但是Maven的默认生命周期中没有加入打包源码的插件，所以需要我们自行引入，在<code>plugins</code>标签中加入插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--源码插件引入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--执行计划--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--在生命周期的哪个阶段执行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新打包完成之后，查看Maven仓库会发现里面多了一个<code>xxx-sources.jar</code>的源码包。</p><p><img src="https://i0.hdslb.com/bfs/article/143c582bccfda3d50cceeff505067e95171301454.png" alt="image-20240119154543318"></p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSO单点登录</title>
      <link href="/2024/01/03/SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>/2024/01/03/SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是SSO"><a href="#什么是SSO" class="headerlink" title="什么是SSO"></a>什么是SSO</h1><p>SSO( Single Sign On)，即单点登录。是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分。</p><p>简单来说，在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录；用户只需注销一次，各个系统即可感知该用户已经注销。</p><h1 id="单系统登录"><a href="#单系统登录" class="headerlink" title="单系统登录"></a>单系统登录</h1><p>众所周知，HTTP是<strong>无状态</strong>的协议，这意味着<strong>服务器无法确认用户的信息</strong>。于是乎，W3C就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是<strong>Cookie</strong>。</p><p>如果说Cookie是检查用户身上的”通行证“来确认用户的身份，那么Session就是通过检查服务器上的”客户明细表“来确认用户的身份的。<strong>Session相当于在服务器中建立了一份“客户明细表”</strong>。</p><p>HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一个用户。于是乎：服务器向用户浏览器发送了一个名为JESSIONID的Cookie，它的值是Session的id值。<strong>其实Session是依据Cookie来识别是否是同一个用户</strong>。</p><blockquote><p>虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？</p></blockquote><p>单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie</p><p>既然这样，为什么不将web应用群中所有子系统的域名统一在一个顶级域名下，例如“*.baidu.com”，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。</p><p>共享cookie的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间；第三，cookie本身不安全。</p><h1 id="多系统登录的问题和解决方式"><a href="#多系统登录的问题和解决方式" class="headerlink" title="多系统登录的问题和解决方式"></a>多系统登录的问题和解决方式</h1><h2 id="Session-不共享问题"><a href="#Session-不共享问题" class="headerlink" title="Session 不共享问题"></a>Session 不共享问题</h2><p>单系统登录功能主要是用Session保存用户信息来实现的，但我们清楚的是：多系统即可能有多个Tomcat，而Session是依赖当前系统的Tomcat，所以系统A的Session和系统B的Session是<strong>不共享</strong>的。</p><p>解决系统之间Session不共享问题有一下几种方案：</p><ul><li>Tomcat集群Session全局复制（集群内每个tomcat的session完全同步）【会影响集群的性能呢，不建议】</li><li>根据请求的IP进行<strong>Hash映射</strong>到对应的机器上（这就相当于请求的IP一直会访问同一个服务器）【如果服务器宕机了，会丢失了一大部分Session的数据，不建议】</li><li>把Session数据放在Redis中（使用Redis模拟Session）【<strong>建议</strong>】</li></ul><h2 id="Cookie-跨域问题"><a href="#Cookie-跨域问题" class="headerlink" title="Cookie 跨域问题"></a>Cookie 跨域问题</h2><p>我们请求<code>&lt;https://www.google.com/&gt;</code>时，浏览器会自动把<code>google.com</code>的Cookie带过去给<code>google</code>的服务器，而不会把<code>&lt;https://www.baidu.com/&gt;</code>的Cookie带过去给<code>google</code>的服务器。</p><p>这就意味着，<strong>由于域名不同</strong>，用户向系统A登录后，系统A返回给浏览器的Cookie，用户再请求系统B的时候不会将系统A的Cookie带过去。</p><p>针对Cookie存在跨域问题，有几种解决方案：</p><ol><li>服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析出来，此后请求都把这个Token带上就行了</li><li>多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。</li><li>将Token保存在SessionStroage中（不依赖Cookie就没有跨域的问题了）</li></ol><h2 id="SSO-CAS"><a href="#SSO-CAS" class="headerlink" title="SSO-CAS"></a>SSO-CAS</h2><p>CAS （Central Authentication Service）</p><p>sso认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立<strong>全局会话（生成一份Token，写到Cookie中，保存在浏览器上）</strong>。随后，认证中心<strong>重定向回系统A</strong>，并把Token携带过去给系统A。</p><p>接着，系统A去sso认证中心验证这个Token是否正确，如果正确，则系统A和用户建立局部会话（<strong>创建Session</strong>）。到此，系统A和用户已经是登录状态了。</p><p>此时，用户想要访问系统B<code>www.java4y.com</code>受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统B<code>www.java4y.com</code>发现用户并没有登录，于是<strong>重定向到sso认证中心，并将自己的地址作为参数</strong>。</p><p>注意，因为之前用户与认证中心<code>www.sso.com</code>已经建立了全局会话（当时已经把Cookie保存到浏览器上了），所以这次系统B<strong>重定向</strong>到认证中心<code>www.sso.com</code>是可以带上Cookie的。</p><p>认证中心<strong>根据带过来的Cookie</strong>发现已经与用户建立了全局会话了，认证中心<strong>重定向回系统B</strong>，并把Token携带过去给系统B。</p><p>接着，系统B去sso认证中心验证这个Token是否正确，如果正确，则系统B和用户建立局部会话（<strong>创建Session</strong>）。到此，系统B和用户已经是登录状态了。</p><p>其实SSO认证中心就类似一个<strong>中转站</strong>。</p><p><img src="https://i0.hdslb.com/bfs/article/48fd7714fdcf677dd1f444901a96a874171301454.png" alt="image-20240207114043185"></p><h2 id="SSO-JWT"><a href="#SSO-JWT" class="headerlink" title="SSO-JWT"></a>SSO-JWT</h2><p>JWT（JSON Web Token）是一种轻量级的开放标准（RFC 7519），用于在各方之间安全地传输信息。在SSO系统中，JWT被广泛应用于认证和授权，可以实现基于令牌的单点登录（SSO）。</p><p>JWT是一种自包含的令牌，它由三部分组成：头部、载荷和签名。头部包含了JWT类型和使用的加密算法；载荷包含了JWT所包含的信息，如用户身份、角色、权限等；签名则用于验证JWT的真实性和完整性。</p><p>在SSO系统中，JWT通常用于跨域认证和授权，实现以下流程：</p><ol><li>用户在第一次登录时，SSO服务器会生成一个JWT令牌，并将该令牌发送给用户。</li><li>用户访问其他应用程序或系统时，将JWT令牌随请求一同发送给目标应用程序或系统。</li><li>目标应用程序或系统通过验证JWT令牌的签名，确认该令牌是由SSO服务器颁发的，并可以解析出JWT中的用户信息。</li><li>目标应用程序或系统可以根据JWT中的用户信息进行身份验证和授权，让用户在不同的应用程序或系统之间实现无缝切换。</li></ol><h2 id="SSO-企微认证"><a href="#SSO-企微认证" class="headerlink" title="SSO-企微认证"></a>SSO-企微认证</h2><p>PaaS企微认证SSO是根据企业微信提供了OAuth的<a href="https://developer.work.weixin.qq.com/document/path/91335">授权登录方式</a>，可以让从企业微信终端打开的网页获取成员的身份信息，从而免去登录的环节。企业应用中的URL链接（包括自定义菜单或者消息中的链接），均可通过OAuth2.0验证接口来获取成员的UserId身份信息。</p><p>企微SSO再根据UserId查询用户表数据找到企微userid对应的用户信息，根据用户信息颁发JWT-token.</p><h2 id="SSO-微信小程序认证"><a href="#SSO-微信小程序认证" class="headerlink" title="SSO-微信小程序认证"></a>SSO-微信小程序认证</h2><p>PaaS微信小程序认证是根据<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">微信小程序登录</a> 调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。<br>调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 、 用户在微信开放平台帐号下的唯一标识UnionID（若当前小程序已绑定到微信开放平台帐号） 和 会话密钥 session_key，根据OpenID和UnionID 生成登录凭证。</p><h2 id="SSO-OAuth-2-0"><a href="#SSO-OAuth-2-0" class="headerlink" title="SSO-OAuth 2.0"></a>SSO-OAuth 2.0</h2><p>系统对接SSO-OAuth2.0,通过sso单点登录获取授权码并跳转到自己的系统,用授权码code获取用户信息比对自己的系统用户数据,以确认登录成功。</p><h3 id="接入流程"><a href="#接入流程" class="headerlink" title="接入流程"></a>接入流程</h3><p><img src="https://i0.hdslb.com/bfs/article/e2a56f673631318ced90a2014b4b5ef9171301454.png" alt="image-20240122114748174"></p><ol><li>用户访问第三方服务，第三方服务通过构造OAuth2链接（参数包括当前第三方服务的身份ID，以及重定向URI），将用户引导到认证服务器的授权页</li><li>用户选择是否同意授权</li><li>若用户同意授权，则认证服务器将用户重定向到第一步指定的重定向URI，同时附上一个授权码。</li><li>第三方服务收到授权码，带上授权码来源的重定向URI，并向认证服务器申请凭证。</li><li>认证服务器检查授权码和重定向URI的有效性，通过后颁发AccessToken（调用凭证）,根据AccessToken和授权码可获得用户数据</li></ol><p>OAuth2.0协议支持多种授权模式，如授权码模式、隐式授权模式、密码凭证授权模式、客户端模式等，每种模式都有不同的应用场景和安全性。</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>授权码模式</td><td>第三方应用先申请一个授权码code，然后根据code获取令牌accessToken</td></tr><tr><td>隐式授权模式</td><td>有些web应用为纯前端应用，该模式允许直接向前端颁发令牌</td></tr><tr><td>密码凭证授权模式</td><td>如果你高度信任某个应用，RFC 6379也允许用户把用户名和密码直接告诉该应用</td></tr><tr><td>客户端凭证模式</td><td>指客户端以自己的名义，而不是以用户的名义，向“服务提供商”进行认证</td></tr></tbody></table><h3 id="OAuth2-0协议的优点"><a href="#OAuth2-0协议的优点" class="headerlink" title="OAuth2.0协议的优点"></a>OAuth2.0协议的优点</h3><ol><li>安全性：OAuth2.0协议通过授权码、访问令牌等机制，保证了用户的资源不会被未经授权的第三方应用程序访问。</li><li>可扩展性：OAuth2.0协议支持多种授权模式，可以适用于不同类型的应用程序和系统。</li><li>简单性：OAuth2.0协议是一种简单的授权协议，易于实现和使用。</li><li>可移植性：OAuth2.0协议可以在不同的平台和语言之间使用，可以提高系统的可移植性和互操作性。</li></ol><h2 id="SSO-OIDC"><a href="#SSO-OIDC" class="headerlink" title="SSO-OIDC"></a>SSO-OIDC</h2><p>英文全称为 OpenID Connect，缩写为 OIDC，是一个基于 OAuth2 协议的身份认证标准协议。它在 OAuth2 上构建了一个身份层，提供完善的身份认证功能。</p><p>OIDC的交互时序图如下：</p><p><img src="https://i0.hdslb.com/bfs/article/9823bb275a6674b61e6a5940fab05b8b171301454.png" alt="image-20240207144926930"></p>]]></content>
      
      
      <categories>
          
          <category> SSO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSO </tag>
            
            <tag> OAuth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSE</title>
      <link href="/2024/01/02/SSE/"/>
      <url>/2024/01/02/SSE/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Server-Sent Events 服务器推送事件，简称 SSE，是一种服务端实时<strong>主动</strong>向浏览器推送消息的技术。</p><p>SSE运行在HTTP协议之上，它允许服务器以事件流（Event Stream）的形式将数据发送给客户端。客户端通过建立持久化的HTTP连接，并监听这个事件流，从而可以实时接收到服务器推送的数据。</p><h1 id="SSE用途"><a href="#SSE用途" class="headerlink" title="SSE用途"></a>SSE用途</h1><p>ChatGPT 是一个基于深度学习的大型语言模型，处理自然语言需要大量的计算资源和时间，响应速度肯定比普通的读数据库要慢的多，普通 http 接口等待时间过长，显然并不合适。对于这种单项对话场景，ChagtGPT 将先计算出的数据“推送”给用户，边计算边返回，避免用户因为等待时间过长关闭页面。而这，可以采用 SSE 技术。</p><p>SSE 可以在 Web 应用程序中实现诸如股票在线数据、日志推送、聊天室实时人数等即时数据推送功能。股票📈k线的实时变化，彩票趋势走向，以及工业数据实时监控（受限于页面的数据获取范围面）和日志推送和CI&#x2F;CD工作流进度的推送等相关单向推送需求的场景。</p><p>需要注意的是，SSE 并不是适用于所有的实时推送场景。在需要高并发、高吞吐量和低延迟的场景下，WebSockets 可能更加适合。而在需要更轻量级的推送场景下，SSE 可能更加适合。因此，在选择即时更新方案时，需要根据具体的需求和场景进行选择。</p><h1 id="SSE与-WebSocket-比较"><a href="#SSE与-WebSocket-比较" class="headerlink" title="SSE与 WebSocket 比较"></a>SSE与 WebSocket 比较</h1><table><thead><tr><th>WebSocket</th><th>SSE</th></tr></thead><tbody><tr><td>基于TCP长连接通讯</td><td>基于HTTP协议</td></tr><tr><td>全双工，可以同时发送和接收消息</td><td>单工，只能服务端单向发送信息</td></tr><tr><td>相对复杂</td><td>轻量级，使用简单</td></tr><tr><td>不在协议范围内，需手动实现</td><td>内置断线重连和消息追踪功能</td></tr><tr><td>类型广泛</td><td>文本或使用 Base64 编码和 gzip 压缩的二进制消息</td></tr><tr><td>不支持自定义事件类型</td><td>支持自定义事件类型</td></tr><tr><td>连接数无限制</td><td>连接数 HTTP&#x2F;1.1 6个，HTTP&#x2F;2 可协商（默认100）</td></tr></tbody></table><h1 id="SSE的实现原理"><a href="#SSE的实现原理" class="headerlink" title="SSE的实现原理"></a>SSE的实现原理</h1><p>以下是SSE（Server-Sent Events）的实现原理：</p><ul><li>连接建立：通常情况下，客户端（如浏览器）通过发送HTTP GET请求到服务器来请求建立一个SSE连接。</li><li>服务器响应：一旦服务器接收到请求，它将返回一个HTTP响应，该响应的状态码为200，内容类型（Content-Type）设置为”text&#x2F;event-stream”。</li><li>数据推送：服务器可以通过已经建立的连接向客户端推送数据。每次推送的数据被称作一个事件（Event）。每个事件由一个或多个以”\n\n”分隔的数据块组成。每个数据块都是一行文本，可能包含一个以”:”开头的注释行、以”data:”开头的数据行，或者以”id:”和”event:”开头的行来指定事件ID和事件类型。</li><li>客户端处理：当客户端接收到服务器推送的事件后，它会触发相应的JavaScript事件处理器来处理这些事件。</li><li>重连：如果连接断开，客户端会自动尝试重新连接。如果服务器在事件中指定了ID，那么在重新连接时，客户端会发送一个”Last-Event-ID”的HTTP头部信息到服务器，告诉服务器客户端接收到的最后一个事件的ID。根据这个信息，服务器可以决定从哪个事件开始重新发送数据。</li></ul><p>总结起来，SSE使用了基于文本和HTTP协议的简单机制，使得服务器能够实时地将数据推送到客户端，而无需客户端频繁地发起新的请求。</p><h1 id="使用SSE的注意事项"><a href="#使用SSE的注意事项" class="headerlink" title="使用SSE的注意事项"></a>使用SSE的注意事项</h1><p>以下是在使用SSE（Server-Sent Events）技术进行实时数据推送时需要注意的几个关键点：</p><ul><li>异步处理：由于SSE基于长连接的机制，因此数据推送过程可能会持续较长时间。为了防止服务器线程被阻塞，建议采用异步方式处理SSE请求。例如，可以在控制器方法中使用@Async注解或利用CompletableFuture等异步编程方式。</li><li>超时处理：SSE连接可能会因网络中断、客户端关闭等原因而超时。为了避免无效连接占据服务器资源，建议设置超时时间并处理超时情况。例如，可以利用SseEmitter对象的setTimeout()方法设定超时时间，并通过onTimeout()方法处理超时逻辑。</li><li>异常处理：在实际应用中，可能会遇到网络异常、数据推送失败等问题。这种情况下，可以使用SseEmitter对象的completeWithError()方法将异常信息发送给客户端，并在客户端通过eventSource.onerror事件进行处理。</li><li>内存管理：在使用SseEmitter时，需要特别注意内存管理问题，尤其是在大量并发连接的场景下。当客户端断开连接后，务必及时释放SseEmitter对象，以避免资源泄漏和内存溢出。</li><li>并发性能：SSE的并发连接数可能对服务器性能产生影响。如果需要处理大量并发连接，可以考虑使用线程池或其他异步处理方式，以最大化服务器资源利用。</li><li>客户端兼容性：虽然大多数现代浏览器都支持SSE，但一些旧版本的浏览器可能不支持。因此，在使用SSE时，需要确保目标客户端对其有良好的支持，或者提供备选的实时数据推送机制。</li></ul><h1 id="SpringBoot-集成-SSE"><a href="#SpringBoot-集成-SSE" class="headerlink" title="SpringBoot 集成 SSE"></a>SpringBoot 集成 SSE</h1><p>下面给出一个 SpringBoot 集成 SSE 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SseEmitter <span class="title function_">streamChatCompletions</span><span class="params">(ChatCompletionRequest completionRequest, String tenantToken)</span> &#123;</span><br><span class="line">        <span class="comment">// 发起OpenaiStream请求，并使用sse发送给客户端</span></span><br><span class="line">      List&lt;ChatCompletionChunk&gt; chunks = Lists.newArrayList();</span><br><span class="line">      Flowable&lt;ChatCompletionChunk&gt; flowable = service.streamChatCompletion(completionRequest);</span><br><span class="line">      <span class="type">SseEmitter</span> <span class="variable">sseEmitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SseEmitter</span>(<span class="number">120000L</span>);</span><br><span class="line">      <span class="type">AtomicBoolean</span> <span class="variable">isCompleted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">      <span class="comment">// CAS 处理超时情况，避免无效连接持续占据服务器资源</span></span><br><span class="line">      sseEmitter.onTimeout(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (isCompleted.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">              sseEmitter.complete();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">       <span class="comment">// 流数据处理</span></span><br><span class="line">      flowable.subscribe(chatCompletionChunk -&gt; &#123;</span><br><span class="line">          <span class="comment">// 监听数据流</span></span><br><span class="line">          <span class="keyword">if</span> (!Objects.isNull(chatCompletionChunk.getId())) &#123;</span><br><span class="line">              <span class="type">boolean</span> <span class="variable">isStop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">              <span class="keyword">if</span> (chatCompletionChunk != <span class="literal">null</span> &amp;&amp; chatCompletionChunk.getChoices() != <span class="literal">null</span>) &#123;</span><br><span class="line">                  isStop = chatCompletionChunk.getChoices().stream().anyMatch(choice -&gt; choice != <span class="literal">null</span> &amp;&amp; <span class="string">&quot;stop&quot;</span>.equals(choice.getFinishReason()));</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (isStop) &#123;</span><br><span class="line">                  <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> chunks.stream().map(item -&gt; item.getChoices().stream().map(choice -&gt; choice.getMessage().getContent()).filter(Objects::nonNull).collect(Collectors.joining())).collect(Collectors.joining());</span><br><span class="line">                  List&lt;ChatMessage&gt; messages = completionRequest.getMessages();</span><br><span class="line">              &#125;</span><br><span class="line">              chunks.add(chatCompletionChunk);</span><br><span class="line">              sseEmitter.send(chatCompletionChunk);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">100</span>);</span><br><span class="line">              sseEmitter.send(JROpenaiConstant.SSE_DONE);</span><br><span class="line">              <span class="keyword">if</span> (isCompleted.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">                  sseEmitter.complete();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,throwable -&gt; &#123;</span><br><span class="line">          <span class="comment">// 异常处理</span></span><br><span class="line">          <span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> OpenAiHttpException) &#123;</span><br><span class="line">               log.error(<span class="string">&quot;OpenAi异常&quot;</span>);</span><br><span class="line">               sseEmitter.send(Result.failed(throwable.getMessage()));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// other throwable error</span></span><br><span class="line">              log.error(throwable.getMessage(), throwable);</span><br><span class="line">              sseEmitter.send(Result.failed(throwable.getMessage()));</span><br><span class="line">          &#125;</span><br><span class="line">          Thread.sleep(<span class="number">100</span>);</span><br><span class="line">          sseEmitter.send(JROpenaiConstant.SSE_DONE);</span><br><span class="line">          <span class="keyword">if</span> (isCompleted.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">              sseEmitter.complete();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">       <span class="comment">// shutdown okhttp3.Dispatcher</span></span><br><span class="line">      service.shutdownExecutor();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> sseEmitter;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logback的配置和使用</title>
      <link href="/2023/12/28/logback%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/12/28/logback%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="logback-简介"><a href="#logback-简介" class="headerlink" title="logback 简介"></a>logback 简介</h1><blockquote><p>logback 官网：<a href="https://logback.qos.ch/">https://logback.qos.ch/</a></p></blockquote><p>logback 由三个模块组成：</p><ul><li>logback-core</li><li>logback-classic</li><li>logback-access</li></ul><p><code>logback-core</code> 是其它模块的基础设施，其它模块基于它构建，<code>logback-core</code> 提供了一些关键的通用机制。</p><p><code>logback-classic</code> 的地位和作用等同于 <code>Log4J</code>，它也被认为是 <code>Log4J</code> 的一个改进版，并且它实现了简单日志门面 <code>SLF4J</code>；</p><p><code>logback-access</code> 主要作为一个与 <code>Servlet</code> 容器交互的模块，比如说<code>tomcat</code>或者 <code>jetty</code>，提供一些与 <code>HTTP</code> 访问相关的功能。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>接下来会介绍关于 logback 配置文件的配置项。</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>整个 logback.xml 配置文件的结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;glmapper-name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;glmapper-demo&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>$&#123;glmapper-name&#125;<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span> </span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span>&gt;</span></span><br><span class="line">        //xxxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span>&gt;</span></span><br><span class="line">        //xxxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span>             </span><br><span class="line">       //xxxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br></pre></td></tr></table></figure><ul><li><p>scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</p></li><li><p>scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</p></li><li><p>debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</p></li></ul><h3 id="contextName"><a href="#contextName" class="headerlink" title="contextName"></a>contextName</h3><p>logger上下文，默认名称为 “default”。可以使用 contextName 标签设置成其他名字，用于区分不同应用程序。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">contextName</span>&gt;</span>xxl_job<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>用于定义变量标签，name 为变量的名称，value 的值是变量的值。可以用 “${name}” 来使用变量。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志记录器，日期滚动记录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;./logs/xxl-job-admin&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><p>用来设置某一个包或者具体的某一个类的日志打印级别以及指定<code>appender</code>。这里的 level 是向下兼容的，即 DEBUG 级别的也会包含 INFO 级别的日志。</p><p>name:用来指定受此<code>logger</code>约束的某一个包或者具体的某一个类。</p><p>level:用来设置打印级别（<code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>, <code>ALL</code> 和 <code>OFF</code>），还有一个值<code>INHERITED</code>或者同义词<code>NULL</code>，代表强制执行上级的级别。如果没有设置此属性，那么当前<code>logger</code>将会继承上级的级别。</p><p>addtivity:用来描述是否向上级<code>logger</code>传递打印信息。默认是<code>true</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.xxl.job.executor&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>根logger，也是一种logger，且只有一个level属性。根logger 用于控制 appender 配置的日志等级和输出权限。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 生产环境下，将此级别配置为适合的级别，以免日志文件太多或影响程序性能 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILEERROR&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILEWARN&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILEINFO&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILEALL&quot;</span> /&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 生产环境将请stdout,testfile去掉 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter其实是appender里面的子元素。它作为过滤器存在，执行一个过滤器会有返回DENY，NEUTRAL，ACCEPT三个枚举值中的一个。可以为<code>appender</code> 添加一个或多个过滤器，可以用任意条件对日志进行过滤。<code>appender</code> 有多个过滤器时，按照配置顺序执行。</p><ul><li>DENY：日志将立即被抛弃不再经过其他过滤器</li><li>NEUTRAL：有序列表里的下个过滤器过接着处理日志</li><li>ACCEPT：日志会被立即处理，不再经过剩余过滤器</li></ul><p>filter 还指定了一个 class，class有两个种类：</p><ul><li>ThresholdFilter：临界值过滤器，过滤掉低于临界值的日志。当日志级别等于或高于临界值，过滤器返回 NEUTRAL；当日志级别低于临界值时，日志会被拒绝。</li><li>LevelFilter：级别过滤器，根据日志级别进行过滤。如果日志级别等于配置级别，过滤器会根据 onMatch 和 onMismatch 接收或拒绝日志。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志记录器，日期滚动记录 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILEINFO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">     ......</span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- 此日志文件只记录info级别的 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">level</span>&gt;</span>info<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 如果命中就使用这条规则 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 如果没有命中就禁止这条日志 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="appender"><a href="#appender" class="headerlink" title="appender"></a>appender</h3><p><code>appender</code>是一个日志打印的组件，这里组件里面定义了打印过滤的条件、打印输出方式、滚动策略、编码方式、打印格式等等。但是它只是一个配置，这个配置的开关和打印级别由 logger 或者 root 的 appender-ref 指定某个具体的 appender 控制。</p><h4 id="appender-的种类"><a href="#appender-的种类" class="headerlink" title="appender 的种类"></a>appender 的种类</h4><p><code>appender</code> 有两个属性 <code>name</code>和<code>class</code>;<code>name</code>指定<code>appender</code>名称，<code>class</code>指定<code>appender</code>的全限定名。</p><ul><li>ConsoleAppender：把日志添加到控制台</li><li>FileAppender：把日志添加到文件</li><li>RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。它是FileAppender的子类</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;GLMAPPER-LOGGERONE&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="append-子标签"><a href="#append-子标签" class="headerlink" title="append 子标签"></a>append 子标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是 <code>true</code>，日志被追加到文件结尾，如果是<code>false</code>，清空现存文件，默认是<code>true</code>。</p><h4 id="file-子标签"><a href="#file-子标签" class="headerlink" title="file 子标签"></a>file 子标签</h4><p>file 标签用于指定被写入的文件名，可以是相对也可以是绝对路径，如果上级目录不存在会自动创建，没有默认值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">    $&#123;logging.path&#125;/glmapper-spring-boot/glmapper-loggerone.log</span><br><span class="line"><span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表示当前appender将会将日志写入到<code>$&#123;logging.path&#125;/glmapper-spring-boot/glmapper-loggerone.log</code>这个目录下。</p><h4 id="rollingPolicy-子标签"><a href="#rollingPolicy-子标签" class="headerlink" title="rollingPolicy 子标签"></a>rollingPolicy 子标签</h4><p>这个子标签用来描述滚动策略的。这个只有<code>appender</code>的<code>class</code>是<code>RollingFileAppender</code>时才需要配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 归档的日志文件的路径，例如今天是2013-12-21日志，当前写的日志文件路径为file节点指定，可以将此文件与file指定文件路径设置为不同路径，从而将当前日志文件或归档日志文件置不同的目录。</span></span><br><span class="line"><span class="comment">           而2013-12-21的日志文件在由fileNamePattern指定。%d&#123;yyyy-MM-dd&#125;指定日期格式，%i指定索引 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/all/log-all-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 除按日志记录之外，还配置了日志文件不能超过2M，若超过2M，日志文件会以索引0开始，</span></span><br><span class="line"><span class="comment">           命名日志文件，例如log-error-2013-12-21.0.log --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="TimeBasedRollingPolicy"><a href="#TimeBasedRollingPolicy" class="headerlink" title="TimeBasedRollingPolicy"></a>TimeBasedRollingPolicy</h4><p>最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。这个下面又包括了两个属性：</p><ul><li>FileNamePattern</li><li>maxHistory</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rollingPolicy</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志文件输出的文件名:按天回滚 daily --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">        $&#123;logging.path&#125;/glmapper-spring-boot/glmapper-loggerone.log.%d&#123;yyyy-MM-dd&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的这段配置表明<strong>每天生成一个日志文件，保存30天的日志文件</strong></p><h4 id="FixedWindowRollingPolicy"><a href="#FixedWindowRollingPolicy" class="headerlink" title="FixedWindowRollingPolicy"></a>FixedWindowRollingPolicy</h4><p>根据固定窗口算法重命名文件的滚动策略。</p><h4 id="encoder-子标签"><a href="#encoder-子标签" class="headerlink" title="encoder 子标签"></a>encoder 子标签</h4><p>对记录事件进行格式化。它干了两件事：</p><ul><li>把日志信息转换成字节数组</li><li>把字节数组写入到输出流</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125;</span><br><span class="line">    - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前<code>encoder</code>只有<code>PatternLayoutEncoder</code>一种类型。</p><h1 id="不同日志隔离级别打印"><a href="#不同日志隔离级别打印" class="headerlink" title="不同日志隔离级别打印"></a>不同日志隔离级别打印</h1><h2 id="根据包、类隔离"><a href="#根据包、类隔离" class="headerlink" title="根据包、类隔离"></a>根据包、类隔离</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--此logger约束将.service包下的日志输出到GLMAPPER-SERVICE，错误日志输出到GERROR-APPENDE；GERROR-APPENDE见上面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.glmapper.spring.boot.service&quot;</span> <span class="attr">level</span>=<span class="string">&quot;$&#123;logging.level&#125;&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;GLMAPPER-SERVICE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;GERROR-APPENDER&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--这里指定到了具体的某一个类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.glmapper.spring.boot.task.TestLogTask&quot;</span> <span class="attr">level</span>=<span class="string">&quot;$&#123;logging.level&#125;&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;SCHEDULERTASKLOCK-APPENDER&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ERROR-APPENDER&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="根据环境隔离"><a href="#根据环境隔离" class="headerlink" title="根据环境隔离"></a>根据环境隔离</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;appender-ref ref=&quot;sendErrorMsgAppender&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;sit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;appender-ref ref=&quot;sendErrorMsgAppender&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;uat&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;appender-ref ref=&quot;sendErrorMsgAppender&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;sendErrorMsgAppender&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="logback小实战"><a href="#logback小实战" class="headerlink" title="logback小实战"></a>logback小实战</h1><p>使用 logback 配置将日志定义到自定义输出源，可以拿SpringBoot 整合 logback 发送企微通知作为例子。</p><p>要实现error级别异常日志异常报警，就是要捕获所有的error级别的日志，然后解析出异常数据，调用企业微信接口发送消息即可。</p><p>Logback中的<code>Appender</code>类用来表示日志的输出的目的地。所以我们只需要自定义一个 <code>Appeder</code>，然后在Logback的配置文件中的所有的<code>Logger</code>配置中(或者是所有Error级别的 <code>Logger</code>配置)增加这个自定义的<code>Appeder</code>就可以以拦截所有的(异常)日志。</p><p>首先定义一个企微发送消息的Appender。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendErrorMsgAppender</span> <span class="keyword">extends</span> <span class="title class_">UnsynchronizedAppenderBase</span>&lt;LoggingEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pattern;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PatternLayout layout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Level</span> <span class="variable">nowLevel</span> <span class="operator">=</span> Level.ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(LoggingEvent eventObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventObject == <span class="literal">null</span> || !eventObject.getLevel().isGreaterOrEqual(nowLevel)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>, userAccount = <span class="string">&quot;&quot;</span>, bodyString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (requestAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> requestAttributes.getRequest();</span><br><span class="line"></span><br><span class="line">                url = request.getRequestURI();</span><br><span class="line">                userAccount = getUserinfo(request);</span><br><span class="line">                bodyString = ServletUtil.getBody(request);</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotBlank(bodyString)) &#123;</span><br><span class="line">                    bodyString = JSON.toJSONString(JSON.parse(bodyString));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                logger.info(<span class="string">&quot;url:&#123;&#125;&quot;</span>, url);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.isBlank(eventObject.getFormattedMessage())) &#123;</span><br><span class="line">                <span class="comment">// 没有地址的错误日志不发送直接存储到日志文件即可,避免企业微信页面展示过多的错误信息</span></span><br><span class="line">                logger.info(<span class="string">&quot;lockKey:&#123;&#125;&quot;</span>, eventObject.getLoggerName());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Environment</span> <span class="variable">bean</span> <span class="operator">=</span> SpringUtil.getBean(Environment.class);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">active</span> <span class="operator">=</span> bean.getProperty(<span class="string">&quot;spring.profiles.active&quot;</span>);</span><br><span class="line">            <span class="comment">// dev本地调试异常错误不推送企微</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;prod&quot;</span>.equals(active)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">serverName</span> <span class="operator">=</span> <span class="string">&quot;jr-ai-open-api&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">errorMessage</span> <span class="operator">=</span> layout.doLayout(eventObject);</span><br><span class="line">            <span class="type">String</span> <span class="variable">webHook</span> <span class="operator">=</span> bean.getProperty(<span class="string">&quot;qyWeChat.webHook&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(webHook)) &#123;</span><br><span class="line">                toWechat(webHook, serverName, active, url, userAccount, bodyString, errorMessage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PatternLayout</span> <span class="variable">patternLayout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PatternLayout</span>();</span><br><span class="line">        patternLayout.setContext(context);</span><br><span class="line">        patternLayout.setPattern(getPattern());</span><br><span class="line">        patternLayout.start();</span><br><span class="line">        <span class="built_in">this</span>.layout = patternLayout;</span><br><span class="line">        <span class="built_in">super</span>.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toWechat</span><span class="params">(String robotUrl, String projectName, String environment, String requestUrl, String requestAccount, String requestBody, String errorLog)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">markdownContent</span> <span class="operator">=</span> buildMarkdownContent(projectName, environment, requestUrl, requestAccount, requestBody, errorLog);</span><br><span class="line">        <span class="type">String</span> <span class="variable">markdownMsg</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;msgtype\&quot;: \&quot;markdown\&quot;, \&quot;markdown\&quot;: &#123;\&quot;content\&quot;: &quot;</span> + JSON.toJSONString(markdownContent) + <span class="string">&quot;&#125;&#125;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">CloseableHttpClient</span> <span class="variable">httpclient</span> <span class="operator">=</span> HttpClients.createDefault()) &#123;</span><br><span class="line">            <span class="type">HttpPost</span> <span class="variable">httppost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(robotUrl);</span><br><span class="line">            httppost.addHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line">            httppost.setEntity(<span class="keyword">new</span> <span class="title class_">StringEntity</span>(markdownMsg, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            httpclient.execute(httppost);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">buildMarkdownContent</span><span class="params">(String projectName, String environment, String requestUrl, String requestAccount, String requestBody, String errorLog)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;font color=\&quot;red\&quot;&gt; 【ERROR 通知】  &lt;/font&gt; \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 触发项目：&lt;/font&gt; &lt;font color=\&quot;info\&quot;&gt; &quot;</span> + projectName + <span class="string">&quot;&lt;/font&gt; \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 触发环境：&lt;/font&gt; &lt;font color=\&quot;info\&quot;&gt; &quot;</span> + environment + <span class="string">&quot;&lt;/font&gt; \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 触发时间：&lt;/font&gt; &quot;</span> + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)) + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 请求URL：&lt;/font&gt; &quot;</span> + requestUrl + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 请求账号：&lt;/font&gt; &quot;</span> + requestAccount + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&gt; &lt;font color=\&quot;comment\&quot;&gt; 请求Body：&lt;/font&gt; \n```json\n&quot;</span> + requestBody + <span class="string">&quot;\n```\n\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;font color=&#x27;red&#x27;&gt;【Exception 详情】&lt;/font&gt; \n```json\n&quot;</span> + errorLog + <span class="string">&quot;\n```\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPattern</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pattern = pattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PatternLayout <span class="title function_">getLayout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> layout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLayout</span><span class="params">(PatternLayout layout)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.layout = layout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Level <span class="title function_">getNowLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nowLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNowLevel</span><span class="params">(Level nowLevel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nowLevel = nowLevel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 logback.xml 中定义 SendErrorMsgAppender 的输出源，并指定在生产环境下才输出日志。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;sendErrorMsgAppender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.junrunrenli.proxy.exception.SendErrorMsgAppender&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] [%X&#123;traceId&#125;] [%X&#123;loginName&#125;] %-5level %logger&#123;50&#125; [line:%L]: %ex&#123;10&#125; -%msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.filter.EvaluatorFilter&quot;</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 过滤指定类型日志 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">evaluator</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">expression</span>&gt;</span>return message.contains(&quot;Broken pipe&quot;);<span class="tag">&lt;/<span class="name">expression</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">evaluator</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">OnMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">OnMatch</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">OnMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">OnMismatch</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">OnMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">OnMatch</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">OnMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">OnMismatch</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;sendErrorMsgAppender&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样配置以后，项目中所有使用<code>log.error()</code>方法打印的日志(即error级别日志)都会通过企业微信发出消息报警。</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logback，日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性哈希</title>
      <link href="/2023/12/27/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
      <url>/2023/12/27/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><p>对于经常使用的数据，我们一般会使用 Redis 作为缓存机制，为了实现高可用，使用了3台Redis（没有设置集群，集群至少要6台）。</p><p>使用hash算法，存储的时候根据公式 h &#x3D; hash(key)%机器节点数，h 为 Redis 对应的编号，取数据的时候也根据相同的公式取，因此一定可以从存储的机器中拿到想要的数据。但是使用这种策略可能会存在以下问题：</p><ul><li>假设有一台 Redis 服务器宕机了，此时每个 key 就要按照 h &#x3D; hash(key)%(机器节点数-1) 重新计算</li><li>假设要新增一台 Redis 服务器，此时每个 key 就要按照 h &#x3D; hash(key)%(机器节点数+1) 重新计算</li></ul><p>也就是说，如果服务节点有变更，会导致缓存失效，大量的 key 需要重新计算，在这期间如果有请求进来，就会直接打到数据库上，导致缓存雪崩。</p><h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><p>一致性哈希是讲整个哈希空间组织成一个虚拟的圆环，假设哈希函数 H 的值空间为 [0,2^32-1]（哈希值是32位无符号整形）。</p><p>把服务器按照 IP 或者主机名作为关键字进行哈希，确定服务器在哈希环中的位置。</p><p>再使用哈希函数把数据对象映射到环上，数据从顺时针方向找，遇到的第一个服务器就是它定位到的服务器。</p><p><img src="https://i0.hdslb.com/bfs/article/a41c409530fc27e7ebb2d744f585e22a171301454.png" alt="image-20231228103401543"></p><p>结论：数据1、2存储服务器B上，数据3存储在服务器C上，数据4存储在服务器A上</p><h2 id="容错性和可扩展性"><a href="#容错性和可扩展性" class="headerlink" title="容错性和可扩展性"></a>容错性和可扩展性</h2><p>假如这时候有服务器C宕机了呢？那么只有原本在B和C之间的数据会失效，重新定位到服务器A，其他数据节点的服务器不会发生变化。</p><p><img src="https://i0.hdslb.com/bfs/article/33a772b9eb938f8d2a865da97731ee75171301454.png" alt="image-20231228103647790"></p><p>或者我们想新增一台服务器D呢？那么只有C和D之间的数据会失效，重新定位到服务器D，而其他的数据节点的存储服务器也不会发生任何变化。</p><p><img src="https://i0.hdslb.com/bfs/article/6cb533eae847346c14f72dc43343b8a0171301454.png" alt="image-20231228103831559"></p><p>可以看出，一致性哈希算法对于节点的增减只会有一部分数据需要重新定位，不会导致大量的缓存失效。</p><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>现实的业务场景中，节点不会分布得那么均匀，如果节点较少，可能会出现数据倾斜的情况。</p><p>观察下图，所有的数据全都定位到服务B上，无法实现负载均衡了。</p><p><img src="https://i0.hdslb.com/bfs/article/dc20a553ace0ca99611ae40d9774f23b171301454.png" alt="image-20231228104239560"></p><p>为了解决这种数据存储不平衡的问题，一致性哈希算法引入了虚拟节点机制，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点称为虚拟节点。</p><p><img src="https://i0.hdslb.com/bfs/article/046f08a7f3e7ec5f5a83beadf6c27054171301454.png" alt="image-20231228112641899"></p><p>增加了虚拟节点到实际节点的映射，这样就能解决服务节点少时数据不平均的问题了。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p><h1 id="手撕源码"><a href="#手撕源码" class="headerlink" title="手撕源码"></a>手撕源码</h1><p>介绍完一致性哈希算法的概念和规则，接下来我们从源码的角度分析一致性哈希算法是怎么实现的。</p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>首先确定项目中要使用的哈希算法，其中服务器和数据的映射都依赖哈希算法。</p><p>非加密算法：MurMurHash算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  MurMurHash算法，是非加密HASH算法，性能很高，</span></span><br><span class="line"><span class="comment"> *  比传统的CRC32,MD5，SHA-1（这两个算法都是加密HASH算法，复杂度本身就很高，带来的性能上的损害也不可避免）</span></span><br><span class="line"><span class="comment"> *  等HASH算法要快很多，而且据说这个算法的碰撞率很低.</span></span><br><span class="line"><span class="comment"> *  http://murmurhash.googlepages.com/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">hash</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(key.getBytes());</span><br><span class="line">    <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="number">0x1234ABCD</span>;</span><br><span class="line">    <span class="type">ByteOrder</span> <span class="variable">byteOrder</span> <span class="operator">=</span> buf.order();</span><br><span class="line">    buf.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">    <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0xc6a4a7935bd1e995L</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">h</span> <span class="operator">=</span> seed ^ (buf.remaining() * m);</span><br><span class="line">    <span class="type">long</span> k;</span><br><span class="line">    <span class="keyword">while</span> (buf.remaining() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">        k = buf.getLong();</span><br><span class="line">        k *= m;</span><br><span class="line">        k ^= k &gt;&gt;&gt; r;</span><br><span class="line">        k *= m;</span><br><span class="line">        h ^= k;</span><br><span class="line">        h *= m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buf.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">finish</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>).order(</span><br><span class="line">                ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        <span class="comment">// for big-endian version, do this first:</span></span><br><span class="line">        <span class="comment">// finish.position(8-buf.remaining());</span></span><br><span class="line">        finish.put(buf).rewind();</span><br><span class="line">        h ^= finish.getLong();</span><br><span class="line">        h *= m;</span><br><span class="line">    &#125;</span><br><span class="line">    h ^= h &gt;&gt;&gt; r;</span><br><span class="line">    h *= m;</span><br><span class="line">    h ^= h &gt;&gt;&gt; r;</span><br><span class="line">    buf.order(byteOrder);</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密算法：md5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get hash code on 2^32 ring (md5散列的方式计算hash值)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> long</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">hash2</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// md5 byte</span></span><br><span class="line">    MessageDigest md5;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;MD5 not supported&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    md5.reset();</span><br><span class="line">    <span class="type">byte</span>[] keyBytes = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        keyBytes = key.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown string :&quot;</span> + key, e);</span><br><span class="line">    &#125;</span><br><span class="line">    md5.update(keyBytes);</span><br><span class="line">    <span class="type">byte</span>[] digest = md5.digest();</span><br><span class="line">    <span class="comment">// hash code, Truncate to 32-bits</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> ((<span class="type">long</span>) (digest[<span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">            | ((<span class="type">long</span>) (digest[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">            | ((<span class="type">long</span>) (digest[<span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">            | (digest[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">truncateHashCode</span> <span class="operator">=</span> hashCode &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">    <span class="keyword">return</span> truncateHashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节点映射"><a href="#节点映射" class="headerlink" title="节点映射"></a>节点映射</h2><p>以有序 Map 的形式在内存中缓存每个节点的 Hash 值对应的物理节点信息，所以引入了 TreeMap 进行存储。</p><p>为了增加一致性哈希算法中的虚拟节点，在初始化节点映射的过程中，将计算出 实际节点*虚拟节点 的hash值，以 Hash 值为 key，以物理节点标识为 value，以有序 Map 的形式在内存中缓存，作为后续计算数据对象对应的物理节点时的查询数据。代码如下，virtualHash2RealNode 中缓存着所有虚拟节点 Hash 值对应的物理节点信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚拟节点数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NODE_NUM</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 映射到哈希环上的 虚拟节点+真实节点 (使用 红黑树 排序)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> TreeMap&lt;Long, String&gt; virtualHash2RealNode = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化节点（引入虚拟节点）</span></span><br><span class="line"><span class="comment"> * init consistency hash ring, put virtual node on the 2^64 ring</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initVirtual2RealRing</span><span class="params">(List&lt;String&gt; shards)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.shardNodes = shards;</span><br><span class="line">    <span class="keyword">for</span> (String node : shardNodes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NODE_NUM; i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> hash(<span class="string">&quot;SHARD-&quot;</span> + node + <span class="string">&quot;-NODE-&quot;</span> + i);</span><br><span class="line">            virtualHash2RealNode.put(hashCode, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据定位节点"><a href="#数据定位节点" class="headerlink" title="数据定位节点"></a>数据定位节点</h2><p>已知 virtualHash2RealNode 中存放着物理节点的信息，使用 tailMap() 方法寻找到比该数据大的范围内的所有物理节点，返回第一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找数据所对应节点</span></span><br><span class="line"><span class="comment"> * 从顺时针遇到的第一个节点</span></span><br><span class="line"><span class="comment"> * get real node by key&#x27;s hash on the 2^64</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getShardInfo</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    SortedMap&lt;Long, String&gt; tailMap = virtualHash2RealNode.tailMap(hashCode);</span><br><span class="line">    <span class="keyword">if</span> (tailMap.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> virtualHash2RealNode.get(virtualHash2RealNode.firstKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> virtualHash2RealNode.get(tailMap.firstKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><p>一般在项目中，会把一致性哈希算法包装成工具类使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistencyHashUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; shardNodes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储节点数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NODE_NUM</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 映射到哈希环上的 虚拟节点+真实节点 (使用 红黑树 排序)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;Long, String&gt; virtualHash2RealNode = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, String&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化节点（引入虚拟节点）</span></span><br><span class="line"><span class="comment">     * init consistency hash ring, put virtual node on the 2^64 ring</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initVirtual2RealRing</span><span class="params">(List&lt;String&gt; shards)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.shardNodes = shards;</span><br><span class="line">        <span class="keyword">for</span> (String node : shardNodes) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NODE_NUM; i++)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> hash(<span class="string">&quot;SHARD-&quot;</span> + node + <span class="string">&quot;-NODE-&quot;</span> + i);</span><br><span class="line">                virtualHash2RealNode.put(hashCode, node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 寻找数据所对应节点</span></span><br><span class="line"><span class="comment">     * 从顺时针遇到的第一个节点</span></span><br><span class="line"><span class="comment">     * get real node by key&#x27;s hash on the 2^64</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShardInfo</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        SortedMap&lt;Long, String&gt; tailMap = virtualHash2RealNode.tailMap(hashCode);</span><br><span class="line">        <span class="keyword">if</span> (tailMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> virtualHash2RealNode.get(virtualHash2RealNode.firstKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualHash2RealNode.get(tailMap.firstKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印节点</span></span><br><span class="line"><span class="comment">     * prinf ring virtual node info</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMap</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(virtualHash2RealNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  MurMurHash算法，是非加密HASH算法，性能很高，</span></span><br><span class="line"><span class="comment">     *  比传统的CRC32,MD5，SHA-1（这两个算法都是加密HASH算法，复杂度本身就很高，带来的性能上的损害也不可避免）</span></span><br><span class="line"><span class="comment">     *  等HASH算法要快很多，而且据说这个算法的碰撞率很低.</span></span><br><span class="line"><span class="comment">     *  http://murmurhash.googlepages.com/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">hash</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(key.getBytes());</span><br><span class="line">        <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="number">0x1234ABCD</span>;</span><br><span class="line">        <span class="type">ByteOrder</span> <span class="variable">byteOrder</span> <span class="operator">=</span> buf.order();</span><br><span class="line">        buf.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0xc6a4a7935bd1e995L</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">h</span> <span class="operator">=</span> seed ^ (buf.remaining() * m);</span><br><span class="line">        <span class="type">long</span> k;</span><br><span class="line">        <span class="keyword">while</span> (buf.remaining() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            k = buf.getLong();</span><br><span class="line">            k *= m;</span><br><span class="line">            k ^= k &gt;&gt;&gt; r;</span><br><span class="line">            k *= m;</span><br><span class="line">            h ^= k;</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buf.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">finish</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>).order(</span><br><span class="line">                    ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">            <span class="comment">// for big-endian version, do this first:</span></span><br><span class="line">            <span class="comment">// finish.position(8-buf.remaining());</span></span><br><span class="line">            finish.put(buf).rewind();</span><br><span class="line">            h ^= finish.getLong();</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line">        h *= m;</span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line">        buf.order(byteOrder);</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get hash code on 2^32 ring (md5散列的方式计算hash值)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">hash2</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// md5 byte</span></span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;MD5 not supported&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.reset();</span><br><span class="line">        <span class="type">byte</span>[] keyBytes = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            keyBytes = key.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown string :&quot;</span> + key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.update(keyBytes);</span><br><span class="line">        <span class="type">byte</span>[] digest = md5.digest();</span><br><span class="line">        <span class="comment">// hash code, Truncate to 32-bits</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">hashCode</span> <span class="operator">=</span> ((<span class="type">long</span>) (digest[<span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (digest[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">truncateHashCode</span> <span class="operator">=</span> hashCode &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">        <span class="keyword">return</span> truncateHashCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; shards = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        shards.add(<span class="string">&quot;consumer-uuid-2&quot;</span>);</span><br><span class="line">        shards.add(<span class="string">&quot;consumer-uuid-1&quot;</span>);</span><br><span class="line">        <span class="type">ConsistencyHashUtil</span> <span class="variable">sh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsistencyHashUtil</span>();</span><br><span class="line">        sh.initVirtual2RealRing(shards);</span><br><span class="line">        sh.printMap();</span><br><span class="line">        <span class="type">int</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;consumer&quot;</span> + i;</span><br><span class="line">            System.out.println(hash(key) + <span class="string">&quot;:&quot;</span> + sh.getShardInfo(key));</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;consumer-uuid-1&quot;</span>.equals(sh.getShardInfo(key))) &#123;</span><br><span class="line">                consumer1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;consumer-uuid-2&quot;</span>.equals(sh.getShardInfo(key))) &#123;</span><br><span class="line">                consumer2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;consumer1:&quot;</span> + consumer1);</span><br><span class="line">        System.out.println(<span class="string">&quot;consumer2:&quot;</span> + consumer2);</span><br><span class="line">        <span class="comment">/*long start = System.currentTimeMillis();</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 1000 * 1000 * 1000; i++) &#123;</span></span><br><span class="line"><span class="comment">            if (i % (100 * 1000 * 1000) == 0) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(i + &quot;:&quot; + hash(&quot;key1&quot; + i));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        long end = System.currentTimeMillis();</span></span><br><span class="line"><span class="comment">        System.out.println(end - start);*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hutool 工具包也有封装好一致性哈希算法的工具类，只需要传入复制的节点个数和节点对象就能初始化节点映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一致性Hash算法</span></span><br><span class="line"><span class="comment"> * 算法详解：http://blog.csdn.net/sparkliang/article/details/5279393</span></span><br><span class="line"><span class="comment"> * 算法实现：https://weblogs.java.net/blog/2007/11/27/consistent-hashing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoleilu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;节点类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistentHash</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Hash计算对象，用于自定义hash算法 */</span></span><br><span class="line">Hash32&lt;Object&gt; hashFunc;</span><br><span class="line"><span class="comment">/** 复制的节点个数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> numberOfReplicas;</span><br><span class="line"><span class="comment">/** 一致性Hash环 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Integer, T&gt; circle = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造，使用Java默认的Hash算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numberOfReplicas 复制的节点个数，增加每个节点的复制节点有利于负载均衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodes 节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConsistentHash</span><span class="params">(<span class="type">int</span> numberOfReplicas, Collection&lt;T&gt; nodes)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.numberOfReplicas = numberOfReplicas;</span><br><span class="line"><span class="built_in">this</span>.hashFunc = key -&gt; &#123;</span><br><span class="line"><span class="comment">//默认使用FNV1hash算法</span></span><br><span class="line"><span class="keyword">return</span> HashUtil.fnvHash(key.toString());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//初始化节点</span></span><br><span class="line"><span class="keyword">for</span> (T node : nodes) &#123;</span><br><span class="line">add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hashFunc hash算法对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numberOfReplicas 复制的节点个数，增加每个节点的复制节点有利于负载均衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodes 节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConsistentHash</span><span class="params">(Hash32&lt;Object&gt; hashFunc, <span class="type">int</span> numberOfReplicas, Collection&lt;T&gt; nodes)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.numberOfReplicas = numberOfReplicas;</span><br><span class="line"><span class="built_in">this</span>.hashFunc = hashFunc;</span><br><span class="line"><span class="comment">//初始化节点</span></span><br><span class="line"><span class="keyword">for</span> (T node : nodes) &#123;</span><br><span class="line">add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加节点&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 每增加一个节点，就会在闭环上增加给定复制节点数&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 例如复制节点数是2，则每调用此方法一次，增加两个虚拟节点，这两个节点指向同一Node</span></span><br><span class="line"><span class="comment"> * 由于hash算法会调用node的toString方法，故按照toString去重</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T node)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfReplicas; i++) &#123;</span><br><span class="line">circle.put(hashFunc.hash32(node.toString() + i), node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除节点的同时移除相应的虚拟节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(T node)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfReplicas; i++) &#123;</span><br><span class="line">circle.remove(hashFunc.hash32(node.toString() + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得一个最近的顺时针节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 为给定键取Hash，取得顺时针方向上最近的一个虚拟节点对应的实际节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (circle.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hashFunc.hash32(key);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span> == circle.containsKey(hash)) &#123;</span><br><span class="line">SortedMap&lt;Integer, T&gt; tailMap = circle.tailMap(hash);<span class="comment">//返回此映射的部分视图，其键大于等于 hash</span></span><br><span class="line">hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正好命中</span></span><br><span class="line"><span class="keyword">return</span> circle.get(hash);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入复制的节点个数和实际物理节点信息，实现一致性哈希。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ConsistentHash&lt;Node&gt; <span class="title function_">makeProxyPool</span><span class="params">(List&lt;OpenaiProxy&gt; openaiProxies)</span> &#123;</span><br><span class="line">        List&lt;Node&gt; realNodes = openaiProxies.stream().map(item -&gt; <span class="keyword">new</span> <span class="title class_">Node</span>(item.getHost(), item.getToken())).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConsistentHash</span>&lt;&gt;(<span class="number">500</span>, realNodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法，一致性哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出Spring AOP</title>
      <link href="/2023/12/21/AOP/"/>
      <url>/2023/12/21/AOP/</url>
      
        <content type="html"><![CDATA[<h1 id="对AOP的理解"><a href="#对AOP的理解" class="headerlink" title="对AOP的理解"></a>对AOP的理解</h1><p><code>AOP(Aspect-Oriented Programming:面向切面编程)</code>，它实际做的就是将业务和一些非业务进行拆解，降低彼此业务模块与非业务模块的耦合度，便于后续的扩展维护。例如<code>权限校验</code>、<code>日志管理</code>、<code>事务处理</code>等都可以使用<code>AOP</code>实现。而<code>Spring</code>就是基于动态代理实现<code>AOP</code>的。如果被代理的类有实现接口的话，就会基于<code>JDK Proxy</code>完成代理的创建。反之就是通过<code>Cglib</code>完成代理创建。</p><p><img src="https://qiniuyun.sharkchili.com/img202304071136659.png"></p><blockquote><p>Spring AOP和AspectJ AOP的区别知道吗？</p></blockquote><p><strong>答:</strong> 其实<code>Spring AOP</code>属于运行时增强，基于<code>代理(Proxying)</code>实现的。而<code>AspectJ AOP</code>属于编译时增强，基于<code>字节码操作(Bytecode Manipulation)</code>实现的。相比之下后者比前者更成熟、更强大一些。如果在切面不多的情况下，两者差异是不大的，如果切面非常多的话，后者性能会比强者好很多。</p><p><code>AOP</code>中有很多核心术语，分别是:</p><ol><li><p><code>目标(Target)</code>: 这就被代理的对象，例如我们希望对<code>UserService</code>每个方法进行<code>增强(在不动它的代码情况下增加一些非业务的动作)</code>，那么这个<code>UserService</code>就是目标。</p></li><li><p><code>代理(Proxy)</code>: 就是给你被代理后的对象的厂商，例如我们上面说过希望对<code>UserService</code>每个方法进行增强，那么给用户返回增强后的对象的类就是<code>代理类</code>。</p></li><li><p><code>连接点(JoinPoint)</code>:目标对象，每一个可能可以被增强的方法都可以称为连接点，尽管它最后可能不会被增强。</p></li><li><p><code>切入点(Pointcut)</code>: 连接点中确确实实被做增强操作的方法就叫切入点。</p></li><li><p><code>通知(Advice)</code>: 不要被表面的语义误导，通知并不是告知某人的意思，通知的意思是拦截对象后，做的增强操作。</p></li><li><p><code>切面(Aspect)</code>: 切入点<code>(Pointcut)</code>+通知<code>(Advice)</code></p></li><li><p><code>织入(Weaving)</code>：把通知的动作融入到对象中，生成代理对象的过程就叫做织入</p></li></ol><blockquote><p>AspectJ 通知类型有哪些？</p></blockquote><p><strong>答:</strong> 有很多，分别是：</p><ol><li><code>Before（前置通知）</code>: 目标对象方法调用前触发增强。</li><li><code>After （后置通知）</code>:目标对象方法调用后进行增强。</li><li><code>AfterReturning（返回通知）</code>:目标对象方法执行结束，返回值时进行增强。</li><li><code>AfterThrowing（异常通知）</code>:目标对象方法执行报错并抛出时做的增强。</li><li><code>Around(环绕通知）</code>:这个比较常用了，目标对象方法调用前后我们可以做各种增强操作,甚至不调用对象的方法都能做到。</li></ol><h1 id="动态代理实现"><a href="#动态代理实现" class="headerlink" title="动态代理实现"></a>动态代理实现</h1><h2 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h2><p>使用 Spring 实现 JDK 动态代理，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDKProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          *  1 创建原始对象</span></span><br><span class="line"><span class="comment">          *  JDK1.8 以前，内部类访问外部类的对象， 原始对象需声明成 final</span></span><br><span class="line"><span class="comment">          *  final UserService userService = new UserServiceImpl();</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    </span><br><span class="line">          <span class="comment">// 2 JDK 创建动态代理</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>()&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作用：书写额外功能，运行原始方法，执行前、后 抛出异常</span></span><br><span class="line"><span class="comment">     * 参数：Proxy 代理对象</span></span><br><span class="line"><span class="comment">            Method 额外功能，增加给原始方法</span></span><br><span class="line"><span class="comment">            Object[] 原始方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;------proxy log ------&quot;</span>);</span><br><span class="line">       <span class="comment">// 原始方法运行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(userService,args);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1. 需要ClassLoader创建代理类的Class对象，可以借一个，借用的类加载器没有限制 TestJDKProxy UserServiceImpl</span></span><br><span class="line"><span class="comment">    * 2. 代理对象和原始对象实现相同的接口，取原始对象实现的接口</span></span><br><span class="line"><span class="comment">    * 3. 重写 InvocationHandler 的 invoke 方法，实现额外功能</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userServiceProxy</span> <span class="operator">=</span> (UserService)Proxy.newProxyInstance(TestJDKProxy.class.getClassLoader(),userService.getClass().getInterfaces(),handler);</span><br><span class="line">    </span><br><span class="line">    userService.login(<span class="string">&quot;suns&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    userServiceProxy.register(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cglib-动态代理"><a href="#Cglib-动态代理" class="headerlink" title="Cglib 动态代理"></a>Cglib 动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCglib</span>  &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">           *  1 创建原始对象</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">         <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">         </span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2 通过Cglib方式创建动态代理</span></span><br><span class="line"><span class="comment">         * Enhancer 通过继承父类创建代理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">         </span><br><span class="line">         enhancer.setClassLoader(TestCglib.class.getClassLoader());</span><br><span class="line">         enhancer.setSuperClass(userService.getClass());</span><br><span class="line">         </span><br><span class="line">     </span><br><span class="line">         <span class="type">MethodInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>()&#123;</span><br><span class="line">     </span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等同于 InvocationHandler --- invoke</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;------cglib log ------&quot;</span>);</span><br><span class="line">       <span class="comment">// 原始方法运行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(userService,args);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">         enhancer.setCallback(interceptor);</span><br><span class="line">         <span class="type">UserService</span> <span class="variable">userServiceProxy</span> <span class="operator">=</span> (UserService)enhancer.create();</span><br><span class="line">         </span><br><span class="line">         userServiceProxy.login(<span class="string">&quot;suns&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">         userServiceProxy.register(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于 @EnableAspectJAutoProxy 注解，在AopAutoConfiguration这个类里可以看到相关定义。</p><p>Cglib代理：@EnableAspectJAutoProxy(proxyTargetClass &#x3D; true) </p><p>JDK代理：@EnableAspectJAutoProxy(proxyTargetClass &#x3D; false) </p><p><strong>Spring AOP 代理默认实现 JDK，SpringBoot AOP 代理默认实现 Cglib。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(Advice.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AspectJAutoProxyingConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JdkDynamicAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CglibAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AOP源码"><a href="#AOP源码" class="headerlink" title="AOP源码"></a>AOP源码</h1><p>注解切面类名为:<code>AnnotationAwareAspectJAutoProxyCreator</code></p><p><img src="https://qiniuyun.sharkchili.com/img202304071136639.png"></p><p>从类图中我们可以看到它继承了<code>BeanPostProcessor</code>以及<code>BeanFactoryAware</code>这就意味着这个类在<code>bean</code>工厂加载期间以及<code>bean</code>初始化前后会对<code>bean</code>做一些手脚。 而且我们看到这个类继承了<code>AbstractAutoProxyCreator</code>，这就意味它的抽象类一定为当前类做了某些方法的模板，即<strong>模板方法模式</strong>。 笔者贴出了<code>bean</code>初始化前置处理器的<code>postProcessBeforeInstantiation</code>的核心逻辑，可以看到<code>AbstractAutoProxyCreator</code>里面会判断当前传入的<code>bean</code>是否是<code>AOP</code>类，如果是则将其生成通知器类然后放入缓存<code>advisedBeans</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="comment">//判断是否是AOP类，或者是否需要跳过?</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line"><span class="comment">//放到增强其的缓存中</span></span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否是<code>AOP</code>类的逻辑方法如下所示，<code>isInfrastructureClass</code>就是判断这个类是否属于通知或者切点或者通知器<code>Advisor</code>类，如果是就返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> &#123;</span><br><span class="line"><span class="comment">//判断这个类是否是切点、增强器或者需要被代理的类</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">retVal</span> <span class="operator">=</span> Advice.class.isAssignableFrom(beanClass) ||</span><br><span class="line">Pointcut.class.isAssignableFrom(beanClass) ||</span><br><span class="line">Advisor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">AopInfrastructureBean.class.isAssignableFrom(beanClass);</span><br><span class="line"><span class="keyword">if</span> (retVal &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Did not attempt to auto-proxy infrastructure class [&quot;</span> + beanClass.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否跳过的逻辑也很简单，如下所示，找到所有的通知器，判断当前这个<code>bean</code>是否这里面某个通知器名字一样，如果一样就返回<code>true</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"><span class="comment">// 这步就会找到并生成通知器类，然后和当前bean比对，如果这个bean属于通知器类则返回true</span></span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line"><span class="keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line"><span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;</span><br><span class="line">((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;</span><br><span class="line"><span class="comment">//如果和当前bean名字一样则返回true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不妨看看<code>findCandidateAdvisors</code>的逻辑，可以看到它又会调用一个<code>findCandidateAdvisors</code>查找通知器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findCandidateAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 查找通知器然后返回</span></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="built_in">super</span>.findCandidateAdvisors();</span><br><span class="line"><span class="comment">//然后创建生成通知器</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.aspectJAdvisorsBuilder != <span class="literal">null</span>) &#123;</span><br><span class="line">advisors.addAll(<span class="built_in">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑来了<code>buildAspectJAdvisors</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title function_">buildAspectJAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">List&lt;String&gt; aspectNames = <span class="built_in">this</span>.aspectBeanNames;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">aspectNames = <span class="built_in">this</span>.aspectBeanNames;</span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//将这个bean封装成factory </span></span><br><span class="line"><span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">BeanFactoryAspectInstanceFactory</span>(<span class="built_in">this</span>.beanFactory, beanName);</span><br><span class="line">Class&lt;?&gt; beanType = <span class="built_in">this</span>.beanFactory.getType(beanName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果当前这个bean类型是切面类则调用getAdvisors然后返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">List&lt;Advisor&gt; classAdvisors = <span class="built_in">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="comment">//存放到缓存中，后续调用时会用到</span></span><br><span class="line"><span class="built_in">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们不断步进就会看到，通过上述的<code>factory</code>各种参数信息找到这个<code>bean</code>的切点，切点表达式，方法名，切面名称构成一个增强器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Advisor <span class="title function_">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span><br><span class="line"><span class="params"><span class="type">int</span> declarationOrderInAspect, String aspectName)</span> &#123;</span><br><span class="line"></span><br><span class="line">validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"></span><br><span class="line"><span class="type">AspectJExpressionPointcut</span> <span class="variable">expressionPointcut</span> <span class="operator">=</span> getPointcut(</span><br><span class="line">candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"><span class="keyword">if</span> (expressionPointcut == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个增强器</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InstantiationModelAwarePointcutAdvisorImpl</span>(expressionPointcut, candidateAdviceMethod,</span><br><span class="line"><span class="built_in">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装成增强器后，如何将其他类变成代理类？-重点"><a href="#封装成增强器后，如何将其他类变成代理类？-重点" class="headerlink" title="封装成增强器后，如何将其他类变成代理类？(重点)"></a>封装成增强器后，如何将其他类变成代理类？(重点)</h2><p><strong>答:</strong> 这就到<code>bean</code>初始化后置操作了，如下代码所示，从缓存中获取这个<code>bean</code>，如果这个<code>bean</code>不在<code>earlyProxyReferences</code>中，则调用<code>wrapIfNecessary</code>，这个方法会在必要情况下根据策略决定用<code>cglib</code>或者jdk代理完成某些需要被代理的类的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="comment">// 如果这个bean不在代理缓存中，则进行增强</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="那你知道他们在bean生命周期的那个阶段实现的呢？"><a href="#那你知道他们在bean生命周期的那个阶段实现的呢？" class="headerlink" title="那你知道他们在bean生命周期的那个阶段实现的呢？"></a>那你知道他们在bean生命周期的那个阶段实现的呢？</h2><p><strong>答:</strong> 上面的类图已经写的非常清楚了，在<code>bean初始化前后</code>也就我们常说的<code>BPP阶段</code>完成<code>AOP</code>类的缓存以及通知器创建。在<code>bean</code>初始化后，根据需要结合通知器完成代理类的改造。</p><h2 id="代理的创建过程是什么呢？"><a href="#代理的创建过程是什么呢？" class="headerlink" title="代理的创建过程是什么呢？"></a>代理的创建过程是什么呢？</h2><p><strong>答:</strong> AOP提供了一个默认工厂根据类是否有继承接口或者是否就是目标类决定创建的策略。然后根据不同的策略决定代理类的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line"><span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下便是<code>jdk</code>代理的创建策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">.........</span><br><span class="line"><span class="comment">//获取被代理的类的接口</span></span><br><span class="line">Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised, <span class="literal">true</span>);</span><br><span class="line">findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成代理对象并返回</span></span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下便是<code>cglib</code>的创建策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">.......</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">.......</span><br><span class="line">将当前类信息通过enhancer 生成代理对象</span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> createEnhancer();</span><br><span class="line"><span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">enhancer.setClassLoader(classLoader);</span><br><span class="line"><span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised));</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> <span class="title class_">ClassLoaderAwareGeneratorStrategy</span>(classLoader));</span><br><span class="line"></span><br><span class="line">Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">Class&lt;?&gt;[] types = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[callbacks.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">types[x] = callbacks[x].getClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回最终生成的代理对象</span></span><br><span class="line"><span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">&#125;</span><br><span class="line">........</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="手写事务-AOP实现"><a href="#手写事务-AOP实现" class="headerlink" title="手写事务-AOP实现"></a>手写事务-AOP实现</h1><p>基于以上对 AOP 的理解，我们可以自己实现AOP，就以事务的实现为例。</p><p>首先列出建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `user_test`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_test` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `balance` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">9</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `user_test` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `user_test` <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="自定义事务注解"><a href="#自定义事务注解" class="headerlink" title="自定义事务注解"></a>自定义事务注解</h2><p>对于声明式的事务，我们可以自定义注解实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTransaction &#123;</span><br><span class="line">    Propagation <span class="title function_">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务的传播属性可以在枚举类中定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Propagation</span> &#123;</span><br><span class="line"></span><br><span class="line">    REQUIRED(<span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    REQUIRES_NEW(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    Propagation(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据库连接资源管理"><a href="#数据库连接资源管理" class="headerlink" title="数据库连接资源管理"></a>数据库连接资源管理</h2><p>数据库的连接是由 ThreadLocal 控制的，ThreadLocal 存储的类型是一个 Map<br>Map 中的 key 是 DataSource，value 是 Connection（为了应对多数据源的情况，所以是一个 Map）<br>用了 ThreadLocal 保证了同一个线程获取一个 Connection 对象，从而保证一次事务的所有操作需要在同一个数据库连接上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ConnectionHolder&gt; CONNECTION_THREAD_LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Connection curConnection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  上一个方法的</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">private</span> ConnectionHolder lastConnectionHolder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unbindResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">lastConnectionHolder</span> <span class="operator">=</span> CONNECTION_THREAD_LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (lastConnectionHolder == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置当前连接为上一个方法的连接</span></span><br><span class="line">        <span class="comment">// 第一个ConnectionHolder的lastConnectionHolder属性为null，间接释放资源</span></span><br><span class="line">        CONNECTION_THREAD_LOCAL.set(lastConnectionHolder.getLastConnectionHolder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  获取资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConnectionHolder <span class="title function_">getResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CONNECTION_THREAD_LOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  绑定(set)资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bindResource</span><span class="params">(ConnectionHolder connectionHolder)</span> &#123;</span><br><span class="line">        CONNECTION_THREAD_LOCAL.set(connectionHolder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getCurConnectionStatic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">connectionHolder</span> <span class="operator">=</span> ConnectionHolder.getResource();</span><br><span class="line">        <span class="keyword">return</span> connectionHolder != <span class="literal">null</span> ? connectionHolder.getCurConnection() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getCurConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> curConnection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurConnection</span><span class="params">(Connection curConnection)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.curConnection = curConnection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConnectionHolder <span class="title function_">getLastConnectionHolder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastConnectionHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastConnectionHolder</span><span class="params">(ConnectionHolder lastConnectionHolder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lastConnectionHolder = lastConnectionHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p>自定义事务管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TransactionManager</span><span class="params">(ObjectProvider&lt;DataSource&gt; dataSourceProvider)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSourceProvider.getIfAvailable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TransactionInfo <span class="title function_">createTransactionIfNecessary</span><span class="params">(MyTransaction miniTransactional)</span> &#123;</span><br><span class="line">        <span class="type">TransactionInfo</span> <span class="variable">transactionInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionInfo</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">needNew</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (miniTransactional != <span class="literal">null</span> &amp;&amp; miniTransactional.propagation() == Propagation.REQUIRES_NEW) &#123;</span><br><span class="line">            needNew = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取连接（可能会调用setAutoCommit）</span></span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">curConnectionHolder</span> <span class="operator">=</span> transactionInfo.createConnectionIfNecessary(<span class="built_in">this</span>.dataSource, needNew);</span><br><span class="line">        transactionInfo.setConnection(curConnectionHolder.getCurConnection());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定ThreadLocal</span></span><br><span class="line">        ConnectionHolder.bindResource(curConnectionHolder);</span><br><span class="line">        <span class="keyword">return</span> transactionInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rollBack</span><span class="params">(TransactionInfo transactionInfo)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (transactionInfo.isNewTransaction()) &#123;</span><br><span class="line">                <span class="comment">// 执行回滚事务</span></span><br><span class="line">                transactionInfo.getConnection().rollback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理资源</span></span><br><span class="line">            TransactionManager.cleanupAfterCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionInfo transactionInfo)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (transactionInfo.isNewTransaction()) &#123;</span><br><span class="line">                <span class="comment">// 执行提交事务</span></span><br><span class="line">                transactionInfo.getConnection().commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理资源</span></span><br><span class="line">            TransactionManager.cleanupAfterCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cleanupAfterCompletion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 先将当前连接还回连接池</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">curConnection</span> <span class="operator">=</span> ConnectionHolder.getCurConnectionStatic();</span><br><span class="line">        <span class="keyword">if</span>(curConnection!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curConnection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再重置当前连接为上一个方法的连接</span></span><br><span class="line">        ConnectionHolder.unbindResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 transactionInfo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前connection是否为事务创建者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">newTransaction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConnectionHolder <span class="title function_">createConnectionIfNecessary</span><span class="params">(DataSource dataSource, <span class="type">boolean</span> needNew)</span> &#123;</span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">curConnectionHolder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">lastConnectionHolder</span> <span class="operator">=</span> ConnectionHolder.getResource();</span><br><span class="line">        <span class="keyword">if</span> (lastConnectionHolder == <span class="literal">null</span> || needNew) &#123;</span><br><span class="line">            curConnectionHolder = newOneConnectionHolder(dataSource, lastConnectionHolder);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!needNew) &#123;</span><br><span class="line">            curConnectionHolder = lastConnectionHolder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curConnectionHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConnectionHolder <span class="title function_">newOneConnectionHolder</span><span class="params">(DataSource dataSource, ConnectionHolder lastConnectionHolder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.newTransaction = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">connectionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionHolder</span>();</span><br><span class="line">        connectionHolder.setLastConnectionHolder(lastConnectionHolder);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">newConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newConnection = dataSource.getConnection();</span><br><span class="line">            <span class="comment">// fixme 关闭自动提交，间接开启事务</span></span><br><span class="line">            newConnection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        connectionHolder.setCurConnection(newConnection);</span><br><span class="line">        <span class="keyword">return</span> connectionHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConnection</span><span class="params">(Connection connection)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connection = connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNewTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newTransaction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNewTransaction</span><span class="params">(<span class="type">boolean</span> newTransaction)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.newTransaction = newTransaction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AOP实现事务逻辑"><a href="#AOP实现事务逻辑" class="headerlink" title="AOP实现事务逻辑"></a>AOP实现事务逻辑</h2><p>使用@Aspect实现AOP，定义切入点和真正实现AOP的切面方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">TransactionAspect</span><span class="params">(TransactionManager transactionManager)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.transactionManager = transactionManager;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Pointcut(value = &quot;@within(com.jrrl.transaction.aop.MyTransaction)&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">point</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around(&quot;point()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">MyTransaction</span> <span class="variable">myTransaction</span> <span class="operator">=</span> ((MethodSignature) joinPoint.getSignature()).getMethod().getAnnotation(MyTransaction.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化 transactionInfo</span></span><br><span class="line">        <span class="type">TransactionInfo</span> <span class="variable">transactionInfo</span> <span class="operator">=</span> transactionManager.createTransactionIfNecessary(myTransaction);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用目标方法</span></span><br><span class="line">            res = joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 回滚事务</span></span><br><span class="line">            transactionManager.rollBack(transactionInfo);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        transactionManager.commit(transactionInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务的传播属性"><a href="#事务的传播属性" class="headerlink" title="事务的传播属性"></a>事务的传播属性</h2><table><thead><tr><th>传播属性</th><th>概念</th><th>建议</th></tr></thead><tbody><tr><td><strong><code>PROPAGATION_REQUIRED</code></strong></td><td>（默认传播属性）如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</td><td>增删改操作@Transactional(rollbackFor &#x3D; Exception.class)</td></tr><tr><td><strong><code>PROPAGATION_SUPPORTS</code></strong></td><td>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</td><td>查询操作@Transactional(propagation&#x3D;Propagation.SUPPORTS, readOnly &#x3D; true)</td></tr><tr><td><strong><code>PROPAGATION_REQUIRES_NEW</code></strong></td><td>创建一个新的事务，如果当前存在事务，则把当前事务挂起。</td><td></td></tr><tr><td><strong><code>PROPAGATION_NESTED</code></strong></td><td>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</td><td></td></tr><tr><td><strong><code>PROPAGATION_MANDATORY</code></strong></td><td>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</td><td></td></tr></tbody></table><blockquote><p>需要注意的是，在同一个类中非事务方法调用事务方法，事务失效问题</p></blockquote><p><strong>原因：</strong></p><p>spring 在扫描bean的时候会扫描方法上是否包含@Transactional注解，如果包含，spring会为这个bean动态地生成一个子类（即代理类，proxy），代理类是继承原来那个bean的。此时，当这个有注解的方法被调用的时候，实际上是由代理类来调用的，代理类在调用之前就会启动transaction。</p><p>然而，如果这个有注解的方法是被同一个类中的其他方法调用的，那么该方法的调用并没有通过代理类，而是直接通过原来的那个bean，所以就不会启动transaction，我们看到的现象就是@Transactional注解无效。</p><p>解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">noneTransactionMethod</span><span class="params">()</span>&#123; <span class="comment">//非事务方法</span></span><br><span class="line">    <span class="type">xxxServiceImpl</span> <span class="variable">bean</span> <span class="operator">=</span> SpringUtils.getBean(xxxServiceImpl.class);</span><br><span class="line">    bean.transactionMethod();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionMethod</span><span class="params">()</span>&#123; <span class="comment">// 事务方法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis源码</title>
      <link href="/2023/12/20/MyBatis%E6%BA%90%E7%A0%81/"/>
      <url>/2023/12/20/MyBatis%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis-执行流程"><a href="#MyBatis-执行流程" class="headerlink" title="MyBatis 执行流程"></a>MyBatis 执行流程</h1><p>首先回顾一下jdbc的执行流程。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/d0e15d400f51753fb576aae72a5a9b5bdd507557.png"></p><p>MyBatis的执行流程也包含jdbc的执行流程，但是会做一些前置处理。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/1ca39ee84c09f243ad7c302e65f3e7724c3e5cc3.png" alt="MyBatis"></p><h2 id="方法代理-MapperMethod"><a href="#方法代理-MapperMethod" class="headerlink" title="方法代理(MapperMethod)"></a>方法代理(MapperMethod)</h2><p>使用动态代理调用，可以看到非常熟悉的 invoke 方法，这个invoke方法就是动态代理的逻辑，method.invoke()方法就是实现代理类对原始方法的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6424540398559729838L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="built_in">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="built_in">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="会话-SqlSession"><a href="#会话-SqlSession" class="headerlink" title="会话(SqlSession)"></a>会话(SqlSession)</h2><p>SqlSession 是myBatis的门面(采用门面模式设计)，核心作用是为用户提供API。API包括增、删、改、查以及提交、关闭等。其自身是没有能力处理这些请求的，所以内部会包含一个唯一的执行器 Executor，所有请求都会交给执行器来处理。</p><p>SqlSession 是SqlSessionFactory会话工厂创建出来的一个会话的对象，这个SqlSession对象用于执行具体的SQL语句并返回给用户请求的结果。</p><h2 id="执行器-Executor"><a href="#执行器-Executor" class="headerlink" title="执行器(Executor)"></a>执行器(Executor)</h2><p>Executor是一个大管家，核心功能包括：缓存维护、获取动态SQL、获取连接、以及最终的JDBC调用等。在图中所有蓝色节点全部都是在Executor中完成。</p><p>这么多事情无法全部亲力亲为，就需要把任务分派下去。所以Executor内部还会包含若干个组件：</p><ul><li>缓存维护：cache</li><li>获取连接：Transaction</li><li>获取动态sql：SqlSource</li><li>调用jdbc：StatementHandler</li></ul><p>上述组件中前三个和Executor是1对1关系，只有StatementHandler是1对多。每执行一次SQL 就会构造一个新的StatementHandler。StatementHandler的作用就是专门和JDBC打交道，执行SQL的。</p><h3 id="SQL处理器-StatementHandler"><a href="#SQL处理器-StatementHandler" class="headerlink" title="SQL处理器(StatementHandler)"></a>SQL处理器(StatementHandler)</h3><p>在JDBC中执行一次sql的步骤包括。预编译SQL、设置参数然后执行。StatementHandler就是用来处理这三步。</p><p>用于获取预处理器，共有三种类型。通过statementType&#x3D;<code>&quot;STATEMENT|PREPARED|CALLABLE&quot;</code> 可分别进行指定。</p><ul><li>PreparedStatementHandler：带预处理的执行器</li><li>CallableStatementHandler：存储过程执行器</li><li>SimpleStatementHandler：基于Sql执行器</li></ul><p>同样它也需要两个助手分别是：</p><ul><li>设置参数：ParameterHandler</li><li>读取结果：ResultSetHandler，可在SqlSession中查询时自行定义ResultSetHandler</li></ul><p>另外的执行是由它自己完成。</p><h1 id="主键生成"><a href="#主键生成" class="headerlink" title="主键生成"></a>主键生成</h1><p>在平时开发的时候经常会有这样的需求，插入数据返回主键，或者插入数据之前需要获取主键，这样的需求在 mybatis 中也是支持的。只需要在 xml 里配置 useGenerateKey &#x3D; true 就好了。</p><p>其中主要的逻辑部分就在 KeyGenerator 中，其接口方法如下：</p><p>processBefore 是在生成 StatementHandler 的时候执行，processAfter 则是在完成插入返回结果之前执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">KeyGenerator</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">processBefore</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">processAfter</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所见 KeyGenerator 非常的简单，主要是通过两个拦截方法实现的：</p><ul><li>Jdbc3KeyGenerator：主要基于 java.sql.Statement.getGeneratedKeys 的主键返回接口实现的，所以他不需要 processBefore 方法，只需要在获取到结果后使用 processAfter 拦截，然后用反射将主键设置到参数中即可；</li><li>SelectKeyGenerator：主要是通过 XML 配置或者注解设置 <strong>selectKey</strong> ，然后单独发出查询语句，在返回拦截方法中使用反射设置主键，其中两个拦截方法只能使用其一，在 <strong>selectKey.order</strong> 属性中设置 <code>AFTER|BEFORE</code> 来确定；</li></ul><h1 id="MyBatis-缓存"><a href="#MyBatis-缓存" class="headerlink" title="MyBatis 缓存"></a>MyBatis 缓存</h1><p>myBatis中存在两个缓存，一级缓存和二级缓存。</p><ul><li>一级缓存：也叫做会话级缓存，生命周期仅存在于当前会话，不可以直接关关闭。但可以通过flushCache和localCacheScope对其做相应控制。</li><li>二级缓存：也叫应用级性缓存，缓存对象存在于整个应用周期，而且可以跨线程使用。</li></ul><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><h3 id="一级缓存的命中场景"><a href="#一级缓存的命中场景" class="headerlink" title="一级缓存的命中场景"></a>一级缓存的命中场景</h3><p>关于一级缓存的命中可大致分为两个场景，满足特定命中参数，第二不触发清空方法。</p><h4 id="缓存命中参数："><a href="#缓存命中参数：" class="headerlink" title="缓存命中参数："></a>缓存命中参数：</h4><ol><li>SQL与参数相同：</li><li>同一个会话：</li><li>相同的MapperStatement ID：</li><li>RowBounds行范围相同：</li></ol><h4 id="触发清空缓存"><a href="#触发清空缓存" class="headerlink" title="触发清空缓存"></a>触发清空缓存</h4><ol><li>手动调用clearCache</li><li>执行提交回滚</li><li>执行update</li><li>配置flushCache&#x3D;true</li><li>缓存作用域为Statement</li></ol><h3 id="一级缓存源码解析"><a href="#一级缓存源码解析" class="headerlink" title="一级缓存源码解析"></a>一级缓存源码解析</h3><p>一级缓存逻辑就存在于 BaseExecutor (基础执行器)里面。当会话接收到查询请求之后，会交给执行器的Query方法，在这里会通过 Sql、参数、分页条件等参数创建一个缓存key，在基于这个key去 PerpetualCache中查找对应的缓存值，如果有命中直接返回。没有就会查询数据库，然后在填充缓存。最终缓存的实现非常简单，就是一个HashMap。</p><h4 id="一级缓存的清空"><a href="#一级缓存的清空" class="headerlink" title="一级缓存的清空"></a>一级缓存的清空</h4><p>缓存的清空对应BaseExecutor中的 clearLocalCache.方法。只要找到调用该方法地方，就知道哪些场景中会清空缓存了。</p><ul><li>update: 执行任意增删改</li><li>select：查询又分为两种情况清空，一前置清空，即配置了flushCache&#x3D;true。二后置清空，配置了缓存作用域为statement 查询结束合会清空缓存。</li><li>commit：提交前清空</li><li>Rolback：回滚前清空</li></ul><blockquote><p>注意：clearLocalCache 不是清空某条具体数据，而清当前会话下所有一级缓存数据。</p></blockquote><h3 id="MyBatis集成Spring后一级缓存失效的问题？"><a href="#MyBatis集成Spring后一级缓存失效的问题？" class="headerlink" title="MyBatis集成Spring后一级缓存失效的问题？"></a>MyBatis集成Spring后一级缓存失效的问题？</h3><p>很多人发现，集成一级缓存后会话失效了，以为是spring Bug ，真正原因是Spring 对SqlSession进行了封装，通过SqlSessionTemplae ，使得每次调用Sql，都会重新构建一个SqlSession，具体参见SqlSessionInterceptor。而根据前面所学，一级缓存必须是同一会话才能命中,所以在这些场景当中不能命中。</p><p>怎么解决呢？给Spring 添加事物 即可。添加事物之后，SqlSessionInterceptor(会话拦截器)就会去判断两次请求是否在同一事物当中，如果是就会共用同一个SqlSession会话来解决。</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>二级缓存也称作是应用级缓存，与一级缓存不同的，是它的作用范围是整个应用，而且可以跨线程使用。所以二级缓存有更高的命中率，适合缓存一些修改较少的数据。在流程上是先访问二级缓存，再访问一级缓存。</p><p>MyBatis抽象出Cache接口，其只定义了缓存中最基本的功能方法：</p><ul><li>设置缓存</li><li>获取缓存</li><li>清除缓存</li><li>获取缓存数量</li></ul><p>然后上述中每一个功能都会对应一个组件类，并基于装饰者加责任链的模式，将各个组件进行串联。在执行缓存的基本功能时，其它的缓存逻辑会沿着这个责任链依次往下传递。</p><p>这样设计有以下优点：</p><ol><li>职责单一：各个节点只负责自己的逻辑，不需要关心其它节点。</li><li>扩展性强：可根据需要扩展节点、删除节点，还可以调换顺序保证灵活性。</li><li>松耦合：各节点之间不没强制依赖其它节点。而是通过顶层的Cache接口进行间接依赖。</li></ol><h3 id="缓存空间声明"><a href="#缓存空间声明" class="headerlink" title="缓存空间声明"></a>缓存空间声明</h3><p>二级默认缓存默认是不开启的，需要为其声明缓存空间才可以使用，通过@CacheNamespace 或 为指定的MappedStatement声明。声明之后该缓存为该Mapper所独有，其它Mapper不能访问。如需要多个Mapper共享一个缓存空间可通过@CacheNamespaceRef 或进行引用同一个缓存空间。</p><h3 id="二级缓存的命中条件"><a href="#二级缓存的命中条件" class="headerlink" title="二级缓存的命中条件"></a>二级缓存的命中条件</h3><p>二级缓存的命中场景与一级缓存类似，不同在于二级可以跨会放使用，还有就是二级缓存的更新，为了保证数据一至性，二级缓存必须是会话提交之才会真正填充，包括对缓存的清空，也必须是会话正常提交之后才生效。</p><h3 id="二级缓存结构"><a href="#二级缓存结构" class="headerlink" title="二级缓存结构"></a>二级缓存结构</h3><p>为了实现会话提交之后才变更二级缓存，MyBatis为每个会话设立了若干个暂存区，当前会话对指定缓存空间的变更，都存放在对应的暂存区，当会话提交之后才会提交到每个暂存区对应的缓存空间。为了统一管理这些暂存区，每个会话都一个唯一的事物缓存管理器。所以这里暂存区也可叫做事物缓存。</p><h3 id="二级缓存的执行流程"><a href="#二级缓存的执行流程" class="headerlink" title="二级缓存的执行流程"></a>二级缓存的执行流程</h3><p>原本会话是通过Executor实现SQL调用，这里基于装饰器模式使用CachingExecutor对SQL调用逻辑进行拦截。以嵌入二级缓存相关逻辑。</p><h4 id="查询操作query"><a href="#查询操作query" class="headerlink" title="查询操作query"></a>查询操作query</h4><p>当会话调用query() 时，会基于查询语句、参数等数据组成缓存Key，然后尝试从二级缓存中读取数据。读到就直接返回，没有就调用被装饰的Executor去查询数据库，然后在填充至对应的暂存区。</p><blockquote><p>请注意，这里的查询是实时从缓存空间读取的，而变更，只会记录在暂存区</p></blockquote><h4 id="更新操作update"><a href="#更新操作update" class="headerlink" title="更新操作update"></a>更新操作update</h4><p>当执行update操作时，同样会基于查询的语句和参数组成缓存KEY，然后在执行update之前清空缓存。这里清空只针对暂存区，同时记录清空的标记，以便当会话提交之时，依据该标记去清空二级缓存空间。</p><blockquote><p>如果在查询操作中配置了flushCache&#x3D;true ，也会执行相同的操作。</p></blockquote><h4 id="提交操作commit"><a href="#提交操作commit" class="headerlink" title="提交操作commit"></a>提交操作commit</h4><p>当会话执行commit操作后，会将该会话下所有暂存区的变更，更新到对应二级缓存空间去。</p><h1 id="Hibernate和MyBatis的区别"><a href="#Hibernate和MyBatis的区别" class="headerlink" title="Hibernate和MyBatis的区别"></a>Hibernate和MyBatis的区别</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。</p><p>其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。Hibernate和MyBatis都支持 JDBC 和 JTA 事务处理。</p><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h3 id="hibernate是全自动，而mybatis是半自动"><a href="#hibernate是全自动，而mybatis是半自动" class="headerlink" title="hibernate是全自动，而mybatis是半自动"></a>hibernate是全自动，而mybatis是半自动</h3><p>hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p><h3 id="hibernate数据库移植性远大于mybatis"><a href="#hibernate数据库移植性远大于mybatis" class="headerlink" title="hibernate数据库移植性远大于mybatis"></a>hibernate数据库移植性远大于mybatis</h3><p>hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（Oracle、MySQL等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于程序员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。</p><h3 id="hibernate拥有完整的日志系统"><a href="#hibernate拥有完整的日志系统" class="headerlink" title="hibernate拥有完整的日志系统"></a>hibernate拥有完整的日志系统</h3><p>hibernate日志系统非常健全，涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等；而mybatis则除了基本记录功能外，功能薄弱很多。</p><h3 id="mybatis相比hibernate需要关心很多细节"><a href="#mybatis相比hibernate需要关心很多细节" class="headerlink" title="mybatis相比hibernate需要关心很多细节"></a>mybatis相比hibernate需要关心很多细节</h3><p>hibernate配置要比mybatis复杂的多，学习成本也比mybatis高。但也正因为mybatis使用简单，才导致它要比hibernate关心很多技术细节。mybatis由于不用考虑很多细节，开发模式上与传统jdbc区别很小，因此很容易上手并开发项目，但忽略细节会导致项目前期bug较多，因而开发出相对稳定的软件很慢，而开发出软件却很快。hibernate则正好与之相反。但是如果使用hibernate很熟练的话，实际上开发效率丝毫不差于甚至超越mybatis。</p><h3 id="sql直接优化上，mybatis要比hibernate方便很多"><a href="#sql直接优化上，mybatis要比hibernate方便很多" class="headerlink" title="sql直接优化上，mybatis要比hibernate方便很多"></a>sql直接优化上，mybatis要比hibernate方便很多</h3><p>由于mybatis的sql都是写在xml里，因此优化sql比hibernate方便很多。而hibernate的sql很多都是自动生成的，无法直接维护sql；虽有hql，但功能还是不及sql强大，见到报表等变态需求时，hql也歇菜，也就是说hql是有局限的；hibernate虽然也支持原生sql，但开发模式上却与orm不同，需要转换思维，因此使用上不是非常方便。总之写sql的灵活度上hibernate不及mybatis。</p><h3 id="缓存机制上，hibernate要比mybatis更好一些"><a href="#缓存机制上，hibernate要比mybatis更好一些" class="headerlink" title="缓存机制上，hibernate要比mybatis更好一些"></a>缓存机制上，hibernate要比mybatis更好一些</h3><p>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p><p>而Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> 源码 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdbc的演变</title>
      <link href="/2023/12/20/jdbc%E7%9A%84%E6%BC%94%E5%8F%98/"/>
      <url>/2023/12/20/jdbc%E7%9A%84%E6%BC%94%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<h1 id="jdbc流程"><a href="#jdbc流程" class="headerlink" title="jdbc流程"></a>jdbc流程</h1><p><img src="https://ashleyblog.oss-cn-shenzhen.aliyuncs.com/post/MyBatis/jdbc.png"></p><h1 id="jdbc操作"><a href="#jdbc操作" class="headerlink" title="jdbc操作"></a>jdbc操作</h1><h2 id="jdbc连接"><a href="#jdbc连接" class="headerlink" title="jdbc连接"></a>jdbc连接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//1.加载配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span></span><br><span class="line">ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pros.load(is);</span><br><span class="line"><span class="comment">//2.读取配置信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"><span class="comment">//3.加载驱动</span></span><br><span class="line">Class.forName(driverClass);</span><br><span class="line"><span class="comment">//4.获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password);</span><br><span class="line">System.out.println(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><h2 id="使用PreparedStatement实现增删改操作"><a href="#使用PreparedStatement实现增删改操作" class="headerlink" title="使用PreparedStatement实现增删改操作"></a>使用PreparedStatement实现增删改操作</h2><p>可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p><h3 id="PreparedStatement-vs-Statement"><a href="#PreparedStatement-vs-Statement" class="headerlink" title="PreparedStatement vs Statement"></a>PreparedStatement vs Statement</h3><ul><li><p>代码的可读性和可维护性。 </p></li><li><p>PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的 编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) </p></li><li><p>PreparedStatement 可以防止 SQL 注入</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String sql,Object ... args)</span>&#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1.获取数据库的连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">//2.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">//3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.执行sql语句</span></span><br><span class="line">ps.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//5.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用PreparedStatement实现查询操作"><a href="#使用PreparedStatement实现查询操作" class="headerlink" title="使用PreparedStatement实现查询操作"></a>使用PreparedStatement实现查询操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getInstance</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取数据库连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">// 2.预编译sql语句，得到PreparedStatement对象</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4.执行executeQuery(),得到结果集：ResultSet</span></span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="comment">// 5.得到结果集的元数据：ResultSetMetaData</span></span><br><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"><span class="comment">// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnCount; i++) &#123;<span class="comment">// 遍历每一个列</span></span><br><span class="line"><span class="comment">// 获取列值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">columnVal</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 获取列的别名:列的别名，使用类的属性名充当</span></span><br><span class="line"><span class="type">String</span> <span class="variable">columnLabel</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 6.2使用反射，给对象的相应属性赋值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnLabel);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 7.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jdbc事务处理"><a href="#jdbc事务处理" class="headerlink" title="jdbc事务处理"></a>jdbc事务处理</h2><ul><li><p>调用 Connection 对象的 setAutoCommit(false); </p></li><li><p>以取消自动提交事务在所有的 SQL 语句都成功执行后，调用 commit(); </p></li><li><p>方法提交事务在出现异常时，调用 rollback(); 方法回滚事务</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJDBCTransaction</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取数据库连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">// 2.开启事务</span></span><br><span class="line">conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 3.进行数据库操作</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance - 100 where user = ?&quot;</span>;</span><br><span class="line">update(conn, sql1, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line"><span class="comment">// 模拟网络异常</span></span><br><span class="line"><span class="comment">//System.out.println(10 / 0);</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance + 100 where user = ?&quot;</span>;</span><br><span class="line">update(conn, sql2, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"><span class="comment">// 4.若没有异常，则提交事务</span></span><br><span class="line">conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">// 5.若有异常，则回滚事务</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//6.恢复每次DML操作的自动提交功能</span></span><br><span class="line">conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7.关闭连接</span></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到的 update 方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Connection conn ,String sql, Object... args)</span> &#123;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 2.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.执行sql语句</span></span><br><span class="line">ps.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 4.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(<span class="literal">null</span>, ps);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Druid数据库连接池"><a href="#Druid数据库连接池" class="headerlink" title="Druid数据库连接池"></a>Druid数据库连接池</h1><p>如果使用传统的jdbc连接方式，可能会出现以下问题：</p><ul><li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求 一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用</strong>。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严 重的甚至会造成服务器的崩溃。 </li><li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统 中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？） </li><li><strong>这种开发不能控制被创建的连接对象数，</strong>系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内 存泄漏，服务器崩溃。</li></ul><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 </p><p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 </p><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了 日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDruid</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">    System.out.println(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【druid.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">20</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">filters</span>=<span class="string">wall</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdbc </tag>
            
            <tag> Druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义starter</title>
      <link href="/2023/12/19/%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
      <url>/2023/12/19/%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
      
        <content type="html"><![CDATA[<h1 id="starter介绍"><a href="#starter介绍" class="headerlink" title="starter介绍"></a>starter介绍</h1><p><strong>Spring Boot Starter是什么？</strong></p><p>Spring Boot Starter可以被理解为一种依赖的集合，也可以看作是一个空的项目，它由<a href="http://pom.xml/">pom.xml</a>文件配置了一堆jar包的组合。</p><p><strong>Spring Boot Starter解决了什么问题？</strong></p><p>Spring Boot Starter解决了手动配置大量依赖项和参数的问题。在Spring Boot之前，如果要开发一个Web应用程序，需要手动添加很多依赖项，如Servlet、JSP、JSTL等，并且还需要配置很多参数，如数据源、事务管理器等。而通过使用Spring Boot Starter，开发者只需要添加一个Starter依赖，就可以轻松地集成各种不同的功能模块，而无需关心底层的配置和集成细节。</p><p><strong>Spring Boot Starter的价值是什么？</strong></p><p>Spring Boot Starter的价值在于它能够提高开发效率和代码质量，同时减少开发成本和复杂度。通过使用Starter，开发者可以专注于业务逻辑的实现，而不需要关心底层的配置和集成细节。另外，Starter还支持更快的迭代和部署，因为它们通常包含了一些可重用的依赖库和自动配置类。</p><h1 id="SpringBoot-starter封装方法"><a href="#SpringBoot-starter封装方法" class="headerlink" title="SpringBoot starter封装方法"></a>SpringBoot starter封装方法</h1><h2 id="第1步：定义一个XXXProperties的类文件"><a href="#第1步：定义一个XXXProperties的类文件" class="headerlink" title="第1步：定义一个XXXProperties的类文件"></a>第1步：定义一个XXXProperties的类文件</h2><p>用于抽象化原有的配置属性与增加新的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(GrowingioProperties.GROWINGIO_PREFIX)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrowingioProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GROWINGIO_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;growingio&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目采集端地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String apiHost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String projectId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息发送间隔时间,单位ms（默认 100）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">sendMsgInterval</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息发送线程数量,默认为3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">sendMsgThread</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息队列大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">msgStoreQueueSize</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据压缩 false:不压缩, true:压缩 不压缩可节省cpu，压缩可省带宽</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">compress</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志输出级别（debug | error）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">loggerLevel</span> <span class="operator">=</span> <span class="string">&quot;debug&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义日志输出实现类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">loggerImplemention</span> <span class="operator">=</span> <span class="string">&quot;com.my.growingio.log.GrowingioLogger&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行模式，test：仅输出消息体，不发送消息，production：发送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">runMode</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * http 连接超时时间，默认2000ms</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">connectionTimeout</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * http 连接读取时间，默认2000ms</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">readTimeout</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否启用:自定义属性:标识是否启用，默认为不启用，非growing io 官方属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">enable</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第2步：定义XXXAutoConfiguration的类文件"><a href="#第2步：定义XXXAutoConfiguration的类文件" class="headerlink" title="第2步：定义XXXAutoConfiguration的类文件"></a>第2步：定义XXXAutoConfiguration的类文件</h2><p>将核心的业务处理类，初始化核心业务处理类并注入到IOC中，通常写在XXXAutoConfiguration的类文件文件中。</p><p>GrowingioAutoConfiguration这个类主要是方便做bean的注册，@ComponentScan这个注解会扫描并加载属性basePackages指定的包路径下所有bean，就不用在spring.factories文件逐个写了，只用写这个类就行了。@SpringBootApplication启动类注解也使用了@ComponentScan。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(GrowingioProperties.class)</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.my.growingio&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrowingioAutoConfiguration</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(GrowingioAutoConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> GrowingioProperties growingioProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GrowingioService <span class="title function_">growingioService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GrowingioServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//校验并开始检查是否配置必填的属性</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(growingioProperties.getApiHost()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;growing properties api.host must be defined&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(growingioProperties.getProjectId()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;growing properties project.id must be defined&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 页面初始化执行函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.checkProperties();</span><br><span class="line">        <span class="comment">//初始化配置</span></span><br><span class="line">        <span class="built_in">this</span>.initGrowingioApiProperties();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initGrowingioApiProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(GrowingioConstant.API_HOST_KEY, growingioProperties.getApiHost());</span><br><span class="line">        properties.setProperty(GrowingioConstant.PROJECT_ID_KEY, growingioProperties.getProjectId());</span><br><span class="line">        properties.setProperty(GrowingioConstant.SEND_MSG_INTERVAL_KEY, growingioProperties.getSendMsgInterval().toString());</span><br><span class="line">        properties.setProperty(GrowingioConstant.SEND_MSG_THREAD_KEY, growingioProperties.getSendMsgThread().toString());</span><br><span class="line">        properties.setProperty(GrowingioConstant.MSG_STORE_QUEUE_SIZE_KEY, growingioProperties.getMsgStoreQueueSize().toString());</span><br><span class="line">        properties.setProperty(GrowingioConstant.COMPRESS_KEY, growingioProperties.getCompress().toString());</span><br><span class="line">        properties.setProperty(GrowingioConstant.LOGGER_LEVEL_KEY, growingioProperties.getLoggerLevel());</span><br><span class="line">        properties.setProperty(GrowingioConstant.LOGGER_IMPL_KEY, growingioProperties.getLoggerImplemention());</span><br><span class="line">        properties.setProperty(GrowingioConstant.RUN_MODE_KEY, growingioProperties.getRunMode());</span><br><span class="line">        properties.setProperty(GrowingioConstant.CONNECTION_TIMEOUT_KEY, growingioProperties.getConnectionTimeout().toString());</span><br><span class="line">        properties.setProperty(GrowingioConstant.READ_TIMEOUT_KEY, growingioProperties.getReadTimeout().toString());</span><br><span class="line">        <span class="comment">//通过SDK中的这个API可以避免使用properties文件</span></span><br><span class="line">        ConfigUtils.init(properties);</span><br><span class="line">        logger.info(<span class="string">&quot;init load growingio starter api properties success,url:&#123;&#125;,runmode:&#123;&#125;,enable:&#123;&#125;&quot;</span>,</span><br><span class="line">                growingioProperties.getApiHost(),growingioProperties.getRunMode(),growingioProperties.getEnable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第3步：声明一个spring-factories的文件"><a href="#第3步：声明一个spring-factories的文件" class="headerlink" title="第3步：声明一个spring.factories的文件"></a>第3步：声明一个spring.factories的文件</h2><p>为了防止使用者与Starter中包名路径不一致，声明一个spring.factories的文件，来提供一种扫描类到IOC中的途径。</p><p>resources包下手动创建一个META-INF文件夹，并且在包下创建一个spring.factories文件，文件内容写，注意空格(使用Idea会有提示)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.my.growingio.config.GrowingioAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>在Spring Boot 2.7后，这个文件过时了，后续版本会取消，那么新版本的约定是怎么样的规则呢，这里以wxjava的spring-boot-starter组件为例，仓库地址如下：</p><p><a href="https://github.com/Wechat-Group/WxJava/tree/develop/spring-boot-starters/wx-java-miniapp-spring-boot-starter">https://github.com/Wechat-Group/WxJava/tree/develop/spring-boot-starters/wx-java-miniapp-spring-boot-starter</a></p><p>在该工程示例中，在resources文件下定义了如下文件：</p><p>META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports</p><p>在该文件中直接定义了实现类，接口声明在体现在了文件名字上。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">com.binarywang.spring.starter.wxjava.miniapp.config.WxMaAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>简化配置: 新的方法可能旨在简化配置过程，使得自动配置和服务的管理更加直观和易于理解。</p><p>性能优化: 改变 SPI 文件的规则可能是为了提高应用启动和运行时的性能。</p><p>增加灵活性: 新的机制可能提供了更大的灵活性，允许更精细的控制和定制。</p><h1 id="SpringBoot-starter-新玩法"><a href="#SpringBoot-starter-新玩法" class="headerlink" title="SpringBoot starter 新玩法"></a>SpringBoot starter 新玩法</h1><h2 id="定义一个XXXXEnable模式-Import模式的注解"><a href="#定义一个XXXXEnable模式-Import模式的注解" class="headerlink" title="定义一个XXXXEnable模式+@Import模式的注解"></a>定义一个XXXXEnable模式+@Import模式的注解</h2><p>用于控制Starter是否生效与动态注册对象Bean到IOC容器中。这里以rocketmq的spring-boot-starter为例，</p><p>首先我们在自定义好一个autoconfiguration类后，如果不想让客户端自动装配上，可以提供一个Enable命名为开头的类，来通过这种方式启用装配，代码样例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Import(RocketMQAutoConfiguration.class)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableRocketMQ &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义好这样的一个注解，使用时在启动类上面进行声明即可。然后再Auto装配类中，我们还可以结合ConditionalOnProperty注解来表达，某个属性等于某个值的时候，才触发某些装配，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DefaultMQProducer.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DefaultMQProducer.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.rocketmq&quot;, value = &#123;&quot;nameServer&quot;, &quot;producer.group&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> DefaultMQProducer <span class="title function_">mqProducer</span><span class="params">(RocketMQProperties rocketMQProperties)</span> &#123;</span><br><span class="line"><span class="comment">//省略部分代码</span></span><br><span class="line"><span class="keyword">return</span> producer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h2><p>使用多种注解，来区分当前starter组件中的先后顺序、环境区分、兼容性等等。</p><p><strong>@Profile注解：用于区分环境来加载不同的自动装配类</strong></p><p><strong>@EnableConfigurationProperties注解：用于装配导入一个属性配置文件，通常结合@ConfigurationProperties来使用</strong></p><p><strong>@ConditionalOnClass注解：用于标识当前类路径中存在某个类的时候，才触发自动装配类</strong></p><p><strong>@ConditionalOnMissingClass注解：用于标识当前类路径中不存在某个类的时候，才触发</strong></p><p><strong>@ConditionalOnMissingBean注解：用于标识当前IOC容器中不存在某个Bean的时候，才触发</strong></p><p><strong>@AutoConfigureAfter、@AutoConfigureBefore注解：用于控制先后顺序的注解</strong></p><h2 id="基于-AOP-注解实现对某些接口或配置的自动拦截、代码增强"><a href="#基于-AOP-注解实现对某些接口或配置的自动拦截、代码增强" class="headerlink" title="基于 AOP 注解实现对某些接口或配置的自动拦截、代码增强"></a>基于 AOP 注解实现对某些接口或配置的自动拦截、代码增强</h2><p>自定义一个AOP类和一个注解，用于动态标识哪些方法进行业务埋点操作，避免一定程度上的代码侵入。</p><p>这里以一个Redis的ratelimiter-spring-boot-starter的限流的Starter组件为例，仓库地址如下：</p><p><a href="https://github.com/taptap/ratelimiter-spring-boot-starter">https://github.com/taptap/ratelimiter-spring-boot-starter</a></p><p>首先，可以定义一个自定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(value = &#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RateLimit &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===================== 公共参数 ============================</span></span><br><span class="line"></span><br><span class="line">    Mode <span class="title function_">mode</span><span class="params">()</span> <span class="keyword">default</span> Mode.TIME_WINDOW;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间窗口模式表示每个时间窗口内的请求数量</span></span><br><span class="line"><span class="comment">     * 令牌桶模式表示每秒的令牌生产数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> rate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，为这个注解定义一个AOP拦截类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitAspectHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(RateLimitAspectHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RateLimiterService rateLimiterService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RuleProvider ruleProvider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RateLimitAspectHandler</span><span class="params">(RateLimiterService lockInfoProvider, RuleProvider ruleProvider)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rateLimiterService = lockInfoProvider;</span><br><span class="line">        <span class="built_in">this</span>.ruleProvider = ruleProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;@annotation(rateLimit)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint, RateLimit rateLimit)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Rule</span> <span class="variable">rule</span> <span class="operator">=</span> ruleProvider.getRateLimiterRule(joinPoint, rateLimit);</span><br><span class="line"></span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> rateLimiterService.isAllowed(rule);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allowed</span> <span class="operator">=</span> result.isAllow();</span><br><span class="line">        <span class="keyword">if</span> (!allowed) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Trigger current limiting,key:&#123;&#125;&quot;</span>, rule.getKey());</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(rule.getFallbackFunction())) &#123;</span><br><span class="line">                <span class="keyword">return</span> ruleProvider.executeFunction(rule.getFallbackFunction(), joinPoint);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">extra</span> <span class="operator">=</span> result.getExtra();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RateLimitException</span>(<span class="string">&quot;Too Many Requests&quot;</span>, extra, rule.getMode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段的核心配置其实是@Around(value &#x3D; “@annotation(rateLimit)”)这个代码，通过这个环绕通知的切面拦截，可以实现一种AOP的Starter的自动增强处理。</p><p>然后在AutoConfiguration类中，去导入这个AOP类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = RateLimiterProperties.PREFIX, name = &quot;enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(RedisAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RateLimiterProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123;RateLimitAspectHandler.class, RateLimitExceptionHandler.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RateLimiterProperties limiterProperties;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">REDISSON_BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;rateLimiterRedissonBeanName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RateLimiterAutoConfiguration</span><span class="params">(RateLimiterProperties limiterProperties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limiterProperties = limiterProperties;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringBoot-自动装配"><a href="#SpringBoot-自动装配" class="headerlink" title="SpringBoot 自动装配"></a>SpringBoot 自动装配</h1><p>@SpringBootApplication的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">       @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ComponentScan的作用是扫描被 @Component @Service @Controller注解的bean，注解会默认扫描该类所在包下的所有类</p><p>@SpringBootConfiguration 的源码如下：</p><p>它的核心就是 @Configuration，允许在上下文中注册额外的bean或导入其他配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableAutoConfiguration是启用SpringBoot的自动配置机制的关键</p><p>可以看到，@EnableAutoConfiguration注解通过 Spring 提供的 @Import 注解导入了 AutoConfigurationImportSelector 类</p><p>AutoConfigurationImportSelector 类中的 getCandidateConfigurations 方法会将所有自动配置类信息以 List 的形式返回。这些配置信息会被 Spring 容器作 bean 来管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Environment property that can be used to override when auto-configuration is</span></span><br><span class="line"><span class="comment"> * enabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment"> * applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">getBeanClassLoader());</span><br><span class="line">Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">+ <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了自动配置信息以后，自动配置还差 @Conditional 注解。</p><p>拿 Spring Security 的自动配置举个例子：SecurityAutoConfiguration 中导入了 WebSecurityEnablerConfiguration类，WebSecurityEnablerConfiguration源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = BeanIds.SPRING_SECURITY_FILTER_CHAIN)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(EnableWebSecurity.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebSecurityEnablerConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebSecurityEnablerConfiguration 类中使用了 @ConditionalOnClass 指定了容器中必须还有 EnableWebSecurity 类。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> starter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL语句执行原理</title>
      <link href="/2023/12/07/MySQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2023/12/07/MySQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*) 的实现方式"></a>count(*) 的实现方式</h1><p>在不同的MySQL引擎中，count(*)有不同的实现方式。</p><ul><li>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</li><li>而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><p>这篇文章里讨论的是没有过滤条件的count(*)，如果加了where 条件的话，MyISAM表也是不能返回得这么快的。</p><blockquote><p><strong>为什么InnoDB不跟MyISAM一样，也把数字存起来呢？</strong></p></blockquote><p>由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</p><h2 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h2><p>一般会想到使用 Redis 缓存总数，但是即使 Redis 正常工作，这个值还是逻辑上不精确的。</p><p>因为使用 Redis 存储会存在数据不一致的情况，无论是先往数据表里插入一行，然后 Redis 计数 + 1; 还是先 Redis 计数 + 1,再往数据表里插入一行。</p><p><strong>Redis 和 MySQL 是不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。</strong></p><h2 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h2><table><thead><tr><th>时刻</th><th>会话A</th><th>会话B</th></tr></thead><tbody><tr><td>T1</td><td></td><td></td></tr><tr><td>T2</td><td>begin;<br>表C中计数加1</td><td></td></tr><tr><td>T3</td><td></td><td>begin;<br>读表C计数值；<br>查询最近100条记录；<br>commit;</td></tr><tr><td>T4</td><td>插入一行数据R;<br>commit;</td><td></td></tr></tbody></table><p>虽然会话B的读操作仍然是在T3执行的，但是因为这时候更新事务还没有提交，所以计数值加1这个操作对会话B还不可见。</p><p>因此，会话B看到的结果里， 查计数值和“最近100条记录”看到的结果，逻辑上就是一致的。</p><h2 id="不同的-count-用法"><a href="#不同的-count-用法" class="headerlink" title="不同的 count 用法"></a>不同的 count 用法</h2><p>count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</p><p>count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。</p><p><strong>对于count(主键id)来说</strong>，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</p><p><strong>对于count(1)来说</strong>，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p><p>单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。</p><p><strong>对于count(字段)来说</strong>：</p><ol><li>如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</li><li>如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</li></ol><p>也就是前面的第一条原则，server层要什么字段，InnoDB就返回什么字段。</p><p><strong>但是count(*)是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不是null，按行累加。</p><blockquote><p>由于事务可以保证中间结果不被别的事务读到，因此修改计数值和插入新记录的顺序是不影响逻辑结果的。但是，从并发系统性能的角度考虑，你觉得在这个事务序列里，应该先插入操作记录，还是应该先更新计数表呢？</p></blockquote><p>并发系统性能的角度考虑，应该先插入操作记录，再更新计数表。<br>因为更新计数表涉及到行锁的竞争，先插入再更新能最大程度地减少事务之间的锁等待，提升并发度。</p><blockquote><p>如果把update计数表放到事务的第一个语句，多个业务表同时插入数据的话，等待时间会更长吗？</p></blockquote><p>答案是不会。即使我们用一个计数表记录多个业务表的行数，也肯定会给表名字段加唯一索引。在更新计数表的时候，一定会传入where table_name&#x3D;$table_name，使用主键索引，更新加行锁只会锁在一行上。而在不同业务表插入数据，是更新不同的行，不会有行锁。</p><h1 id="查询一行数据怎么那么慢"><a href="#查询一行数据怎么那么慢" class="headerlink" title="查询一行数据怎么那么慢"></a>查询一行数据怎么那么慢</h1><p>构造一个表，插入10万行数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">100000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><h2 id="第一类：查询长时间不返回"><a href="#第一类：查询长时间不返回" class="headerlink" title="第一类：查询长时间不返回"></a>第一类：查询长时间不返回</h2><p>在表t执行下面的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>大概率是表t被锁住了，执行一下show processlist命令，看看当前语句处于什么状态。</p><h3 id="等MDL锁"><a href="#等MDL锁" class="headerlink" title="等MDL锁"></a>等MDL锁</h3><p>如图2所示，就是使用show processlist命令查看Waiting for table metadata lock的示意图。</p><p><img src="https://static001.geekbang.org/resource/image/50/28/5008d7e9e22be88a9c80916df4f4b328.png" alt="img"></p><p>session A 通过lock table命令持有表t的MDL写锁，而session B的查询需要获取MDL读锁。所以，session B进入等待状态。</p><p>通过查询sys.schema_table_lock_waits这张表，我们就可以直接找出造成阻塞的process id，把这个连接用kill 命令断开即可。</p><p><img src="https://static001.geekbang.org/resource/image/74/01/74fb24ba3826e3831eeeff1670990c01.png" alt="img"></p><h3 id="等flush"><a href="#等flush" class="headerlink" title="等flush"></a>等flush</h3><p>在表t上，执行下面的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.processlist <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查出来这个线程的状态是Waiting for table flush，这个状态表示的是，现在有一个线程正要对表t做flush操作。<br><img src="https://static001.geekbang.org/resource/image/2d/24/2d8250398bc7f8f7dce8b6b1923c3724.png" alt="img"></p><p>如果指定表t的话，代表的是只关闭表t；如果没有指定具体的表名，则表示关闭MySQL里所有打开的表。但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。</p><p>所以，出现Waiting for table flush状态的可能情况是：有一个flush tables命令被别的语句堵住了，然后它又堵住了我们的select语句。</p><p>同样使用show processlist命令，找到并kill掉阻塞的线程。</p><h3 id="等行锁"><a href="#等行锁" class="headerlink" title="等行锁"></a>等行锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode; </span><br></pre></td></tr></table></figure><p>由于访问id&#x3D;1这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的select语句就会被堵住。</p><p>如果你用的是MySQL 5.7版本，可以通过sys.innodb_lock_waits 表查到谁在占用这个写锁。</p><p>查询方法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t sys.innodb_lock_waits <span class="keyword">where</span> locked_table<span class="operator">=</span>`<span class="string">&#x27;test&#x27;</span>.<span class="string">&#x27;t&#x27;</span>`\G</span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/d8/18/d8603aeb4eaad3326699c13c46379118.png" alt="img"></p><p>可以看到，这个信息很全，4号线程是造成堵塞的罪魁祸首。而干掉这个罪魁祸首的方式，就是KILL QUERY 4或KILL 4。</p><p>不过，这里不应该显示“KILL QUERY 4”。这个命令表示停止4号线程当前正在执行的语句，而这个方法其实是没有用的。因为占有行锁的是update语句，这个语句已经是之前执行完成了的，现在执行KILL QUERY，无法让这个事务去掉id&#x3D;1上的行锁。</p><p>实际上，KILL 4才有效，也就是说直接断开这个连接。这里隐含的一个逻辑就是，连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了id&#x3D;1上的行锁。</p><h2 id="第二类：查询慢"><a href="#第二类：查询慢" class="headerlink" title="第二类：查询慢"></a>第二类：查询慢</h2><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>start transaction with consistent snapshot;</td><td>update t set c&#x3D;c+1 where id&#x3D;1;<br>执行100万次</td></tr><tr><td></td><td></td></tr><tr><td>select * from t where id &#x3D; 1;</td><td></td></tr><tr><td>select * from t where id&#x3D;1 lock in share mode;</td><td></td></tr></tbody></table><p>session A先用start transaction with consistent snapshot命令启动了一个事务，之后session B才开始执行update 语句。</p><p>session B更新完100万次，生成了100万个回滚日志(undo log)。</p><p>带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select * from t where id&#x3D;1这个语句，是一致性读，因此需要从1000001开始，依次执行undo log，执行了100万次以后，才将1这个结果返回。</p><h1 id="Order-by的排序原理"><a href="#Order-by的排序原理" class="headerlink" title="Order by的排序原理"></a>Order by的排序原理</h1><p>现给出一个使用 order by 的查询语句，通过这个语句了解其执行流程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>  ;</span><br></pre></td></tr></table></figure><h2 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h2><p>为避免全表扫描，我们需要在city字段加上索引。</p><p>在city字段上创建索引之后，我们用explain命令来看看这个语句的执行情况。</p><p>Extra这个字段中的“Using filesort”表示的就是需要排序，MySQL会给每个线程分配一块内存用于排序，称为<strong>sort_buffer</strong>。</p><p>假设满足city&#x3D;’杭州’条件的行，是从ID_X到ID_Y的这些记录。</p><p>通常情况下，这个语句执行流程如下所示 ：</p><ol><li>初始化sort_buffer，确定放入name、city、age这三个字段；</li><li>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是ID_X；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是ID_Y；</li><li>对sort_buffer中的数据按照字段name做快速排序；</li><li>按照排序结果取前1000行返回给客户端。</li></ol><p><img src="https://i0.hdslb.com/bfs/openplatform/f56cf8ff6454d562e9d5b6f76f1992051c1bcc61.png" alt="17012396485694"></p><p>可以看到，排序操作是再 sort_buffer 内完成的，也有可能会使用到外部排序，取决于排序所需的内存和参数 sort_buffer_size。</p><p><strong>sort_buffer_size</strong>：是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p><p>你可以用下面介绍的方法，来确定一个排序语句是否使用了临时文件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* @a保存Innodb_rows_read的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@a</span> <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`\G</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @b保存Innodb_rows_read的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@b</span> <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算Innodb_rows_read差值 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@b</span><span class="operator">-</span><span class="variable">@a</span>;</span><br></pre></td></tr></table></figure><p>这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，你可以从 number_of_tmp_files中看到是否使用了临时文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;filesort_summary&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span><span class="number">4000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;examined_rows&quot;</span><span class="punctuation">:</span><span class="number">4000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;number_of_tmp_files&quot;</span><span class="punctuation">:</span><span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort_buffer_size&quot;</span><span class="punctuation">:</span><span class="number">32664</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort_mode&quot;</span><span class="punctuation">:</span><span class="string">&quot;&lt;sort_key,packed_additional_fields&gt;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>number_of_tmp_files表示的是，排序过程中使用的临时文件数。当number_of_tmp_files的值大于0，表示内存放不下了，就需要使用外部排序，外部排序一般使用归并排序算法。可以这么简单理解，<strong>MySQL将需要排序的数据分成n份，每一份单独排序后存在这些临时文件中。然后把这n个有序文件再合并成一个有序的大文件。</strong></p><p>如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，表示排序可以直接在内存中完成。</p><p>表中有4000条满足city&#x3D;’杭州’的记录，所以你可以看到 examined_rows&#x3D;4000，表示参与排序的行数是4000行。</p><p>sort_mode 里面的packed_additional_fields的意思是，排序过程对字符串做了“紧凑”处理。即使name字段的定义是varchar(16)，在排序过程中还是要按照实际长度来分配空间的。</p><p>同时，最后一个查询语句select @b-@a 的返回结果是4000，表示整个执行过程只扫描了4000行。</p><p>这里需要注意的是，为了避免对结论造成干扰，我把internal_tmp_disk_storage_engine设置成MyISAM。否则，select @b-@a的结果会显示为4001。</p><p>这是因为查询OPTIMIZER_TRACE这个表时，需要用到临时表，而internal_tmp_disk_storage_engine的默认值是InnoDB。如果使用的是InnoDB引擎的话，把数据从临时表取出来的时候，会让Innodb_rows_read的值加1。</p><h2 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h2><p>如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p><p>针对于排序的单行长度太大的问题，可以通过修改 max_length_for_sort_dat 的值来解决。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> max_length_for_sort_data <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>max_length_for_sort_data 是如果单行的长度超过这个值，MySQL 就认为单行太大，需要换一个算法。</p><p>假设 city、name、age 这三个字段的定义总长度是36，新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id。</p><p>因此会比全字段排序多一个步骤，遍历排序结果，按照 id 值回到原表中取出 city,name,age 三个字段返回给客户端。</p><p>examined_rows的值还是4000，表示用于排序的数据是4000行。但是select @b-@a这个语句的值变成5000了。</p><p>因为这时候除了排序过程外，在排序完成后，还要根据id去原表取值。由于语句是limit 1000，因此会多读1000行。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;filesort_summary&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span><span class="number">4000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;examined_rows&quot;</span><span class="punctuation">:</span><span class="number">4000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;number_of_tmp_files&quot;</span><span class="punctuation">:</span><span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort_buffer_size&quot;</span><span class="punctuation">:</span><span class="number">32728</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort_mode&quot;</span><span class="punctuation">:</span><span class="string">&quot;&lt;sort_key,rowid&gt;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>从OPTIMIZER_TRACE的结果中，还能看到另外两个信息也变了。</p><ul><li>sort_mode变成了&lt;sort_key, rowid&gt;，表示参与排序的只有name和id这两个字段。</li><li>number_of_tmp_files变成10了，是因为这时候参与排序的行数虽然仍然是4000行，但是每一行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了。</li></ul><p><strong>更佳实践：</strong></p><ul><li>建一个(city,name)的联合索引，就可以避免使用order by 排序时生成临时表并在临时表上排序了。原因是索引保证了从city这个索引取出来的行，天然按照name递增排序。</li><li>建一个(city,name,age)的覆盖索引，不但能避免多余的排序操作，还能避免回到主键索引上取数据的操作</li></ul><h1 id="随机数据的显示"><a href="#随机数据的显示" class="headerlink" title="随机数据的显示"></a>随机数据的显示</h1><blockquote><p>有个英语学习App首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。</p><p>现在，如果让你来设计这个SQL语句，你会怎么写呢？</p></blockquote><p>为了便于理解，我对这个例子进行了简化：去掉每个级别的用户都有一个对应的单词表这个逻辑，直接就是从一个单词表中随机选出三个单词。</p><p>建表语句和初始化数据如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `words` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `word` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">  while i<span class="operator">&lt;</span><span class="number">10000</span> do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> words(word) <span class="keyword">values</span>(concat(<span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i div <span class="number">1000</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">1000</span> div <span class="number">100</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">100</span> div <span class="number">10</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">10</span>))));</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><h2 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>我们先用explain命令来看看这个语句的执行情况。</p><p><img src="https://static001.geekbang.org/resource/image/59/50/59a4fb0165b7ce1184e41f2d061ce350.png" alt="img"></p><p>图1 使用explain命令查看语句的执行情况</p><p>Extra字段显示Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行排序操作。</p><p>因此这个Extra的意思就是，需要临时表，并且需要在临时表上排序。</p><p><strong>对于InnoDB表来说</strong>，执行全字段排序会减少磁盘访问，因此会被优先选择。</p><p><strong>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘</strong>。优化器会优先考虑的，就是用于排序的行越少越好了，所以，MySQL这时就会选择rowid排序。</p><p>这条语句的执行流程是这样的：</p><ol><li>创建一个临时表。这个临时表使用的是memory引擎，表里有两个字段，第一个字段是double类型，为了后面描述方便，记为字段R，第二个字段是varchar(64)类型，记为字段W。并且，这个表没有建索引。</li><li>从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中，到此，扫描行数是10000。</li><li>现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排序。</li><li>初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。</li><li>从内存临时表中一行一行地取出R值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加10000，变成了20000。</li><li>在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li><li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。</li></ol><p>接下来，我们通过慢查询日志（slow log）来验证一下我们分析得到的扫描行数是否正确。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Query_time: <span class="number">0.900376</span>  Lock_time: <span class="number">0.000347</span> Rows_sent: <span class="number">3</span> Rows_examined: <span class="number">20003</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">timestamp</span><span class="operator">=</span><span class="number">1541402277</span>;</span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行，也就验证了我们分析得出的结论。</p><p>如果你创建的表没有主键，或者把一个表的主键删掉了，那么InnoDB会自己生成一个长度为6字节的rowid来作为主键。</p><p>这也就是排序模式里面，rowid名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行的信息。</p><ul><li>对于有主键的InnoDB表来说，这个rowid就是主键ID；</li><li>对于没有主键的InnoDB表来说，这个rowid就是由系统生成的；</li><li>MEMORY引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个rowid其实就是数组的下标。</li></ul><p>到这里，我来稍微小结一下：<strong>order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。</strong></p><h2 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h2><p>tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。</p><p>磁盘临时表使用的引擎默认是InnoDB，是由参数internal_tmp_disk_storage_engine控制的。</p><p>为了复现这个过程，把tmp_table_size设置成1024，把sort_buffer_size设置成 32768, 把 max_length_for_sort_data 设置成16。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> tmp_table_size<span class="operator">=</span><span class="number">1024</span>;</span><br><span class="line"><span class="keyword">set</span> sort_buffer_size<span class="operator">=</span><span class="number">32768</span>;</span><br><span class="line"><span class="keyword">set</span> max_length_for_sort_data<span class="operator">=</span><span class="number">16</span>;</span><br><span class="line"><span class="comment">/* 打开 optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`\G</span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/78/ab/78d2db9a4fdba81feadccf6e878b4aab.png" alt="img"></p><p>R字段存放的随机值就8个字节，rowid是6个字节，数据总行数是10000，这样算出来就有140000字节，超过了sort_buffer_size 定义的 32768字节了。但是，number_of_tmp_files的值居然是0。</p><p>此时采用是MySQL 5.6版本引入的一个新的排序算法，即：优先队列排序算法。filesort_priority_queue_optimization这个部分的chosen&#x3D;true，就表示使用了优先队列排序算法</p><blockquote><p>为什么不使用归并排序算法呢？</p></blockquote><p>原因是我们的 sql 语句只需要取R值最小的3个rowid，使用归并排序需要将10000行数据排好，浪费很多计算量。</p><p>而优先队列算法，就可以精确地只得到三个最小值，执行流程如下：</p><ol><li>对于这10000个准备排序的(R,rowid)，先取前三行，构造成一个堆；</li></ol><p>（对数据结构印象模糊的同学，可以先设想成这是一个由三个元素组成的数组）</p><ol start="2"><li><p>取下一个行(R’,rowid’)，跟当前堆里面最大的R比较，如果R’小于R，把这个(R,rowid)从堆中去掉，换成(R’,rowid’)；</p></li><li><p>重复第2步，直到第10000个(R’,rowid’)完成比较。</p></li></ol><p>整个排序过程中，为了最快地拿到当前堆的最大值，总是保持最大值在堆顶，因此这是一个最大堆。</p><h2 id="随机排序算法"><a href="#随机排序算法" class="headerlink" title="随机排序算法"></a>随机排序算法</h2><p>要随机取3个word值，你可以这么做：</p><ol><li>取得整个表的行数，记为C；</li><li>根据相同的随机方法得到Y1、Y2、Y3；</li><li>再执行三个limit Y, 1语句得到三行数据。</li></ol><p>下面这段代码，就是上面流程的执行语句的序列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@C</span> <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y1</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y2</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y3</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y1</span>，<span class="number">1</span>； <span class="operator">/</span><span class="operator">/</span>在应用代码里面取Y1、Y2、Y3值，拼出<span class="keyword">SQL</span>后执行</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y2</span>，<span class="number">1</span>；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y3</span>，<span class="number">1</span>；</span><br></pre></td></tr></table></figure><blockquote><p>为什么这个算法比order by rand()的代价小很多？</p></blockquote><p>因为进行limit获取数据的时候是根据主键排序获取的，主键天然索引排序。获取到第9999条的数据也远比order by rand()方法的组成临时表R字段排序再获取rowid代价小的多。</p><blockquote><p>上面的随机算法3的总扫描行数是 C+(Y1+1)+(Y2+1)+(Y3+1)，实际上它还是可以继续优化，来进一步减少扫描行数的。</p><p>我的问题是，如果你是这个需求的开发人员，你会怎么做，来减少扫描行数呢？说说你的方案，并说明你的方案需要的扫描行数。</p></blockquote><p>取Y1、Y2和Y3里面最大的一个数，记为M，最小的一个数记为N，然后执行下面这条SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit N, M<span class="operator">-</span>N<span class="operator">+</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>再加上取整个表总行数的C行，这个方案的扫描行数总共只需要C+M+1行。</p><p>当然也可以先取回id值，在应用中确定了三个id值以后，再执行三次where id&#x3D;X的语句也是可以的。</p><h1 id="Kill-线程"><a href="#Kill-线程" class="headerlink" title="Kill 线程"></a>Kill 线程</h1><p><strong>实现上，当用户执行kill query thread_id_B时，MySQL里处理kill命令的线程做了两件事：</strong></p><ol><li>把session B的运行状态改成THD::KILL_QUERY(将变量killed赋值为THD::KILL_QUERY)；</li><li>给session B的执行线程发一个信号。让session B退出等待，来处理这个THD::KILL_QUERY状态。</li></ol><p>语句的执行终止过程：</p><ol><li>一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态是THD::KILL_QUERY，才开始进入语句终止逻辑；</li><li>如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处；</li><li>语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。</li></ol><p><strong>为什么在执行kill query命令时，这条语句不像第一个例子的update语句一样退出呢？</strong></p><p><strong>第一类线程没有执行到判断线程状态的逻辑。</strong>跟这种情况相同的，还有由于IO压力过大，读写IO的函数一直无法返回，导致不能及时判断线程的状态。</p><p><strong>另一类情况是，终止逻辑耗时较长。</strong>这时候，从show processlist结果上看也是Command&#x3D;Killed，需要等到终止逻辑完成，语句才算真正完成。这类情况，比较常见的场景有以下几种：</p><ol><li>超大事务执行期间被kill。这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。</li><li>大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待IO资源，导致耗时较长。</li><li>DDL命令执行到最后阶段，如果被kill，需要删除中间过程的临时文件，也可能受IO资源影响耗时较久。</li></ol><blockquote><p>如果直接在客户端通过Ctrl+C命令，是不是就可以直接终止线程呢？</p></blockquote><p>答案是，不可以。</p><p>这里有一个误解，其实在客户端的操作只能操作到客户端的线程，客户端和服务端只能通过网络交互，是不可能直接操作服务端线程的。</p><p>而由于MySQL是停等协议，所以这个线程执行的语句还没有返回的时候，再往这个连接里面继续发命令也是没有用的。实际上，执行Ctrl+C的时候，是MySQL客户端另外启动一个连接，然后发送一个kill query 命令。</p><blockquote><p>如果库里面的表特别多，连接就会很慢。这是什么原因？</p></blockquote><p>每个客户端在和服务端建立连接的时候，需要做的事情就是TCP握手、用户校验、获取权限。但这几个操作，显然跟库里面表的个数无关。</p><p>当使用默认参数连接的时候，MySQL客户端会提供一个本地库名和表名补全的功能。为了实现这个功能，客户端在连接成功后，需要多做一些操作：</p><ol><li>执行show databases；</li><li>切到db1库，执行show tables；</li><li>把这两个命令的结果用于构建一个本地的哈希表。</li></ol><p>在这些操作中，最花时间的就是第三步在本地构建哈希表的操作。所以，当一个库中的表个数非常多的时候，这一步就会花比较长的时间。</p><p>如果在连接命令中加上-A，就可以关掉这个自动补全的功能，然后客户端就可以快速返回了。</p><p>这里自动补全的效果就是，你在输入库名或者表名的时候，输入前缀，可以使用Tab键自动补全表名或者显示提示。</p><p>实际使用中，如果你自动补全功能用得并不多，我建议你每次使用的时候都默认加-A。</p><blockquote><p>如果你碰到一个被killed的事务一直处于回滚状态，你认为是应该直接把MySQL进程强行重启，还是应该让它自己执行完成呢？为什么呢？</p></blockquote><p>因为重启之后该做的回滚动作还是不能少的，所以从恢复速度的角度来说，应该让它自己结束。</p><p>当然，如果这个语句可能会占用别的锁，或者由于占用IO资源过多，从而影响到了别的语句执行的话，就需要先做主备切换，切到新主库提供服务。</p><p>切换之后别的线程都断开了连接，自动停止执行。接下来还是等它自己执行完成。</p><h1 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h1><h2 id="对-server-层影响"><a href="#对-server-层影响" class="headerlink" title="对 server 层影响"></a>对 server 层影响</h2><p>假设，我们现在要对一个200G的InnoDB表db1. t，执行一个全表扫描。要把扫描结果保存在客户端，会使用类似这样的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h$host <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="operator">-</span>p$pwd <span class="operator">-</span>e &quot;select * from db1.t&quot; <span class="operator">&gt;</span> $target_file</span><br></pre></td></tr></table></figure><p>InnoDB的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表t的主键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到结果集里面，然后返回给客户端。</p><p>取数据和发数据的流程是这样的：</p><ol><li>获取一行，写到net_buffer中。这块内存的大小是由参数net_buffer_length定义的，默认是16k。</li><li>重复获取行，直到net_buffer写满，调用网络接口发出去。</li><li>如果发送成功，就清空net_buffer，然后继续取下一行，并写入net_buffer。</li><li>如果发送函数返回EAGAIN或WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。</li></ol><p><strong>MySQL是“边读边发的”</strong>,如果客户端接收得慢，会导致MySQL服务端由于结果发不出去，这个事务的执行时间变长。</p><p>如果客户端使用–quick参数，会使用mysql_use_result方法。这个方法是读一行处理一行。你可以想象一下，假设有一个业务的逻辑比较复杂，每读一行数据以后要处理的逻辑如果很慢，就会导致客户端要过很久才会去取下一行数据，就很有可能看到State的值一直处于<strong>“Sending to client”</strong>。</p><p><strong>对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，我都建议你使用mysql_store_result这个接口，直接把查询结果保存到本地内存。</strong></p><p>如果你在自己负责维护的MySQL里看到很多个线程都处于“Sending to client”这个状态，就意味着你要让业务开发同学优化查询结果，并评估这么多的返回结果是否合理。</p><p>而如果要快速减少处于这个状态的线程的话，将net_buffer_length参数设置为一个更大的值是一个可选方案。</p><p>仅当一个线程处于“等待客户端接收结果”的状态，才会显示”Sending to client”；而如果显示成“Sending data”，它的意思只是“正在执行”。</p><h2 id="对-InnoDB-的影响"><a href="#对-InnoDB-的影响" class="headerlink" title="对 InnoDB 的影响"></a>对 InnoDB 的影响</h2><p>Buffer Pool对查询的加速效果，依赖于一个重要的指标，即：<strong>内存命中率</strong> Buffer pool hit rate。InnoDB Buffer Pool的大小是由参数 innodb_buffer_pool_size确定的，一般建议设置成可用物理内存的60%~80%。</p><p>在大约十年前，单机的数据量是上百个G，而物理内存是几个G；现在虽然很多服务器都能有128G甚至更高的内存，但是单机的数据量却达到了T级别。</p><p>所以，innodb_buffer_pool_size小于磁盘的数据量是很常见的。如果一个 Buffer Pool满了，而又要从磁盘读入一个数据页，那肯定是要淘汰一个旧数据页的。</p><p>InnoDB内存管理用的是最近最少使用 (Least Recently Used, LRU)算法，这个算法的核心就是淘汰最久未使用的数据。但是实际上，InnoDB不是直接使用 LRU 算法的，因为如果完全按照这个算法，当业务上需要扫描一个200G的历史数据表（平时没有业务访问），就会使得当前 Buffer Pool 里的数据全部淘汰掉，Buffer Pool 的内存命中率下降，磁盘压力增加，SQL语句响应变慢。</p><p>实际上，InnoDB对LRU算法做了改进。在InnoDB实现上，按照5:3的比例把整个LRU链表分成了young区域和old区域。</p><ol><li><p>图中状态1，要访问数据页P3，由于P3在young区域，因此和优化前的LRU算法一样，将其移到链表头部，变成状态2。</p></li><li><p>之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页Pm，但是新插入的数据页Px，是放在LRU_old处。</p></li><li><p>处于old区域的数据页，每次被访问的时候都要做下面这个判断：</p><ul><li>若这个数据页在LRU链表中存在的时间超过了1秒，就把它移动到链表头部；</li><li>如果这个数据页在LRU链表中存在的时间短于1秒，位置保持不变。1秒这个时间，是由参数innodb_old_blocks_time控制的。其默认值是1000，单位毫秒。</li></ul><p><img src="https://static001.geekbang.org/resource/image/25/9e/25e18920dd204cf99eec2d62755fe99e.png" alt="img"></p></li><li><p>扫描过程中，需要新插入的数据页，都被放到old区域;</p></li><li><p>一个数据页里面有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过1秒，因此还是会被保留在old区域；</p></li><li><p>再继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移到链表头部（也就是young区域），很快就会被淘汰出去</p></li></ol><h1 id="Join-执行原理"><a href="#Join-执行原理" class="headerlink" title="Join 执行原理"></a>Join 执行原理</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t2` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> idata;</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">like</span> t2;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>可以看到，这两个表都有一个主键索引id和一个索引a，字段b上无索引。存储过程idata()往表t2里插入了1000行数据，在表t1里插入的是100行数据。</p><h2 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h2><p>我们来看一下这个语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a<span class="operator">=</span>t2.a);</span><br></pre></td></tr></table></figure><p>可以看到，在这条语句里，被驱动表t2的字段a上有索引，join过程用上了这个索引，因此这个语句的执行流程是这样的：先遍历表t1，然后根据从表t1中取出的每行数据中的a值，去表t2中查找满足条件的记录。</p><p>在这个流程里：</p><ol><li>对驱动表t1做了全表扫描，这个过程需要扫描100行；</li><li>而对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描100行；</li><li>所以，整个执行流程，总扫描行数是200。</li></ol><p>在这个join语句执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索。</p><p>假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每次搜索一棵树近似复杂度是以2为底的M的对数，记为log2M，所以在被驱动表上查一行的时间复杂度是 2*log2M。</p><p>假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次。</p><p>因此整个执行过程，近似复杂度是 N + N<em>2</em>log2M。显然，N对扫描行数的影响更大，因此应该让小表来做驱动表。</p><h2 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h2><p>这时候，被驱动表上没有可用的索引，算法的流程是这样的：</p><ol><li>把表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是select *，因此是把整个表t1放入了内存；</li><li>扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。</li></ol><p>可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100。由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做的判断次数是：100*1000&#x3D;10万次。</p><p>假设小表的行数是N，大表的行数是M，那么在这个算法里：</p><ol><li>两个表都做一次全表扫描，所以总的扫描行数是M+N；</li><li>内存中的判断次数是M*N。</li></ol><blockquote><p> 如果表t1是一张大表，join_buffer的 join_buffer_size 不够怎么办？</p></blockquote><p>分段放。</p><ol><li>扫描表t1，顺序读取数据行放入join_buffer中，放完第88行join_buffer满了，继续第2步；</li><li>扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回；</li><li>清空join_buffer；</li><li>继续扫描表t1，顺序读取最后的12行数据放入join_buffer中，继续执行第2步。</li></ol><p>假设，驱动表的数据行数是N，需要分K段才能完成算法流程，被驱动表的数据行数是M。</p><p>注意，这里的K不是常数，N越大K就会越大，因此把K表示为λ*N，显然λ的取值范围是(0,1)。</p><p>所以，在这个算法的执行过程中：</p><ol><li>扫描行数是 N+λ<em>N</em>M；</li><li>内存判断 N*M次。</li></ol><p>考虑到扫描行数，在M和N大小确定的情况下，N小一些，整个算式的结果会更小。那么，N固定的时候，什么参数会影响K的大小呢？（也就是λ的大小）答案是join_buffer_size。join_buffer_size越大，一次可以放入的行越多，分成的段数也就越少，对被驱动表的全表扫描次数就越少。</p><blockquote><p>能不能使用join语句？</p></blockquote><ol><li>如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</li><li>如果使用Block Nested-Loop Join算法，扫描行数就会过多。尤其是在大表上的join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。</li></ol><blockquote><p>如果要使用join，应该选择大表做驱动表还是选择小表做驱动表？</p></blockquote><ol><li>如果是Index Nested-Loop Join算法，应该选择小表做驱动表；</li><li>如果是Block Nested-Loop Join算法：<ul><li>在join_buffer_size足够大的时候，是一样的；</li><li>在join_buffer_size不够大的时候（这种情况更常见），应该选择小表做驱动表。</li></ul></li></ol><p><strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</strong></p><h2 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested Loop Join"></a>Simple Nested Loop Join</h2><p>Simple Nested Loop Join算法的执行逻辑是：顺序取出驱动表中的每一行数据，到被驱动表去做全表扫描匹配，匹配成功则作为结果集的一部分返回。</p><blockquote><p>为什么Simple Nested Loop Join算法和BNL算法性能差距那么大？</p></blockquote><ol><li>在对被驱动表做全表扫描的时候，如果数据没有在Buffer Pool中，就需要等待这部分数据从磁盘读入；<br>从磁盘读入数据到内存中，会影响正常业务的Buffer Pool命中率，而且这个算法天然会对被驱动表的数据做多次访问，更容易将这些数据页放到Buffer Pool的头部</li><li>即使被驱动表数据都在内存中，每次查找“下一个记录的操作”，都是类似指针操作。而join_buffer中是数组，遍历的成本更低。</li></ol><h1 id="Join-优化方法"><a href="#Join-优化方法" class="headerlink" title="Join 优化方法"></a>Join 优化方法</h1><h2 id="Multi-Range-Read-优化"><a href="#Multi-Range-Read-优化" class="headerlink" title="Multi-Range Read 优化"></a>Multi-Range Read 优化</h2><p><strong>因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</strong></p><p>这，就是MRR优化的设计思路。此时，语句的执行流程变成了这样：</p><ol><li>根据索引a，定位到满足条件的记录，将id值放入read_rnd_buffer中;</li><li>将read_rnd_buffer中的id进行递增排序；</li><li>排序后的id数组，依次到主键id索引中查记录，并作为结果返回。</li></ol><p>read_rnd_buffer的大小是由read_rnd_buffer_size参数控制的。如果步骤1中，read_rnd_buffer放满了，就会先执行完步骤2和3，然后清空read_rnd_buffer。之后继续找索引a的下个记录，并继续循环。</p><p>如果你想要稳定地使用MRR优化的话，需要设置<code>set optimizer_switch=&quot;mrr_cost_based=off&quot;</code>。</p><h2 id="Batched-Key-Access"><a href="#Batched-Key-Access" class="headerlink" title="Batched Key Access"></a>Batched Key Access</h2><p>从驱动表t1，一次性多拿些行写入到 join_buffer，再到被驱动表t2去做join。</p><p>如果要使用BKA优化算法的话，你需要在执行SQL语句之前，先设置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;</span>;</span><br></pre></td></tr></table></figure><p>其中，前两个参数的作用是要启用MRR。这么做的原因是，BKA算法的优化要依赖于MRR。</p><h2 id="BNL算法性能问题"><a href="#BNL算法性能问题" class="headerlink" title="BNL算法性能问题"></a>BNL算法性能问题</h2><blockquote><p>如果被驱动表是一个大表，并且是一个冷数据表，除了查询过程中可能会导致IO压力大以外，你觉得对这个MySQL服务还有什么更严重的影响吗？</p></blockquote><p>如果一个使用BNL算法的join语句，多次扫描一个冷表，而且这个语句执行时间超过1秒，就会在再次扫描冷表的时候，把冷表的数据页移到LRU链表头部。</p><p>这种情况对应的，是冷表的数据量小于整个Buffer Pool的3&#x2F;8，能够完全放入old区域的情况。</p><p>如果这个冷表很大，就会出现另外一种情况：业务正常访问的数据页，没有机会进入young区域。</p><p>BNL算法对系统的影响主要包括三个方面：</p><ol><li>可能会多次扫描被驱动表，占用磁盘IO资源；</li><li>判断join条件需要执行M*N次对比（M、N分别是两张表的行数），如果是大表就会占用非常多的CPU资源；</li><li>可能会导致Buffer Pool的热数据被淘汰，影响内存命中率。</li></ol><h2 id="BNL算法转BKA"><a href="#BNL算法转BKA" class="headerlink" title="BNL算法转BKA"></a>BNL算法转BKA</h2><p>一些情况下，我们可以直接在被驱动表上建索引，这时就可以直接转成BKA算法了。</p><p>但是，有时候你确实会碰到一些不适合在被驱动表上建索引的情况。比如下面这个语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span> (t1.b<span class="operator">=</span>t2.b) <span class="keyword">where</span> t2.b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> t2.b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br></pre></td></tr></table></figure><p>表t2中插入了100万行数据，但是经过where条件过滤后，需要参与join的只有2000行数据。如果这条语句同时是一个低频的SQL语句，那么再为这个语句在表t2的字段b上创建一个索引就很浪费了。</p><p>如果使用BNL算法来join的话，这个语句的执行流程是这样的：</p><ol><li>把表t1的所有字段取出来，存入join_buffer中。这个表只有1000行，join_buffer_size默认值是256k，可以完全存入。</li><li>扫描表t2，取出每一行数据跟join_buffer中的数据进行对比，<ul><li>如果不满足t1.b&#x3D;t2.b，则跳过；</li><li>如果满足t1.b&#x3D;t2.b, 再判断其他条件，也就是是否满足t2.b处于[1,2000]的条件，如果是，就作为结果集的一部分返回，否则跳过。</li></ul></li></ol><p>对于表t2的每一行，判断join是否满足的时候，都需要遍历join_buffer中的所有行。因此判断等值条件的次数是1000*100万&#x3D;10亿次，这个判断的工作量很大。</p><p>这时候，我们可以考虑使用临时表。使用临时表的大致思路是：</p><ol><li>把表t2中满足条件的数据放在临时表tmp_t中；</li><li>为了让join使用BKA算法，给临时表tmp_t的字段b加上索引；</li><li>让表t1和tmp_t做join操作。</li></ol><p>此时，对应的SQL语句的写法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(b))engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b<span class="operator">=</span>temp_t.b);</span><br></pre></td></tr></table></figure><p>接下来，我们一起看一下这个过程的消耗：</p><ol><li>执行insert语句构造temp_t表并插入数据的过程中，对表t2做了全表扫描，这里扫描行数是100万。</li><li>之后的join语句，扫描表t1，这里的扫描行数是1000；join比较过程中，做了1000次带索引的查询。相比于优化前的join语句需要做10亿次条件判断来说，这个优化效果还是很明显的。</li></ol><p>其实这里使用内存临时表的效果更好，原因有三个：</p><ol><li>相比于InnoDB表，使用内存表不需要写磁盘，往表temp_t的写数据的速度更快；</li><li>索引b使用hash索引，查找的速度比B-Tree索引快；</li><li>临时表数据只有2000行，占用的内存有限。</li></ol><p>将临时表t1改成内存临时表，并且在字段b上创建一个hash索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index (b))engine<span class="operator">=</span>memory;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b<span class="operator">=</span>temp_t.b);</span><br></pre></td></tr></table></figure><h2 id="扩展-hash-join"><a href="#扩展-hash-join" class="headerlink" title="扩展-hash join"></a>扩展-hash join</h2><p>如果join_buffer里面维护的不是一个无序数组，而是一个哈希表的话，那么就不是10亿次判断，而是100万次hash查找。这样的话，整条语句的执行速度就快多了。</p><p>这个优化思路，我们可以自己实现在业务端。实现流程大致如下：</p><ol><li><code>select * from t1;</code>取得表t1的全部1000行数据，在业务端存入一个hash结构，比如C++里的set、PHP的dict这样的数据结构。</li><li><code>select * from t2 where b&gt;=1 and b&lt;=2000;</code> 获取表t2中满足条件的2000行数据。</li><li>把这2000行数据，一行一行地取到业务端，到hash结构的数据表中寻找匹配的数据。满足匹配的条件的这行数据，就作为结果集的一行。</li></ol><p>现在有一个三个表join的需求，假设这三个表的表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t1;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t3 <span class="keyword">like</span> t2;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ... <span class="operator">/</span><span class="operator">/</span>初始化三张表的数据</span><br></pre></td></tr></table></figure><p>语句的需求实现如下的join逻辑：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span>(t1.a<span class="operator">=</span>t2.a) <span class="keyword">join</span> t3 <span class="keyword">on</span> (t2.b<span class="operator">=</span>t3.b) <span class="keyword">where</span> t1.c<span class="operator">&gt;=</span>X <span class="keyword">and</span> t2.c<span class="operator">&gt;=</span>Y <span class="keyword">and</span> t3.c<span class="operator">&gt;=</span>Z;</span><br></pre></td></tr></table></figure><blockquote><p>现在为了得到最快的执行速度，如果让你来设计表t1、t2、t3上的索引，来支持这个join语句，你会加哪些索引呢？</p></blockquote><blockquote><p>同时，如果我希望你用straight_join来重写这个语句，配合你创建的索引，你就需要安排连接顺序，你主要考虑的因素是什么呢？</p></blockquote><p>答：第一原则是要尽量使用BKA算法。需要注意的是，使用BKA算法的时候，并不是“先计算两个表join的结果，再跟第三个表join”，而是直接嵌套查询的。</p><p>具体实现是：在t1.c&gt;&#x3D;X、t2.c&gt;&#x3D;Y、t3.c&gt;&#x3D;Z这三个条件里，选择一个经过过滤以后，数据最少的那个表，作为第一个驱动表。此时，可能会出现如下两种情况。</p><p>第一种情况，如果选出来是表t1或者t3，那剩下的部分就固定了。</p><ol><li>如果驱动表是t1，则连接顺序是t1-&gt;t2-&gt;t3，要在被驱动表字段创建上索引，也就是t2.a 和 t3.b上创建索引；</li><li>如果驱动表是t3，则连接顺序是t3-&gt;t2-&gt;t1，需要在t2.b 和 t1.a上创建索引。</li></ol><p>同时，我们还需要在第一个驱动表的字段c上创建索引。</p><p>第二种情况是，如果选出来的第一个驱动表是表t2的话，则需要评估另外两个条件的过滤效果。</p><p>总之，整体的思路就是，尽量让每一次参与join的驱动表的数据集，越小越好，因为这样我们的驱动表就会越小。</p><h1 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h1><p><strong>临时表和内存表的区别：</strong></p><ul><li>内存表，指的是使用Memory引擎的表，建表语法是create table … engine&#x3D;memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。</li><li>而临时表，可以使用各种引擎类型 。如果是使用InnoDB引擎或者MyISAM引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用Memory引擎。</li></ul><h2 id="为什么临时表可以重名"><a href="#为什么临时表可以重名" class="headerlink" title="为什么临时表可以重名"></a>为什么临时表可以重名</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key)engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></table></figure><p>MySQL要给这个InnoDB表创建一个frm文件保存表结构定义，<strong>这个frm文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程id}_{线程id}_序列号”</strong>。你可以使用select @@tmpdir命令，来显示实例的临时文件目录。</p><p>而关于表中数据的存放方式，在不同的MySQL版本中有着不同的处理方式：</p><ul><li>在5.6以及之前的版本里，MySQL会在临时文件目录下创建一个相同前缀、以.ibd为后缀的文件，用来存放数据文件；</li><li>而从 5.7版本开始，MySQL引入了一个临时文件表空间，专门用来存放临时文件的数据。因此，我们就不需要再创建ibd文件了。</li></ul><p>MySQL维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个table_def_key。一个普通表的table_def_key的值是由“库名+表名”得到的，而临时表的 table_def_key 是由 “server_id+thread_id+库名+表名”。</p><p>每个线程都维护了自己的临时表链表。这样每次session内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在session结束的时候，对链表里的每个临时表，执行 “DROP TEMPORARY TABLE +表名”操作。</p><h2 id="临时表和主备复制"><a href="#临时表和主备复制" class="headerlink" title="临时表和主备复制"></a>临时表和主备复制</h2><p>在主库上执行下面这个语句序列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_normal(id <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>)engine<span class="operator">=</span>innodb;<span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t <span class="keyword">like</span> t_normal;<span class="comment">/*Q2*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">/*Q3*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_normal <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp_t;<span class="comment">/*Q4*/</span></span><br></pre></td></tr></table></figure><p>如果关于临时表的操作都不记录，那么在备库就只有create table t_normal表和insert into t_normal select * from temp_t这两个语句的binlog日志，备库在执行到insert into t_normal的时候，就会报错“表temp_t不存在”。</p><p>如果把binlog设置为row格式，在记录insert into t_normal的binlog时，记录的是这个操作的数据，即：write_row event里面记录的逻辑是“插入一行数据（1,1)”。也就是说，只在binlog_format&#x3D;statment&#x2F;mixed 的时候，binlog中才会记录临时表的操作。</p><p>这种情况下，创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，这时候我们就需要在主库上再写一个DROP TEMPORARY TABLE传给备库执行。</p><p>MySQL在记录binlog的时候，会把主库执行这个语句的线程id写到binlog中。这样，在备库的应用线程就能够知道执行每个语句的主库线程id，并利用这个线程id来构造临时表的table_def_key：</p><ol><li>session A的临时表t1，在备库的table_def_key就是：库名+t1+“M的serverid”+“session A的thread_id”;</li><li>session B的临时表t1，在备库的table_def_key就是 ：库名+t1+“M的serverid”+“session B的thread_id”。</li></ol><p>由于table_def_key不同，所以这两个表在备库的应用线程里面是不会冲突的。</p><blockquote><p>我们可以使用alter table语法修改临时表的表名，而不能使用rename语法。你知道这是什么原因吗？</p></blockquote><p>在实现上，执行rename table语句的时候，要求按照“库名&#x2F;表名.frm”的规则去磁盘找文件，但是临时表在磁盘上的frm文件是放在tmpdir目录下的，并且文件名的规则是“#sql{进程id}_{线程id}_序列号.frm”，因此会报“找不到文件名”的错误。</p><blockquote><p>假设你刚刚接手的一个数据库上，真的发现了一个内存表。备库重启之后肯定是会导致备库的内存表数据被清空，进而导致主备同步停止。这时，最好的做法是将它修改成InnoDB引擎表。</p><p>假设当时的业务场景暂时不允许你修改引擎，你可以加上什么自动化逻辑，来避免主备同步停止呢？</p></blockquote><p>那么就把备库的内存表引擎先都改成InnoDB。对于每个内存表，执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> sql_log_bin<span class="operator">=</span>off;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tbl_name engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></table></figure><p>这样就能避免备库重启的时候，数据丢失的问题。</p><p>由于主库重启后，会往binlog里面写“delete from tbl_name”，这个命令传到备库，备库的同名的表数据也会被清空。</p><p>因此，就不会出现主备同步停止的问题。</p><p>如果由于主库异常重启，触发了HA，这时候我们之前修改过引擎的备库变成了主库。而原来的主库变成了新备库，在新备库上把所有的内存表（这时候表里没数据）都改成InnoDB表。</p><p>所以，如果我们不能直接修改主库上的表引擎，可以配置一个自动巡检的工具，在备库上发现内存表就把引擎改了。</p><h1 id="Union执行流程"><a href="#Union执行流程" class="headerlink" title="Union执行流程"></a>Union执行流程</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">reate <span class="keyword">table</span> t1(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(a));</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><p>然后，我们执行下面这条语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> <span class="number">1000</span> <span class="keyword">as</span> f) <span class="keyword">union</span> (<span class="keyword">select</span> id <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> limit <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>这条语句用到了union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。</p><p>这个语句的执行流程是这样的：</p><ol><li>创建一个内存临时表，这个临时表只有一个整型字段f，并且f是主键字段。</li><li>执行第一个子查询，得到1000这个值，并存入临时表中。</li><li>执行第二个子查询：<ul><li>拿到第一行id&#x3D;1000，试图插入临时表中。但由于1000这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；</li><li>取到第二行id&#x3D;999，插入临时表成功。</li></ul></li><li>从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是1000和999。</li></ol><p>这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键id的唯一性约束，实现了union的语义。</p><h1 id="Group-by-执行流程"><a href="#Group-by-执行流程" class="headerlink" title="Group by 执行流程"></a>Group by 执行流程</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id<span class="operator">%</span><span class="number">10</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure><p>这个语句的逻辑是把表t1里的数据，按照 id%10 进行分组统计，并按照m的结果排序后输出。</p><p>这个语句的执行流程是这样的：</p><ol><li>创建内存临时表，表里有两个字段m和c，主键是m；</li><li>扫描表t1的索引a，依次取出叶子节点上的id值，计算id%10的结果，记为x；<ul><li>如果临时表中没有主键为x的行，就插入一个记录(x,1);</li><li>如果表中有主键为x的行，就将x这一行的c值加1；</li></ul></li><li>遍历完成后，再根据字段m做排序，得到结果集返回给客户端。</li></ol><p>如果你的需求并不需要对结果进行排序，那你可以在SQL语句末尾增加order by null，也就是改成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id<span class="operator">%</span><span class="number">10</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>这个例子里由于临时表只有10行，内存可以放得下，因此全程只使用了内存临时表。但是，内存临时表的大小是有限制的，参数tmp_table_size就是控制这个内存大小的，默认是16M。</p><p>如果我执行下面这个语句序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set tmp_table_size=1024;</span><br><span class="line">select id%100 as m, count(*) as c from t1 group by m order by null limit 10;</span><br></pre></td></tr></table></figure><p>把内存临时表的大小限制为最大1024字节，并把语句改成id % 100，这样返回结果里有100行数据。但是，这时的内存临时表大小不够存下这100行数据，也就是说，执行过程中会发现内存临时表大小到达了上限（1024字节）。</p><p>那么，这时候就会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是InnoDB。</p><h1 id="Group-by-优化方法"><a href="#Group-by-优化方法" class="headerlink" title="Group by 优化方法"></a>Group by 优化方法</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>不论是使用内存临时表还是磁盘临时表，group by逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。</p><p>group by的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的id%100的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。</p><p>InnoDB的索引，就可以满足这个输入有序的条件。</p><p>在MySQL 5.7版本支持了generated column机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列z，然后在z列上创建一个索引（如果是MySQL 5.6及之前的版本，你也可以创建普通列和索引，来解决这个问题）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">column</span> z <span class="type">int</span> generated always <span class="keyword">as</span>(id <span class="operator">%</span> <span class="number">100</span>), <span class="keyword">add</span> index(z);</span><br></pre></td></tr></table></figure><h2 id="直接排序"><a href="#直接排序" class="headerlink" title="直接排序"></a>直接排序</h2><p>在group by语句中加入SQL_BIG_RESULT这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。</p><p>因此，下面这个语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;</span><br></pre></td></tr></table></figure><p>的执行流程就是这样的：</p><ol><li>初始化sort_buffer，确定放入一个整型字段，记为m；</li><li>扫描表t1的索引a，依次取出里面的id值, 将 id%100的值存入sort_buffer中；</li><li>扫描完成后，对sort_buffer的字段m做排序（如果sort_buffer内存不够用，就会利用磁盘临时文件辅助排序）；</li><li>排序完成后，就得到了一个有序数组。</li></ol><p>根据有序数组，得到数组里面的不同值，以及每个值的出现次数。</p><blockquote><p>MySQL什么时候会使用内部临时表？</p></blockquote><ol><li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；</li><li>join_buffer是无序数组，sort_buffer是有序数组，临时表是二维表结构；</li><li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union需要用到唯一索引约束， group by还需要用到另外一个字段来存累积计数。</li></ol><blockquote><p>group by 优化方法总结：</p></blockquote><ol><li>如果对group by语句的结果没有排序要求，要在语句后面加 order by null；</li><li>尽量让group by过程用上表的索引，确认方法是explain结果里没有Using temporary 和 Using filesort；</li><li>如果group by需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大tmp_table_size参数，来避免用到磁盘临时表；</li><li>如果数据量实在太大，使用SQL_BIG_RESULT这个提示，来告诉优化器直接使用排序算法得到group by的结果。</li></ol><h1 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h1><h2 id="自增主键存储位置"><a href="#自增主键存储位置" class="headerlink" title="自增主键存储位置"></a>自增主键存储位置</h2><p>实际上，<strong>表的结构定义存放在后缀名为.frm的文件中，但是并不会保存自增值。</strong></p><p>不同的引擎对于自增值的保存策略不同。</p><ul><li>MyISAM引擎的自增值保存在数据文件中。</li><li>InnoDB引擎的自增值，其实是保存在了内存里，并且到了MySQL 8.0版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为MySQL重启前的值”，具体情况是：<ul><li>在MySQL 5.7及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值max(id)，然后将max(id)+1作为这个表当前的自增值。﻿<br>也就是说，MySQL重启可能会修改一个表的AUTO_INCREMENT的值。</li><li>在MySQL 8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值。</li></ul></li></ul><h2 id="自增值修改机制"><a href="#自增值修改机制" class="headerlink" title="自增值修改机制"></a>自增值修改机制</h2><p>在插入一行数据的时候，自增值的行为如下：</p><ol><li>如果插入数据时id字段指定为0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT值填到自增字段；</li><li>如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值。</li></ol><p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是X，当前的自增值是Y。</p><ol><li>如果X&lt;Y，那么这个表的自增值不变；</li><li>如果X≥Y，就需要把当前自增值修改为新的自增值 + 1。</li></ol><p>auto_increment_offset 和 auto_increment_increment是两个系统参数，分别用来表示自增的初始值和步长，默认值都是1。</p><blockquote><p>备注：在一些场景下，使用的就不全是默认值。比如，双M的主备结构里要求双写的时候，我们就可能会设置成auto_increment_increment&#x3D;2，让一个库的自增id都是奇数，另一个库的自增id都是偶数，避免两个库生成的主键发生冲突。</p></blockquote><h2 id="自增值修改时机"><a href="#自增值修改时机" class="headerlink" title="自增值修改时机"></a>自增值修改时机</h2><h3 id="唯一键冲突"><a href="#唯一键冲突" class="headerlink" title="唯一键冲突"></a>唯一键冲突</h3><p>表t里面已经有了(1,1,1)这条记录，这时我再执行一条插入数据命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>, <span class="number">1</span>); </span><br></pre></td></tr></table></figure><ol><li>执行器调用InnoDB引擎接口写入一行，传入的这一行的值是(0,1,1);</li><li>InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2；</li><li>将传入的行的值改成(2,1,1);</li><li>将表的自增值改成3；</li><li>继续执行插入数据操作，由于已经存在c&#x3D;1的记录，所以报Duplicate key error，语句返回。</li></ol><p>在这之后，再插入新的数据行时，拿到的自增id就是3。</p><h3 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚"></a>事务回滚</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>插入的行是(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>事务回滚后，自增值为什么不能回退？</p></blockquote><p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请。</p><ol><li>每次申请id之前，先判断表里面是否已经存在这个id。如果存在，就跳过这个id。但是，这个方法的成本很高。因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断id是否存在。</li><li>把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li></ol><p>这两个方法都会导致性能问题。InnoDB放弃了这个设计，语句执行失败也不回退自增id。</p><h3 id="自增锁的优化"><a href="#自增锁的优化" class="headerlink" title="自增锁的优化"></a>自增锁的优化</h3><p>MySQL 5.0版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。</p><p>MySQL 5.1.22版本引入了一个新策略，新增参数innodb_autoinc_lock_mode，默认值是1。</p><ol><li>这个参数的值被设置为0时，表示采用之前MySQL 5.0版本的策略，即语句执行结束后才释放锁；</li><li>这个参数的值被设置为1时：<ul><li>普通insert语句，自增锁在申请之后就马上释放；</li><li>类似insert … select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li></ul></li><li>这个参数的值被设置为2时，所有的申请自增主键的动作都是申请后就释放锁。</li></ol><blockquote><p>为什么参数innodb_autoinc_lock_mode要设置为2?</p></blockquote><p>如果有两个事务在批量新增，而批量插入过程中没有加自增锁，在binlog_format&#x3D;statement的情况下，binlog里面对表t的更新日志只有两种情况：要么先记session A的，要么先记session B的。但不论是哪一种，这个binlog拿去从库执行，或者用来恢复临时实例，备库和临时实例里面，session B这个语句执行出来，生成的结果里面，id都是连续的。这时，这个库就发生了数据不一致。</p><p>因此，<strong>在生产上，尤其是有insert … select这种批量插入数据的场景时，从并发插入数据性能的角度考虑，我建议你这样设置：innodb_autoinc_lock_mode&#x3D;2 ，并且 binlog_format&#x3D;row</strong>.这样做，既能提升并发性，又不会出现数据一致性问题。</p><p>对于批量插入数据的语句，MySQL有一个批量申请自增id的策略：</p><ol><li><p>语句执行过程中，第一次申请自增id，会分配1个；</p></li><li><p>1个用完以后，这个语句第二次申请自增id，会分配2个；</p></li><li><p>2个用完以后，还是这个语句，第三次申请自增id，会分配4个；</p></li><li><p>依此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">5</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>insert…select，实际上往表t2中插入了4行数据。但是，这四行数据是分三次申请的自增id，第一次申请到了id&#x3D;1，第二次被分配了id&#x3D;2和id&#x3D;3， 第三次被分配到id&#x3D;4到id&#x3D;7。</p><p>由于这条语句实际只用上了4个id，所以id&#x3D;5到id&#x3D;7就被浪费掉了。之后，再执行insert into t2 values(null, 5,5)，实际上插入的数据就是（8,5,5)。</p></li></ol><h1 id="Insert-加锁"><a href="#Insert-加锁" class="headerlink" title="Insert 加锁"></a>Insert 加锁</h1><p>表t和t2的表结构、初始化数据语句如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t</span><br></pre></td></tr></table></figure><p>为什么在可重复读隔离级别下，binlog_format&#x3D;statement时执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure><p>这个语句时，需要对表t的所有行和间隙加锁呢？</p><table><thead><tr><th>session A</th><th>session B</th></tr></thead><tbody><tr><td>insert into t values(-1,-1,-1);</td><td>insert into t2(c,d) select c,d from t;</td></tr></tbody></table><p>如果session B先执行，由于这个语句对表t主键索引加了(-∞,1]这个next-key lock，会在语句执行完成后，才允许session A的insert语句执行。</p><p>但如果没有锁的话，就可能出现session B的insert语句先执行，但是后写入binlog的情况。于是，在binlog_format&#x3D;statement的情况下，binlog里面就记录了这样的语句序列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure><p>这个语句到了备库执行，就会把id&#x3D;-1这一行也写到表t2中，出现主备不一致。</p><h2 id="insert-循环写入"><a href="#insert-循环写入" class="headerlink" title="insert 循环写入"></a>insert 循环写入</h2><p>执行insert … select 的时候，对目标表也不是锁全表，而是只锁住需要访问的资源。</p><p>如果现在有这么一个需求：要往表t2中插入一行数据，这一行的c值是表t中c值的最大值加1。</p><p>此时，我们可以这么写这条SQL语句 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d)  (<span class="keyword">select</span> c<span class="operator">+</span><span class="number">1</span>, d <span class="keyword">from</span> t force index(c) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> limit <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这个语句的加锁范围，就是表t索引c上的(4,supremum]这个next-key lock和主键索引上id&#x3D;4这一行。</p><h2 id="insert-唯一键冲突"><a href="#insert-唯一键冲突" class="headerlink" title="insert 唯一键冲突"></a>insert 唯一键冲突</h2><table><thead><tr><th>session A</th><th>session B</th></tr></thead><tbody><tr><td>insert into t values(10,10,10);</td><td></td></tr><tr><td>begin;<br>insert into t values(11,10,10);<br>(Duplicate entry ‘10’ for key ‘c’)</td><td></td></tr><tr><td></td><td>insert into t values(12,9,9);<br>(blocked)</td></tr></tbody></table><p>session A执行的insert语句，发生主键冲突的时候，并不只是简单地报错返回，还在冲突的索引上加了锁。这时候，session A持有索引c上的(5,10]共享next-key lock（读锁）。从作用上来看，这样做可以避免这一行被别的事务删掉。</p><h1 id="拷贝数据"><a href="#拷贝数据" class="headerlink" title="拷贝数据"></a>拷贝数据</h1><h2 id="mysqldump方法"><a href="#mysqldump方法" class="headerlink" title="mysqldump方法"></a>mysqldump方法</h2><p>使用mysqldump命令将数据导出成一组INSERT语句。你可以使用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user --add-locks --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&gt;900&quot; --result-file=/client_tmp/t.sql</span><br></pre></td></tr></table></figure><ol><li>–single-transaction的作用是，在导出数据的时候不需要对表db1.t加表锁，而是使用START TRANSACTION WITH CONSISTENT SNAPSHOT的方法；</li><li>–add-locks设置为0，表示在输出的文件结果里，不增加” LOCK TABLES <code>t</code> WRITE;” ；</li><li>–no-create-info的意思是，不需要导出表结构；</li><li>–set-gtid-purged&#x3D;off表示的是，不输出跟GTID相关的信息；</li><li>–result-file指定了输出文件的路径，其中client表示生成的文件是在客户端机器上的。</li></ol><p>如果你希望生成的文件中一条INSERT语句只插入一行数据的话，可以在执行mysqldump命令时，加上参数–skip-extended-insert。</p><p>然后，将这些INSERT语句放到db2库里去执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h127.0.0.1 -P13000  -uroot db2 -e &quot;source /client_tmp/t.sql&quot;</span><br></pre></td></tr></table></figure><p>需要说明的是，source并不是一条SQL语句，而是一个客户端命令。mysql客户端执行这个命令的流程是这样的：</p><ol><li>打开文件，默认以分号为结尾读取一条条的SQL语句；</li><li>将SQL语句发送到服务端执行。</li></ol><h2 id="导出CSV文件"><a href="#导出CSV文件" class="headerlink" title="导出CSV文件"></a>导出CSV文件</h2><p>MySQL提供了下面的语法，用来将查询结果导出到服务端本地目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from db1.t where a&gt;900 into outfile &#x27;/server_tmp/t.csv&#x27;;</span><br></pre></td></tr></table></figure><p>我们在使用这条语句时，需要注意如下几点。</p><ol><li>这条语句会将结果保存在服务端。如果你执行命令的客户端和MySQL服务端不在同一个机器上，客户端机器的临时目录下是不会生成t.csv文件的。</li><li>into outfile指定了文件的生成位置（&#x2F;server_tmp&#x2F;），这个位置必须受参数secure_file_priv的限制。参数secure_file_priv的可选值和作用分别是：<ul><li>如果设置为empty，表示不限制文件生成的位置，这是不安全的设置；</li><li>如果设置为一个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录；</li><li>如果设置为NULL，就表示禁止在这个MySQL实例上执行select … into outfile 操作。</li></ul></li><li>这条命令不会帮你覆盖文件，因此你需要确保&#x2F;server_tmp&#x2F;t.csv这个文件不存在，否则执行语句时就会因为有同名文件的存在而报错。</li><li>这条命令生成的文本文件中，原则上一个数据行对应文本文件的一行。但是，如果字段中包含换行符，在生成的文本中也会有换行符。不过类似换行符、制表符这类符号，前面都会跟上“\”这个转义符，这样就可以跟字段之间、数据行之间的分隔符区分开。</li></ol><p><strong>select …into outfile方法不会生成表结构文件</strong>, 所以我们导数据时还需要单独的命令得到表结构定义。mysqldump提供了一个–tab参数，可以同时导出表结构定义文件和csv数据文件。这条命令的使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user ---single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&gt;900&quot; --tab=$secure_file_priv</span><br></pre></td></tr></table></figure><p>这条命令会在$secure_file_priv定义的目录下，创建一个t.sql文件保存建表语句，同时创建一个t.txt文件保存CSV数据。</p><p>得到.csv导出文件后，你就可以用下面的load data命令将数据导入到目标表db2.t中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data infile &#x27;/server_tmp/t.csv&#x27; into table db2.t;</span><br></pre></td></tr></table></figure><p>这条语句的执行流程如下所示。</p><ol><li>主库执行完成后，将&#x2F;server_tmp&#x2F;t.csv文件的内容直接写到binlog文件中。</li><li>往binlog文件中写入语句load data local infile ‘&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0’ INTO TABLE <code>db2</code>.<code>t</code>。</li><li>把这个binlog日志传到备库。</li><li>备库的apply线程在执行这个事务日志时：<br>a. 先将binlog中t.csv文件的内容读出来，写入到本地临时目录&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0 中；<br>b. 再执行load data语句，往备库的db2.t表中插入跟主库相同的数据</li></ol><p><strong>load data命令有两种用法</strong>：</p><ol><li>不加“local”，是读取服务端的文件，这个文件必须在secure_file_priv指定的目录或子目录下；</li><li>加上“local”，读取的是客户端的文件，只要mysql客户端有访问这个文件的权限即可。这时候，MySQL客户端会先把本地文件传给服务端，然后执行上述的load data流程。</li></ol><blockquote><p>binlog_format&#x3D;statement的时候，binlog记录的load data命令是带local的。既然这条命令是发送到备库去执行的，那么备库执行的时候也是本地执行，为什么需要这个local呢？如果写到binlog中的命令不带local，又会出现什么问题呢？</p></blockquote><p>这样做的一个原因是，为了确保备库应用binlog正常。因为备库可能配置了secure_file_priv&#x3D;null，所以如果不用local的话，可能会导入失败，造成主备同步延迟。</p><p>另一种应用场景是使用mysqlbinlog工具解析binlog文件，并应用到目标库的情况。你可以使用下面这条命令 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog $binlog_file | mysql -h$host -P$port -u$user -p$pwd</span><br></pre></td></tr></table></figure><p>把日志直接解析出来发给目标库执行。增加local，就能让这个方法支持非本地的$host。</p><h2 id="物理拷贝方法"><a href="#物理拷贝方法" class="headerlink" title="物理拷贝方法"></a>物理拷贝方法</h2><p>在MySQL 5.6版本引入了<strong>可传输表空间</strong>(transportable tablespace)的方法，可以通过导出+导入表空间的方式，实现物理拷贝表的功能。</p><p>假设我们现在的目标是在db1库下，复制一个跟表t相同的表r，具体的执行步骤如下：</p><ol><li>执行 create table r like t，创建一个相同表结构的空表；</li><li>执行alter table r discard tablespace，这时候r.ibd文件会被删除；</li><li>执行flush table t for export，这时候db1目录下会生成一个t.cfg文件；</li><li>在db1目录下执行cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令；</li><li>执行unlock tables，这时候t.cfg文件会被删除；</li><li>执行alter table r import tablespace，将这个r.ibd文件作为表r的新的表空间，由于这个文件的数据内容和t.ibd是相同的，所以表r中就有了和表t相同的数据。</li></ol><p>关于拷贝表的这个流程，有以下几个注意点：</p><ol><li>在第3步执行完flsuh table命令之后，db1.t整个表处于只读状态，直到执行unlock tables命令后才释放读锁；</li><li>在执行import tablespace的时候，为了让文件里的表空间id和数据字典中的一致，会修改t.ibd的表空间id。而这个表空间id存在于每一个数据页中。因此，如果是一个很大的文件（比如TB级别），每个数据页都需要修改，所以你会看到这个import语句的执行是需要一些时间的。当然，如果是相比于逻辑导入的方法，import语句的耗时是非常短的。</li></ol><h1 id="MySQL权限"><a href="#MySQL权限" class="headerlink" title="MySQL权限"></a>MySQL权限</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;ua&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;pa&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这条语句的逻辑是创建一个用户’ua’@’%’，密码是pa。注意，在MySQL里面，用户名(user)+地址(host)才表示一个用户，因此 ua@ip1 和 ua@ip2代表的是两个不同的用户。</p><p>这条命令做了两个动作：</p><ol><li>磁盘上，往mysql.user表里插入一行，由于没有指定权限，所以这行数据上所有表示权限的字段的值都是N；</li><li>内存里，往数组acl_users里插入一个acl_user对象，这个对象的access字段值为0。</li></ol><h2 id="全局权限"><a href="#全局权限" class="headerlink" title="全局权限"></a>全局权限</h2><p>如果我要给用户ua赋一个最高权限的话，语句是这么写的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;ua&#x27;@&#x27;%&#x27; with grant option;</span><br></pre></td></tr></table></figure><p>这个grant命令做了两个动作：</p><ol><li>磁盘上，将mysql.user表里，用户’ua’@’%’这一行的所有表示权限的字段的值都修改为‘Y’；</li><li>内存里，从数组acl_users中找到这个用户对应的对象，将access值（权限位）修改为二进制的“全1”。</li></ol><p>grant 命令对于全局权限，同时更新了磁盘和内存。命令完成后即时生效，接下来新创建的连接会使用新的权限。对于一个已经存在的连接，它的全局权限不受 grant 命令影响。</p><p>如果要回收上面的grant语句赋予的权限，你可以使用下面这条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke all privileges on *.* from &#x27;ua&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><h2 id="db权限"><a href="#db权限" class="headerlink" title="db权限"></a>db权限</h2><p>如果要让用户ua拥有库db1的所有权限，可以执行下面这条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on db1.* to &#x27;ua&#x27;@&#x27;%&#x27; with grant option;</span><br></pre></td></tr></table></figure><p>基于库的权限记录保存在mysql.db表中，在内存里则保存在数组acl_dbs中。这条grant命令做了如下两个动作：</p><ol><li>磁盘上，往mysql.db表中插入了一行记录，所有权限位字段设置为“Y”；</li><li>内存里，增加一个对象到数组acl_dbs中，这个对象的权限位为“全1”。</li></ol><p>每次需要判断一个用户对一个数据库读写权限的时候，都需要遍历一次acl_dbs数组，根据user、host和db找到匹配的对象，然后根据对象的权限位来判断。</p><p>也就是说，grant修改db权限的时候，是同时对磁盘和内存生效的。</p><p>super是全局权限，这个权限信息在线程对象中，而revoke操作影响不到这个线程对象。</p><h2 id="表权限和列权限"><a href="#表权限和列权限" class="headerlink" title="表权限和列权限"></a>表权限和列权限</h2><p>表权限定义存放在表mysql.tables_priv中，列权限定义存放在表mysql.columns_priv中。这两类权限，组合起来存放在内存的hash结构column_priv_hash中。</p><p>这两类权限的赋权命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table db1.t1(id int, a int);</span><br><span class="line"></span><br><span class="line">grant all privileges on db1.t1 to &#x27;ua&#x27;@&#x27;%&#x27; with grant option;</span><br><span class="line">GRANT SELECT(id), INSERT (id,a) ON mydb.mytbl TO &#x27;ua&#x27;@&#x27;%&#x27; with grant option;</span><br></pre></td></tr></table></figure><p>flush privileges命令会清空acl_users数组，然后从mysql.user表中读取数据重新加载，重新构造一个acl_users数组。也就是说，以数据表中的数据为准，会将全局权限内存数组重新加载一遍。</p><p><strong>正常情况下，grant命令之后，没有必要跟着执行flush privileges命令。</strong></p><p><strong>flush privileges使用场景：</strong>当数据表中的权限数据跟内存中的权限数据不一致的时候，flush privileges语句可以用来重建内存数据，达到一致状态。而这种不一致往往是由于直接用DML语句操作系统权限表导致的，所以我们尽量不要使用这类语句。</p><h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><p>先创建一个表t：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `ftime` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  KEY (`ftime`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(ftime))</span><br><span class="line">(<span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2017</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2018 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2018</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2019 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2019</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"><span class="keyword">PARTITION</span> p_others <span class="keyword">VALUES</span> LESS THAN MAXVALUE ENGINE <span class="operator">=</span> InnoDB);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="string">&#x27;2017-4-1&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;2018-4-1&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>我在表t中初始化插入了两行记录，按照定义的分区规则，这两行记录分别落在p_2018和p_2019这两个分区上。</p><p>可以看到，这个表包含了一个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件。也就是说：</p><ul><li>对于引擎层来说，这是4个表；</li><li>对于Server层来说，这是1个表。</li></ul><h2 id="分区表的引擎层行为"><a href="#分区表的引擎层行为" class="headerlink" title="分区表的引擎层行为"></a>分区表的引擎层行为</h2><p>初始化表t的时候，只插入了两行数据， ftime的值分别是，‘2017-4-1’ 和’2018-4-1’ 。</p><table><thead><tr><th></th><th>session A</th><th>session B</th></tr></thead><tbody><tr><td>T1</td><td>begin;<br>select * from t where ftime&#x3D;’2017-5-1’ for update;</td><td></td></tr><tr><td>T2</td><td></td><td>insert into t values(‘2018-2-1’,1);<br>(Query OK)<br>insert into t values(‘2017-12-1’,1);<br>(blocked)</td></tr></tbody></table><p>session A的select语句对索引ftime上这两个记录之间的间隙加了锁，(‘2017-4-1’,’2018-4-1’)，sesion B的两条插入语句应该都要进入锁等待状态。</p><p>但实际上，session B的第一个insert语句是可以执行成功的。这是因为，对于引擎来说，p_2018和p_2019是两个不同的表，也就是说2017-4-1的下一个记录并不是2018-4-1，而是p_2018分区的supremum。</p><p>所以T1时刻，在表t的ftime索引上，间隙和加锁的状态是 p_2018 表上的 (2017-4-1,supremum)，session B要写入一行ftime是2018-2-1的时候是可以成功的，而要写入2017-12-1这个记录，就要等session A的间隙锁。</p><h2 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h2><p>使用MyISAM引擎时，每当第一次访问一个分区表的时候，MySQL需要把所有的分区都访问一遍。<strong>一个典型的报错情况</strong>是这样的：如果一个分区表的分区很多，比如超过了1000个，而MySQL启动的时候，open_files_limit参数使用的是默认值1024，那么就会在访问这个表的时候，由于需要打开所有的文件，导致打开表文件的个数超过了上限而报错。</p><p>MyISAM分区表使用的分区策略，我们称为<strong>通用分区策略</strong>（generic partitioning），每次访问分区都由server层控制。通用分区策略，是MySQL一开始支持分区表的时候就存在的代码，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题。</p><p>从MySQL 5.7.9开始，InnoDB引擎引入了<strong>本地分区策略</strong>（native partitioning）。这个策略是在InnoDB内部自己管理打开分区的行为。</p><p>从MySQL 8.0版本开始，就不允许创建MyISAM分区表了，只允许创建已经实现了本地分区策略的引擎。目前来看，只有InnoDB和NDB这两个引擎支持了本地分区策略。</p><h2 id="分区表的server层行为"><a href="#分区表的server层行为" class="headerlink" title="分区表的server层行为"></a>分区表的server层行为</h2><ol><li>MySQL在第一次打开分区表的时候，需要访问所有的分区；</li><li>在server层，认为这是同一张表，因此所有分区共用同一个MDL锁；</li><li>在引擎层，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，只访问必要的分区。</li></ol><h2 id="分区表的应用场景"><a href="#分区表的应用场景" class="headerlink" title="分区表的应用场景"></a>分区表的应用场景</h2><p>如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求。这时候，按照时间分区的分区表，就可以直接通过alter table t drop partition …这个语法删掉分区，从而删掉过期的历史数据。</p><p>这个alter table t drop partition …操作是直接删除分区文件，效果跟drop普通表类似。与使用delete语句删除数据相比，优势是速度快、对系统影响小。</p><blockquote><p>假设现在要创建一个自增字段id。MySQL要求分区表中的主键必须包含分区字段。如果要在表t的基础上做修改，你会怎么定义这个表的主键呢？为什么这么定义呢？</p></blockquote><p>由于MySQL要求主键包含所有的分区字段，所以肯定是要创建联合主键的。</p><p>两种方案：一种是(ftime, id)，另一种是(id, ftime)。</p><p>如果从利用率上来看，应该使用(ftime, id)这种模式。因为用ftime做分区key，说明大多数语句都是包含ftime的，使用这种模式，可以利用前缀索引的规则，减少一个索引。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高可用</title>
      <link href="/2023/11/30/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
      <url>/2023/11/30/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL主备一致"><a href="#MySQL主备一致" class="headerlink" title="MySQL主备一致"></a>MySQL主备一致</h1><h2 id="MySQL-主从复制"><a href="#MySQL-主从复制" class="headerlink" title="MySQL 主从复制"></a>MySQL 主从复制</h2><p><img src="https://i0.hdslb.com/bfs/openplatform/79408cf8f817db1de60ed356bd28dd55256c2b9b.png" alt="主从复制原理"></p><p> 主库将数据库中数据的变化写入到 binlog</p><ul><li>在从库上通过change master命令，设置主库的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。</li><li>在从库上执行start slave命令，这时候从库会启动两个线程，就是图中的io_thread和sql_thread。其中io_thread负责与主库建立连接。</li><li>主库校验完用户名、密码后，创建一个 binlog dump 线程，开始按照从库传过来的位置来发送 binlog ，从库中的 I&#x2F;O 线程负责接收</li><li>从库的 I&#x2F;O 线程将接收的 binlog 写入到 relay log 中。</li><li>从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。</li></ul><h2 id="基于位点的主备切换"><a href="#基于位点的主备切换" class="headerlink" title="基于位点的主备切换"></a>基于位点的主备切换</h2><p>把节点B设置成节点A’的从库的时候，需要执行一条change master命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST=$host_name  #IP</span><br><span class="line">MASTER_PORT=$port       #端口</span><br><span class="line">MASTER_USER=$user_name  #用户名</span><br><span class="line">MASTER_PASSWORD=$password  #密码</span><br><span class="line">MASTER_LOG_FILE=$master_log_name  #主库对应的文件名</span><br><span class="line">MASTER_LOG_POS=$master_log_pos  #日志偏移量，从master_log_pos这个位置的日志继续同步</span><br></pre></td></tr></table></figure><p>从库B要切换的时候，就需要先经过“找同步位点”这个逻辑。</p><p>考虑到切换过程中不能丢数据，所以我们找位点的时候，总是要找一个“稍微往前”的，然后再通过判断跳过那些在从库B上已经执行过的事务。</p><p>一种取同步位点的方法是这样的：</p><ol><li>等待新主库A’把中转日志（relay log）全部同步完成；</li><li>在A’上执行show master status命令，得到当前A’上最新的File 和 Position；</li><li>取原主库A故障的时刻T；</li><li>用mysqlbinlog工具解析A’的File，得到T时刻的位点。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog File --stop-datetime=T --start-datetime=T</span><br></pre></td></tr></table></figure><p>假设在T这个时刻，主库A已经执行完成了一个insert 语句插入了一行数据R，并且已经将binlog传给了A’和B，然后在传完的瞬间主库A的主机就掉电了。</p><p>那么，这时候系统的状态是这样的：</p><ol><li>在从库B上，由于同步了binlog， R这一行已经存在；</li><li>在新主库A’上， R这一行也已经存在，日志是写在123这个位置之后的；</li><li>我们在从库B上执行change master命令，指向A’的File文件的123位置，就会把插入R这一行数据的binlog又同步到从库B去执行。</li></ol><p>这时候，从库B的同步线程就会报告 Duplicate entry ‘id_of_R’ for key ‘PRIMARY’ 错误，提示出现了主键冲突，然后停止同步。</p><p>切换任务时，要主动跳过错误，有两种方法：</p><p><strong>一种做法是</strong>，主动跳过一个事务。跳过命令的写法是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global sql_slave_skip_counter=1;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库B刚开始接到新主库A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。</p><p><strong>另外一种方式是，</strong>通过设置slave_skip_errors参数，直接设置跳过指定的错误。</p><p>在执行主备切换时，有这么两类错误，是经常会遇到的：</p><ul><li>1062错误是插入数据时唯一键冲突；</li><li>1032错误是删除数据时找不到行。</li></ul><p>因此，我们可以把slave_skip_errors 设置为 “1032,1062”，这样中间碰到这两个错误时就直接跳过。</p><p>记住等到主备间的同步关系建立完成，并稳定执行一段时间之后，我们还需要把这个参数设置为空，以免之后真的出现了主从数据不一致，也跳过了。</p><h2 id="GTID"><a href="#GTID" class="headerlink" title="GTID"></a>GTID</h2><p>GTID的全称是Global Transaction Identifier，也就是全局事务ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GTID=server_uuid:gno</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>server_uuid是一个实例第一次启动时自动生成的，是一个全局唯一的值；</li><li>gno是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1。</li></ul><p>GTID模式启动方式：启动时加上参数 gtid_mode&#x3D;on和enforce_gtid_consistency&#x3D;on</p><h3 id="关于GTID的理解"><a href="#关于GTID的理解" class="headerlink" title="关于GTID的理解"></a>关于GTID的理解</h3><p>假设，现在这个实例X是另外一个实例Y的从库，并且此时在实例Y上执行了下面这条插入语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>并且，这条语句在实例Y上的GTID是 “aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”。</p><p>那么，实例X作为Y的从库，就要同步这个事务过来执行，显然会出现主键冲突，导致实例X的同步线程停止。这时，我们应该怎么处理呢？</p><p>处理方法就是，你可以执行下面的这个语句序列：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set gtid_next=&#x27;aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10&#x27;;</span><br><span class="line">begin;</span><br><span class="line">commit;</span><br><span class="line">set gtid_next=automatic;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>其中，前三条语句的作用，是通过提交一个空事务，把这个GTID加到实例X的GTID集合中。</p><p>再执行start slave命令让同步线程执行起来的时候，虽然实例X上还是会继续执行实例Y传过来的事务，但是由于“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”已经存在于实例X的GTID集合中了，所以实例X就会直接跳过这个事务，也就不会再出现主键冲突的错误。</p><h3 id="GTID的使用"><a href="#GTID的使用" class="headerlink" title="GTID的使用"></a>GTID的使用</h3><p>在GTID模式下，备库B要设置为新主库A’的从库的语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$password </span><br><span class="line">master_auto_position=1 </span><br></pre></td></tr></table></figure><p>其中，master_auto_position&#x3D;1就表示这个主备关系使用的是GTID协议。可以看到，前面让我们头疼不已的MASTER_LOG_FILE和MASTER_LOG_POS参数，已经不需要指定了。</p><p>我们在实例B上执行start slave命令，取binlog的逻辑是这样的：</p><ol><li>实例B指定主库A’，基于主备协议建立连接。</li><li>实例B把set_b发给主库A’。</li><li>实例A’算出set_a与set_b的差集，也就是所有存在于set_a，但是不存在于set_b的GITD的集合，判断A’本地是否包含了这个差集需要的所有binlog事务。<br>a. 如果不包含，表示A’已经把实例B需要的binlog给删掉了，直接返回错误；<br>b. 如果确认全部包含，A’从自己的binlog文件里面，找出第一个不在set_b的事务，发给B；</li><li>之后就从这个事务开始，往后读文件，按顺序取binlog发给B去执行。</li></ol><p>其实，这个逻辑里面包含了一个设计思想：在基于GTID的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。因此，如果实例B需要的日志已经不存在，A’就拒绝把日志发给B。</p><blockquote><p>你在GTID模式下设置主从关系的时候，从库执行start slave命令后，主库发现需要的binlog已经被删除掉了，导致主备创建不成功。这种情况下，你觉得可以怎么处理呢？</p></blockquote><ol><li>如果业务允许主从不一致的情况，那么可以在主库上先执行show global variables like ‘gtid_purged’，得到主库已经删除的GTID集合，假设是gtid_purged1；然后先在从库上执行reset master，再执行set global gtid_purged &#x3D;‘gtid_purged1’；最后执行start slave，就会从主库现存的binlog开始同步。binlog缺失的那一部分，数据在从库上就可能会有丢失，造成主从不一致。</li><li>如果需要主从数据一致的话，最好还是通过重新搭建从库来做。</li><li>如果有其他的从库保留有全量的binlog的话，可以把新的从库先接到这个保留了全量binlog的从库，追上日志以后，如果有需要，再接回主库。</li><li>如果binlog有备份的情况，可以先在从库上应用缺失的binlog，然后再执行start slave。</li></ol><h2 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h2><p><strong>双M结构下（主备切换过程中），怎么解决循环复制问题？</strong></p><p>首先说一下什么是循环复制问题，举个例子说明一下。</p><p>业务逻辑在节点A上更新了一条语句，然后再把生成的binlog 发给节点B，节点B执行完这条更新语句后也会生成binlog。（参数log_slave_updates设置为on，表示备库执行relay log后生成binlog）</p><p>那么，如果节点A同时是节点B的备库，相当于又把节点B新生成的binlog拿过来执行了一次，然后节点A和B间，会不断地循环执行这个更新语句，也就是循环复制了。</p><p>MySQL在binlog中记录了这个命令第一次执行时所在实例的server id。所以它是根据 server id  来解决两个节点间的循环复制问题的：</p><ol><li>规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系；</li><li>一个备库接到binlog并在重放的过程中，生成与原binlog的server id相同的新的binlog；</li><li>每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li></ol><p>按照这个逻辑，如果我们设置了双M结构，日志的执行流就会变成这样：</p><ol><li>从节点A更新的事务，binlog里面记的都是A的server id；</li><li>传到节点B执行一次以后，节点B生成的binlog 的server id也是A的server id；</li><li>再传回给节点A，A判断到这个server id与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了。</li></ol><blockquote><p>什么情况下双M结构会出现循环复制？</p></blockquote><ul><li>在一个主库更新事务后，用命令set global server_id&#x3D;x修改了server_id。等日志再传回来的时候，发现server_id跟自己的server_id不同，就只能执行了。</li><li>trx1是在节点 B执行的，因此binlog上的server_id就是B，binlog传给节点 A，然后A和A’搭建了双M结构，就会出现循环复制。</li></ul><p>如果出现了循环复制，可以在A或者A’上，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave；</span><br><span class="line">CHANGE MASTER TO IGNORE_SERVER_IDS=(server_id_of_B);</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>这样这个节点收到日志后就不会再执行。过一段时间后，再执行下面的命令把这个值改回来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave；</span><br><span class="line">CHANGE MASTER TO IGNORE_SERVER_IDS=();</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><h2 id="binlog的三种格式对比"><a href="#binlog的三种格式对比" class="headerlink" title="binlog的三种格式对比"></a>binlog的三种格式对比</h2><h3 id="statement格式"><a href="#statement格式" class="headerlink" title="statement格式"></a>statement格式</h3><p>statement格式是记录语句到 binlog，因此可能会出现这样一种情况：在主库执行SQL语句的时候，用的是索引a；而在备库执行这条SQL语句的时候，却使用了索引b。假如这是条带有 LIMIT 的 DELETE 语句，从库和主库走不同的索引会导致数据不一致。</p><h3 id="row格式"><a href="#row格式" class="headerlink" title="row格式"></a>row格式</h3><p>使用 mysqlbinlog 工具查看binlog的内容，这个事务的binlog是从8900这个位置开始的，所以可以用start-position参数来指定从这个位置的日志开始解析。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog  <span class="operator">-</span>vv data<span class="operator">/</span>master<span class="number">.000001</span> <span class="comment">--start-position=8900;</span></span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/c3/c2/c342cf480d23b05d30a294b114cebfc2.png" alt="img"></p><p>从这个图中，我们可以看到以下几个信息：</p><ul><li>server id 1，表示这个事务是在server_id&#x3D;1的这个库上执行的。</li><li>每个event都有CRC32的值，这是因为我把参数binlog_checksum设置成了CRC32。</li><li>Table_map event示了接下来要打开的表，map到数字226。现在我们这条SQL语句只操作了一张表，如果要操作多张表呢？每个表都有一个对应的Table_map event、都会map到一个单独的数字，用于区分对不同表的操作。</li><li>我们在mysqlbinlog的命令中，使用了-vv参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1&#x3D;4、 @2&#x3D;4这些值）。</li><li>binlog_row_image的默认配置是FULL，因此Delete_event里面，包含了删掉的行的所有字段的值。如果把binlog_row_image设置为MINIMAL，则只会记录必要的信息，在这个例子里，就是只会记录id&#x3D;4这个信息。</li><li>最后的Xid event，用于表示事务被正确地提交了。</li></ul><p>你可以看到，当binlog_format使用row格式的时候，binlog里面记录了真实删除行的主键id，这样binlog传到备库去的时候，就肯定会删除id&#x3D;4的行，不会有主备删除不同行的问题。</p><ul><li>执行delete语句，row格式的binlog也会把被删掉的行的整行信息保存起来。</li><li>执行insert语句，row格式下，insert语句的binlog里会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行。</li><li>执行update语句，binlog里面会记录修改前整行的数据和修改后的整行数据。</li></ul><h3 id="mixed格式"><a href="#mixed格式" class="headerlink" title="mixed格式"></a>mixed格式</h3><p><strong>为什么会有mixed这种binlog格式的存在场景？</strong>推论过程是这样的：</p><ul><li>因为有些statement格式的binlog可能会导致主备不一致，所以要使用row格式。</li><li>但row格式的缺点是，很占空间。比如你用一个delete语句删掉10万行数据，用statement的话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但如果用row格式的binlog，就要把这10万条记录都写到binlog中。这样做，不仅会占用更大的空间，同时写binlog也要耗费IO资源，影响执行速度。</li><li>所以，MySQL就取了个折中方案，也就是有了mixed格式的binlog。mixed格式的意思是，MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。</li></ul><p>也就是说，mixed格式可以利用statment格式的优点，同时又避免了数据不一致的风险。</p><h2 id="binglog恢复数据"><a href="#binglog恢复数据" class="headerlink" title="binglog恢复数据"></a>binglog恢复数据</h2><p>用binlog来恢复数据的标准做法是，用 mysqlbinlog工具解析出来，然后把解析结果整个发给MySQL执行。类似下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog master.000001  --start-position=2738 --stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;</span><br></pre></td></tr></table></figure><p>这个命令的意思是，将 master.000001 文件里面从第2738字节到第2973字节中间这段内容解析出来，放到MySQL去执行。</p><h2 id="主备延迟问题"><a href="#主备延迟问题" class="headerlink" title="主备延迟问题"></a>主备延迟问题</h2><p>与数据同步有关的时间点主要包括以下三个：</p><ol><li>主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</li><li>之后传给备库B，我们把备库B接收完这个binlog的时刻记为T2;</li><li>备库B执行完成这个事务，我们把这个时刻记为T3。</li></ol><p>所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。</p><p>在备库上执行show slave status命令，它的返回结果里面会显示seconds_behind_master，用于表示当前备库延迟了多少秒。</p><blockquote><p>如果主备库机器的系统时间设置不一致，会不会导致主备延迟的值不准？</p></blockquote><p>不会的。因为，备库连接到主库的时候，会通过执行SELECT UNIX_TIMESTAMP()函数来获得当前主库的系统时间。如果这时候发现主库的系统时间与自己不一致，备库在执行seconds_behind_master计算的时候会自动扣掉这个差值。</p><p>主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产binlog的速度要慢。</p><h3 id="主备延迟来源"><a href="#主备延迟来源" class="headerlink" title="主备延迟来源"></a>主备延迟来源</h3><p><strong>有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。</strong></p><p>有些人把20个主库放在4台机器上，而把备库集中在一台机器上。更新请求对IOPS的压力，在主库和备库上是无差别的。所以，做这种部署时，一般都会将备库设置为“非双1”的模式。</p><p>但是更新过程中也会触发大量的读操作。所以，当备库主机上的多个备库都在争抢资源的时候，就可能会导致主备延迟了。</p><p><strong>备库压力大</strong></p><p>由于主库直接影响业务，大家使用起来会比较克制，反而忽视了备库的压力控制。结果就是，备库上的查询耗费了大量的CPU资源，影响了同步速度，造成主备延迟。</p><p>这种情况，我们一般可以这么处理：</p><ol><li>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。</li><li>通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力。</li></ol><p><strong>大事务</strong></p><p>有时候主库开启一个大事务，那必须等待主库大事务执行完成才写入 binlog，再传给备库。</p><p>比如，一些归档类的数据，平时没有注意删除历史数据，等到空间快满了，业务开发人员要一次性地删掉大量历史数据。同时，又因为要避免在高峰期操作会影响业务（至少有这个意识还是很不错的），所以会在晚上执行这些大量数据的删除操作。但还是建议控制每个事务删除的数据量，分多次删除。</p><h2 id="主备切换策略"><a href="#主备切换策略" class="headerlink" title="主备切换策略"></a>主备切换策略</h2><h3 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h3><p>双M结构下，主备切换的详细过程是这样的：</p><ol><li>判断备库B现在的 seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则持续重试这一步；</li><li>把主库A改成只读状态，即把 readonly 设置为 true ；</li><li>判断备库B的 seconds_behind_master 的值，直到这个值变成0为止；</li><li>把备库B改成可读写状态，也就是把 readonly 设置为false；</li><li>把业务请求切到备库B。</li></ol><p>这个切换流程，一般是由专门的HA系统来完成的，我们暂时称之为可靠性优先流程。</p><p>这个切换流程中是有不可用时间的。因为在步骤2之后，主库A和备库B都处于 readonly 状态，也就是说这时系统处于不可写状态，直到步骤5完成后才能恢复。</p><h3 id="可用性优先策略"><a href="#可用性优先策略" class="headerlink" title="可用性优先策略"></a>可用性优先策略</h3><p>如果不等主备数据同步，直接把连接切到备库B，并且让备库B可以读写，那么系统几乎就没有不可用时间了。</p><p>我们把这个切换流程，暂时称作可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。</p><p>使用可用性优先策略，且<strong>binlog_format&#x3D;mixed</strong></p><ol><li>主库A执行完 insert 语句，插入了一行数据（4,4），之后开始进行主备切换。</li><li>由于主备之间有5秒的延迟，所以备库B还没来得及应用“插入c&#x3D;4”这个中转日志，就开始接收客户端“插入 c&#x3D;5”的命令。</li><li>备库B插入了一行数据（4,5），并且把这个 binlog 发给主库A。</li><li>备库B执行“插入c&#x3D;4”这个中转日志，插入了一行数据（5,4）。而直接在备库B执行的“插入c&#x3D;5”这个语句，传到主库A，就插入了一行新数据（5,5）。</li></ol><p>使用可用性优先策略，且<strong>binlog_format&#x3D;row</strong></p><p>因为row格式在记录binlog的时候，会记录新插入的行的所有字段值，所以最后只会有一行不一致。而且，两边的主备同步的应用线程会报错duplicate key error并停止。也就是说，这种情况下，备库B的(5,4)和主库A的(5,5)这两行数据，都不会被对方执行。</p><blockquote><p>有没有哪种情况数据的可用性优先级更高呢？</p></blockquote><p>有过这样的一个场景：</p><ul><li>有一个库的作用是记录操作日志。这时候，如果数据不一致可以通过binlog来修补，而这个短暂的不一致也不会引发业务问题。</li><li>同时，业务系统依赖于这个日志写入逻辑，如果这个库不可写，会导致线上的业务操作无法执行。</li></ul><p>另一种使用可靠性优先策略的改进措施就是，让业务逻辑不要依赖于这类日志的写入。也就是说，日志写入这个逻辑模块应该可以降级，比如写到本地文件，或者写到另外一个临时库里面。</p><h2 id="MySQL并行复制策略"><a href="#MySQL并行复制策略" class="headerlink" title="MySQL并行复制策略"></a>MySQL并行复制策略</h2><p>备库从主库同步数据时，会由一个IO线程接收 relay log，然后有一个 sql_thread 执行 relay log。而MySQL的并行复制，就是将一个 sql_thread 拆分成多个线程，使用一个 coordinator 负责读取中转日志和分发事务，分发到各个 worker 中更新日志。</p><p>worker 线程数由 slave_parallel_workers 决定。建议设置在 8~16之间（32核物理机）。</p><p>coordinator在分发的时候，需要满足以下这两个基本要求：</p><ol><li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。</li><li>同一个事务不能被拆开，必须放到同一个worker中。</li></ol><h3 id="按表分发策略（MySQL-5-5）"><a href="#按表分发策略（MySQL-5-5）" class="headerlink" title="按表分发策略（MySQL 5.5）"></a>按表分发策略（MySQL 5.5）</h3><p>每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事务所涉及的表。hash表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表。</p><p>在有事务分配给worker时，事务里面涉及的表会被加到对应的hash表中。worker执行完成后，这个表会被从hash表中去掉。</p><p>如果一个事务T修改表t1和t2，但是已知 worker1中涉及到修改表 t1 的操作，worker2 中涉及到修改表 t2 的操作，因此事务 T 和 worker1、worker2 均存在冲突。coordinator线程就进入等待，等到只存在一个冲突的worker后，就可以让事务T加入worker了。</p><h3 id="按行分发策略-MySQL-5-5"><a href="#按行分发策略-MySQL-5-5" class="headerlink" title="按行分发策略(MySQL 5.5)"></a>按行分发策略(MySQL 5.5)</h3><p>如果两个事务没有更新相同的行，它们在备库上可以并行执行。</p><p>为每个worker，分配一个hash表。只是要实现按行分发，这时候的key，就必须是“库名+表名+索引a的名字+a的值”。</p><p>在实现这个策略的时候会设置一个阈值，单个事务如果超过设置的行数阈值（比如，如果单个事务更新的行数超过10万行），就暂时退化为单线程模式。</p><p>按行分发策略和按表分发策略其实都有一些约束条件：</p><ol><li>要能够从binlog里面解析出表名、主键值和唯一索引的值。也就是说，主库的binlog格式必须是row；</li><li>表必须有主键；</li><li>不能有外键。表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准确。</li></ol><h3 id="按库分发策略-MySQL-5-6"><a href="#按库分发策略-MySQL-5-6" class="headerlink" title="按库分发策略(MySQL 5.6)"></a>按库分发策略(MySQL 5.6)</h3><p>用于决定分发策略的hash表里，key就是数据库名。</p><p>这个策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使用这个策略的效果会很好。</p><p>相比于按表和按行分发，这个策略有两个优势：</p><ol><li>构造hash值的时候很快，只需要库名；而且一个实例上DB数也不会很多，不会出现需要构造100万个项这种情况。</li><li>不要求binlog的格式。因为statement格式的binlog也可以很容易拿到库名。</li></ol><p>但是，如果你的主库上的表都放在同一个DB里面，这个策略就没有效果了；或者如果不同DB的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。</p><h3 id="MySQL-5-7的并行复制策略"><a href="#MySQL-5-7的并行复制策略" class="headerlink" title="MySQL 5.7的并行复制策略"></a>MySQL 5.7的并行复制策略</h3><h4 id="由参数slave-parallel-type来控制并行复制策略："><a href="#由参数slave-parallel-type来控制并行复制策略：" class="headerlink" title="由参数slave-parallel-type来控制并行复制策略："></a>由参数slave-parallel-type来控制并行复制策略：</h4><ol><li>配置为DATABASE，表示使用MySQL 5.6版本的按库并行策略；</li><li>配置为 LOGICAL_CLOCK，表示的就是类似MariaDB的策略。</li></ol><p>MySQL 5.7并行复制策略的思想是：</p><ol><li>同时处于prepare状态的事务，在备库执行时是可以并行的；</li><li>处于prepare状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的。</li></ol><p>有两个参数：</p><ol><li>binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync;</li><li>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。</li></ol><p>这两个参数是用于故意拉长binlog从write到fsync的时间，以此减少binlog的写盘次数。在MySQL 5.7的并行复制策略里，它们可以用来制造更多的“同时处于prepare阶段的事务”。这样就增加了备库复制的并行度。</p><p>也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些。在MySQL 5.7处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。</p><h4 id="基于WRITESET的并行复制策略"><a href="#基于WRITESET的并行复制策略" class="headerlink" title="基于WRITESET的并行复制策略"></a>基于WRITESET的并行复制策略</h4><p>相应地，新增了一个参数binlog-transaction-dependency-tracking，用来控制是否启用这个新策略。这个参数的可选值有以下三种。</p><ol><li>COMMIT_ORDER，表示的就是前面介绍的，根据同时进入prepare和commit来判断是否可以并行的策略。</li><li>WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的hash值，组成集合writeset。如果两个事务没有操作相同的行，也就是说它们的writeset没有交集，就可以并行。</li><li>WRITESET_SESSION，是在WRITESET的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li></ol><p>当然为了唯一标识，这个hash值是通过“库名+表名+索引名+值”计算出来的。如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert语句对应的writeset就要多增加一个hash值。</p><p>你可能看出来了，这跟我们前面介绍的基于MySQL 5.5版本的按行分发的策略是差不多的。不过，MySQL官方的这个实现还是有很大的优势：</p><ol><li>writeset是在主库生成后直接写入到binlog里面的，这样在备库执行的时候，不需要解析binlog内容（event里的行数据），节省了很多计算量；</li><li>不需要把整个事务的binlog都扫一遍才能决定分发到哪个worker，更省内存；</li><li>由于备库的分发策略不依赖于binlog内容，所以binlog是statement格式也是可以的</li></ol><h2 id="MariaDB的并行复制策略"><a href="#MariaDB的并行复制策略" class="headerlink" title="MariaDB的并行复制策略"></a>MariaDB的并行复制策略</h2><p>MariaDB的并行复制策略利用的是redo log组提交(group commit)优化：</p><ol><li>能够在同一组里提交的事务，一定不会修改同一行；</li><li>主库上可以并行执行的事务，备库上也一定是可以并行执行的。</li></ol><p>在实现上，MariaDB是这么做的：</p><ol><li>在一组里面一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1；</li><li>commit_id直接写到binlog里面；</li><li>传到备库应用的时候，相同commit_id的事务分发到多个worker执行；</li><li>这一组全部执行完成后，coordinator再去取下一批。</li></ol><p>但是，这个策略有一个问题，它并没有实现“真正的模拟主库并发度”这个目标。在主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，这样系统的吞吐量就不够。</p><blockquote><p>假设一个MySQL 5.7.22版本的主库，单线程插入了很多数据，过了3个小时后，我们要给这个主库搭建一个相同版本的备库。</p><p>这时候，你为了更快地让备库追上主库，要开并行复制。在binlog-transaction-dependency-tracking参数的COMMIT_ORDER、WRITESET和WRITE_SESSION这三个取值中，你会选择哪一个呢？</p><p>你选择的原因是什么？如果设置另外两个参数，你认为会出现什么现象呢？</p></blockquote><p>应该将这个参数设置为WRITESET。</p><p>由于主库是单线程压力模式，所以每个事务的commit_id都不同，那么设置为COMMIT_ORDER模式的话，从库也只能单线程执行。</p><p>同样地，由于WRITESET_SESSION模式要求在备库应用日志的时候，同一个线程的日志必须与主库上执行的先后顺序相同，也会导致主库单线程压力模式下退化成单线程复制。</p><p>所以，应该将binlog-transaction-dependency-tracking 设置为WRITESET。</p><h2 id="处理过期读方案"><a href="#处理过期读方案" class="headerlink" title="处理过期读方案"></a>处理过期读方案</h2><p>尽管知道了主备延迟的原因和对应的优化策略，主从延迟仍不是能100%避免的。从库仍有可能读到系统的过期状态，那么接下来我们可以讨论如何处理过期读问题。</p><h3 id="强制走主库"><a href="#强制走主库" class="headerlink" title="强制走主库"></a>强制走主库</h3><p>通常情况下，可以把请求分为两类：</p><ol><li>对于必须要拿到最新结果的请求，强制将其发到主库上。</li><li>对于可以读到旧数据的请求，才将其发到从库上。</li></ol><h3 id="Sleep-方案"><a href="#Sleep-方案" class="headerlink" title="Sleep 方案"></a>Sleep 方案</h3><p>主库更新后，读从库之前先sleep一下。具体的方案就是，类似于执行一条select sleep(1)命令。</p><p>这个方案的假设是，大多数情况下主备延迟在1秒之内，做一个sleep可以有很大概率拿到最新的数据。</p><h3 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h3><p>执行 show slave status。</p><ol><li><p>观察 seconds_behind_master 字段。每次从库执行查询请求前，先判断seconds_behind_master是否已经等于0。如果还不等于0 ，那就必须等到这个参数变为0才能执行查询请求。</p></li><li><p>对比位点确保主备无延迟：</p><ul><li>Master_Log_File和Read_Master_Log_Pos，表示的是读到的主库的最新位点；</li><li>Relay_Master_Log_File和Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li></ul><p>如果Master_Log_File和Relay_Master_Log_File、Read_Master_Log_Pos和Exec_Master_Log_Pos这两组值完全相同，就表示接收到的日志已经同步完成。</p></li><li><p>对比GTID集合确保主备无延迟：</p><ul><li>Auto_Position&#x3D;1 ，表示这对主备关系使用了GTID协议。</li><li>Retrieved_Gtid_Set，是备库收到的所有日志的GTID集合；</li><li>Executed_Gtid_Set，是备库所有已经执行完成的GTID集合。</li></ul><p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。</p></li></ol><h3 id="配合-semi-sync"><a href="#配合-semi-sync" class="headerlink" title="配合 semi-sync"></a>配合 semi-sync</h3><p>semi-sync做了这样的设计：</p><ol><li>事务提交的时候，主库把binlog发给从库；</li><li>从库收到binlog以后，发回给主库一个ack，表示收到了；</li><li>主库收到这个ack以后，才能给客户端返回“事务完成”的确认。</li></ol><p>也就是说，如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。</p><p>但是，semi-sync+位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：</p><ol><li>如果查询是落在这个响应了ack的从库上，是能够确保读到最新数据；</li><li>但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。</li></ol><p>其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者GTID集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。</p><h3 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure><p>这条命令的逻辑如下：</p><ol><li>它是在从库执行的；</li><li>参数file和pos指的是主库上的文件名和位置；</li><li>timeout可选，设置为正整数N表示这个函数最多等待N秒。</li></ol><p>这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。</p><p>这里我们假设，这条select查询最多在从库上等待1秒。那么，如果1秒内master_pos_wait返回一个大于等于0的整数，就确保了从库上执行的这个查询结果一定包含了trx1的数据。</p><p>若返回一个小于0的整数，则到主库执行查询语句，是这类方案常用的退化机制。因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查。</p><h3 id="GTID-方案"><a href="#GTID-方案" class="headerlink" title="GTID 方案"></a>GTID 方案</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> wait_for_executed_gtid_set(gtid_set, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这条命令的逻辑是：</p><ol><li>等待，直到这个库执行的事务中包含传入的gtid_set，返回0；</li><li>超时返回1。</li></ol><p>而MySQL 5.7.6版本开始，允许在执行完更新类事务后，把这个事务的GTID返回给客户端，这样等GTID的方案就可以减少一次查询。</p><p>这时，等GTID的执行流程就变成了：</p><ol><li>trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1；</li><li>选定一个从库执行查询语句；</li><li>在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</li><li>如果返回值是0，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。</li></ol><p>跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。</p><blockquote><p>怎么能够让MySQL在执行事务后，返回包中带上GTID呢？</p></blockquote><p>将参数session_track_gtids设置为OWN_GTID，然后通过API接口mysql_session_track_get_first从返回包解析出GTID的值即可。</p><blockquote><p>实际业务场景中，怎么结合以上几种处理过期读方案？</p></blockquote><p>先在客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读；然后，对于不能接受过期读的语句，再使用等GTID或等位点的方案。</p><p>但话说回来，过期读在本质上是由一写多读导致的。在实际应用中，可能会有别的不需要等待就可以水平扩展的数据库方案，但这往往是用牺牲写性能换来的，也就是需要在读性能和写性能中取权衡。</p><blockquote><p>假设你的系统采用了我们文中介绍的最后一个方案，也就是等GTID的方案，现在你要对主库的一张大表做DDL，可能会出现什么情况呢？为了避免这种情况，你会怎么做呢？</p></blockquote><p>假设，这条语句在主库上要执行10分钟，提交后传到备库就要10分钟（典型的大事务）。那么，在主库DDL之后再提交的事务的GTID，去备库查的时候，就会等10分钟才出现。</p><p>这样，这个读写分离机制在这10分钟之内都会超时，然后走主库。</p><p>这种预期内的操作，应该在业务低峰期的时候，确保主库能够支持所有业务查询，然后把读请求都切到主库，再在主库上做DDL。等备库延迟追上以后，再把读请求切回备库。</p><h2 id="判断主库情况"><a href="#判断主库情况" class="headerlink" title="判断主库情况"></a>判断主库情况</h2><p>主备切换有两种场景，一种是主动切换，一种是被动切换。而其中被动切换，往往是因为主库出问题了，由HA系统发起的。</p><h3 id="select-1-判断"><a href="#select-1-判断" class="headerlink" title="select 1 判断"></a>select 1 判断</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_thread_concurrency<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>innodb_thread_concurrency：控制InnoDB的并发线程上限。一旦并发线程数达到这个值，InnoDB在接收到新请求的时候，就会进入等待状态，直到有线程退出。</p><p>同时在执行的语句超过了设置的innodb_thread_concurrency的值，这时候系统其实已经不行了，但是通过select 1来检测系统，会认为系统还是正常的。</p><h3 id="查表判断"><a href="#查表判断" class="headerlink" title="查表判断"></a>查表判断</h3><p>在系统库（mysql库）里创建一个表，比如命名为health_check，里面只放一行数据，然后定期执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.health_check; </span><br></pre></td></tr></table></figure><p>更新事务要写binlog，而一旦binlog所在磁盘的空间占用率达到100%，那么所有的更新语句和事务提交的commit语句就都会被堵住。但是，系统这时候还是可以正常读数据的。</p><h3 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h3><p>既然要更新，就要放个有意义的字段，常见做法是放一个timestamp字段，用来表示最后一次执行检测的时间。这条更新语句类似于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> mysql.health_check <span class="keyword">set</span> t_modified<span class="operator">=</span>now();</span><br></pre></td></tr></table></figure><p>为了让主备之间的更新不产生冲突，我们可以在mysql.health_check表上存入多行数据，并用A、B的server_id做主键。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `health_check` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `t_modified` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检测命令 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql.health_check(id, t_modified) <span class="keyword">values</span> (@<span class="variable">@server_id</span>, now()) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> t_modified<span class="operator">=</span>now();</span><br></pre></td></tr></table></figure><p>IO利用率100%表示系统的IO是在工作的，每个请求都有机会获得IO资源，执行自己的任务。而我们的检测使用的update命令，需要的资源很少，所以可能在拿到IO资源的时候就可以提交成功，并且在超时时间N秒未到达之前就返回给了检测系统。</p><p>检测系统一看，update命令没有超时，于是就得到了“系统正常”的结论。</p><p>之所以会出现这个现象，根本原因是我们上面说的所有方法，都是基于外部检测的。</p><h3 id="内部统计"><a href="#内部统计" class="headerlink" title="内部统计"></a>内部统计</h3><p>MySQL 5.6版本以后提供的performance_schema库，就在file_summary_by_event_name表里统计了每次IO请求的时间。</p><p>如果打开所有的performance_schema项，性能大概会下降10%左右。所以，我建议你只打开自己需要的项进行统计。你可以通过下面的方法打开或者关闭某个具体项的统计。</p><p>如果要打开redo log的时间监控，你可以执行这个语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> setup_instruments <span class="keyword">set</span> ENABLED<span class="operator">=</span><span class="string">&#x27;YES&#x27;</span>, Timed<span class="operator">=</span><span class="string">&#x27;YES&#x27;</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%wait/io/file/innodb/innodb_log_file%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>现在你已经开启了redo log和binlog这两个统计信息，就可以通过MAX_TIMER的值来判断数据库是否出问题了。比如，你可以设定阈值，单次IO请求时间超过200毫秒属于异常，然后使用类似下面这条语句作为检测逻辑。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> event_name,MAX_TIMER_WAIT  <span class="keyword">FROM</span> performance_schema.file_summary_by_event_name <span class="keyword">where</span> event_name <span class="keyword">in</span> (<span class="string">&#x27;wait/io/file/innodb/innodb_log_file&#x27;</span>,<span class="string">&#x27;wait/io/file/sql/binlog&#x27;</span>) <span class="keyword">and</span> MAX_TIMER_WAIT<span class="operator">&gt;</span><span class="number">200</span><span class="operator">*</span><span class="number">1000000000</span>;</span><br></pre></td></tr></table></figure><p>发现异常后，取到你需要的信息，再通过下面这条语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">truncate</span> <span class="keyword">table</span> performance_schema.file_summary_by_event_name;</span><br></pre></td></tr></table></figure><p>把之前的统计信息清空。这样如果后面的监控中，再次出现这个异常，就可以加入监控累积值了。</p><h2 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h2><h3 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h3><p>MySQL建立连接的过程，成本是很高的。除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的数据读写权限。</p><p>短连接模型是存在风险的。max_connections参数是用来控制一个MySQL实例同时存在的连接数的上限，超过这个值，系统就会拒绝接下来的请求，报错提示：“Too many connection”</p><blockquote><p>如果调高max_connections的值呢？</p></blockquote><p>存在一定风险。因为设计max_connections这个参数的目的是想保护MySQL，如果我们把它改得太大，让更多的连接都可以进来，那么系统的负载可能会进一步加大，大量的资源耗费在权限验证等逻辑上，结果可能是适得其反，已经连接的线程拿不到CPU资源去执行业务的SQL请求。</p><h4 id="处理掉占着连接不工作的线程"><a href="#处理掉占着连接不工作的线程" class="headerlink" title="处理掉占着连接不工作的线程"></a>处理掉占着连接不工作的线程</h4><p>首先 show processlist 查看正在 sleep 的线程。</p><p><img src="https://static001.geekbang.org/resource/image/ae/25/ae6a9ceecf8517e47f9ebfc565f0f925.png" alt="img"></p><p>图中id&#x3D;4和id&#x3D;5的两个会话都是Sleep 状态。而要看事务具体状态的话，你可以查information_schema库的innodb_trx表。</p><p><img src="https://static001.geekbang.org/resource/image/ca/e8/ca4b455c8eacbf32b98d1fe9ed9876e8.png" alt="img"></p><p>trx_mysql_thread_id&#x3D;4，表示id&#x3D;4的线程还处在事务中。</p><p>可以优先断开事务外空闲太久的连接，再考虑断开事务内空闲太久的连接。</p><p>断开连接使用的是kill connection + id的命令， 一个客户端处于sleep状态时，它的连接被服务端主动断开后，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。</p><h4 id="减少连接过程的消耗"><a href="#减少连接过程的消耗" class="headerlink" title="减少连接过程的消耗"></a>减少连接过程的消耗</h4><p>有的业务代码会在短时间内先大量申请数据库连接做备用，如果现在数据库确认是被连接行为打挂了，那么一种可能的做法，是让数据库跳过权限验证阶段。</p><p>因此可以重启数据库，并使用–skip-grant-tables参数启动。</p><p>MySQL 8.0版本里，如果你启用–skip-grant-tables参数，MySQL会默认把 –skip-networking参数打开，表示这时候数据库只能被本地的客户端连接。</p><h3 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h3><h4 id="索引没有设计好"><a href="#索引没有设计好" class="headerlink" title="索引没有设计好"></a>索引没有设计好</h4><p>MySQL 5.6版本以后，创建索引都支持Online DDL了，对于那种高峰期数据库已经被这个语句打挂了的情况，最高效的做法就是直接执行alter table 语句。</p><p>比较理想的是能够在备库先执行。假设你现在的服务是一主一备，主库A、备库B，这个方案的大致流程是这样的：</p><ol><li>在备库B上执行 set sql_log_bin&#x3D;off，也就是不写binlog，然后执行alter table 语句加上索引；</li><li>执行主备切换；</li><li>这时候主库是B，备库是A。在A上执行 set sql_log_bin&#x3D;off，然后执行alter table 语句加上索引。</li></ol><p>这是一个“古老”的DDL方案。平时在做变更的时候，你应该考虑类似gh-ost这样的方案，更加稳妥。</p><h4 id="语句没有写好"><a href="#语句没有写好" class="headerlink" title="语句没有写好"></a>语句没有写好</h4><p>MySQL 5.7提供了query_rewrite功能，可以把输入的一种语句改写成另外一种模式。</p><p>比如，语句被错误地写成了 select * from t where id + 1 &#x3D; 10000，你可以通过下面的方式，增加一个语句改写规则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> query_rewrite.rewrite_rules(<span class="keyword">pattern</span>, replacement, pattern_database) <span class="keyword">values</span> (&quot;select * from t where id + 1 = ?&quot;, &quot;select * from t where id = ? - 1&quot;, &quot;db1&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> query_rewrite.flush_rewrite_rules();</span><br></pre></td></tr></table></figure><p>这里，call query_rewrite.flush_rewrite_rules()这个存储过程，是让插入的新规则生效，也就是我们说的“查询重写”。你可以用图中的方法来确认改写规则是否生效。</p><p><img src="https://static001.geekbang.org/resource/image/47/8a/47a1002cbc4c05c74841591d20f7388a.png" alt="img"></p><h4 id="MySQL选错索引"><a href="#MySQL选错索引" class="headerlink" title="MySQL选错索引"></a>MySQL选错索引</h4><p>应急方案就是给这个语句加上force index。</p><h3 id="QPS突增问题"><a href="#QPS突增问题" class="headerlink" title="QPS突增问题"></a>QPS突增问题</h3><p>有时候由于业务突然出现高峰，或者应用程序bug，导致某个语句的QPS突然暴涨，也可能导致MySQL压力过大，影响服务。</p><p>当然，最理想的情况是让业务把这个功能下掉，服务自然就会恢复。而下掉一个功能，如果从数据库端处理的话，对应于不同的背景，有不同的方法可用。</p><ol><li>一种是由全新业务的bug导致的。假设你的DB运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</li><li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的QPS就会变成0。</li><li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的SQL语句直接重写成”select 1”返回。</li></ol><p>当然，这个操作的风险很高，需要你特别细致。它可能存在两个副作用：</p><ol><li>如果别的功能里面也用到了这个SQL语句模板，会有误伤；</li><li>很多业务并不是靠这一个语句就能完成逻辑的，所以如果单独把这一个语句以select 1的结果返回的话，可能会导致后面的业务逻辑一起失败。</li></ol><p>所以，方案3是用于止血的，跟前面提到的去掉权限验证一样，应该是你所有选项里优先级最低的一个方案。</p><p>同时你会发现，其实方案1和2都要依赖于规范的运维体系：虚拟化、白名单机制、业务账号分离。由此可见，更多的准备，往往意味着更稳定的系统。</p><h3 id="上线准备"><a href="#上线准备" class="headerlink" title="上线准备"></a>上线准备</h3><p>通过下面这个过程，我们可以预先发现问题。</p><ol><li>上线前，在测试环境，把慢查询日志（slow log）打开，并且把long_query_time设置成0，确保每个语句都会被记录入慢查询日志；</li><li>在测试表里插入模拟线上的数据，做一遍回归测试；</li><li>观察慢查询日志里每类语句的输出，特别留意Rows_examined字段是否与预期一致。（我们在前面文章中已经多次用到过Rows_examined方法了，相信你已经动手尝试过了。如果还有不明白的，欢迎给我留言，我们一起讨论）。</li></ol><p>不要吝啬这段花在上线前的“额外”时间，因为这会帮你省下很多故障复盘的时间。</p><p>如果新增的SQL语句不多，手动跑一下就可以。而如果是新项目的话，或者是修改了原有项目的 表结构设计，全量回归测试都是必要的。这时候，你需要工具帮你检查所有的SQL语句的返回结果。比如，你可以使用开源工具pt-query-digest(<a href="https://www.percona.com/doc/percona-toolkit/3.0/pt-query-digest.html)%E3%80%82">https://www.percona.com/doc/percona-toolkit/3.0/pt-query-digest.html)。</a></p><h2 id="误删数据"><a href="#误删数据" class="headerlink" title="误删数据"></a>误删数据</h2><p>传统的高可用架构是不能预防误删数据的，因为主库的一个drop table命令，会通过binlog传给所有从库和级联从库，进而导致整个集群的实例都会执行这个命令。</p><h3 id="误删行"><a href="#误删行" class="headerlink" title="误删行"></a>误删行</h3><p>如果是使用delete语句误删了数据行，可以用Flashback工具通过闪回把数据恢复回来。</p><p>Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放。而能够使用这个方案的前提是，需要确保binlog_format&#x3D;row 和 binlog_row_image&#x3D;FULL。</p><p>具体恢复数据时，对单个事务做如下处理：</p><ol><li>对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event即可；</li><li>同理，对于delete语句，也是将Delete_rows event改为Write_rows event；</li><li>而如果是Update_rows的话，binlog里面记录了数据行修改前和修改后的值，对调这两行的位置即可。</li></ol><p>如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。</p><p>恢复数据比较安全的做法，是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。</p><p><strong>事前预防</strong></p><ol><li>把sql_safe_updates参数设置为on。这样一来，如果我们忘记在delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错。</li><li>代码上线前，必须经过SQL审计</li></ol><p>使用truncate &#x2F;drop table和drop database命令删除的数据，就没办法通过Flashback来恢复了。这是因为，即使我们配置了binlog_format&#x3D;row，执行这三个命令时，记录的binlog还是statement格式。binlog里面就只有一个truncate&#x2F;drop 语句，这些信息是恢复不出数据的。</p><h3 id="误删库-表"><a href="#误删库-表" class="headerlink" title="误删库&#x2F;表"></a>误删库&#x2F;表</h3><p>要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份binlog。</p><p>在这两个条件都具备的情况下，假如有人中午12点误删了一个库，恢复数据的流程如下：</p><ol><li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点；</li><li>用备份恢复出一个临时库；</li><li>从日志备份里面，取出凌晨0点之后的日志；</li><li>把这些日志，除了误删除数据的语句外，全部应用到临时库。</li></ol><p><strong>建议</strong></p><ol><li>为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用mysqlbinlog命令时，加上一个–database参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其他库日志的情况。</li><li>在应用日志的时候，需要跳过12点误操作的那个语句的binlog：<ul><li>如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用–stop-position参数执行到误操作之前的日志，然后再用–start-position从误操作之后的日志继续执行；</li><li>如果实例使用了GTID模式，就方便多了。假设误操作命令的GTID是gtid1，那么只需要执行set gtid_next&#x3D;gtid1;begin;commit; 先把这个GTID加到临时实例的GTID集合，之后按顺序执行binlog的时候，就会自动跳过误操作的语句。</li></ul></li></ol><p><strong>加速方法</strong></p><p>在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，这样：</p><ol><li>在start slave之前，先通过执行﻿<br>﻿change replication filter replicate_do_table &#x3D; (tbl_name) 命令，就可以让临时库只同步误操作的表；</li><li>这样做也可以用上并行复制技术，来加速整个数据恢复过程。</li><li>如果由于时间太久，备库上已经删除了临时实例需要的binlog的话，我们可以从binlog备份系统中找到需要的binlog，再放回备库中。</li></ol><p>把之前删掉的binlog放回备库的操作步骤，是这样的：</p><ol><li>从备份系统下载master.000005和master.000006这两个文件，放到备库的日志目录下；</li><li>打开日志目录下的master.index文件，在文件开头加入两行，内容分别是 “.&#x2F;master.000005”和“.&#x2F;master.000006”;</li><li>重启备库，目的是要让备库重新识别这两个日志文件；</li><li>现在这个备库上就有了临时库需要的所有binlog了，建立主备关系，就可以正常同步了。</li></ol><p>建议将数据恢复功能做成自动化工具，并经常演练，避免线上出问题无法及时恢复数据。</p><h3 id="延迟恢复备库"><a href="#延迟恢复备库" class="headerlink" title="延迟恢复备库"></a>延迟恢复备库</h3><p>延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY &#x3D; N命令，可以指定这个备库持续保持跟主库有N秒的延迟。</p><p>比如你把N设置为3600，这就代表了如果主库上有数据被误删了，并且在1小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行stop slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。</p><p>这样的话，你就随时可以得到一个，只需要最多再追1小时，就可以恢复出数据的临时实例，也就缩短了整个数据恢复需要的时间。</p><h3 id="预防误删库-表的方法"><a href="#预防误删库-表的方法" class="headerlink" title="预防误删库&#x2F;表的方法"></a>预防误删库&#x2F;表的方法</h3><p>账号分离。这样做的目的是，避免写错命令。比如：</p><ul><li>我们只给业务开发同学DML权限，而不给truncate&#x2F;drop权限。而如果业务开发人员有DDL需求的话，也可以通过开发管理系统得到支持。</li><li>即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</li></ul><p>制定操作规范。这样做的目的，是避免写错要删除的表名。比如：</p><ul><li>在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。</li><li>改表名的时候，要求给表名加固定的后缀（比如加_to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。</li></ul><h3 id="rm-删除数据"><a href="#rm-删除数据" class="headerlink" title="rm 删除数据"></a>rm 删除数据</h3><p>对于一个有高可用机制的MySQL集群来说，最不怕的就是rm删除数据了。这时，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。</p><p>当然了，现在不止是DBA有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批量下线机器的操作，会让你整个MySQL集群的所有节点都全军覆没。</p><p>应对这种情况，我的建议只能是说尽量把你的备份跨机房，或者最好是跨城市保存。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Git分支模型的理解与思考</title>
      <link href="/2023/11/27/%E5%9F%BA%E4%BA%8EGit%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%9D%E8%80%83/"/>
      <url>/2023/11/27/%E5%9F%BA%E4%BA%8EGit%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>进入企业后，开发过程中为了实现多人同步协作，企业往往会有一套 git 分支规范，这和学习中遇到的分支大有不同。本文是对 git 成熟模型 A successful Git branching model 的理解和对公司约定的 git 分支规范的思考。</p><p>在实际生产开发的过程中，如果每个人都随意的创建分支，随意的提交commit，必将导致整个git仓库非常的混乱，不易于团队协作。Vincent Driessen 同学为了解决这个问题提出了 <a href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>，最后形成了业内普遍采用的 git 工作流程，大家都在约定的流程内使用git，使得团队协作效率大大提高‌。</p><h1 id="为什么使用Git？"><a href="#为什么使用Git？" class="headerlink" title="为什么使用Git？"></a>为什么使用Git？</h1><p>Git 是一个分布式版本管理工具，在多人协作的条件下高效处理任何规模的软件工程，并对项目版本、状态做环境隔离。每一个Git克隆都是一个完整的文件库，含有全部历史记录和修订追踪能力，不依赖于网络连接或中心服务器。最大特色是分支和合并操作非常快速、简便。</p><p>与SVN相比，git有以下5点优势：</p><ol><li><p><strong>版本库本地化，支持离线提交，相对独立不影响协同开发。</strong>每个开发者都拥有自己的版本控制库，在自己的版本库上可以任意的执行提交代码、创建分支等行为。例如，开发者认为自己提交的代码有问题？没关系，因为版本库是自己的，回滚历史、反复提交、归并分支并不会影响到其他开发者。</p></li><li><p><strong>更少的“仓库污染”。</strong>git对于每个工程只会产生一个.git目录，这个工程所有的版本控制信息都在这个目录中，不会像SVN那样在每个目录下都产生.svn目录。</p></li><li><p><strong>把内容按元数据方式存储，完整克隆版本库。</strong>所有版本信息位于.git目录中，它是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签、分支、版本记录等。</p></li><li><p><strong>支持快速切换分支方便合并，比较合并性能好。</strong>在同一目录下即可切换不同的分支，方便合并，且合并文件速度比SVN快。</p></li><li><p><strong>分布式版本库，无单点故障，内容完整性好。</strong>内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p></li></ol><h1 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a>主分支</h1><p>对于 Git 初学者来讲，应该都很熟悉 master-develop 双分支模型吧。我们一般把 <code>origin/master</code> 库认作为主分支，HEAD 的源代码存在于此版本中，并且随时是预备生产状态。而 <code>origin/develop</code> 分支 HEAD 源码始终体现下个发布版的最新变更，当 <code>develop</code>分支的源码到达了一个稳定状态待发布，所有的代码变更需合并到 <code>master</code> 分支，然后标记一个版本号。</p><p>所以，每次变更都合并到了master，这就是新产品的定义。理论上，每当对<code>master</code> 有一个提交操作，我们就可以使用Git钩子脚本来自动构建并且发布软件到生产服务器。</p><h1 id="辅助性分支"><a href="#辅助性分支" class="headerlink" title="辅助性分支"></a>辅助性分支</h1><p>开发模型一般会使用各种辅助性分支，这些分支与关键分支（<code>master</code>和<code>develop</code>）一起，用来支持团队成员并行开发，协助生产发布环境准备，以及快速修复实时在线问题。与关键分支不同，这些分支是有生命周期的，因为它们最终会被移除。</p><p>我们用到的分支类型包括：</p><ul><li>功能分支（<code>feature</code>）</li><li>发布分支（<code>release</code>）</li><li>测试分支（<code>sit</code>）</li><li>预发布分支（<code>uat</code>）</li><li>热修复分支（<code>hotfix</code>）</li></ul><p>每一种分支有一个特定目的，并且有一定程度的规则，比如：可以用哪些分支作为源分支，哪些分支能作为合并目标。</p><h2 id="功能分支（feature）"><a href="#功能分支（feature）" class="headerlink" title="功能分支（feature）"></a>功能分支（feature）</h2><p>功能分支通常为即将发布或者未来发布版开发的新的功能。当新功能开始研发时，负责此需求的工作者应该本地创建一个相应的功能分支进行开发（注意不要将本地分支 push 到远程）。</p><p>可能是 develop&#x2F;release 分支的分支版本，最终必须合并到 develop&#x2F;release 分支中。</p><p>根据企业自身状况，功能分支可能也会从 release&#x2F;版本号 中拉取，因为也许企业需要两个版本的系统并行开发，只有 <code>develop</code> 分支作为主要的开发环境不太能满足这种需求。</p><h3 id="创建一个功能分支"><a href="#创建一个功能分支" class="headerlink" title="创建一个功能分支"></a>创建一个功能分支</h3><p>开始一项功能的开发工作时，基于<code>develop</code>创建分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b feature/v1.0/myfeature develop</span></span><br></pre></td></tr></table></figure><h3 id="合并一个功能到develop分支"><a href="#合并一个功能到develop分支" class="headerlink" title="合并一个功能到develop分支"></a>合并一个功能到develop分支</h3><p>完成的功能可以合并进<code>develop</code>分支，明确加入到未来的发布：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout develop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge -no-ff myfeature</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d myfeature</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin develop</span></span><br></pre></td></tr></table></figure><p>–no-ff 标志导致合并操作创建一个新commit对象，即使该合并操作可以fast-forward。这避免了丢失这个功能分支存在的历史信息，将该功能的所有提交组合在一起。</p><p>如果直接 git merge，不可能从 Git 历史中看到哪些提交一起实现了一个功能，必须手动阅读全部的日志信息。因此回滚一组提交也变得非常困难。</p><h2 id="发布分支（release）"><a href="#发布分支（release）" class="headerlink" title="发布分支（release）"></a>发布分支（release）</h2><p><code>Release</code> 分支是为新产品的发布做准备的，创建时要为即将发行版本分配一个版本号。</p><p><code>Release</code>分支可能从 <code>develop</code> 分支分离，但是最终一定要合并到 <code>develop</code> 和 <code>master</code> 分支上。</p><p>从<code>develop</code>分支创建新的 <code>release</code> 分支的关键时刻是 <code>develop</code> 分支达到了发布的理想状态。<code>release </code>分支允许一些小bugs的修改和准备发布元数据（版本号、开发时间）。</p><h3 id="创建一个release分支"><a href="#创建一个release分支" class="headerlink" title="创建一个release分支"></a>创建一个release分支</h3><p>若当前产品的发行版本是1.1.5，同时有一个大的版本即将发行。<code>develop</code>分支为下次发行做好了准备，决定好下一个版本是1.2。所以此时可以将<code>release</code>分支分离出来，给一个能反映版本号的分支名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b release-1.2 develop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bump-version.sh 1.2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&quot;Bumped version number to 1.2&quot;</span></span></span><br></pre></td></tr></table></figure><p>创建新分支以后，切换到该分支，添加版本号。这里，bump-version.sh 是一个虚构的shell脚本，它可以复制一些文件来反映新的版本（这当然可以手动改变–目的就是修改一些文件）。然后版本号被提交。</p><p>这个新分支可能会存在一段时间，直到该发行版到达它的预定目标。在此期间，bug的修复可能被提交到该分支上（而不是提交到<code>develop</code>分支上）。在这里严格禁止增加大的新features。他们必须合并到<code>develop</code>分支上，然后等待下一次大的发行版。</p><h3 id="完成一个release分支"><a href="#完成一个release分支" class="headerlink" title="完成一个release分支"></a>完成一个release分支</h3><p>当一个<code>release</code>分支准备好成为一个真正的发行版时（即已经通过所有测试），<code>release</code>分支要合并到<code>master</code>上（因为每一次提交到<code>master</code>上的都是一个新定义的发行版）。提交到<code>master</code>上必须打一个标签，以便以后更加方便引用历史版本。最后，在<code>release</code>分支上的修改必须合并到<code>develop</code>上，以便未来的发行版包含这些bugs的修复。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff release-1.2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a 1.2</span></span><br></pre></td></tr></table></figure><p>合并到<code>develop</code>上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout develop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff release-1.2</span></span><br></pre></td></tr></table></figure><p>最后删除掉这个<code>release</code>分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d release-1.2</span></span><br></pre></td></tr></table></figure><h2 id="测试分支（sit）"><a href="#测试分支（sit）" class="headerlink" title="测试分支（sit）"></a>测试分支（sit）</h2><p>测试环境分支，只接受 <code>feature</code> ，<code>hotfix</code>， <code>release</code> 分支的合并。研发内测联调通过后，由研发人员将自己的 <code>feature</code> 分支或 <code>hotfix</code> 分支代码合并到 <code>sit</code> 。该分支对应测试环境，测试人员的专用测试环境。</p><h3 id="创建一个-sit"><a href="#创建一个-sit" class="headerlink" title="创建一个 sit"></a>创建一个 sit</h3><p><code>sit</code> 可以基于 <code>feature</code> 分支创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b sit myfeature</span></span><br></pre></td></tr></table></figure><h3 id="完成一个-sit"><a href="#完成一个-sit" class="headerlink" title="完成一个 sit"></a>完成一个 sit</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b sit myfeature</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d sit</span></span><br></pre></td></tr></table></figure><h2 id="预发布分支（uat）"><a href="#预发布分支（uat）" class="headerlink" title="预发布分支（uat）"></a>预发布分支（uat）</h2><p>产品版本即将发布上线时，必须经过预发布分支的测试。</p><p>预发布环境，只接受 <code>hotfix</code> 、<code>release</code> 分支的代码合并。</p><h3 id="创建一个uat"><a href="#创建一个uat" class="headerlink" title="创建一个uat"></a>创建一个uat</h3><p>一般此分支是基于 <code>release</code> 分支创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b uat-1.2 release</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bump-version.sh 1.2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&quot;Bumped version number to 1.2&quot;</span></span></span><br></pre></td></tr></table></figure><p>如果生产环境下突然出现需要紧急修复的情况，<code>uat</code> 也可以支持 <code>hotfix</code> 的合并</p><h3 id="完成一个uat"><a href="#完成一个uat" class="headerlink" title="完成一个uat"></a>完成一个uat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b uat-1.2 release</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bump-version.sh 1.2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&quot;Bumped version number to 1.2&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d uat-1.2</span></span><br></pre></td></tr></table></figure><h2 id="热修复分支（hotfix）"><a href="#热修复分支（hotfix）" class="headerlink" title="热修复分支（hotfix）"></a>热修复分支（hotfix）</h2><p>热修复分支通常用于紧急修复的情况，项目上线到生产环境后多多少少会有一些漏洞需要进行紧急修复，因此热修复分支可以基于<code>master</code>分支上对应与线上版本的tag创建。</p><p>可以基于 <code>master</code> 分支，必须合并回 <code>develop</code> 和 <code>master</code> 分支。</p><h3 id="创建修补bug分支"><a href="#创建修补bug分支" class="headerlink" title="创建修补bug分支"></a>创建修补bug分支</h3><p><code>hotfix branch</code> 是从 <code>master</code> 分支上面分出来的。例如，1.2 版本是当前的生产环境版本并且有 bug。但是开发分支变化还不稳定，需要分出来一个修补 bug 分支来解决这个问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b hotfix-1.2.1 master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bump-version.sh 1.2.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&quot;Bumped version number to 1.2.1&quot;</span></span></span><br></pre></td></tr></table></figure><p>分支关闭时不要忘记更新版本号，然后修复bug</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;Fixed severe production problem&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="完成一个-hotfix-分支"><a href="#完成一个-hotfix-分支" class="headerlink" title="完成一个 hotfix 分支"></a>完成一个 hotfix 分支</h3><p>完成一个<code>hotfix</code>之后，需要把<code>hotfix</code>合并到<code>master</code>和<code>develop</code>分支去，这样就可以保证修复的这个bug也包含到下一个发行版中。这一点和完成<code>release</code>分支很相似。</p><p>首先，更新<code>master</code>并对<code>release</code>打上tag：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff hotfix-1.2.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a 1.2.1</span></span><br></pre></td></tr></table></figure><p>编辑：你可能也会想使用 -sor-u <key>参数来对你的tag进行加密</key></p><p>下一步，把bugfix添加到<code>develop</code>分支中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout develop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff hotfix-1.2.1</span></span><br></pre></td></tr></table></figure><p> <strong>如果一个<code>release</code>分支已经存在，那么应该把<code>hotfix</code>合并到这个<code>release</code>分支，而不是合并到<code>develop</code>分支。</strong>当<code>release</code>分支完成后， 将<code>hotfix</code>分支合并回<code>release</code>分支也会使得<code>hotfix</code>被合并到<code>develop</code>分支。</p><p>最后，删除临时分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d hotfix-1.2.1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记</title>
      <link href="/2023/11/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-的基本架构"><a href="#MySQL-的基本架构" class="headerlink" title="MySQL 的基本架构"></a>MySQL 的基本架构</h1><p>要想探究 MySQL 的执行原理，首先要了解 MySQL 的基础架构，从中清楚看到 SQL 语句在 MySQL 的各个模块中的执行过程。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/6a6ba5d6f15a0fdd546018e5cacbd3509e887c17.png" alt="系统架构图"></p><p>Server层涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>第一步，先连接到数据库，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>因此，一个用户成功建立连接后，它的权限会维持在建立连接那一刻读到的权限。如果用管理员账号对这个用户的权限做修改，只要这个用户不断开连接，它的权限就不会发生变化。</p><p><strong>那么，什么时候会断开连接呢？</strong></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p><strong>长连接</strong>：指连接成功后，如果客户端持续有请求，则一直使用同一个连接。</p><p><strong>短连接</strong>：指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中<strong>临时使用的内存是管理在连接对象里面的</strong>。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li><p><strong>定期断开长连接</strong>。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</p></li><li><p>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 <strong>mysql_reset_connection</strong>来重新<strong>初始化连接资源</strong>。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。（推荐第二种）</p></li></ol><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以<strong>key-value对</strong>的形式，被直接缓存在内存中。<strong>key是查询的语句，value是查询的结果。</strong>如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。</p><p>但是，一般不建议使用查询缓存，原因是查询缓存很容易失效。只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p><p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>；</span><br></pre></td></tr></table></figure><p>另外，MySQL 8.0版本已经把查询缓存的功能删掉了。</p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p><p>首先，分析器会做“<strong>词法分析</strong>”。MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p><p>然后，分析器会做“<strong>语法分析</strong>”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID)  <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li><li>也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ERROR <span class="number">1142</span> (<span class="number">42000</span>): <span class="keyword">SELECT</span> command denied <span class="keyword">to</span> <span class="keyword">user</span> <span class="string">&#x27;b&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">for</span> <span class="keyword">table</span> <span class="string">&#x27;T&#x27;</span></span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。</p><p>问题：</p><blockquote><p>如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k&#x3D;1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</p></blockquote><p>答案：分析器阶段。</p><p>网友回答：</p><blockquote><p>《高性能mysql》里提到解析器和预处理器。<br>解析器处理语法和解析查询, 生成一课对应的解析树。<br>预处理器进一步检查解析树的合法。比如: 数据表和数据列是否存在, 别名是否有歧义等。如果通过则生成新的解析树，再提交给优化器。</p></blockquote><h1 id="SQL执行过程"><a href="#SQL执行过程" class="headerlink" title="SQL执行过程"></a>SQL执行过程</h1><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_student  A <span class="keyword">where</span> A.age<span class="operator">=</span><span class="string">&#x27;18&#x27;</span> <span class="keyword">and</span> A.name<span class="operator">=</span><span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p></li><li><p>通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id&#x3D;’1’。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p></li><li><p>接下来就是优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p></li><li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p></li></ul><h3 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_student A <span class="keyword">set</span> A.age<span class="operator">=</span><span class="number">19</span> <span class="keyword">where</span> A.ID<span class="operator">=</span><span class="number">50</span>;</span><br></pre></td></tr></table></figure><ul><li>在一张表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句会把表上所有缓存结果清空</li><li>分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</li><li>执行器先找引擎取ID&#x3D;50这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID&#x3D;50这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个 age 值设为19，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li></ul><p>这里涉及到两个日志，redo log 和 binlog，还有一个概念，两阶段提交。</p><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>redo log 是在有一条记录需要更新时，InnoDB 引擎先将记录写到 redo log 里面，并更新内存。同时， InnoDB引擎会在适当的时候，把这个操作记录更新到磁盘里。</p><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos和checkpoint之间的是 redo log 剩余的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示 redo log 满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p><p><strong>redo log 有什么用处呢？</strong></p><blockquote><p>一个事务提交后，对Buffer Pool对应的页的修改还未持久到磁盘。如果Mysql突然宕机，这个事务的更改会不会直接消失？</p></blockquote><p>答案是不会。Mysql InnoDB 引擎使用 redo log来保证事务的持久性。redo log 主要做的事情就是记录页的修改，redo log中的每一条记录包含了表空间号、数据页号、偏移量、具体修改的数据，可能会记录修改数据的长度（取决于redo log的类型）。 某个页面某个偏移量处修改了几个字节的值以及被修改的内容是什么，都由redo log记录。 在事务提交时，我们会将 redo log按照刷盘策略刷到磁盘上去，即使Mysql宕机，重启后也能恢复未写入磁盘的数据，从而保证了事务的持久性。 刷盘策略 innodb_flush_log_at_trx_commit 的默认值为 1，设置为 1 时不会丢失任何数据。 redo log 采用循环写的方式进行写入，大小固定，当写到结尾时，会回到开头循环写日志，会出现前面写的日志被覆盖的情况。</p><blockquote><p>redo log 一般设置多大？</p></blockquote><p>redo log太小的话，会导致很快就被写满，然后不得不强行刷redo log，这样WAL机制的能力就发挥不出来了。因此建议将redo log设置为4个文件、每个文件1GB。</p><h5 id="redo-log写入机制"><a href="#redo-log写入机制" class="headerlink" title="redo log写入机制"></a>redo log写入机制</h5><p>事务在执行过程中，生成的redo log是要先写到redo log buffer的。</p><blockquote><p>redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？</p></blockquote><p>在一个事务的更新过程中，日志是要写多次的。插入数据过程中，需要保存日志，但是不能在还没 commit 的时候直接写到 redo log 文件里。所以，redo log buffer 是一块内存，用来先存 redo log 日志的。在执行第一个插入语句时，数据的内存被修改了， redo log buffer 也写入了日志。</p><p>真正把日志写到 redo log 文件里，是在执行 commit 语句的时候做的。</p><p>redo log可能存在的三种状态，这三种状态分别是：</p><ol><li>存在redo log buffer中，物理上是在MySQL进程内存中，就是图中的红色部分；</li><li>写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面，也就是图中的黄色部分；</li><li>持久化到磁盘，对应的是hard disk，也就是图中的绿色部分。</li></ol><p><img src="https://static001.geekbang.org/resource/image/9d/d4/9d057f61d3962407f413deebc80526d4.png" alt="img"></p><p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种可能取值：</p><ol><li>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中;</li><li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</li><li>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。</li></ol><p>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cache，然后调用fsync持久化到磁盘。</p><p>注意，事务执行中间过程的redo log也是直接写在redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的redo log，也是可能已经持久化到磁盘的。</p><p>除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中。</p><ol><li><strong>一种是，redo log buffer占用的空间即将达到 innodb_log_buffer_size一半的时候，后台线程会主动写盘。</strong>注意，由于这个事务并没有提交，所以这个写盘动作只是write，而没有调用fsync，也就是只留在了文件系统的page cache。</li><li><strong>另一种是，并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。</strong>假设一个事务A执行到一半，已经写了一些redo log到buffer中，这时候有另外一个线程的事务B提交，如果innodb_flush_log_at_trx_commit设置的是1，那么按照这个参数的逻辑，事务B要把redo log buffer里的日志全部持久化到磁盘。这时候，就会带上事务A在redo log buffer里的日志一起持久化到磁盘。</li></ol><p>那也就意味着，redo log在prepare阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于prepare 的redo log，再加上binlog来恢复的。每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只会write到文件系统的page cache中。</p><p><strong>MySQL的“双1”配置</strong>：sync_binlog和innodb_flush_log_at_trx_commit都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare 阶段），一次是binlog。</p><blockquote><p>在什么时候会把线上生产库设置成“非双1”？</p></blockquote><p>目前知道的场景，有以下这些：</p><ol><li>业务高峰期。一般如果有预知的高峰期，DBA会有预案，把主库设置成“非双1”。</li><li>备库延迟，为了让备库尽快赶上主库。</li><li>用备份恢复主库的副本，应用binlog的过程，这个跟上一种场景类似。</li><li>批量导入数据的时候。</li></ol><p>一般情况下，把生产库改成“非双1”配置，是设置innodb_flush_logs_at_trx_commit&#x3D;2、sync_binlog&#x3D;1000。</p><h5 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h5><p>日志逻辑序列号（log sequence number，LSN）：LSN是单调递增的，用来对应redo log的一个个写入点。每次写入长度为length的redo log， LSN的值就会加上length。</p><p>LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。</p><h5 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h5><blockquote><p>从MySQL看到的TPS是每秒两万的话，每秒就会写四万次磁盘。但是，用工具测试出来，磁盘能力也就两万左右，怎么能实现两万的TPS？</p></blockquote><p>如图所示，是三个并发事务(trx1, trx2, trx3)在prepare 阶段，都写完redo log buffer，持久化到磁盘的过程，对应的LSN分别是50、120 和160。</p><p><img src="https://static001.geekbang.org/resource/image/93/cc/933fdc052c6339de2aa3bf3f65b188cc.png" alt="img"></p><p>从图中可以看到，</p><ol><li>trx1是第一个到达的，会被选为这组的 leader；</li><li>等trx1要开始写盘的时候，这个组里面已经有了三个事务，这时候LSN也变成了160；</li><li>trx1去写盘的时候，带的就是LSN&#x3D;160，因此等trx1返回时，所有LSN小于等于160的redo log，都已经被持久化到磁盘；</li><li>这时候trx2和trx3就可以直接返回了。</li></ol><p>所以，一次组提交里面，组员越多，节约磁盘IOPS的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。</p><p>在并发更新场景下，第一个事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能越多，节约IOPS的效果就越好。</p><p>两阶段提交里虽然把写binlog当成一个动作。但实际上，写binlog分为了两步。</p><ol><li>先把binlog从binlog cache中写到磁盘上的binlog文件；</li><li>调用fsync持久化</li></ol><p>MySQL为了让组提交的效果更好，把redo log做fsync的时间拖到了步骤1之后。也就是说，上面的图变成了这样：</p><p><img src="https://static001.geekbang.org/resource/image/5a/28/5ae7d074c34bc5bd55c82781de670c28.png" alt="img"></p><p>这么一来，binlog也可以组提交了。在执行图5中第4步把binlog fsync到磁盘时，如果有多个事务的binlog已经写完了，也是一起持久化的，这样也可以减少IOPS的消耗。</p><p>不过通常情况下第3步执行得会很快，所以binlog的write和fsync间的间隔时间短，导致能集合到一起持久化的binlog比较少，因此binlog的组提交的效果通常不如redo log的效果那么好。</p><p>如果你想提升binlog组提交的效果，可以通过设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count来实现。</p><ol><li>binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync;</li><li>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。</li></ol><p>这两个条件是或的关系，也就是说只要有一个满足条件就会调用fsync。</p><p>所以，当binlog_group_commit_sync_delay设置为0的时候，binlog_group_commit_sync_no_delay_count也无效了。</p><p><strong>WAL机制主要得益于两个方面</strong>：</p><ol><li>redo log 和 binlog都是顺序写，磁盘的顺序写比随机写速度要快；</li><li>组提交机制，可以大幅度降低磁盘的IOPS消耗。</li></ol><blockquote><p>如果你的MySQL现在出现了性能瓶颈，而且瓶颈在IO上，可以通过哪些方法来提升性能呢？</p></blockquote><p>可以考虑以下三种方法：</p><ol><li>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li><li>将sync_binlog 设置为大于1的值（比较常见是100~1000）。这样做的风险是，主机掉电时会丢binlog日志。</li><li>将innodb_flush_log_at_trx_commit设置为2。这样做的风险是，主机掉电的时候会丢数据</li></ol><p>不建议把innodb_flush_log_at_trx_commit 设置成0。因为把这个参数设置成0，表示redo log只保存在内存中，这样的话MySQL本身异常重启也会丢数据，风险太大。而redo log写到文件系统的page cache的速度也是很快的，所以将这个参数设置成2跟设置成0其实性能差不多，但这样做MySQL异常重启时就不会丢数据了，相比之下风险会更小。</p><blockquote><p> 为什么binlog cache是每个线程自己维护的，而redo log buffer是全局共用的？</p></blockquote><p>回答：MySQL这么设计的主要原因是，binlog是不能“被打断的”。一个事务的binlog必须连续写，因此要整个事务完成后，再一起写到文件里。</p><p>而redo log并没有这个要求，中间有生成的日志可以写到redo log buffer中。redo log buffer中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。</p><h4 id="binglog"><a href="#binglog" class="headerlink" title="binglog"></a>binglog</h4><p>MySQL binlog(binary log 即二进制日志文件) **主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)**。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。</p><p><strong>为什么要用两个日志模块，用一个日志模块不行吗?</strong></p><p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p><p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。</p><p><strong>binlog 和 redolog 的区别</strong></p><ul><li>binlog 主要用于数据库还原，属于数据级别的数据恢复。主从复制是 binlog 最常见的一个应用场景。redolog 主要用于保证事务的持久性，属于事务级别的数据恢复。</li><li>redolog 属于 InnoDB 引擎特有，binlog 属于所有引擎共有，因为 binlog 是 mysql 的 Server 层实现的。</li><li>redolog 属于物理日志，主要记录的是某个页的修改。binlog 属于逻辑日志，主要记录的是数据库执行的所有 DDL 和 DML 语句。</li><li>binlog 通过追加的方式进行写入，大小没有限制。redolog 采用循环写的方式写入，大小固定，当写到结尾时，会回到开头循环写日志。</li></ul><h5 id="binlog-写入机制"><a href="#binlog-写入机制" class="headerlink" title="binlog 写入机制"></a>binlog 写入机制</h5><p>事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p><p>系统给binlog cache分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p><ul><li><p>每个线程写入其对应的 binlog_cache_size</p></li><li><p>write 操作把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。</p></li><li><p>fsync 操作才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占磁盘的IOPS。</p></li></ul><p>write 和fsync的时机，是由参数sync_binlog控制的：</p><ol><li>sync_binlog&#x3D;0的时候，表示每次提交事务都只write，不fsync；</li><li>sync_binlog&#x3D;1的时候，表示每次提交事务都会执行fsync；</li><li>sync_binlog&#x3D;N(N&gt;1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。</li></ol><p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100~1000中的某个数值。</p><p>但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。</p><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p><code>redo log</code>（重做日志）让 <code>InnoDB</code> 存储引擎拥有了崩溃恢复能力。</p><p><code>binlog</code>（归档日志）保证了 <code>MySQL</code> 集群架构的数据一致性。</p><p>虽然它们都属于持久化的保证，但是侧重点不同。</p><p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/2c3f42bf0258deed73db8fb0211ab82738189308.png" alt="日志写入时机"></p><p>为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做。</p><ul><li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li><li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li></ul><p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。</p><p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/2c3f42bf0258deed73db8fb0211ab82738189308.png"></p><h5 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h5><p>假设写入redo log 处于prepare阶段之后、写binlog之前，发生了崩溃（crash），由于此时binlog还没写，redo log也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog还没写，所以也不会传到备库。</p><p>那么问题来了，有没有一个极端的情况呢？假设binlog写完，redo log还没commit前发生crash， <strong>MySQL异常重启会出现什么现象</strong>？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p><ul><li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 redo log 里的事务是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li></ul><p><img src="https://i0.hdslb.com/bfs/openplatform/7f9d6c4a8ff69c8afe58bb901a8b16db3f5816f0.png" alt="2PC情况1"></p><p>如果 redo log 设置 commit 阶段发生异常，那会不会回滚事务呢？</p><ul><li><p>它会判断对应的事务binlog是否存在并完整，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/3b4115dcbe3c6caf9ba50038cb9a061b4cd863ac.png" alt="2PC情况2"></p></li></ul><p>这样就解决了数据一致性的问题。</p><blockquote><p>MySQL怎么知道binlog是完整的?</p></blockquote><p>回答：一个事务的binlog是有完整格式的：</p><ul><li><p>statement格式的binlog，最后会有COMMIT；</p></li><li><p>row格式的binlog，最后会有一个XID event。</p></li></ul><p>另外，在MySQL 5.6.2版本以后，还引入了binlog-checksum参数，用来验证binlog内容的正确性。校验checksum的结果可以处理关于binlog日志由于磁盘原因可能会在日志中间出错的情况。</p><blockquote><p>redo log 和 binlog是怎么关联起来的?</p></blockquote><p>回答：它们有一个共同的数据字段，叫XID。崩溃恢复的时候，会按顺序扫描redo log：</p><ul><li><p>如果碰到既有prepare、又有commit的redo log，就直接提交；</p></li><li><p>如果碰到只有parepare、而没有commit的redo log，就拿着XID去binlog找对应的事务。</p></li></ul><h4 id="生产建议"><a href="#生产建议" class="headerlink" title="生产建议"></a>生产建议</h4><p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数建议设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p><p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数也建议设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p><blockquote><p>定期全量备份的周期取决于系统重要性，有的是一天一备，有的是一周一备。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？</p></blockquote><p>好处是“最长恢复时间”更短。</p><p>在一天一备的模式里，最坏情况下需要应用一天的binlog。</p><p>一周一备份，那就需要全备+周一到周日某个时间点的全部binlog用来恢复，时间相比前者需要增加很多；且需要确保整个一周的binlog都完好无损，否则将无法恢复。</p><p>系统的对应指标就是 RTO（恢复目标时间）。当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个RTO是成本换来的，就需要根据业务重要性来评估了。</p><h1 id="数据的存储"><a href="#数据的存储" class="headerlink" title="数据的存储"></a>数据的存储</h1><blockquote><p>为什么一条 SQL 语句正常执行的时候特别快，但是有时候突然又变慢了？</p></blockquote><p><strong>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</strong>。</p><p>平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。</p><p>那么，什么情况会引发数据库的flush过程呢？</p><ul><li><p>redo log 写满了，系统停止所有更新操作，把 checkpoint 往前推进， 在这之前需要将移动的位置之间的日志对应的所有脏页都 flush 到磁盘上。（要尽量避免）</p></li><li><p>系统内存不足，需要新的内存页，也就需要淘汰掉一些数据页。如果淘汰的是脏页，就要先将脏页写到磁盘。</p><p>如果刷脏页一定会写盘，就保证了每个数据页有两种状态：</p><ul><li>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</li><li>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。<br>这样的效率最高。</li></ul></li><li><p>MySQL认为系统“空闲”的时候。有机会就刷一点“脏页”。</p></li><li><p>MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p></li></ul><p>对于第二种情况是很常见的。</p><p>InnoDB 存储引擎是以页为单位来管理存储空间的，我们往 MySQL 插入的数据最终都是存在于页中，准确来说是数据页这种类型，为了减少磁盘 IO 开销，还有一个叫做 Buffer Pool(缓冲池)的区域，存在于内存中。当数据对应的页不存在于 Buffer Pool 中的话，mysql 会先将磁盘上的页缓存到 Buffer Pool 中，这样后面我们直接操作的就是 Buffer Pool 中的页，这样大大提高了读写性能。</p><p><strong>缓冲池中的内存页有三种状态：</strong></p><ul><li>第一种是，还没有使用的；</li><li>第二种是，使用了并且是干净页；</li><li>第三种是，使用了并且是脏页。</li></ul><p>这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p><p>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p><ol><li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li><li>日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。</li></ol><p>所以，InnoDB需要有控制脏页比例的机制，来尽量避免上面的这两种情况。</p><p>测试磁盘随机读写的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest </span><br></pre></td></tr></table></figure><p>InnoDB的刷盘速度参考因素：<strong>脏页比例，redo log写盘速度</strong>。</p><p>参数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%（需多关注脏页比例，不要让其经常接近75%）。InnoDB会根据当前的脏页比例（假设为M），算出一个范围在0到100之间的数字，计算这个数字的伪代码类似这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记(当前日志序号-checkpoint) &#x3D; N，InnoDB 会根据这个 N 计算出一个范围在 0-100 的数字，计算公式为 F2(N)</p><p>取 F1(M) 和 F2(N) 的最大值 R，<strong>之后引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。</strong></p><p>MySQL 中刷脏页可能会有连坐机制，如果这个数据页旁边正好是一个脏页，就会把它的邻居一起刷掉。在 InnoDB 中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为1的时候会有上述的“连坐”机制，值为0时表示不找邻居，自己刷自己的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机IO。机械硬盘的随机IOPS一般只有几百，相同的逻辑操作减少随机IO就意味着系统性能的大幅度提升。</span><br><span class="line"></span><br><span class="line">而如果使用的是SSD这类IOPS比较高的设备的话，我就建议你把innodb_flush_neighbors的值设置成<span class="number">0</span>。因为这时候IOPS往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少SQL语句响应时间。</span><br><span class="line"></span><br><span class="line">在MySQL <span class="number">8.0</span>中，innodb_flush_neighbors参数的默认值已经是<span class="number">0</span>了。</span><br></pre></td></tr></table></figure><blockquote><p>一个内存配置为128GB、innodb_io_capacity设置为20000的大规格实例，正常会建议你将redo log设置成4个1GB的文件。</p><p>但如果你在配置的时候不慎将redo log设置成了1个100M的文件，会发生什么情况呢？又为什么会出现这样的情况呢？</p></blockquote><p>每次事务提交都要写redo log，如果设置太小，很快就会被写满，这时候系统不得不停止所有更新，去推进checkpoint。在这种情况下，连change buffer的优化也失效了。因为checkpoint一直要往前推，这个操作就会触发merge操作，然后又进一步地触发刷脏页操作。</p><h2 id="数据库表的空间回收"><a href="#数据库表的空间回收" class="headerlink" title="数据库表的空间回收"></a>数据库表的空间回收</h2><p>一个InnoDB表包含两部分，即：表结构定义和数据。</p><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><p>在MySQL 8.0版本以前，表结构是存在以.frm为后缀的文件里。</p><p>而MySQL 8.0版本，则已经允许把表结构定义放在系统数据表中了。</p><h3 id="表数据"><a href="#表数据" class="headerlink" title="表数据"></a>表数据</h3><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数innodb_file_per_table控制的：</p><ol><li>这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li><li>这个参数设置为ON表示的是，每个InnoDB表数据存储在一个以 .ibd为后缀的文件中。</li></ol><p>从MySQL 5.6.6版本开始，它的默认值就是ON了。无论是哪个版本，建议设置为 ON。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过 <span class="keyword">drop</span> <span class="keyword">table</span> 命令，系统会直接删除这个文件；如果放在共享空间，即使表删掉了，空间也不会被回收。</span><br><span class="line">而 <span class="keyword">delete</span> 命令，分为记录的复用和数据页的复用。</span><br><span class="line">删除某条记录，InnoDB 只会把记录标记为删除，如果要插入在这个记录删除区间的记录，可能会复用这个位置。但是磁盘文件大小不会被缩小。</span><br><span class="line">删除一个数据页上的所有记录，整个数据页就都可以被复用了。发生页合并时，另一个空出来的页也能被复用了。</span><br></pre></td></tr></table></figure><p>使用 delete 删除不能回收表空间，而没有被使用的空间，看起来像空洞。实际上插入数据使得页分裂也会造成空洞。</p><h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>使用alter table A engine&#x3D;InnoDB命令来重建表。</p><p>在MySQL 5.5版本之前，</p><ul><li>MySQL会自动新建一个与表A结构相同的表B</li><li>按照主键ID递增的顺序，把数据一行一行地从表A里读出来再插入到表B中。</li><li>表B的主键索引更紧凑，数据页的利用率也更高。但是InnoDB不会把整张表占满，每个页留了1&#x2F;16给后续的更新用。</li><li>把表B作为临时表，数据从表A导入表B的操作完成后，用表B替换A，收缩了表A空间。</li></ul><p>显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表A的话，就会造成数据丢失。因此，在整个DDL过程中，表A中不能有更新。也就是说，这个DDL不是Online的。</p><p>而在<strong>MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。</strong></p><p>这个方案在重建表的过程中，允许对表A做增删改操作。重建表的流程：</p><ol><li>建立一个临时文件，扫描表A主键的所有数据页；</li><li>用数据页中表A的记录生成B+树，存储到临时文件中；</li><li>生成临时文件的过程中，将所有对A的操作记录在一个日志文件（row log）中；</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件；</li><li>用临时文件替换表A的数据文件。</li></ol><blockquote><p>DDL之前是要拿MDL写锁的，这样还能叫Online DDL吗？</p></blockquote><p>alter语句在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。为了实现Online，MDL读锁不会阻塞增删改操作，同时 MDL 读锁可以保护这张表，禁止其他线程对这个表同时做 DDL。</p><p>上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很消耗IO和CPU资源的。因此，如果是线上服务，你要很小心地控制操作时间。如果想要比较安全的操作的话，我推荐你使用GitHub开源的gh-ost来做。</p><h3 id="Online-和-inplace"><a href="#Online-和-inplace" class="headerlink" title="Online 和 inplace"></a>Online 和 inplace</h3><p>根据表A重建出来的数据是放在“tmp_file”里的，这个临时文件是InnoDB在内部创建出来的。整个DDL过程都在InnoDB内部完成。对于server层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。</p><blockquote><p>如果你有一个1TB的表，现在磁盘间是1.2TB，能不能做一个inplace的DDL呢？</p></blockquote><p>不能。因为，tmp_file也是要占用临时空间的。</p><p>重建表的这个语句alter table t engine&#x3D;InnoDB，其实隐含的意思是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t engine<span class="operator">=</span>innodb,ALGORITHM<span class="operator">=</span>inplace;</span><br></pre></td></tr></table></figure><p>跟inplace对应的就是拷贝表的方式了，用法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t engine<span class="operator">=</span>innodb,ALGORITHM<span class="operator">=</span><span class="keyword">copy</span>;</span><br></pre></td></tr></table></figure><p>Online 和 inplace 不是一个概念。如果我要给InnoDB表的一个字段加全文索引，写法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> FULLTEXT(field_name);</span><br></pre></td></tr></table></figure><p>这个过程是inplace的，但会阻塞增删改操作，是非Online的。</p><p>如果说这两个逻辑之间的关系是什么的话，可以概括为：</p><ol><li>DDL过程如果是Online的，就一定是inplace的；</li><li>反过来未必，也就是说inplace的DDL，有可能不是Online的。截止到MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引(SPATIAL index)就属于这种情况。</li></ol><blockquote><p>使用optimize table、analyze table和alter table这三种方式重建表的区别？</p></blockquote><ul><li>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁；</li><li>optimize table t 等于alter table + analyze。</li></ul><h1 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h1><p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。</p><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>ACID，原子性、一致性、隔离性、持久性</p><p><strong>原子性：</strong>事务是原子操作，事务内任何一个 SQL 执行失败，所有已执行成功的 SQL 语句必须撤销。通过 undo log 实现。</p><p><strong>隔离性：</strong>事务操作按照一定粒度隔离，通过 读写锁 + MVCC 来实现。</p><p><strong>一致性：</strong>事务开始之前和结束之后，数据库的完整性约束没有破坏。</p><p><strong>持久性：</strong>一个事务一旦被提交，它对数据库中数据的改变就是永久性的。</p><h2 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h2><table><thead><tr><th align="center">启动事务，查询得到值1</th><th align="center">启动事务</th></tr></thead><tbody><tr><td align="center">事务A</td><td align="center">事务B</td></tr><tr><td align="center"></td><td align="center">查询得到值1</td></tr><tr><td align="center"></td><td align="center">讲1改成2</td></tr><tr><td align="center">查询得到值 V1</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">提交事务B</td></tr><tr><td align="center">查询得到值 V2</td><td align="center"></td></tr><tr><td align="center">提交事务A</td><td align="center"></td></tr><tr><td align="center">查询得到值 V3</td><td align="center"></td></tr></tbody></table><p>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。</p><ul><li><p>若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。</p></li><li><p>若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。</p></li><li><p>若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</p></li><li><p>若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。</p></li></ul><p>配置方式：将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="string">&#x27;transaction_isolation&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"></span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br></pre></td></tr></table></figure><h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p><p>在<strong>“可重复读”</strong>隔离级别下，这个视图是在<strong>事务启动时</strong>创建的，整个事务存在期间都用这个视图。</p><p>在<strong>“读提交”</strong>隔离级别下，这个视图是在<strong>每个SQL语句开始执行</strong>的时候创建的。</p><p>这里需要注意的是，<strong>“读未提交”</strong>隔离级别下直接返回记录上的最新值，<strong>没有视图概念</strong>；</p><p>而<strong>“串行化”</strong>隔离级别下直接用<strong>加锁</strong>的方式来避免并行访问。</p><p>这里提到了“视图”的概念，在MySQL里，有两个视图概念：</p><ul><li>一个是view。它是一个用查询语句定义的虚拟表。语法：create view….</li><li>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持读提交和可重复读的隔离级别的实现。</li></ul><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。（事务隔离级别为“可重复读”）</p><p><img src="https://i0.hdslb.com/bfs/openplatform/dd0fd177fe75dd983f4f2a373dd89888b87ccc62.png" alt="事务隔离实现"></p><p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p><p><em>当系统判断没有事务再需要用到这些回滚日志时，即当系统内没有比这个回滚日志更早的 read-view 的时候，回滚日志会被删除</em></p><h3 id="关于MVCC的理解"><a href="#关于MVCC的理解" class="headerlink" title="关于MVCC的理解"></a>关于MVCC的理解</h3><h4 id="快照在MVCC里是怎么工作的？"><a href="#快照在MVCC里是怎么工作的？" class="headerlink" title="快照在MVCC里是怎么工作的？"></a>快照在MVCC里是怎么工作的？</h4><p><strong>可见性规则：</strong></p><ol><li><p>InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。</p></li><li><p>每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。而对于当前版本之前的版本并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InnoDB 的每一行都会有三个默认隐式字段 row_id, tx_id, roll_point</span><br><span class="line"><span class="number">1.</span>row_id：若表中没有主键，会使用系统的一个默认递增 row_id 作为主键</span><br><span class="line"><span class="number">2.</span>tx_id：事务 id，记录当前操作此记录的事务</span><br><span class="line"><span class="number">3.</span>roll_point：上一个版本对应的 undo log 的指针</span><br></pre></td></tr></table></figure><p>在内部实现中，InnoDB 通过数据行的 <code>row_id </code>和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>roll_point</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前提交的修改和对事务本身做的修改。</p><ol start="3"><li><p>InnoDB 为每个事务构造了一个视图数组，用来保存这个事务启动瞬间，当前正在活跃的所有事务ID。 “活跃”是指，启动了但还没提交。数组中最小的事务id记录为低水位，当前系统创建过的事务id最大值+1 记录为高水位</p></li><li><p>视图数组和高水位，就组成了当前事务的一致性视图 </p></li><li><p>数据版本的可见性规则，就是基于数据的行事务id（ row trx_id） 和一致性视图的对比。对比的结论 就是：一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p></li></ol><ul><li>版本未提交，不可见 </li><li>版本已提交，但是是在视图创建后提交的，不可见 </li><li>版本已提交，而且是在视图创建前提交的，可见</li></ul><p>基于上边提到的可见性规则，在可重复读的隔离级别下，看一个例子。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基于 MySQL 5.7.37</span></span><br><span class="line"><span class="comment">-- 创建表 t、初始化数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">`id` <span class="type">INT</span> ( <span class="number">11</span> ) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`k` <span class="type">INT</span> ( <span class="number">11</span> ) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY ( `id` )) ENGINE <span class="operator">=</span> INNODB;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t ( id, k ) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>),(<span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th><th>事务C</th></tr></thead><tbody><tr><td>1</td><td>start transaction with consistent snapshot;</td><td></td><td></td></tr><tr><td>2</td><td></td><td>start transaction with consistent snapshot;</td><td></td></tr><tr><td>3</td><td></td><td></td><td>update t set k&#x3D;k+1 where id &#x3D; 1;</td></tr><tr><td>4</td><td></td><td>update t set k&#x3D;k+1 where id &#x3D; 1;</td><td></td></tr><tr><td>5</td><td></td><td>select k from t where id &#x3D; 1;</td><td></td></tr><tr><td>6</td><td>select k from t where id &#x3D; 1;</td><td></td><td></td></tr><tr><td>7</td><td>commit;</td><td></td><td></td></tr><tr><td>8</td><td></td><td>commit;</td><td></td></tr></tbody></table><p>假设事务 A,B,C 的事务 id 分别为 100，101，102，三个事务开始之前，id&#x3D;1这行数据的 tx_id &#x3D; 90</p><table><thead><tr><th>时间</th><th>事务A(100)</th><th>事务B(101)</th><th>事务C(102)</th><th>数据版本</th></tr></thead><tbody><tr><td>1</td><td>start transaction with consistent snapshot;<br>视图数组[100]，高水位100</td><td></td><td></td><td>数据版本90（1，1）</td></tr><tr><td>2</td><td></td><td>start transaction with consistent snapshot;<br>视图数组[100，101]，高水位101</td><td></td><td></td></tr><tr><td>3</td><td></td><td></td><td>update t set k&#x3D;k+1 where id &#x3D; 1;<br>视图数组[100，101，102]，高水位102</td><td>数据版本102（1，2）</td></tr><tr><td>4</td><td></td><td>update t set k&#x3D;k+1 where id &#x3D; 1;</td><td></td><td>数据版本101（1，3）</td></tr><tr><td>5</td><td></td><td>select k from t where id &#x3D; 1;</td><td></td><td></td></tr><tr><td>6</td><td>select k from t where id &#x3D; 1;</td><td></td><td></td><td></td></tr><tr><td>7</td><td>commit;</td><td></td><td></td><td></td></tr><tr><td>8</td><td></td><td>commit;</td><td></td><td></td></tr></tbody></table><p>根据可见性规则判断事务A的查询结果：</p><ul><li>(1,3)还没提交，属于情况1，不可见；</li><li>(1,2)虽然提交了，但是是在视图数组创建之后提交的，属于情况2，不可见；</li><li>(1,1)是在视图数组创建之前提交的，可见。</li></ul><blockquote><p>但是关于事务B的update语句，如果按照一致性读，好像不太对？</p><p>事务B的视图是先生成的，之后事务C才提交，不是应该看不见(1,2)吗？它又是怎么算出(1,3)的？</p><p>答案和更新逻辑有关。</p></blockquote><h4 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h4><p>事务B 在更新之前会先查询一次数据，这个查询返回 k 值为 1。</p><p>但是更新数据时，不能再在历史版本上更新了，不然事务 C 会丢失它的更新。因此，事务B<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p><p>“当前读” 实际上是通过加锁实现的。在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是等到事务结束时才释放，这就是两阶段锁协议。</p><p>所以假设事务C没有马上提交，事务B会阻塞直到事务C提交后释放锁，事务B再拿到锁继续执行。</p><p>可重复读的核心就是一致性读，而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p><p>其实，除了 update 语句外，select 语句加上锁，也是当前读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode; # 共享锁 </span><br><span class="line"><span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>; # 排他锁</span><br></pre></td></tr></table></figure><h4 id="MVCC-的好处"><a href="#MVCC-的好处" class="headerlink" title="MVCC 的好处"></a>MVCC 的好处</h4><p>我觉得可以从数据库的三种并发场景来说，<br>第一种是读和读的并发，就是两个线程 A 和 B，同时进行读操作，这时不会产生任何并发问题；<br>第二种是读和写的并发，就是两个线程 A 和 B 分别进行读写操作，这时会对数据库的数据造成以下几个问题：1. 事务隔离性问题 2. 会出现脏读、幻读、不可重复读的问题<br>第三种是写和写的并发，就是两个线程 A 和 B，同时进行写操作，这种情况下可能会出现数据更新丢失问题，而 MVCC 就是为了解决事务操作中并发安全问题的多版本并发控制技术。它是通过数据库记录中的隐式字段、undo 日志和 Read View 实现的。<br>MVCC 主要解决三个问题：</p><ol><li>读写并发阻塞问题，从而提高数据的并发处理能力</li><li>MVCC 采用乐观锁的方式实现，降低了死锁的概率</li><li>解决了一致性读的问题，也就是事务启动时根据某个条件读取到的数据，直到事务结束时再去执行相同的条件，还是读到同一份数据，不会发生变化</li></ol><p>我们在开发过程中主要是根据业务场景使用乐观锁或悲观锁，这两个组合中，MVCC 用来解决读写冲突，乐观锁或悲观锁用来解决写和写的冲突，从而最大程度地提高数据库的并发性能</p><h2 id="事务的启动"><a href="#事务的启动" class="headerlink" title="事务的启动"></a>事务的启动</h2><p>MySQL的事务启动方式有以下几种：</p><ol><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</li><li>set autocommit&#x3D;0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。</li></ol><h4 id="事务启动时机"><a href="#事务启动时机" class="headerlink" title="事务启动时机"></a>事务启动时机</h4><p>begin&#x2F;start transaction命令不是事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句（第一个快照语句），事务才真正启动。</p><p>如果要实现马上启动一个事务，要使用 <strong>start transaction with consistent snapshot</strong> 命令。</p><p><em>读已提交隔离级别下，等同于普通的 start transaction</em></p><h2 id="生产建议-1"><a href="#生产建议-1" class="headerlink" title="生产建议"></a>生产建议</h2><p><strong>尽量不要使用长事务</strong>。</p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><p>在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。</p><p><strong>方法一：</strong></p><p>有些客户端连接框架会默认连接成功后先执行一个set autocommit&#x3D;0的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p><p>因此，建议使用set autocommit&#x3D;1, 通过显式语句的方式来启动事务。</p><p><strong>方法二：</strong></p><p>而对于一个<strong>需要频繁使用事务的业务</strong>，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果想要使用第二种方式并避免长事务的误用，建议使用commit work and chain语法。</p><p>如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p><p>你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(timediff(now(),trx_started))<span class="operator">&gt;</span><span class="number">60</span></span><br></pre></td></tr></table></figure><blockquote><p>你现在知道了系统里面应该避免长事务，如果你是业务开发负责人同时也是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢？</p></blockquote><p><strong>首先，从应用开发端来看：</strong></p><ol><li>确认是否使用了set autocommit&#x3D;0。这个确认工作可以在测试环境中开展，把MySQL的general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。</li><li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用begin&#x2F;commit框起来。我见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务可以去掉。</li><li>业务连接数据库的时候，根据业务本身的预估，通过SET MAX_EXECUTION_TIME命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li></ol><p><strong>其次，从数据库端来看：</strong></p><ol><li>监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警&#x2F;或者kill；</li><li>Percona的pt-kill这个工具不错，推荐使用；</li><li>在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题；</li><li>如果使用的是MySQL 5.6或者更新版本，把innodb_undo_tablespaces设置成2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li></ol><h1 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h1><h2 id="B树：为磁盘而生"><a href="#B树：为磁盘而生" class="headerlink" title="B树：为磁盘而生"></a>B树：为磁盘而生</h2><p>B树也称B-树，是为磁盘等辅存储设备设计的多路平衡查找树，与二叉树相比，B树的每个非叶节点可以有很多个子树。因此，当总节点数量相同时，B树的高度远远小于AVL树和红黑树，磁盘IO大大减少。<br><img src="https://i0.hdslb.com/bfs/openplatform/06afe1afb661287f941cdb21229c20fe7047e7d5.png" alt="Pasted image 20221214231623"><br>B树的优势除了树高小，还有对访问局部性原理的利用。局部性原理是指，当一个数据被使用时，其附近的数据有较大概率在短时间内被使用。B树将键相近的数据存储在同一个节点，当访问其中某个数据时，数据库会将整个节点读到缓存中；当它临近的数据紧接着被访问时，可以直接在缓存中读取，无需进行磁盘IO；换句话说，B树的缓存命中率更高。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><h3 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h3><ul><li>B树中每个节点（包括叶节点和非叶节点）都存储真实的数据，B+树只有叶子节点存储真实的数据，非叶节点只存储键。这里说的真实数据，可能是行的全部数据（如InnoDB的聚簇索引），也可能只是行的主键（如InnoDB的辅助索引），或者是行所在的地址（如MyIsam的非聚簇索引）。</li><li>B树中一条记录只会出现一次，不会重复出现，而B+树的键则可能重复出现——一定会在叶节点出现，也可能在非叶节点重复出现。</li><li>B+树的叶节点之间通过双向链表链接。</li><li>B树中的非叶节点，记录数比子节点个数少1；而B+树中记录数与子节点个数相同</li></ul><h3 id="B-树优势"><a href="#B-树优势" class="headerlink" title="B+树优势"></a>B+树优势</h3><ul><li><strong>更少的IO次数</strong>：B+树的非叶节点只包含键，而不包含真实数据，因此每个节点存储的记录个数比B数多很多（即阶m更大），因此B+树的高度更低，访问时所需要的IO次数更少。此外，由于每个节点存储的记录数更多，所以对局部性原理的利用更好，缓存命中率更高。</li><li><strong>更适用于范围查询</strong>：在B树中进行范围查询时，首先找到要查找的下限，然后对B树进行中序遍历，直到找到查找的上限。而B+树的范围查询，只需要对链表进行遍历即可。</li><li><strong>更稳定的查询效率</strong>：B树的查询时间复杂度在1到树高之间（分别对应记录在根节点和叶节点），而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点。</li></ul><h3 id="B-树效率估算"><a href="#B-树效率估算" class="headerlink" title="B+树效率估算"></a>B+树效率估算</h3><p>对于InnoDB的B+索引来说，树的高度一般在2-4层。（下面是具体的估算，最好理解后记下来）</p><p>树的高度是由阶数决定的，阶数越大树越矮；而阶数大小又取决于每个节点可以存储多少条记录。InnoDB中每个节点使用一个页，页的大小为16KB，其中元数据只占128字节左右（包括文件管理头信息，页面头信息等等），大多数空间都用来存储数据。</p><ul><li>对于非叶节点，记录只包含索引的键和指向下一层节点的指针。假设每个非叶节点页面存储1000条记录，则每条记录大约占用16字节；当索引列是整型或较短的字符串时，这个假设合理。经常有建议说索引列长度不应过大，原因在于：索引列太长，每个节点包含的记录数太少，会导致树太高，索引的效果会大打折扣，而且索引会浪费更多空间。</li><li>对于叶节点，记录包含了索引的键和值（值可能是行的主键、一行完整数据等），数据量更大。这里假设每个叶节点页面存储100条记录（实际上，当索引为聚簇索引时，这个数字可能不足100；当索引为辅助索引时，可能远大于100）。</li></ul><p>对于一棵3层B+树，第一层（根节点）有1个页面，可以存储1000条记录；第二层有1000个页面，可以存储1000×1000条记录；第三层有1000×1000个页面，每个页面存储100条记录，因此可以存储千万条数据。</p><h3 id="不适用其他类型索引原因"><a href="#不适用其他类型索引原因" class="headerlink" title="不适用其他类型索引原因"></a>不适用其他类型索引原因</h3><ul><li><p>哈希表：链表里存储的value不是有序的，区间查询速度慢；</p></li><li><p>二叉查找树：解决了排序的基本问题，但是无法保证平衡，可能退化成链表；</p></li><li><p>平衡二叉树：通过旋转解决了平衡问题，但是旋转操作效率太低；</p></li><li><p>红黑树：通过舍弃严格平衡和引入红黑节点，解决了AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多；</p></li></ul><h2 id="存储引擎的索引类型"><a href="#存储引擎的索引类型" class="headerlink" title="存储引擎的索引类型"></a>存储引擎的索引类型</h2><p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p><h3 id="联合索引的使用"><a href="#联合索引的使用" class="headerlink" title="联合索引的使用"></a>联合索引的使用</h3><p>我们在进行数据库表设计的时候，往往不会使用物理删除，通常会通过一个 is_deleted 字段实现逻辑删除。假设字段 a 需要设置唯一索引，若使用逻辑删除，就不能单独给这个字段a 设置唯一索引了，而应该设置 uq_index(a,is_deleted)。</p><blockquote><p>假设 is_deleted 为 0 为 未删除，当我们要删除其中一条数据时，将该行数据的 is_deleted 设置为1，这样会出现什么问题呢？该怎么解决这个问题？</p></blockquote><p>如果只将 is_deleted 设置为1，那么此时我们再插入一条数据，该数据标识为未删除。再过一会，我们再将这行数据删除，此时就会违反唯一性约束了。</p><p>针对这个问题，有两种解决方案：</p><ul><li>当需要删除时，将 is_deleted 设置为 null，null 是不走索引的，且 MySQL 中的每个 null 值都是不相同的，因此也就不会受到唯一性约束。</li><li>当需要删除该行数据时，将 is_deleted 设置为该行数据的 id，每行数据的 id 值都是一定的，因此也就不会违反唯一性约束了。</li></ul><h3 id="普通索引与唯一索引的选择"><a href="#普通索引与唯一索引的选择" class="headerlink" title="普通索引与唯一索引的选择"></a>普通索引与唯一索引的选择</h3><h4 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h4><p>假设在 k 上建一个索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> T <span class="keyword">where</span> k<span class="operator">=</span><span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k&#x3D;5条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><p>但是这个查找性能差距微乎其微。</p><p>普通索引要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p><p>极端情况下，如果 k &#x3D; 5这条记录刚好是这个数据页最后一个记录，这时可能会需要读取下一个数据页来取下一个记录，这个操作略微复杂。</p><p>但是对于整型字段，一个数据页可以放近千个key，出现这种情况概率较低。</p><h4 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h4><h5 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h5><p>需要更新一个在内存中的数据页时可以直接更新，但是该数据页没在内存中的话，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在 change buffer 中，避免从磁盘读入该数据页。而下次查询需要访问这个数据页时，将数据页读入内存，执行 change buffer 中的相关操作。</p><p>change buffer 是可持久化的数据，在内存中有拷贝，也会写入到磁盘。其使用的内存是 buffer pool 里的内存，因此其不能无限增大。</p><p>change buffer 的大小可以通过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p><p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4,400)这个记录，就要先判断现在表中是否已经存在k&#x3D;4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。</p><p>因此，唯一性约束更新使用不了 change buffer，只有普通索引可以使用。</p><p>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><h5 id="change-buffer-使用场景"><a href="#change-buffer-使用场景" class="headerlink" title="change buffer 使用场景"></a>change buffer 使用场景</h5><ul><li><p>写多读少的业务，如账单类、日志类。change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p></li><li><p>普通索引和change buffer的配合使用，对于数据量大的表的更新优化效果显著。</p></li><li><p>当有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那应该特别关注这些表里的索引，尽量使用普通索引，然后把change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。</p></li></ul><blockquote><p>change buffer一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致change buffer丢失呢？change buffer丢失可不是小事儿，再从磁盘读入数据可就没有了merge过程，就等于是数据丢失了。会不会出现这种情况呢？</p></blockquote><p>1.change buffer 有一部分在内存有一部分在ibdata（系统表空间）<br>做 purge 操作,应该就会把 change buffer 里相应的数据持久化到 ibdata<br>2.redo log 里记录了数据页的修改以及 change buffer 新写入的信息<br>如果掉电,持久化的 change buffer 数据已经 purge , 不用恢复。主要分析没有持久化的数据<br>情况又分为以下几种:<br>(1) change buffer 写入, redo log 虽然做了 fsync 但未 commit ,binlog 未 fsync 到磁盘,这部分数据丢失<br>(2) change buffer 写入, redo log 写入但没有 commit, binlog 以及fsync到磁盘,先从 binlog 恢复 redo log,再从redo log恢复change buffer<br>(3)change buffer写入,redo log和binlog都已经fsync.那么直接从redo log里恢复。</p><blockquote><p>merge的过程是否会把数据直接写回磁盘？</p></blockquote><p>merge的执行流程是这样的：</p><ol><li>从磁盘读入数据页到内存（老版本的数据页）；</li><li>从change buffer里找出这个数据页的change buffer 记录(可能有多个），依次应用，得到新版数据页；</li><li>写redo log。这个redo log包含了数据的变更和change buffer的变更。</li></ol><p>到这里merge过程就结束了。这时候，数据页和内存中change buffer对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。</p><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>假设你现在维护了一个交易系统，其中交易记录表tradelog包含交易流水号（tradeid）、交易员id（operator）、交易时间（t_modified）等字段。为了便于描述，我们先忽略其他字段。这个表的建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tradelog` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `operator` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `t_modified` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`),</span><br><span class="line">  KEY `t_modified` (`t_modified`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>trade_id在数据库中是varchar类型的，看这个全表扫描的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid<span class="operator">=</span><span class="number">110717</span>;</span><br></pre></td></tr></table></figure><p>对于优化器来说，这个语句相当于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span>  <span class="built_in">CAST</span>(tradid <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">110717</span>;</span><br></pre></td></tr></table></figure><p>也就是说，这条语句触发了我们上面说到的规则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p><p>另一个问题是，id的类型是int，如果执行下面这个语句，是否会导致全表扫描呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> id<span class="operator">=</span>&quot;83126&quot;;</span><br></pre></td></tr></table></figure><p>答案是不会，这个语句相当于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> id <span class="operator">=</span> <span class="built_in">CAST</span>(&quot;83126&quot; <span class="keyword">AS</span> signed <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>可以看到这里只是对参数进行了隐式转换，还是会走id这个索引。</p><h4 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h4><p>假设系统有表trade_detail，用于记录交易的操作细节。为了便于量化分析和复现，我往交易日志表tradelog和交易详情表trade_detail这两个表里插入一些数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `trade_detail` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `trade_step` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/*操作步骤*/</span></span><br><span class="line">  `step_info` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/*步骤信息*/</span></span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">6</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">8</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">9</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">11</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这时候，如果要查询id&#x3D;2的交易的所有操作步骤信息，SQL语句可以这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> l.id<span class="operator">=</span><span class="number">2</span>; <span class="comment">/*语句Q1*/</span></span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/ad/22/adfe464af1d15f3261b710a806c0fa22.png" alt="img"></p><ol><li>第一行显示优化器会先在交易记录表tradelog上查到id&#x3D;2的行，这个步骤用上了主键索引，rows&#x3D;1表示只扫描一行；</li><li>第二行key&#x3D;NULL，表示没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫描。</li></ol><p>这个语句的执行流程如下：</p><ul><li>第1步，是根据id在tradelog表里找到L2这一行；</li><li>第2步，是从L2中取出tradeid字段的值；</li><li>第3步，是根据tradeid值到trade_detail表中查找条件匹配的行。explain的结果里面第二行的key&#x3D;NULL表示的就是，这个过程是通过遍历主键索引的方式，一个一个地判断tradeid的值是否匹配</li></ul><p>这里问题出现在第3步，这两个表的字符集不同，一个是utf8，一个是utf8mb4，所以做表连接查询的时候用不上关联字段的索引。</p><p>如果单独把第3步改成 SQL 语句的话，那就是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trade_detail <span class="keyword">where</span> tradeid<span class="operator">=</span>$L2.tradeid.value; </span><br></pre></td></tr></table></figure><p>其中，$L2.tradeid.value的字符集是utf8mb4。</p><p>字符集utf8mb4是utf8的超集，所以当这两个类型的字符串在做比较的时候，MySQL内部的操作是，先把utf8字符串转成utf8mb4字符集，再做比较。</p><p>实际上这个语句等同于下面这个写法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trade_detail  <span class="keyword">where</span> <span class="keyword">CONVERT</span>(traideid <span class="keyword">USING</span> utf8mb4)<span class="operator">=</span>$L2.tradeid.value; </span><br></pre></td></tr></table></figure><p>对索引字段做了函数操作，优化器就放弃了走搜索树功能。</p><blockquote><p>怎么优化这个查询语句呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> l.id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure></blockquote><ul><li>比较常见的优化方法是，把trade_detail表上的tradeid字段的字符集也改成utf8mb4，这样就没有字符集转换的问题了。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> trade_detail modify tradeid <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">default</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><ul><li>如果能够修改字段的字符集的话，是最好不过了。但如果数据量比较大， 或者业务上暂时不能做这个DDL的话，那就只能采用修改SQL语句的方法了。主动把 l.tradeid转成utf8，就避免了被驱动表上的字符编码转换。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l , trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span><span class="keyword">CONVERT</span>(l.tradeid <span class="keyword">USING</span> utf8) <span class="keyword">and</span> l.id<span class="operator">=</span><span class="number">2</span>; </span><br></pre></td></tr></table></figure><h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>B+树为了维护索引有序性，在插入新值时需要做必要的维护。</p><ul><li>假如此时插入的新值是中间值，需要逻辑上挪动后面的数据，空出位置。</li><li>可能会出现<strong>页分裂</strong>：如果当前插入所在的数据页满了，根据B+树的算法，需要申请一个数据页，挪动部分数据过去，影响性能；原本放到一个页的数据，现在分到两个页种，整体空间利用率降低约50%。</li><li><strong>页合并</strong>：当相邻两个页删除了数据，利用率很低后，会将数据页合并。</li></ul><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like &#x27;张%&#x27; and age=10 and ismale=1;</span><br></pre></td></tr></table></figure><p>执行流程：</p><p>首先这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3。</p><p>在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。</p><p>而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。也就是说，MySQL 5.6 以后，会过滤掉 age 不为 10 且 ismale 不为 1 的数据。</p><p>如果要重建索引 k，你的两个SQL语句可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table T drop index k;</span><br><span class="line">alter table T add index(k);</span><br></pre></td></tr></table></figure><p>如果要重建主键索引，也可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table T drop primary key;</span><br><span class="line">alter table T add primary key(id);</span><br></pre></td></tr></table></figure><blockquote><p>我的问题是，对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好的方法是什么？</p></blockquote><p>重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： alter table T engine&#x3D;InnoDB。</p><blockquote><p>为什么要重建索引呢？什么情况下需要重建索引？</p></blockquote><p>索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。</p><h3 id="优化器是怎么选择索引的？"><a href="#优化器是怎么选择索引的？" class="headerlink" title="优化器是怎么选择索引的？"></a>优化器是怎么选择索引的？</h3><p>我们先建一个简单的表，表里有a、b两个字段，并分别建上索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `a` int(11) DEFAULT NULL,</span><br><span class="line">  `b` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE=InnoDB；</span><br></pre></td></tr></table></figure><p>然后，我们往表t中插入10万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到(100000,100000,100000)。</p><p>我是用存储过程来插入数据的，这里我贴出来方便你复现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">100000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><p>接下来，我们分析一条SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;</span><br></pre></td></tr></table></figure><p>使用 explain 来分析这条语句，发现确实是走了 a 索引。</p><p>再做如下操作：</p><table><thead><tr><th>session A</th><th>session B</th></tr></thead><tbody><tr><td>start transaction with consistent snapshot;</td><td></td></tr><tr><td></td><td>delete from t;<br>call idata();</td></tr><tr><td></td><td>explain select * from t where a between 10000 and 20000;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p>session B把数据都删除后，又调用了 idata这个存储过程，插入了10万行数据。这时候 session B 的查询语句就不会选择索引 a 了。</p><p>使用慢查询日志查看具体的执行情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>; <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t force index(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;<span class="comment">/*Q2*/</span></span><br></pre></td></tr></table></figure><ul><li>第一句，是将慢查询日志的阈值设置为0，表示这个线程接下来的语句都会被记录入慢查询日志中；</li><li>第二句，Q1是session B原来的查询；</li><li>第三句，Q2是加了force index(a)来和session B原来的查询语句执行情况对比。</li></ul><p>发现我们没有使用 foece index 的时候，MySQL用错了索引，导致了更长的执行时间。</p><h4 id="优化器逻辑"><a href="#优化器逻辑" class="headerlink" title="优化器逻辑"></a>优化器逻辑</h4><p>优化器会结合扫描行数、是否使用临时表、是否排序等因素综合判断。扫描行数越少，访问磁盘数据次数越少，消耗CPU资源越少。</p><p>使用 explain 分析出 <code>rows</code> 这个字段值下的扫描行数是多少，这个数据是优化器预估的，而非真实的数据。</p><p>优化器不仅会考虑扫描行数，还会考虑回表次数及代价。这个例子中，优化器可能认为直接扫描主键索引更快，但是从执行时间上看，这个选择不是最优的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze <span class="keyword">table</span> t #可以用来重新统计索引信息。</span><br></pre></td></tr></table></figure><p>重新统计完后，就能成功走索引 a 了。</p><p>依然是基于这个表t，我们看看另外一个语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>)  <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>使用索引a 进行查询，就是扫描1000行；而使用索引b 进行查询，就需要扫描50001行。但使用 explain 分析，这次优化器选择了索引b，而 rows 字段显示为 50198。</p><p>原因是，优化器任务使用索引b 可以避免排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 优化方法</span><br><span class="line"># <span class="number">1.</span> force index </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t force index(a) <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>) <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b,a limit <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> <span class="keyword">order</span> <span class="keyword">by</span> b,a</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>) <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b,a limit <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span>limit <span class="number">100</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>)  <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b limit <span class="number">100</span>)alias limit <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">4.</span>在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</span><br></pre></td></tr></table></figure><h3 id="如何给字符串字段添加索引？"><a href="#如何给字符串字段添加索引？" class="headerlink" title="如何给字符串字段添加索引？"></a>如何给字符串字段添加索引？</h3><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>前缀索引可用在给可变字符串定义前缀长度，即节省空间，又不用额外增加太多查询成本。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (column_name(length));</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_list,</span><br><span class="line">    INDEX index_name (column_name(length))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>如何确定应该使用多长的前缀呢？</p></blockquote><p>你可以使用下面这个语句，算出这个列上有多少个不同的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure><p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引，可以用这个语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> </span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>)）<span class="keyword">as</span> L4,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>)）<span class="keyword">as</span> L5,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>)）<span class="keyword">as</span> L6,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>)）<span class="keyword">as</span> L7,</span><br><span class="line"><span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure><p>当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如5%。然后，在返回的L4~L7中，找出不小于 L * 95%的值，假设这里L6、L7都满足，你就可以选择前缀长度为6。</p><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><p>如果遇到前缀的区分度不够好时，应该怎么办呢？</p><p>比如我们国家的身份证号，一共18位，其中前6位是地址码，所以同个县的人的身份证号前6位一般是相同的。但是如果要维护一个市的身份证号，那这个长度就到前12位才能满足区分度要求了。</p><ul><li>倒序存储</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card <span class="operator">=</span> reverse(<span class="string">&#x27;input_id_card_string&#x27;</span>);</span><br></pre></td></tr></table></figure><p>身份证的后6位更容易区分，倒序存储后，再创建长度为6的前缀索引，解决。</p><ul><li>hash 字段。在表上创建一个整数字段，保存身份证的校验码，给这个字段创建索引。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> id_card_crc <span class="type">int</span> unsigned, <span class="keyword">add</span> index(id_card_crc);</span><br></pre></td></tr></table></figure><p>由于校验码可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你的查询语句where部分要判断id_card的值是否精确相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select field_list from t where id_card_crc=crc32(&#x27;input_id_card_string&#x27;) and id_card=&#x27;input_id_card_string&#x27;</span><br></pre></td></tr></table></figure><p>这样，索引的长度变成了4个字节，比原来小了很多。</p><p><strong>使用倒序存储和使用hash字段这两种方法的异同点：</strong></p><p>相同点：不支持范围查询。</p><p>不同点：</p><ol><li>倒序存储方式在主键索引上，不会消耗额外的存储空间。hash字段需要增加一个字段。但是倒序存储很大可能会使用大于4个字节的前缀长度，这个消耗和hash字段差不多抵消。</li><li>倒序方式每次写和读都需要额外调用一次 reverse 函数，而 hash 字段需要额外调用 crc32() 函数。reverse函数额外消耗的 CPU 资源小一点。</li><li>hash字段的查询性能更稳定。虽然 crc32 算出来的值有冲突概率，但是概率较小，每次查询的平均扫描行数接近 1。倒序存储其实还是使用前缀索引方式，还是会增加扫描行数。</li></ol><blockquote><p>如果你在维护一个学校的学生信息数据库，学生登录名的统一格式是”学号@gmail.com”, 而学号的规则是：十五位的数字，其中前三位是所在城市编号、第四到第六位是学校编号、第七位到第十位是入学年份、最后五位是顺序编号。</p><p>系统登录的时候都需要学生输入登录名和密码，验证正确后才能继续使用系统。就只考虑登录验证这个行为的话，你会怎么设计这个登录名的索引呢？</p></blockquote><p><strong>从优化索引空间角度看，</strong></p><p>由于这个学号的规则，无论是正向还是反向的前缀索引，重复度都比较高。因为维护的只是一个学校的，因此前面6位（其中，前三位是所在城市编号、第四到第六位是学校编号）其实是固定的，邮箱后缀都是@gamil.com，因此可以只存入学年份加顺序编号，它们的长度是9位。</p><p>而其实在此基础上，可以用数字类型来存这9位数字。比如201100001，这样只需要占4个字节。其实这个就是一种hash，只是它用了最简单的转换规则：字符串转数字的规则，而刚好我们设定的这个背景，可以保证这个转换后结果的唯一性。</p><p><strong>从业务量预估优化和收益看，</strong></p><p>一个学校每年预估2万新生，50年才100万记录，能节省多少空间，直接全字段索引。省去了开发转换及局限性风险，碰到超大量迫不得已再用后两种办法。</p><h1 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁是对整个数据库实例加锁。</p><p><strong>使用场景：</strong></p><p>做全库逻辑备份，把整库每个表都 select 出来存成文本。</p><p>加全局读锁命令是：Flush tables with read lock (FTWRL)</p><p>FTWRL 执行的时候要刷脏页的数据到磁盘，因为要保持数据的一致性 ，理解的执行 FTWRL 时候是<strong>所有事务都提交完毕</strong>的时候</p><p>在备份过程中整个库完全处于只读状态。</p><ul><li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li><li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟</li></ul><blockquote><p>为什么备份过程中要加锁呢？不加锁会怎样？</p></blockquote><p>不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。</p><p>当存储引擎<strong>支持可重复读的隔离级别</strong>且<strong>当前数据库中的所有表使用事务引擎</strong>，我们可以利用一致性视图进行备份，官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p><blockquote><p><strong>既然要全库只读，为什么不使用set global readonly&#x3D;true的方式呢</strong>？</p></blockquote><ol><li><p>在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，我不建议你使用。</p></li><li><p>全库只读 readonly &#x3D; true 还有个情况在 slave 上 如果用户有超级权限的话 readonly 是失效的</p></li><li><p>在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</p></li></ol><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>使用方法：<strong>lock tables … read&#x2F;write</strong>，使用 unlock tables 主动释放锁，或者在客户端断开时自动释放。</p><p>但 lock tables 除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p><h3 id="MDL"><a href="#MDL" class="headerlink" title="MDL"></a>MDL</h3><p>不需要显式使用，在访问一个表时会自动加上。</p><p>在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p><ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><p>MySQL 5.6 支持 online ddl,对表字段的修改不会阻塞读写（事实上是近似的online，仍有极少时间阻塞）。online ddl的过程：</p><ul><li>获取 MDL 写锁(短暂阻塞，这里获取写锁再降级是为了防止并发表结构修改)</li><li>降级成 MDL 读锁</li><li>真正做 DDL（可以理解为prepare状态的）</li><li>升级成 MDL 写锁（短暂阻塞，将DDL操作提交）</li><li>释放 MDL 锁</li></ul><p><em>注意，大多数的 ddl 都支持 online，但也有不支持的，如：添加全文索引，空间索引</em></p><blockquote><p>给一个小表加个字段，导致整个库挂了，这是出了什么问题？</p></blockquote><p>申请MDL锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。</p><blockquote><p>如何安全地给小表加字段？</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># MariaDB 和 AliSQL 支持</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name NOWAIT <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name WAIT N <span class="keyword">add</span> <span class="keyword">column</span> ... </span><br></pre></td></tr></table></figure><blockquote><p>备份一般都会在备库上执行，你在用–single-transaction方法做逻辑备份的过程中，如果主库上的一个小表做了一个DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？</p></blockquote><p>假设这个DDL是针对表t1的， 这里我把备份过程中几个关键的语句列出来：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Q1:<span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">Q2:<span class="keyword">START</span> TRANSACTION  <span class="keyword">WITH</span> CONSISTENT SNAPSHOT；</span><br><span class="line"><span class="comment">/* other tables */</span></span><br><span class="line">Q3:<span class="keyword">SAVEPOINT</span> sp;</span><br><span class="line"><span class="comment">/* 时刻 1 */</span></span><br><span class="line">Q4:<span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> `t1`;</span><br><span class="line"><span class="comment">/* 时刻 2 */</span></span><br><span class="line">Q5:<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `t1`;</span><br><span class="line"><span class="comment">/* 时刻 3 */</span></span><br><span class="line">Q6:<span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> sp;</span><br><span class="line"><span class="comment">/* 时刻 4 */</span></span><br><span class="line"><span class="comment">/* other tables */</span></span><br></pre></td></tr></table></figure><p>在备份开始的时候，为了确保RR（可重复读）隔离级别，再设置一次RR隔离级别(Q1);</p><p>启动事务，这里用 WITH CONSISTENT SNAPSHOT确保这个语句执行完就可以得到一个一致性视图（Q2)；</p><p>设置一个保存点，这个很重要（Q3）；</p><p>show create 是为了拿到表结构(Q4)，然后正式导数据 （Q5），回滚到SAVEPOINT sp，在这里的作用是释放 t1的MDL锁 （Q6。当然这部分属于“超纲”，上文正文里面都没提到。</p><p>DDL从主库传过来的时间按照效果不同，我打了四个时刻。题目设定为小表，我们假定到达后，如果开始执行，则很快能够执行完成。</p><p>参考答案如下：</p><ol><li>如果在Q4语句执行之前到达，现象：没有影响，备份拿到的是DDL后的表结构。</li><li>如果在“时刻 2”到达，则表结构被改过，Q5执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump终止；</li><li>如果在“时刻2”和“时刻3”之间到达，mysqldump占着t1的MDL读锁，binlog被阻塞，现象：主从延迟，直到Q6执行完成。</li><li>从“时刻4”开始，mysqldump释放了MDL读锁，现象：没有影响，备份拿到的是DDL前的表结构。</li></ol><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>MySQL的行锁是在引擎层由各个引擎自己实现的。</p><p>但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。</p><h3 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h3><p>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p><p>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p><p>当出现死锁以后，有两种策略：</p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</li><li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</li></ul><p>第一种方法的默认等待时间为50s，这个时间对于某些在线服务是无法接受的，但是又不能将其设置为很小的值，如果不是死锁而是正常的锁等待的话，会出现误伤。</p><p>正常情况下，我们使用第二组策略。</p><p>当所有事务都要更新同一行，每个被堵住的线程都要判断一次是否由于自己的加入导致了死锁。假设有1000个并发线程需要同时更新同一行，那么死锁检测的操作是100万这个量级的，这期间需要耗费大量的CPU资源。</p><blockquote><p>如何解决由这种热点行更新导致的性能问题？</p></blockquote><ol><li>确保这个业务不出现死锁，可以临时把死锁检测关掉。（有风险，不采用）</li><li>控制并发度。利用中间件控制流量，对于相同行的更新，在进入数据库前排队。</li><li>将热点行数据拆分成逻辑上的多行来减少锁冲突，但业务逻辑复杂。</li></ol><blockquote><p>如果你要删除一个表里面的前10000行数据，有以下三种方法可以做到：</p><ul><li>第一种，直接执行delete from T limit 10000;</li><li>第二种，在一个连接中循环执行20次 delete from T limit 500;</li><li>第三种，在20个连接中同时执行delete from T limit 500</li></ul><p>哪一种方法最好？说说理由。</p></blockquote><p>第二种方式是相对较好的。</p><p>第一种方式（即：直接执行delete from T limit 10000）里面，单个语句占用时间长，锁的时间也比较长；而且大事务还会导致主从延迟。</p><p>第三种方式（即：在20个连接中同时执行delete from T limit 500），会人为造成锁冲突。</p><h2 id="Next-key-Lock"><a href="#Next-key-Lock" class="headerlink" title="Next-key Lock"></a>Next-key Lock</h2><p>间隙锁，锁的就是两个值之间的空隙。<strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。</strong></p><p>间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。也就是说，我们的表t初始化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +suprenum]。</p><blockquote><p>备注：这篇文章中，如果没有特别说明，我们把间隙锁记为开区间，把next-key lock记为前开后闭区间。</p></blockquote><p>这个suprenum是InnoDB给每个索引加了一个不存在的最大值suprenum，为了保证next-key lock的前开后闭区间。</p><h3 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h3><p><em>此规则适用于5.x系列&lt;&#x3D;5.7.24，8.0系列 &lt;&#x3D;8.0.13</em></p><ol><li>原则1：加锁基本单位是 next-key lock。前开后闭区间。（但是具体执行时，会分成间隙锁和行锁两段来执行）</li><li>原则2：查找过程中访问到的对象才会加锁</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><p>来看一个例子理解以上规则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><h4 id="案例一：等值查询间隙锁"><a href="#案例一：等值查询间隙锁" class="headerlink" title="案例一：等值查询间隙锁"></a>案例一：等值查询间隙锁</h4><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;<br>update t set d &#x3D; d+1 where id &#x3D; 7;</td><td></td><td></td></tr><tr><td></td><td>insert into t values(8,8,8);<br>(blocked)</td><td></td></tr><tr><td></td><td></td><td>update t set d &#x3D; d+1 where id &#x3D; 10;<br>(Query OK)</td></tr></tbody></table><p>由于表t中没有id&#x3D;7的记录，所以用我们上面提到的加锁规则判断一下的话：</p><ol><li>加锁单位是next-key lock，session A加锁范围就是(5,10]；</li><li>这是一个等值查询(id&#x3D;7)，而id&#x3D;10不满足查询条件，next-key lock退化成间隙锁，因此最终加锁的范围是(5,10)。</li></ol><h4 id="案例二：非唯一索引等值锁"><a href="#案例二：非唯一索引等值锁" class="headerlink" title="案例二：非唯一索引等值锁"></a>案例二：非唯一索引等值锁</h4><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;<br>select id from t where c &#x3D; 5 lock in share mode;</td><td></td><td></td></tr><tr><td></td><td>update t set d &#x3D; d+1 where id &#x3D; 5;<br>(Query OK)</td><td></td></tr><tr><td></td><td></td><td>insert into t values(7,7,7);<br>(blocked)</td></tr></tbody></table><p>这里session A要给索引c上c&#x3D;5的这一行加上读锁。</p><ol><li>根据原则1，加锁单位是next-key lock，因此会给(0,5]加上next-key lock。</li><li>要注意c是普通索引，因此仅访问c&#x3D;5这一条记录是不能马上停下来的，需要向右遍历，查到c&#x3D;10才放弃。根据原则2，访问到的都要加锁，因此要给(5,10]加next-key lock。</li><li>但是同时这个符合优化2：等值判断，向右遍历，最后一个值不满足c&#x3D;5这个等值条件，因此退化成间隙锁(5,10)。</li><li>根据原则2 ，<strong>只有访问到的对象才会加锁</strong>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么session B的update语句可以执行完成。</li></ol><p>但session C要插入一个(7,7,7)的记录，就会被session A的间隙锁(5,10)锁住。</p><p>lock in share mode只锁覆盖索引， for update会给主键索引上满足条件的行加上行锁。锁是加在索引上的，如果你要用lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将session A的查询语句改成select d from t where c&#x3D;5 lock in share mode。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><p>在查找c&#x3D;5的时候，先锁住了(0,5]。但是因为c不是唯一索引，为了确认还有没有别的记录c&#x3D;5，就要向右遍历，找到c&#x3D;10才确认没有了，这个过程满足优化2，所以加了间隙锁(5,10)。</p><p>同样的，执行c&#x3D;10这个逻辑的时候，加锁的范围是(5,10] 和 (10,15)；执行c&#x3D;20这个逻辑的时候，加锁的范围是(15,20] 和 (20,25)。</p><p>通过这个分析，我们可以知道，这条语句在索引c上加的三个记录锁的顺序是：先加c&#x3D;5的记录锁，再加c&#x3D;10的记录锁，最后加c&#x3D;20的记录锁。</p><p>这些锁是“在执行过程中一个一个加的”，而不是一次性加上去的。</p><h4 id="案例三：主键索引范围锁"><a href="#案例三：主键索引范围锁" class="headerlink" title="案例三：主键索引范围锁"></a>案例三：主键索引范围锁</h4><p>对于我们这个表t，下面这两条查询语句，加锁范围相同吗？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">11</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>语句2：</p><ol><li>开始执行的时候，要找到第一个id&#x3D;10的行，因此本该是next-key lock(5,10]。 根据优化1， 主键id上的等值条件，退化成行锁，只加了id&#x3D;10这一行的行锁。</li><li>范围查找就往后继续找，找到id&#x3D;15这一行停下来，因此需要加next-key lock(10,15]</li></ol><p>分析一下这条查询语句的加锁范围：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">9</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">12</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>利用上面的加锁规则，我们知道这个语句的加锁范围是主键索引上的 (0,5]、(5,10]和(10, 15)。</p><ol><li>首先这个查询语句的语义是order by id desc，要拿到满足条件的所有行，优化器必须先找到“第一个id&lt;12的值”。</li><li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到id&#x3D;12的这个值，只是最终没找到，但找到了(10,15)这个间隙。</li><li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到id&#x3D;5这一行，所以会加一个next-key lock (0,5]。</li></ol><p>也就是说，在执行过程中，通过树搜索的方式定位记录的时候，用的是“等值查询”的方法。</p><h4 id="案例四：非唯一索引范围锁"><a href="#案例四：非唯一索引范围锁" class="headerlink" title="案例四：非唯一索引范围锁"></a>案例四：非唯一索引范围锁</h4><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;<br>select * from t where c&gt;&#x3D;10 and c&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>insert into t values(8,8,8);<br>(blocked)</td><td></td></tr><tr><td></td><td></td><td>update t set d &#x3D; d+1 where c &#x3D; 15;<br>(blocked)</td></tr></tbody></table><p>在第一次用c&#x3D;10定位记录的时候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终sesion A加的锁是，索引c上的(5,10] 和(10,15] 这两个next-key lock。</p><p>这里需要扫描到c&#x3D;15才停止扫描，是合理的，因为InnoDB要扫到c&#x3D;15，才知道不需要继续往后找了。</p><h4 id="案例五：唯一索引范围锁bug"><a href="#案例五：唯一索引范围锁bug" class="headerlink" title="案例五：唯一索引范围锁bug"></a>案例五：唯一索引范围锁bug</h4><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;<br>select * from t where id&gt;10 and id&lt;&#x3D;15 for update;</td><td></td><td></td></tr><tr><td></td><td>update t set d &#x3D; d+1 where id &#x3D; 20;<br>(blocked)</td><td></td></tr><tr><td></td><td></td><td>insert into t values(16,16,16);<br>(blocked)</td></tr></tbody></table><p>session A是一个范围查询，按照原则1的话，应该是索引id上只加(10,15]这个next-key lock，并且因为id是唯一键，所以循环判断到id&#x3D;15这一行就应该停止了。</p><p>但是实现上，InnoDB会往前扫描到第一个不满足条件的行为止，也就是id&#x3D;20。而且由于这是个范围扫描，因此索引id上的(15,20]这个next-key lock也会被锁上。</p><h4 id="案例六·：limit语句加锁"><a href="#案例六·：limit语句加锁" class="headerlink" title="案例六·：limit语句加锁"></a>案例六·：limit语句加锁</h4><p>limit 语句可以判断满足条件的语句有n条，然后直接返回，不会走到判断最后一个值不满足等值条件。</p><p><strong>在删除数据的时候尽量加limit</strong>。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围</p><blockquote><p>&lt;&#x3D;到底是间隙锁还是行锁？</p></blockquote><p>其实，这个问题，你要跟“执行过程”配合起来分析。在InnoDB要去找“第一个值”的时候，是按照等值去找的，用的是等值判断的规则；找到第一个值以后，要在索引内找“下一个值”，对应于我们规则中说的范围查找。</p><blockquote><p>所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义的。</p><p>那么，一个空表有间隙吗？这个间隙是由谁定义的？你怎么验证这个结论呢？</p></blockquote><p>一个空表就只有一个间隙。比如，在空表上执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>这个查询语句加锁的范围就是next-key lock (-∞, supremum]。</p><h3 id="MVCC➕Next-key-Lock-防止幻读"><a href="#MVCC➕Next-key-Lock-防止幻读" class="headerlink" title="MVCC➕Next-key-Lock 防止幻读"></a>MVCC➕Next-key-Lock 防止幻读</h3><p><code>InnoDB</code> 存储引擎在 RR 级别下通过 <code>MVCC</code> 和 <code>Next-key Lock</code> 来解决幻读问题：</p><p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p><p><strong>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读</strong></p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks">Next-key Lock</a> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p><h3 id="解决幻读的方法"><a href="#解决幻读的方法" class="headerlink" title="解决幻读的方法"></a>解决幻读的方法</h3><p>解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。解决幻读的方式主要有以下几种：</p><ol><li>将事务隔离级别调整为 <code>SERIALIZABLE</code> 。</li><li>在可重复读的事务级别下，给事务操作的这张表添加表锁。</li><li>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-key Lock（Record Lock+Gap Lock）</code>。</li></ol><h2 id="业务设计问题"><a href="#业务设计问题" class="headerlink" title="业务设计问题"></a>业务设计问题</h2><blockquote><p>业务上有这样的需求，A、B两个用户，如果互相关注，则成为好友。设计上是有两张表，一个是like表，一个是friend表，like表有user_id、liker_id两个字段，我设置为复合唯一索引即uk_user_id_liker_id。语句执行逻辑是这样的：</p></blockquote><blockquote><p>以A关注B为例：<br>第一步，先查询对方有没有关注自己（B有没有关注A）<br>select * from like where user_id &#x3D; B and liker_id &#x3D; A;</p></blockquote><blockquote><p>如果有，则成为好友<br>insert into friend;</p></blockquote><blockquote><p>没有，则只是单向关注关系<br>insert into like;</p></blockquote><blockquote><p>但是如果A、B同时关注对方，会出现不会成为好友的情况。因为上面第1步，双方都没关注对方。第1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效。请问这种情况，在MySQL锁层面有没有办法处理？</p></blockquote><p>先根据上边的场景建两张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">like</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `liker_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_user_id_liker_id` (`user_id`,`liker_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `friend` (</span><br><span class="line">  id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `friend_1_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `firned_2_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_friend` (`friend_1_id`,`firned_2_id`)</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><table><thead><tr><th>session 1(A关注B)</th><th>session 2(B关注A)</th></tr></thead><tbody><tr><td>begin;<br>select * from <code>like</code> where user_id &#x3D; B and liker_id &#x3D; A;（返回空）</td><td></td></tr><tr><td></td><td>begin;<br>select * from <code>like</code> where user_id &#x3D; A and liker_id &#x3D; B;（返回空）</td></tr><tr><td></td><td>insert into <code>like</code>(user_id,liker_id) values(B,A);</td></tr><tr><td>insert into <code>like</code>(user_id,liker_id) values(A,B);</td><td></td></tr><tr><td>commit;</td><td></td></tr><tr><td></td><td>commit;</td></tr></tbody></table><p>也就是说，在并发情况下，A和B在查询对方有没有关注自己的时候 select 语句查出来的结果为空，因此，session 1的逻辑就是“既然B没有关注A，那就只插入一个单向关注关系”。session 2也同样是这个逻辑。</p><p>解决方法如下：</p><p>首先，要给“like”表增加一个字段，比如叫作 relation_ship，并设为整型，取值1、2、3。</p><blockquote><p>值是1的时候，表示user_id 关注 liker_id;<br>值是2的时候，表示liker_id 关注 user_id;<br>值是3的时候，表示互相关注。</p></blockquote><p>然后，当 A关注B的时候，逻辑改成如下所示的样子：</p><p>应用代码里面，比较A和B的大小，如果A&lt;B，就执行下面的逻辑</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>; <span class="comment">/*启动事务*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `<span class="keyword">like</span>`(user_id, liker_id, relation_ship) <span class="keyword">values</span>(A, B, <span class="number">1</span>) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> relation_ship<span class="operator">=</span>relation_ship <span class="operator">|</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> relation_ship <span class="keyword">from</span> `<span class="keyword">like</span>` <span class="keyword">where</span> user_id<span class="operator">=</span>A <span class="keyword">and</span> liker_id<span class="operator">=</span>B;</span><br><span class="line"><span class="comment">/*代码中判断返回的 relation_ship，</span></span><br><span class="line"><span class="comment">  如果是1，事务结束，执行 commit</span></span><br><span class="line"><span class="comment">  如果是3，则执行下面这两个语句：</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">insert</span> ignore <span class="keyword">into</span> friend(friend_1_id, friend_2_id) <span class="keyword">values</span>(A,B);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>如果A&gt;B，则执行下面的逻辑</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>; <span class="comment">/*启动事务*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `<span class="keyword">like</span>`(user_id, liker_id, relation_ship) <span class="keyword">values</span>(B, A, <span class="number">2</span>) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> relation_ship<span class="operator">=</span>relation_ship <span class="operator">|</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> relation_ship <span class="keyword">from</span> `<span class="keyword">like</span>` <span class="keyword">where</span> user_id<span class="operator">=</span>B <span class="keyword">and</span> liker_id<span class="operator">=</span>A;</span><br><span class="line"><span class="comment">/*代码中判断返回的 relation_ship，</span></span><br><span class="line"><span class="comment">  如果是2，事务结束，执行 commit</span></span><br><span class="line"><span class="comment">  如果是3，则执行下面这两个语句：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">insert</span> ignore <span class="keyword">into</span> friend(friend_1_id, friend_2_id) <span class="keyword">values</span>(B,A);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>这个设计里，让“like”表里的数据保证user_id &lt; liker_id，这样不论是A关注B，还是B关注A，在操作“like”表的时候，如果反向的关系已经存在，就会出现行锁冲突。</p><p>然后，insert … on duplicate语句，确保了在事务内部，执行了这个SQL语句后，就强行占住了这个行锁，之后的select 判断relation_ship这个逻辑时就确保了是在行锁保护下的读操作。</p><p>操作符 “|” 是按位或，连同最后一句insert语句里的ignore，是为了保证重复调用时的幂等性。</p><p>这样，即使在双方“同时”执行关注操作，最终数据库里的结果，也是like表里面有一条关于A和B的记录，而且relation_ship的值是3， 并且friend表里面也有了A和B的这条记录。</p><blockquote><p>这里提到了insert … on duplicate语句，但是这个语句可能会造成 death lock 问题。</p></blockquote><p>如果有两个事务并发的执行同样的语句，那么就会产生death lock，如：</p><table><thead><tr><th>时间</th><th>session 1</th><th>session 2</th></tr></thead><tbody><tr><td>T1</td><td>begin;<br>insert on duplicate key</td><td></td></tr><tr><td>T2</td><td>key已存在，获取该记录的S锁</td><td>begin;<br>insert on duplicate key</td></tr><tr><td>T3</td><td>对读取的记录进行修改</td><td>key已存在，获取该记录的S锁</td></tr><tr><td>T4</td><td></td><td>对读取的记录进行修改</td></tr><tr><td>T5</td><td>把修改写入存储引擎，给该记录加上 X 锁，session2存在 S 锁，等待 session2 释放 S 锁</td><td></td></tr><tr><td>T6</td><td></td><td>把修改写进存储引擎，给该记录加上 X 锁，session1 存在 S 锁，等待 session1 释放 S 锁</td></tr><tr><td>T7</td><td></td><td>死锁</td></tr></tbody></table><p>那么，再来看看为什么上面的方法不会存在死锁问题呢？</p><p>原因是加入了 relation_ship 这个字段，在并发情况下 insert 的时候，实际上 insert 的是不同行。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对设计模式的理解</title>
      <link href="/2023/11/20/%E5%AF%B9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/11/20/%E5%AF%B9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><em>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。同时设计模式也是软件开发人员在软件开发过程中面临的一般问题的解决方案。</em></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式主要是会定义一系列的算法或策略，其中的算法和策略都是独立封装，互不影响的。通过策略模式，可以在运行时选择不同的策略进行匹配，而不需要修改客户端的代码。</p><p>我们可以参考 xxl-job 里的路由策略编写逻辑，其中的路由策略就是一个标准的策略模式例子。现给出 xxl-job 的路由策略结构图。</p><p><img src="https://i0.hdslb.com/bfs/openplatform/caeece2f078e49ecf144911636ea9cc94da88a1f.png" alt="xxl-job策略模式结构图"></p><p>同时观察 xxl-job 的源码，XxlJobTrigger 中的 processTrigger() 方法中有一段关于路由策略的逻辑</p><ol><li>根据传入的 jobInfo 获取到路由策略的参数</li><li>如果是分片广播，则for循环调用外部传入的index获取执行器地址并调用执行器。</li><li>反之根据参数获取路由策略调用获取对应地址并调用即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processTrigger</span><span class="params">(XxlJobGroup group, XxlJobInfo jobInfo, <span class="type">int</span> finalFailRetryCount, TriggerTypeEnum triggerType, <span class="type">int</span> index, <span class="type">int</span> total)</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// param</span></span><br><span class="line">       <span class="type">ExecutorBlockStrategyEnum</span> <span class="variable">blockStrategy</span> <span class="operator">=</span> ExecutorBlockStrategyEnum.match(jobInfo.getExecutorBlockStrategy(), ExecutorBlockStrategyEnum.SERIAL_EXECUTION);  <span class="comment">// block strategy</span></span><br><span class="line">       <span class="type">ExecutorRouteStrategyEnum</span> <span class="variable">executorRouteStrategyEnum</span> <span class="operator">=</span> ExecutorRouteStrategyEnum.match(jobInfo.getExecutorRouteStrategy(), <span class="literal">null</span>);    <span class="comment">// route strategy</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shardingParam</span> <span class="operator">=</span> (ExecutorRouteStrategyEnum.SHARDING_BROADCAST==executorRouteStrategyEnum)?String.valueOf(index).concat(<span class="string">&quot;/&quot;</span>).concat(String.valueOf(total)):<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1、save log-id</span></span><br><span class="line">       <span class="type">XxlJobLog</span> <span class="variable">jobLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobLog</span>();</span><br><span class="line">       jobLog.setJobGroup(jobInfo.getJobGroup());</span><br><span class="line">       jobLog.setJobId(jobInfo.getId());</span><br><span class="line">       jobLog.setTriggerTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">       XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().save(jobLog);</span><br><span class="line">       logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job trigger start, jobId:&#123;&#125;&quot;</span>, jobLog.getId());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2、init trigger-param</span></span><br><span class="line">       <span class="type">TriggerParam</span> <span class="variable">triggerParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TriggerParam</span>();</span><br><span class="line">       triggerParam.setJobId(jobInfo.getId());</span><br><span class="line">       triggerParam.setExecutorHandler(jobInfo.getExecutorHandler());</span><br><span class="line">       triggerParam.setExecutorParams(jobInfo.getExecutorParam());</span><br><span class="line">       triggerParam.setExecutorBlockStrategy(jobInfo.getExecutorBlockStrategy());</span><br><span class="line">       triggerParam.setExecutorTimeout(jobInfo.getExecutorTimeout());</span><br><span class="line">       triggerParam.setLogId(jobLog.getId());</span><br><span class="line">       triggerParam.setLogDateTime(jobLog.getTriggerTime().getTime());</span><br><span class="line">       triggerParam.setGlueType(jobInfo.getGlueType());</span><br><span class="line">       triggerParam.setGlueSource(jobInfo.getGlueSource());</span><br><span class="line">       triggerParam.setGlueUpdatetime(jobInfo.getGlueUpdatetime().getTime());</span><br><span class="line">       triggerParam.setBroadcastIndex(index);</span><br><span class="line">       triggerParam.setBroadcastTotal(total);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3、init address</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       ReturnT&lt;String&gt; routeAddressResult = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (group.getRegistryList()!=<span class="literal">null</span> &amp;&amp; !group.getRegistryList().isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (ExecutorRouteStrategyEnum.SHARDING_BROADCAST == executorRouteStrategyEnum) &#123;</span><br><span class="line">               <span class="keyword">if</span> (index &lt; group.getRegistryList().size()) &#123;</span><br><span class="line">                   address = group.getRegistryList().get(index);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   address = group.getRegistryList().get(<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               routeAddressResult = executorRouteStrategyEnum.getRouter().route(triggerParam, group.getRegistryList());</span><br><span class="line">               <span class="keyword">if</span> (routeAddressResult.getCode() == ReturnT.SUCCESS_CODE) &#123;</span><br><span class="line">                   address = routeAddressResult.getContent();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           routeAddressResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, I18nUtil.getString(<span class="string">&quot;jobconf_trigger_address_empty&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4、trigger remote executor</span></span><br><span class="line">       ReturnT&lt;String&gt; triggerResult = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (address != <span class="literal">null</span>) &#123;</span><br><span class="line">           triggerResult = runExecutor(triggerParam, address);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           triggerResult = <span class="keyword">new</span> <span class="title class_">ReturnT</span>&lt;String&gt;(ReturnT.FAIL_CODE, <span class="literal">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码中有一个地方是用来定位到该任务的路由策略的，其中 ExecutorRouteStrategyEnum 就是一个切入点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">routeAddressResult = executorRouteStrategyEnum.getRouter().route(triggerParam, group.getRegistryList());</span><br></pre></td></tr></table></figure><p>在 ExecutorRouteStrategyEnum 这个枚举类里枚举了 xxl-job 目前的策略名称，还有一个 match() 方法通过策略名称进行匹配，找到该策略所对应的 route() 方法执行相应的路由策略逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorRouteStrategyEnum <span class="title function_">match</span><span class="params">(String name, ExecutorRouteStrategyEnum defaultItem)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (ExecutorRouteStrategyEnum item: ExecutorRouteStrategyEnum.values()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (item.name().equals(name)) &#123;</span><br><span class="line">                   <span class="keyword">return</span> item;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> defaultItem;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="策略模式的优势"><a href="#策略模式的优势" class="headerlink" title="策略模式的优势"></a>策略模式的优势</h3><ul><li><p>策略模式中定义了一个公共的抽象类，每个策略都可以通过重写抽象类中的方法实现其算法逻辑。</p></li><li><p>可以以相同的方式调用所有策略，减少了各种策略类与使用策略之间的耦合。</p></li><li><p>策略都是相对独立的类，策略之间互不影响，可以随业务需求拓展，简化了单元测试。</p></li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式提供了一种将对象的实例化过程封装在工厂类中的方式。通过使用工厂模式，可以将对象的创建与使用代码分离，提供一种统一的接口来创建不同类型的对象。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>现有一个需求，要求对前端传进来的参数做校验，并组装这些参数供后续使用，每次传过来的参数根据规则不同有增减。这个需求可以用工厂模式实现，我们不关心不同的参数如何校验和组装，只想要接收前端传来的参数，最终以它想要的形式返回回去。</p><p>现给出使用工厂模式实现该需求的结构图：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/818a92da719d836dfb450faaadc6fc996f6519b8.png" alt="rpa业务策略结构图"></p><p>基于工厂模式，创建一个策略接口，用于规范化策略的实现。</p><p>定义策略工厂类，用于创建并获取策略。</p><p>导入任务时，向业务策略工厂类传递业务策略类别，获取并执行相应的业务策略，最后组装并返回任务字段信息。</p><h3 id="工厂模式和策略模式的区别"><a href="#工厂模式和策略模式的区别" class="headerlink" title="工厂模式和策略模式的区别"></a>工厂模式和策略模式的区别</h3><p>工厂模式关注的是<em>对象的创建</em>：好比想要一台电脑、想要一台计算器，工厂给你生产出来。</p><p>策略模式关注的是<em>行为的封装</em>：好比要开发一台电脑或者计算器，你想实现加减法。是 a+b 还是 b+a，由你决定；是 a×10÷10+b 还是 (a+b)，也由你决定。对外暴露的就是加减功能，用户能知道有这俩功能就行。</p><h3 id="工厂模式的优势"><a href="#工厂模式的优势" class="headerlink" title="工厂模式的优势"></a>工厂模式的优势</h3><ul><li>对于复杂的参数的构造对象，可以很好地对外层屏蔽代码的复杂性。</li><li>可以自定义对象实例化规则，例如在对象存在某个字段时做特殊操作，在工厂中统一处理。</li><li>上层代码完全不了解实现层的情况，因此并不会影响到上层代码的调用，达到解耦目的。</li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是为其他对象提供一种代理以控制对这个对象的访问。</p><p>现给出代理模式的结构图：</p><p><img src="https://i0.hdslb.com/bfs/openplatform/1516ee4ea3fbdf4b33425952dc311fcafe55e2d8.png" alt="代理模式结构图"></p><h3 id="代理模式的简单实现"><a href="#代理模式的简单实现" class="headerlink" title="代理模式的简单实现"></a>代理模式的简单实现</h3><p>代理模式分为静态代理和动态代理。</p><ul><li>静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。</li><li>动态：在程序运行时，运用反射机制动态创建而成</li></ul><p><strong>静态代理:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DateService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">del</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DateServiceImplA</span> <span class="keyword">implements</span> <span class="title class_">DateService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功添加！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功删除！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DateServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">DateService</span> &#123;</span><br><span class="line">    DateService server;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DateServiceProxy</span><span class="params">(DateService server)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.server = server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        server.add();</span><br><span class="line">        System.out.println(<span class="string">&quot;程序执行add方法，记录日志.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">()</span> &#123;</span><br><span class="line">        server.del();</span><br><span class="line">        System.out.println(<span class="string">&quot;程序执行del方法，记录日志.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DateService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateServiceProxy</span>();</span><br><span class="line">        service.add();</span><br><span class="line">        service.del();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态代理：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DateService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">del</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DateServiceImplA</span> <span class="keyword">implements</span> <span class="title class_">DateService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功添加！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功删除！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DateService service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyInvocationHandler</span><span class="params">(DateService service)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getDateServiceProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(), service.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(service, args); <span class="comment">// 让service调用方法，方法返回值</span></span><br><span class="line">        System.out.println(proxy.getClass().getName() + <span class="string">&quot;代理类执行&quot;</span> + method.getName() + <span class="string">&quot;方法，返回&quot;</span> + result +  <span class="string">&quot;，记录日志！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DateService</span> <span class="variable">serviceA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateServiceImplA</span>();</span><br><span class="line">        <span class="type">DateService</span> <span class="variable">serviceProxy</span> <span class="operator">=</span> (DateService) <span class="keyword">new</span> <span class="title class_">ProxyInvocationHandler</span>(serviceA).getDateServiceProxy();</span><br><span class="line">        serviceProxy.add();</span><br><span class="line">        serviceProxy.del();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功添加！</span></span><br><span class="line"><span class="comment">$Proxy0代理类执行add方法，返回null，记录日志！</span></span><br><span class="line"><span class="comment">成功删除！</span></span><br><span class="line"><span class="comment">$Proxy0代理类执行del方法，返回null，记录日志！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我之前曾经写过一个手写缓存的项目，在自己创建一个缓存结构的时候，实现了Spring动态代理</p><p>生成缓存测试入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">expireTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       ICache&lt;String, String&gt; cache = CacheBs.&lt;String, String&gt;newInstance()</span><br><span class="line">               .size(<span class="number">3</span>)</span><br><span class="line">               .build();</span><br><span class="line">       cache.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       cache.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>自定义的缓存类CacheBs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ICache&lt;K,V&gt; <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">       Cache&lt;K, V&gt; cache = <span class="keyword">new</span> <span class="title class_">Cache</span>&lt;&gt;();</span><br><span class="line">       cache.map(map);</span><br><span class="line">       cache.sizeLimit(size);</span><br><span class="line">       cache.cacheEvict(evict);</span><br><span class="line">       cache.removeListeners(removeListeners);</span><br><span class="line">       cache.load(load);</span><br><span class="line">       cache.persist(persist);</span><br><span class="line">       cache.slowListeners(slowListeners);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//初始化</span></span><br><span class="line">       cache.init();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> CacheProxy.getProxy(cache);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>缓存代理类 CacheProxy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取对象代理</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> cache 对象代理</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 代理信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; ICache&lt;K,V&gt; <span class="title function_">getProxy</span><span class="params">(<span class="keyword">final</span> ICache&lt;K,V&gt; cache)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(ObjectUtil.isNull(cache))&#123;</span><br><span class="line">          <span class="keyword">return</span> (ICache&lt;K, V&gt;) <span class="keyword">new</span> <span class="title class_">NoneProxy</span>(cache).proxy();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> cache.getClass();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果targetClass本身是个接口或者targetClass是JDK Proxy生成的，则使用JDK动态代理</span></span><br><span class="line">      <span class="comment">//参考 spring AOP 判断</span></span><br><span class="line">      <span class="keyword">if</span>(clazz.isInterface() || Proxy.isProxyClass(clazz))&#123;</span><br><span class="line">          <span class="keyword">return</span> (ICache&lt;K, V&gt;) <span class="keyword">new</span> <span class="title class_">DynamicProxy</span>(cache).proxy();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (ICache&lt;K, V&gt;) <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(cache).proxy();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>JDK 代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, ICacheProxy &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICache target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxy</span><span class="params">(ICache target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">proxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象调用其方法的</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicProxy</span>(target);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(handler.getClass().getClassLoader(),target.getClass().getInterfaces(),handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这种方式虽然实现了异步执行，但是存在一个缺陷：</span></span><br><span class="line"><span class="comment">     * 强制用户返回值为 Future 的子类</span></span><br><span class="line"><span class="comment">     * 如何实现才能不影响原来的值？？</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ICacheProxyBsContext</span> <span class="variable">context</span> <span class="operator">=</span> CacheProxyBsContext.newInstance()</span><br><span class="line">                .method(method).params(args).target(target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CacheProxyBs.newInstance().context(context).execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cglib 代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>, ICacheProxy &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICache target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CglibProxy</span><span class="params">(ICache target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">proxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//目标对象类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//通过字节码技术创建目标对象类的子类实例作为代理</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">ICacheProxyBsContext</span> <span class="variable">context</span> <span class="operator">=</span> CacheProxyBsContext.newInstance()</span><br><span class="line">                .method(method).params(objects).target(target);</span><br><span class="line">        <span class="keyword">return</span> CacheProxyBs.newInstance().context(context).execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理模式应用"><a href="#代理模式应用" class="headerlink" title="代理模式应用"></a>代理模式应用</h3><p>远程代理，为一个对象在不同的地址空间提供局部代表，可以隐藏一个对象存在于不同地址空间的事实。</p><p>虚拟代理，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层，通过它来存放实例化需要很长时间的真实对象。</p><p>安全代理，用来控制真实对象访问时的权限，一般用于对象应该有不同的访问权限的时候。</p><p>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它(C++智能指针)；例如上面的房产中介代理就是一种智能指引代理，代理附加了一些额外的功能，例如带看房等。</p><h3 id="代理模式的优点"><a href="#代理模式的优点" class="headerlink" title="代理模式的优点"></a>代理模式的优点</h3><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式主要是用于解决一个全局使用的类频繁地创建与销毁的问题，它保证了一个类只有一个实例，并提供一个访问它的访问点。</p><p>单例模式使用了双端检锁的方式实现，其中 Spring 的 bean 单例作用域就是一个典型的单例模式。</p><p>Spring 通过 <code>ConcurrentHashMap</code> 实现单例注册表的特殊方式实现单例模式。</p><p>Spring 实现单例的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象添加到单例注册表</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="built_in">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="literal">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多线程下的双端检锁</strong></p><p>下面的代码在多线程环境下不是原子执行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance=<span class="keyword">new</span> <span class="title class_">DoubleCheckSingleton</span>();</span><br></pre></td></tr></table></figure><p>正常的底层执行顺序会转变成三步：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 给<span class="title class_">DoubleCheckSingleton</span>类的实例instance分配内存</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 调用实例instance的构造函数来初始化成员变量</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>) 将instance指向分配的内存地址</span><br></pre></td></tr></table></figure><p>假如现在有线程A和线程B，线程A 按照 123 的顺序执行，不会出任何问题。</p><p>但是如果线程A在重排序的情况下，上面的执行顺序会变成1,3,2。现在假设A线程按1,3,2三个步骤顺序执行，当执行到第二步的时候。B线程开始调用这个方法，那么在第一个null的检查的时候，就有可能看到这个实例不是null，然后直接返回这个实例开始使用，但其实是有问题的，因为对象还没有初始化，状态还处于不可用的状态，故而会导致异常发生。 </p><p>要解决这个问题，可以通过volatile关键词来避免指令重排序，那么在变量赋值之后，会有一个内存屏障。也就说只有执行完1,2,3步操作后，读取操作才能看到，读操作不会被重排序到写操作之前。这样以来就解决了对象状态不完整的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式优势"><a href="#单例模式优势" class="headerlink" title="单例模式优势"></a>单例模式优势</h3><ul><li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul><h3 id="定义私有化构造函数防止类被实例化"><a href="#定义私有化构造函数防止类被实例化" class="headerlink" title="定义私有化构造函数防止类被实例化"></a>定义私有化构造函数防止类被实例化</h3><p>当在一个类中定义了私有构造函数时，它将限制其他代码在类外部直接实例化该类的对象。这意味着除了类内部的代码，其他代码无法通过调用类的构造函数来创建类的实例。</p><p>通过定义私有构造函数，可以实现以下几个方面的控制：</p><ol><li>防止类被意外地实例化：私有构造函数可以确保类的实例化只能在类的内部进行。这样可以防止其他代码意外地创建该类的对象，确保该类的使用符合设计意图。</li><li>实现单例模式：单例模式是一种设计模式，它要求一个类只能有一个实例。通过在类中定义私有构造函数，并在类内部控制实例的创建和访问，可以确保只有一个类的实例存在。</li><li>提供静态工厂方法：私有构造函数可以与静态工厂方法一起使用，使类的实例化过程更加灵活和可控。静态工厂方法是类中的一个静态方法，用于创建和返回类的实例，可以在创建实例之前进行一些额外的逻辑判断或操作。</li></ol><p>举例：</p><p>假设我们有一个名为 “Logger” 的日志记录器类，我们希望在整个应用程序中只有一个日志记录器实例。我们可以使用单例模式来实现这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger instance;</span><br><span class="line">    <span class="keyword">private</span> List&lt;string&gt; logs;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Logger</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        logs = <span class="keyword">new</span> <span class="title class_">List</span>&lt;string&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Log</span><span class="params">(string message)</span></span><br><span class="line">    &#123;</span><br><span class="line">        logs.Add(message);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Log: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintLogs</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Logs:&quot;</span>);</span><br><span class="line">        foreach (string log in logs)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(log);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，Logger 类被设计为单例模式。它具有一个私有的构造函数，以及一个公共的静态属性 Instance，用于获取 Logger 类的实例。当第一次访问 Instance 属性时，将创建一个 Logger 实例，并在后续的访问中返回该实例。</p><p>现在，我们可以在应用程序的任何地方使用 Logger 类来记录日志，而无需多次实例化它。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logger.Instance.Log(<span class="string">&quot;Error occurred: NullReferenceException&quot;</span>);</span><br><span class="line">Logger.Instance.Log(<span class="string">&quot;Warning: Invalid input detected&quot;</span>);</span><br><span class="line">Logger.Instance.PrintLogs();</span><br></pre></td></tr></table></figure><p>通过 Logger.Instance，我们可以在不同的代码部分获取同一个 Logger 实例，并使用 Log 方法记录日志信息。最后，我们可以使用 PrintLogs 方法打印所有已记录的日志。</p><p>这样，通过单例模式，我们确保了整个应用程序中只有一个 Logger 实例存在，避免了多个日志记录器实例导致的资源浪费或日志信息的不一致性。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8新特性</title>
      <link href="/2023/11/14/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2023/11/14/java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h1><p>Java8 新增了一些新特性，详情请参考 <a href="https://www.oracle.com/java/technologies/javase/8-whats-new.html">ORACLE官网—JDK8新增功能</a></p><p>本篇文章仅整理出常用的几个特性，日常开发中可灵活使用。</p><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>以前，我们可以使用<code>Collections</code> 工具类的 <code>Comparator</code> 比较器对给定的 <code>List</code> 集合进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;peter&quot;</span>, <span class="string">&quot;anna&quot;</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&quot;xenia&quot;</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在有了 lambda 表达式以后，推荐使用以下方法比较大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br><span class="line">names.sort((a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口（Functional Interface）就是只包含一个抽象方法的声明。针对该接口类型的所有 Lambda 表达式都会与这个抽象方法匹配。</p><p><code>@FunctionalInterface</code>保证接口内只有一个抽象方法。一旦添加了第二个抽象方法，编译器会立刻抛出错误提示。不过，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lyf.lambda.demo3.a01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01UserFunctionalInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用函数式接口中的方法</span></span><br><span class="line">        method((arr) -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">                sum += n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义的函数式接口作为方法参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Operator op)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> op.getSum(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;sum = &quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>[] arr)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用类的构造器及方法"><a href="#引用类的构造器及方法" class="headerlink" title="引用类的构造器及方法"></a>引用类的构造器及方法</h2><p>Java 8 允许使用 <code>::</code> 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaClassSuper</span> &#123;</span><br><span class="line">    LambdaInterface <span class="title function_">sf</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaClass</span> <span class="keyword">extends</span> <span class="title class_">LambdaClassSuper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LambdaInterface <span class="title function_">staticF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LambdaInterface <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.调用静态函数，返回类型必须是functional-interface</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">t</span> <span class="operator">=</span> LambdaClass::staticF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.实例方法调用</span></span><br><span class="line">        <span class="type">LambdaClass</span> <span class="variable">lambdaClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaClass</span>();</span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">lambdaInterface</span> <span class="operator">=</span> lambdaClass::f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.超类上的方法调用</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">superf</span> <span class="operator">=</span> <span class="built_in">super</span>::sf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 构造方法调用</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">tt</span> <span class="operator">=</span> LambdaClassSuper::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - i);</span><br><span class="line"><span class="comment">//i =3;</span></span><br></pre></td></tr></table></figure><p>lambda 表达式可以引用外边变量，但是该变量默认拥有 final 属性，不能被修改，如果修改，编译时就报错。</p><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p><code>Stream</code>依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。</p><p>它的源数据可以是 <code>Collection</code>、<code>Array</code> 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="comment">//返回符合条件的stream</span></span><br><span class="line">    Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; <span class="string">&quot;abc&quot;</span>.equals(s));</span><br><span class="line">    <span class="comment">//计算流符合条件的流的数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringStream.count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//forEach遍历-&gt;打印元素</span></span><br><span class="line">    strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//limit 获取到1个元素的stream</span></span><br><span class="line">    Stream&lt;String&gt; limit = strings.stream().limit(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//toArray 比如我们想看这个limitStream里面是什么，比如转换成String[],比如循环</span></span><br><span class="line">    String[] array = limit.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map 对每个元素进行操作返回新流</span></span><br><span class="line">    Stream&lt;String&gt; map = strings.stream().map(s -&gt; s + <span class="string">&quot;22&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sorted 升序排列并打印</span></span><br><span class="line">    strings.stream().sorted().forEach(System.out::println);</span><br><span class="line">    <span class="comment">//sorted 降序排列</span></span><br><span class="line">    Stream.of(<span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">55</span>).sorted((o1, o2) -&gt; o2 - o1).forEach(System.out::println);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//distinct 去重</span></span><br><span class="line">     Stream.of(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;刘德华&quot;</span>, <span class="number">58</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张学友&quot;</span>, <span class="number">56</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张学友&quot;</span>, <span class="number">56</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;黎明&quot;</span>, <span class="number">52</span>))</span><br><span class="line">                .distinct()</span><br><span class="line">                <span class="comment">// 按年龄升序进行排序</span></span><br><span class="line">                .sorted(Comparator.comparingInt(Person::getAge))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Collectors collect 把abc放入容器中</span></span><br><span class="line">    List&lt;String&gt; collect = strings.stream().filter(string -&gt; <span class="string">&quot;abc&quot;</span>.equals(string)).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//把list转为string，各元素用，号隔开</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mergedString</span> <span class="operator">=</span> strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组的统计，比如用</span></span><br><span class="line">    List&lt;Integer&gt; number = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">IntSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> number.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span>+statistics.getMax());</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span>+statistics.getMin());</span><br><span class="line">    System.out.println(<span class="string">&quot;平均数 : &quot;</span>+statistics.getAverage());</span><br><span class="line">    System.out.println(<span class="string">&quot;所有数之和 : &quot;</span>+statistics.getSum());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//concat 合并流</span></span><br><span class="line">    List&lt;String&gt; strings2 = Arrays.asList(<span class="string">&quot;xyz&quot;</span>, <span class="string">&quot;jqx&quot;</span>);</span><br><span class="line">    Stream.concat(strings2.stream(),strings.stream()).count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意 一个Stream只能操作一次，不能断开，否则会报错。</span></span><br><span class="line">    <span class="type">Stream</span> <span class="variable">stream</span> <span class="operator">=</span> strings.stream();</span><br><span class="line">    <span class="comment">//第一次使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//第二次使用</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">    <span class="comment">//报错 java.lang.IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是可以这样, 连续使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date-Time API"></a>Date-Time API</h2><p><strong>日期格式化</strong></p><p>Java8 之前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oldFormat</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">date</span>  <span class="operator">=</span> sdf.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format HH:mm:ss</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> sdft.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdfdt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">datetime</span> <span class="operator">=</span> sdfdt.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, datetime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java8 之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newFormat</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format HH:mm:ss</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now().withNano(<span class="number">0</span>);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">dateTimeStr</span> <span class="operator">=</span> dateTime.format(dateTimeFormatter);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, dateTimeStr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取指定日期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDayNew</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="comment">//获取当前月第一天：</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">firstDayOfThisMonth</span> <span class="operator">=</span> today.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">    <span class="comment">// 取本月最后一天</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastDayOfThisMonth</span> <span class="operator">=</span> today.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">    <span class="comment">//取下一天：</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">nextDay</span> <span class="operator">=</span> lastDayOfThisMonth.plusDays(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//当年最后一天</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastday</span> <span class="operator">=</span> today.with(TemporalAdjusters.lastDayOfYear());</span><br><span class="line">    <span class="comment">//2021年最后一个周日，如果用Calendar是不得烦死。</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastMondayOf2021</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-12-31&quot;</span>).with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈RocketMQ负载均衡策略</title>
      <link href="/2023/11/14/%E6%B5%85%E8%B0%88RocketMQ%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/"/>
      <url>/2023/11/14/%E6%B5%85%E8%B0%88RocketMQ%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>消息队列存在生产者和消费者，其中RocketMQ的生产者和消费者都有分组。</p><h3 id="生产者负载均衡"><a href="#生产者负载均衡" class="headerlink" title="生产者负载均衡"></a>生产者负载均衡</h3><p>生产者发送消息到RocketMQ时，RocketMQ将根据生产者负载均衡将消息均匀存储在多个队列中。</p><ul><li>同步刷盘，只有在消息真正持久化至磁盘后RocketMQ的Broker端才会真正返回给Producer端一个成功的ACK响应。同步刷盘对MQ消息可靠性来说是一种不错的保障，但是性能上会有较大影响，一般适用于金融业务应用该模式比较多。</li><li>异步刷盘：能够充分利用OS的PageCache的优势，只要消息写入PageCache即可成功的将ACK返回给Producer端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量。</li></ul><h4 id="RoundRobin模式"><a href="#RoundRobin模式" class="headerlink" title="RoundRobin模式"></a>RoundRobin模式</h4><p>对于非顺序消息（普通消息、定时&#x2F;延时消息、事务消息），<strong>默认且只能使用</strong>RoundRobin模式。</p><p>生产者发送消息时，以消息为粒度，按照轮询方式将消息发送到指定主题中的所有可写目标队列中，保证消息尽可能均衡分布到所有队列。</p><h5 id="故障规避策略"><a href="#故障规避策略" class="headerlink" title="故障规避策略"></a>故障规避策略</h5><p>当生产者某条消息发送失败时，RocketMQ会决定在接下来一段事件内，跳过本地失败队列所在节点，实现自适应的故障转移。</p><p>该参数由 <strong>sendLatencyFaultEnable</strong> 控制，用户可干预，表示是否开启延迟规避机制，默认为不开启。</p><ul><li>sendLatencyFaultEnable 设置为 false：默认值，不开启，延迟规避策略只在重试时生效，例如在一次消息发送过程中如果遇到消息发送失败，规避 broekr-a，但是在下一次消息发送时，即再次调用 DefaultMQProducer 的 send 方法发送消息时，还是会选择 broker-a 的消息进行发送，只要继续发送失败后，重试时再次规避 broker-a。</li><li>sendLatencyFaultEnable 设置为 true：开启延迟规避机制，一旦消息发送失败会将 broker-a “悲观”地认为在接下来的一段时间内该 Broker 不可用，在为未来某一段时间内所有的客户端不会向该 Broker 发送消息。这个延迟时间就是通过 notAvailableDuration、latencyMax 共同计算的，就首先先计算本次消息发送失败所耗的时延，然后对应 latencyMax 中哪个区间，即计算在 latencyMax 的下标，然后返回 notAvailableDuration 同一个下标对应的延迟值。</li></ul><p><em>按照笔者的实践经验，RocketMQ Broker 的繁忙基本都是瞬时的，而且通常与系统 PageCache 内核的管理相关，很快就能恢复，故不建议开启延迟机制。因为一旦开启延迟机制，例如 5 分钟内不会向一个 Broker 发送消息，这样会导致消息在其他 Broker 激增，从而会导致部分消费端无法消费到消息，增大其他消费者的处理压力，导致整体消费性能的下降。</em></p><h4 id="MessageGroupHash模式"><a href="#MessageGroupHash模式" class="headerlink" title="MessageGroupHash模式"></a>MessageGroupHash模式</h4><p>对于顺序消息场景，<strong>默认且只能使用</strong>MessageGroupHash模式的负载均衡策略。</p><p>生产者发送消息时，以消息组为粒度，按照内置的Hash算法，将相同消息组的消息分配到同一队列中，保证同消息组的消息按照发送的先后顺序存储。</p><h5 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h5><ul><li><strong>避免出现热点队列：</strong>如果业务侧将消息集中在少量或唯一的的消息组，则服务端存储消息时，也会集中存储在少量或唯一的队列中。不利于水平扩展。建议在设计消息组时，尽量将消息分散开。例如采用较离散的订单ID、用户名作为消息组的关键字，既能保证消息被分散到多个消息组中，又能保证统一终端用户的消息按顺序处理。</li><li><strong>避免绑定单队列发送：</strong>单队列容易产生性能瓶颈和容灾风险。</li></ul><h3 id="消费者负载均衡"><a href="#消费者负载均衡" class="headerlink" title="消费者负载均衡"></a>消费者负载均衡</h3><p>消费者消费RocketMQ上的消息时，可通过消费者负载均衡策略，将主题内的消息分配给指定消费者分组中多个消费者共同分担。</p><h4 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h4><p>每个消费者分组只初始化唯一一个消费者，每个消费者可消费到消费者分组内所有的消息，各消费者分组都订阅相同的消息，以此实现单客户端级别的广播一对多推送效果。</p><p>通俗点讲，就是消费者分组内唯一的消费者消费了分组内所有的消息。这个场景下其实不涉及消费者的负载均衡，因为只有一个消费者在消费。</p><p>该方式一般可用于网关推送、配置推送等场景。</p><h4 id="共享消费"><a href="#共享消费" class="headerlink" title="共享消费"></a>共享消费</h4><p>每个消费者分组下初始化了多个消费者，这些消费者共同分担消费者分组内的所有消息，实现消费者分组内流量的水平拆分和均衡负载。</p><p>通俗点讲，就是消费者分组内所有消费者共同消费了分组内所有的消息。</p><p>该方式一般可用于微服务解耦场景。</p><h4 id="消息粒度负载均衡"><a href="#消息粒度负载均衡" class="headerlink" title="消息粒度负载均衡"></a>消息粒度负载均衡</h4><p>对于PushConsumer和SimpleConsumer类型的消费者，<strong>默认且仅使用</strong>消息粒度负载均衡策略。</p><p>同一个队列中的消息，可被平均分配给多个消费者共同消费。</p><p><strong>那消息粒度负载均衡性是怎么保证消息不被重复消费的呢？</strong></p><p>消息粒度的负载均衡机制，是基于内部的单条消息确认语义实现的。<strong>消费者获取某条消息后，服务端会将该消息加锁</strong>，保证这条消息对其他消费者不可见，直到该消息消费成功或消费超时。因此，即使多个消费者同时消费同一队列的消息，服务端也可保证消息不会被多个消费者重复消费。</p><h4 id="队列粒度负载均衡"><a href="#队列粒度负载均衡" class="headerlink" title="队列粒度负载均衡"></a>队列粒度负载均衡</h4><p>对于历史版本（服务端4.x&#x2F;3.x版本）的消费者，包括PullConsumer、DefaultPushConsumer、DefaultPullConsumer、LitePullConsumer等，默认且仅能使用队列粒度负载均衡策略。</p><p>在该策略下，同一消费者分组内的多个消费者讲按照队列粒度消费消息，即每个队列仅被一个消费者消费。</p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>队列粒度负载均衡策略适用于流式计算、数据聚合等需要明确对消息进行聚合、批处理的场景。</p><h5 id="消息消费队列负载算法"><a href="#消息消费队列负载算法" class="headerlink" title="消息消费队列负载算法"></a>消息消费队列负载算法</h5><p><strong>AllocateMessageQueueAveragely</strong></p><p>平均连续分配算法。主要的特点是一个消费者分配的消息队列是连续的。</p><p><img src="https://i0.hdslb.com/bfs/article/9f63dc57d78a7ba763688b97bd6df28f171301454.png" alt="image-20250124103255784"></p><p><strong>AllocateMessageQueueAveragelyByCircle</strong></p><p>平均轮流分配算法，其分配示例图如下：</p><p><img src="https://i0.hdslb.com/bfs/article/66334fb3b9266e59697a082daaa08f03171301454.png" alt="image-20250124103502875"></p><p><strong>AllocateMachineRoomNearby</strong></p><p>机房内优先就近分配。其分配示例图如下：</p><p><img src="https://i0.hdslb.com/bfs/article/dd313668a91bf6de874472d291c3bfc8171301454.png" alt="image-20250124103955708"></p><p>上述的背景是一个 MQ 集群的两台 Broker 分别部署在两个不同的机房，每一个机房中都部署了一些消费者，其队列的负载情况是同机房中的消费队列优先被同机房的消费者进行分配，其分配算法可以指定其他的算法，例如示例中的平均分配，但如果机房 B 中的消费者宕机，B 机房中没有存活的消费者，那该机房中的队列会被其他机房中的消费者获取进行消费。</p><p><strong>AllocateMessageQueueByConfig</strong></p><p>手动指定，这个通常需要配合配置中心，在消费者启动时，首先先创建 AllocateMessageQueueByConfig 对象，然后根据配置中心的配置，再根据当前的队列信息，进行分配，即该方法不具备队列的自动负载，在 Broker 端进行队列扩容时，无法自动感知，需要手动变更配置。</p><p><strong>AllocateMessageQueueByMachineRoom</strong></p><p>消费指定机房中的队列，该分配算法首先需要调用该策略的 <code>setConsumeridcs(Set&lt;String&gt; consumerIdCs)</code> 方法，用于设置需要消费的机房，将刷选出来的消息按平均连续分配算法进行队列负载，其分配示例图如下所示：</p><p><img src="https://i0.hdslb.com/bfs/article/3db0c7c49be80aad04dd615ae657520f171301454.png" alt="image-20250124104207675"></p><p>由于设置 consumerIdCs 为 A 机房，故 B 机房中的队列并不会消息。</p><p><strong>AllocateMessageQueueConsistentHash</strong></p><p>一致性 Hash 算法，讲真，在消息队列负载这里使用一致性算法，没有任何实际好处，一致性 Hash 算法最佳的使用场景用在 Redis 缓存的分布式领域最适宜。</p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ重试机制</title>
      <link href="/2023/11/14/RocketMQ%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/11/14/RocketMQ%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><p>触发消息发送重试机制的条件如下：</p><ul><li>客户端消息发送请求调用失败或请求超时</li><li>网络异常造成连接失败或请求超时。</li><li>服务端节点处于重启或下线等状态造成连接失败。</li><li>服务端运行慢造成请求超时。</li><li>服务端返回失败错误码<ul><li>系统逻辑错误：因运行逻辑不正确造成的错误。</li><li>系统流控错误：因容量超限造成的流控错误。</li></ul></li></ul><p>消息重试时间间隔如下：</p><ul><li><p>无序消息：重试时间为阶梯时间<br><img src="https://i0.hdslb.com/bfs/openplatform/ccdbc327fba9ed09b4597f665bc573e94d7dd42c.png" alt="消息重试时间间隔"></p></li><li><p>顺序消息：重试时间为固定时间，默认为3s</p></li></ul><p>RocketMQ的重试机制涉及发送端重试和消费端重试，消费端重试关联死信队列</p><h3 id="发送端重试"><a href="#发送端重试" class="headerlink" title="发送端重试"></a>发送端重试</h3><p>RocketMQ 在客户端中内置了请求重试逻辑，支持在初始化时配置消息发送<strong>最大重试次数（默认为 2 次</strong>），失败时会按照设置的重试次数重新发送。直到消息发送成功，或者达到最大重试次数时结束，并在最后一次失败后返回调用错误的响应。对于<strong>同步发送和异步发送，均支持消息发送重试</strong>。</p><ul><li>同步发送：调用线程会一直阻塞，直到某次重试成功或最终重试失败（返回错误码或抛出异常）。</li><li>异步发送：调用线程不会阻塞，但调用结果会通过回调的形式，以异常事件或者成功事件返回。</li></ul><p>我们也手动设置重试次数。代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultMQProducer</span>  &#123;</span><br><span class="line"><span class="comment">//设置消息发送失败时的最大重试次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRetryTimesWhenSendFailed</span><span class="params">(<span class="type">int</span> retryTimesWhenSendFailed)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.retryTimesWhenSendFailed = retryTimesWhenSendFailed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>();</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;0.0.0.0:9876;0.0.0.1:9876&quot;</span>);</span><br><span class="line">producer.setRetryTimesWhenSendFailed(<span class="number">3</span>);</span><br><span class="line">producer.start();</span><br></pre></td></tr></table></figure><p>或者在配置文件 application.yaml 中配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rocketmq:  </span><br><span class="line">name-server: <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">9876</span>  </span><br><span class="line">producer:  </span><br><span class="line">group: producer-group  </span><br><span class="line">enable-msg-trace: <span class="literal">false</span>  </span><br><span class="line">retry-times-when-send-async-failed: <span class="number">3</span>  </span><br><span class="line">retry-times-when-send-failed: <span class="number">3</span>  </span><br><span class="line">send-message-timeout: <span class="number">60000</span>  </span><br><span class="line">consumer:  </span><br><span class="line">group: consumer-group</span><br></pre></td></tr></table></figure><h3 id="消费端重试"><a href="#消费端重试" class="headerlink" title="消费端重试"></a>消费端重试</h3><p>RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+ consumerGroup “的重试队列(这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的)，用于暂时保存因为各种异常而导致Consumer端无法消费的消息。</p><p>考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为<strong>“SCHEDULE_TOPIC XXXX”</strong>的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至**”%RETRY%+consumerGroup”**的重试队列中。</p><ul><li>只有在消息模式为<strong>MessageModel.CLUSTERING</strong>集群模式时，Broker才会自动进行重试，广播消息是不会重试的。</li></ul><p>分析了ConsumeMessageConcurrentlyService的源码，Consumer消费完成后会返回一个状态码，ConsumeConcurrentlyStatus是一个记录了并发消费状态的枚举类，共有两种状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ConsumeConcurrentlyStatus</span> &#123;</span><br><span class="line">   <span class="comment">//消费成功</span></span><br><span class="line">   ConsumeConcurrentlyStatus,</span><br><span class="line"></span><br><span class="line">   <span class="comment">//消费失败，一段时间后重试</span></span><br><span class="line">   RECONSUME_LATER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们拿并发消费时举例，MessageListenerConcurrently 中当捕获到异常时会设置下一级别的消费时间间隔并返回“再次消费”的状态码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;  </span><br><span class="line"><span class="keyword">for</span> (MessageExt messageExt : msgs) &#123;  </span><br><span class="line">log.debug(<span class="string">&quot;received msg: &#123;&#125;&quot;</span>, messageExt);  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line"><span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();  </span><br><span class="line">handleMessage(messageExt);  </span><br><span class="line"><span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> System.currentTimeMillis() - now;  </span><br><span class="line">log.debug(<span class="string">&quot;consume &#123;&#125; cost: &#123;&#125; ms&quot;</span>, messageExt.getMsgId(), costTime);  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;  <span class="comment">// 捕获到异常</span></span><br><span class="line">log.warn(<span class="string">&quot;consume message failed. messageExt:&#123;&#125;, error:&#123;&#125;&quot;</span>, messageExt, e);  </span><br><span class="line"><span class="comment">//设置下一个超时时间间隔</span></span><br><span class="line">context.setDelayLevelWhenNextConsume(delayLevelWhenNextConsume);  </span><br><span class="line"><span class="comment">// 返回状态码</span></span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常重试"><a href="#异常重试" class="headerlink" title="异常重试"></a>异常重试</h4><p>RocketMQ可在broker.conf文件中配置Consumer端的重试次数和重试时间间隔，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br></pre></td></tr></table></figure><p>我们可以在代码中指定最大重试次数，利用RocketMQConstant.MAX_RETRY_TIMES判断，如果超过最大重试次数，则提前返回“消费成功”，让 MQ 停止重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>:RocketMQ消息消费者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageConsumer</span> <span class="keyword">implements</span> <span class="title class_">MessageListenerConcurrently</span> &#123;</span><br><span class="line">   <span class="meta">@Value(&quot;$&#123;spring.rocketmq.namesrvAddr&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;DefaultConsumer&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@PostConstruct</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           consumer.setNamesrvAddr(namesrvAddr);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//从消息队列头部开始消费</span></span><br><span class="line">           consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//设置集群消费模式</span></span><br><span class="line">           consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//订阅主题</span></span><br><span class="line">           consumer.subscribe(<span class="string">&quot;DefaultCluster&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//注册消息监听器</span></span><br><span class="line">           consumer.registerMessageListener(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//启动消费端</span></span><br><span class="line">           consumer.start();</span><br><span class="line"></span><br><span class="line">           log.info(<span class="string">&quot;Message Consumer Start...&quot;</span>);</span><br><span class="line">           System.err.println(<span class="string">&quot;Message Consumer Start...&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">           log.error(<span class="string">&quot;Message Consumer Start Error!!&quot;</span>,e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (CollectionUtils.isEmpty(msgs)) &#123;</span><br><span class="line">           <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">MessageExt</span> <span class="variable">message</span> <span class="operator">=</span> msgs.get(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//逐条消费</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">messageBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), RemotingHelper.DEFAULT_CHARSET);</span><br><span class="line">           System.err.println(<span class="string">&quot;Message Consumer: Handle New Message: messageId: &quot;</span> + message.getMsgId() + <span class="string">&quot;,topic: &quot;</span> +</span><br><span class="line">                   message.getTopic() + <span class="string">&quot;,tags: &quot;</span> + message.getTags() + <span class="string">&quot;,messageBody: &quot;</span> + messageBody);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//模拟业务异常</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           log.error(<span class="string">&quot;Consume Message Error!!&quot;</span>, e);</span><br><span class="line">           <span class="comment">//抛出异常时，返回ConsumeConcurrentlyStatus.RECONSUME_LATER，尝试重试。当重试指定次数后返回ConsumeConcurrentlyStatus.CONSUME_SUCCESS</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">reconsumeTimes</span> <span class="operator">=</span> message.getReconsumeTimes();</span><br><span class="line">           System.err.println(<span class="string">&quot;Now Retry Times: &quot;</span> + reconsumeTimes);</span><br><span class="line">           <span class="keyword">if</span> (reconsumeTimes &gt;= RocketMQConstant.MAX_RETRY_TIMES) &#123;</span><br><span class="line">               <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用监听器监听时，可以在 service 层里抛出异常，RocketMQ 检测到异常后会自动返回 ConsumeConcurrentlyStatus.RECONSUME_LATER 的状态码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = TopicConstant.RPA_CALLBACK_RESULT_TASK,  </span></span><br><span class="line"><span class="meta">consumerGroup = &quot;$&#123;rocketmq.consumer.group&#125;&quot;+ &quot;-test-mq&quot;, consumeThreadMax = 2)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line">TestService testService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SneakyThrows</span>  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String msg)</span> &#123;  </span><br><span class="line">     log.info(<span class="string">&quot;收到信息：msg:&#123;&#125;&quot;</span>, msg);  </span><br><span class="line">     testService.receiveMsgTest(msg);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="超时重试"><a href="#超时重试" class="headerlink" title="超时重试"></a>超时重试</h4><p>当 Consumer 处理时间过长，在一定时间内没有返回 Broker 消费状态，Broker 也会自动重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageConsumer</span> <span class="keyword">implements</span> <span class="title class_">MessageListenerConcurrently</span> &#123;</span><br><span class="line">   <span class="meta">@Value(&quot;$&#123;spring.rocketmq.namesrvAddr&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;DefaultConsumer&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@PostConstruct</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           consumer.setNamesrvAddr(namesrvAddr);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//从消息队列头部开始消费</span></span><br><span class="line">           consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//设置集群消费模式</span></span><br><span class="line">           consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//设置消费超时时间(分钟)</span></span><br><span class="line">           consumer.setConsumeTimeout(RocketMQConstant.CONSUMER_TIMEOUT_MINUTES);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//订阅主题</span></span><br><span class="line">           consumer.subscribe(<span class="string">&quot;DefaultCluster&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//注册消息监听器</span></span><br><span class="line">           consumer.registerMessageListener(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//启动消费端</span></span><br><span class="line">           consumer.start();</span><br><span class="line"></span><br><span class="line">           log.info(<span class="string">&quot;Message Consumer Start...&quot;</span>);</span><br><span class="line">           System.err.println(<span class="string">&quot;Message Consumer Start...&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">           log.error(<span class="string">&quot;Message Consumer Start Error!!&quot;</span>,e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (CollectionUtils.isEmpty(msgs)) &#123;</span><br><span class="line">           <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">MessageExt</span> <span class="variable">message</span> <span class="operator">=</span> msgs.get(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//逐条消费</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">messageBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), RemotingHelper.DEFAULT_CHARSET);</span><br><span class="line">           System.err.println(<span class="string">&quot;Message Consumer: Handle New Message: messageId: &quot;</span> + message.getMsgId() + <span class="string">&quot;,topic: &quot;</span> +</span><br><span class="line">                   message.getTopic() + <span class="string">&quot;,tags: &quot;</span> + message.getTags() + <span class="string">&quot;,messageBody: &quot;</span> + messageBody);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//模拟耗时操作2分钟，大于设置的消费超时时间</span></span><br><span class="line">           Thread.sleep(<span class="number">1000L</span> * <span class="number">60</span> * <span class="number">2</span>);</span><br><span class="line">           <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           log.error(<span class="string">&quot;Consume Message Error!!&quot;</span>, e);</span><br><span class="line">           <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识RocketMQ</title>
      <link href="/2023/11/13/%E5%88%9D%E8%AF%86RocketMQ/"/>
      <url>/2023/11/13/%E5%88%9D%E8%AF%86RocketMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h1><ol><li>消息由生产者初始化并发送到云消息队列 RocketMQ 版服务端。</li><li>消息按照到达云消息队列 RocketMQ 版服务端的顺序存储到主题的指定队列中。</li><li>消费者按照指定的订阅关系从云消息队列 RocketMQ 版服务端中获取消息并消费<br><img src="https://i0.hdslb.com/bfs/openplatform/f7e5ffd73c98147c2a71a329a78ac5934bc7f946.png"></li></ol><p><img src="https://i0.hdslb.com/bfs/article/e32bfd4ea64369c5689bb4bab2797b98171301454.png" alt="image-20241106164027902"></p><p>RocketMO架构上主要分为四部分，如上图所示:</p><ul><li><p>Producer：消息发布的角色，支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p></li><li><p>Consumer：消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费<br>同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。</p></li><li><p>NameServer：NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。NameServer 互相独立，彼此没有通信关系，无状态。</p><p>主要包括两个功能：</p><ul><li><strong>Broker管理</strong>，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活;</li><li><strong>路由信息管理</strong>，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息,Producer,Consumer仍然可以动态感知Broker的路由的信息。</li></ul><p>消息客户端与NameServer、Broker的交互设计要点如下。</p><ul><li>Broker每隔30s向NameServer集群的每一台机器发送心跳包，包含自身创建的topic路由等信息。</li><li>消息客户端每隔30s向NameServer更新对应topic的路由信息。</li><li>NameServer收到Broker发送的心跳包时会记录时间戳。</li><li>NameServer每隔10s会扫描一次brokerLiveTable（存放心跳包的时间戳信息），如果在120s内没有收到心跳包，则认为Broker失效，更新topic的路由信息，将失效的Broker信息移除。</li><li>更新上述路由表（HashTable）使用了锁粒度较少的读写锁，允许多个消息发送者并发读操作，保证消息发送时的高并发。同一时刻NameServer只处理一个Broker心跳包，多个心跳包请求串行执行。</li></ul></li><li><p>BrokerServer：Broker主要负责消息的存储、投递和查询以及服务高可用保证，为了实现这些功能，Broker包含了以下几个重要子模块。</p><ul><li>Remoting Module：整个Broker的实体，负责处理来自clients端的请求</li><li>Client Manager：负责管理客户端(Producer&#x2F;Consumer)和维护Consumer的Topic订阅信息</li><li>Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。</li><li>HA Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。</li><li>HA Service:高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</li><li>Index Service:根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询。</li></ul></li></ul><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>主题是用于标识同一类业务的消息。<strong>主题是一个逻辑概念，并不是真实存在的消息容器。</strong></p><p>在拆分主题时，需要考虑拆分粒度：</p><ul><li>消息类型：顺序消息和普通消息要使用不同的主题</li><li>消息业务：业务上没有关联性的要使用不同的主题</li><li>消息量级：数量级或时效性不同的业务建议使用不同的主题</li></ul><p>创建和管理主题会占用一定系统资源，生产环境下，主题管理应尽量避免自动化机制。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是消息存储和传输的实际容器，主题中有多个队列组成，以此实现队列数量的水平拆分和队列内部的流式存储。</p><p><strong>队列的主要作用</strong></p><ul><li>存储顺序性：先进先出，通过offset对消息进行标记管理</li><li><strong>流式操作语义</strong>：可确保消息从任意offset读取任意数量的消息，实现类似聚合读取、回溯读取等特性</li></ul><p><strong>常见队列增加场景</strong></p><ul><li>增加队列实现物理节点负载均衡</li><li>增加队列实现顺序消息性能扩展</li><li>非顺序消息消费的负载均衡与队列数无关</li></ul><h1 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h1><p>异构系统间需要维持强一致的同步，上游的事件变更需要按照顺序传递到下游进行处理，这类场景下需要使用顺序消息保证数据传输的顺序。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>数据实时增量同步：当涉及到系统同步数据库中数据时，往往需要使用顺序消息。否则，在查询过程中易出现读取到已删除的数据的情况。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序消息发送。</span></span><br><span class="line"><span class="type">MessageBuilder</span> <span class="variable">messageBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messageBuilder.setTopic(<span class="string">&quot;topic&quot;</span>)</span><br><span class="line">        <span class="comment">//设置消息索引键，可根据关键字精确查找某条消息。</span></span><br><span class="line">        .setKeys(<span class="string">&quot;messageKey&quot;</span>)</span><br><span class="line">        <span class="comment">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span><br><span class="line">        .setTag(<span class="string">&quot;messageTag&quot;</span>)</span><br><span class="line">        <span class="comment">//设置顺序消息的排序分组，该分组尽量保持离散，避免热点排序分组。</span></span><br><span class="line">        .setMessageGroup(<span class="string">&quot;fifoGroup001&quot;</span>)</span><br><span class="line">        <span class="comment">//消息体。</span></span><br><span class="line">        .setBody(<span class="string">&quot;messageBody&quot;</span>.getBytes())</span><br><span class="line">        .build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//发送消息，需要关注发送结果，并捕获失败等异常</span></span><br><span class="line">    <span class="type">SendReceipt</span> <span class="variable">sendReceipt</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">    System.out.println(sendReceipt.getMessageId());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费顺序消息时，需要确保当前消费者分组是顺序投递模式，否则仍然按并发乱序投递。</span></span><br><span class="line"><span class="comment">//消费示例一：使用PushConsumer消费顺序消息，只需要在消费监听器处理即可。</span></span><br><span class="line"><span class="type">MessageListener</span> <span class="variable">messageListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeResult <span class="title function_">consume</span><span class="params">(MessageView messageView)</span> &#123;</span><br><span class="line">        System.out.println(messageView);</span><br><span class="line">        <span class="comment">//根据消费结果返回状态。</span></span><br><span class="line">        <span class="keyword">return</span> ConsumeResult.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//消费示例二：使用SimpleConsumer消费顺序消息，主动获取消息进行消费处理并提交消费结果。</span></span><br><span class="line"><span class="comment">//需要注意的是，同一个MessageGroup的消息，如果前序消息没有消费完成，再次调用Receive是获取不到后续消息的。</span></span><br><span class="line">List&lt;MessageView&gt; messageViewList = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    messageViewList = simpleConsumer.receive(<span class="number">10</span>, Duration.ofSeconds(<span class="number">30</span>));</span><br><span class="line">    messageViewList.forEach(messageView -&gt; &#123;</span><br><span class="line">        System.out.println(messageView);</span><br><span class="line">        <span class="comment">//消费处理完成后，需要主动调用ACK提交消费结果。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            simpleConsumer.ack(messageView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">    <span class="comment">//如果遇到系统流控等原因造成拉取失败，需要重新发起获取消息请求。</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定时-延时消息"><a href="#定时-延时消息" class="headerlink" title="定时&#x2F;延时消息"></a>定时&#x2F;延时消息</h1><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="1-分布式定时调度"><a href="#1-分布式定时调度" class="headerlink" title="1 分布式定时调度"></a>1 分布式定时调度</h3><p>在分布式定时调度场景下，需要实现精确的定时任务，比如每晚22:00执行一次数据同步，每隔5分钟触发一次任务推送。<br>RocketMQ在其中就充当一个定时任务触发器，我们发送到MQ上的消息会根据固定的时刻推送。</p><h3 id="2-任务超时处理"><a href="#2-任务超时处理" class="headerlink" title="2 任务超时处理"></a>2 任务超时处理</h3><p>电商支付场景下，订单下单后暂未支付，不可以直接关闭订单，而需要等待一段事件后才能关闭订单。<br>RocketMQ 可以实现超时任务的检查触发。</p><h2 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时/延时消息发送</span></span><br><span class="line"><span class="type">MessageBuilder</span> <span class="variable">messageBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageBuilder</span>();</span><br><span class="line"><span class="comment">//以下示例表示：延迟时间为10分钟之后的Unix时间戳。</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">deliverTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis() + <span class="number">10L</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messageBuilder.setTopic(<span class="string">&quot;topic&quot;</span>)</span><br><span class="line">        <span class="comment">//设置消息索引键，可根据关键字精确查找某条消息。</span></span><br><span class="line">        .setKeys(<span class="string">&quot;messageKey&quot;</span>)</span><br><span class="line">        <span class="comment">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span><br><span class="line">        .setTag(<span class="string">&quot;messageTag&quot;</span>)</span><br><span class="line">        .setDeliveryTimestamp(deliverTimeStamp)</span><br><span class="line">        <span class="comment">//消息体</span></span><br><span class="line">        .setBody(<span class="string">&quot;messageBody&quot;</span>.getBytes())</span><br><span class="line">        .build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//发送消息，需要关注发送结果，并捕获失败等异常。</span></span><br><span class="line">    <span class="type">SendReceipt</span> <span class="variable">sendReceipt</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">    System.out.println(sendReceipt.getMessageId());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费示例一：使用PushConsumer消费定时消息，只需要在消费监听器处理即可。</span></span><br><span class="line"><span class="type">MessageListener</span> <span class="variable">messageListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeResult <span class="title function_">consume</span><span class="params">(MessageView messageView)</span> &#123;</span><br><span class="line">        System.out.println(messageView.getDeliveryTimestamp());</span><br><span class="line">        <span class="comment">//根据消费结果返回状态。</span></span><br><span class="line">        <span class="keyword">return</span> ConsumeResult.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费示例二：使用SimpleConsumer消费定时消息，主动获取消息进行消费处理并提交消费结果。</span></span><br><span class="line">List&lt;MessageView&gt; messageViewList = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    messageViewList = simpleConsumer.receive(<span class="number">10</span>, Duration.ofSeconds(<span class="number">30</span>));</span><br><span class="line">    messageViewList.forEach(messageView -&gt; &#123;</span><br><span class="line">        System.out.println(messageView);</span><br><span class="line">        <span class="comment">//消费处理完成后，需要主动调用ACK提交消费结果。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            simpleConsumer.ack(messageView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">    <span class="comment">//如果遇到系统流控等原因造成拉取失败，需要重新发起获取消息请求。</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h1><h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><p>分布式系统调用的特点是一个核心业务逻辑的执行，同时需要调用多个下游业务进行处理。因此，为了保证核心业务和多个下游业务的执行结果一致，需要用到事务消息。</p><p>以电商场景为例，用户支付订单后，会修改物流发货、积分变更、购物车状态清空等多个子系统的变更。</p><h2 id="事务消息处理流程"><a href="#事务消息处理流程" class="headerlink" title="事务消息处理流程"></a>事务消息处理流程</h2><p><img src="https://i0.hdslb.com/bfs/openplatform/25b7eaf51a4c2bb0f2e946fd9c655f5700bcdbca.png" alt="事务消息"></p><ol><li>生产者将消息发送至云消息队列 RocketMQ 版服务端。</li><li>云消息队列 RocketMQ 版服务端将消息持久化成功之后，向生产者返回Ack确认消息已经发送成功，此时消息被标记为“暂不能投递”，这种状态下的消息即为半事务消息。</li><li>生产者开始执行本地事务逻辑。</li><li>生产者根据本地事务执行结果向服务端提交二次确认结果（Commit或是Rollback），服务端收到确认结果后处理逻辑如下：<ul><li>二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。</li><li>二次确认结果为Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。</li></ul></li><li>在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。</li><li>生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li><li>生产者根据检查到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行处理。</li></ol><h2 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h2><p>事务消息相比普通消息发送时需要修改以下几点：</p><ul><li>发送事务消息前，需要开启事务并关联本地的事务执行。</li><li>为保证事务一致性，在构建生产者时，必须设置事务检查器和预绑定事务消息发送的主题列表，客户端内置的事务检查器会对绑定的事务主题做异常状态恢复。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示demo，模拟订单表查询服务，用来确认订单事务是否提交成功。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkOrderById</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示demo，模拟本地事务的执行结果。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">doLocalTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClientException &#123;</span><br><span class="line">    <span class="type">ClientServiceProvider</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceProvider</span>();</span><br><span class="line">    <span class="type">MessageBuilder</span> <span class="variable">messageBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageBuilder</span>();</span><br><span class="line">    <span class="comment">//构造事务生产者：事务消息需要生产者构建一个事务检查器，用于检查确认异常半事务的中间状态。</span></span><br><span class="line">    <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> provider.newProducerBuilder()</span><br><span class="line">            .setTransactionChecker(messageView -&gt; &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 事务检查器一般是根据业务的ID去检查本地事务是否正确提交还是回滚，此处以订单ID属性为例。</span></span><br><span class="line"><span class="comment">                 * 在订单表找到了这个订单，说明本地事务插入订单的操作已经正确提交；如果订单表没有订单，说明本地事务已经回滚。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> messageView.getProperties().get(<span class="string">&quot;OrderId&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (Strings.isNullOrEmpty(orderId)) &#123;</span><br><span class="line">                    <span class="comment">// 错误的消息，直接返回Rollback。</span></span><br><span class="line">                    <span class="keyword">return</span> TransactionResolution.ROLLBACK;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> checkOrderById(orderId) ? TransactionResolution.COMMIT : TransactionResolution.ROLLBACK;</span><br><span class="line">            &#125;)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">//开启事务分支。</span></span><br><span class="line">    <span class="keyword">final</span> Transaction transaction;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        transaction = producer.beginTransaction();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//事务分支开启失败，直接退出。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messageBuilder.setTopic(<span class="string">&quot;topic&quot;</span>)</span><br><span class="line">            <span class="comment">//设置消息索引键，可根据关键字精确查找某条消息。</span></span><br><span class="line">            .setKeys(<span class="string">&quot;messageKey&quot;</span>)</span><br><span class="line">            <span class="comment">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span><br><span class="line">            .setTag(<span class="string">&quot;messageTag&quot;</span>)</span><br><span class="line">            <span class="comment">//一般事务消息都会设置一个本地事务关联的唯一ID，用来做本地事务回查的校验。</span></span><br><span class="line">            .addProperty(<span class="string">&quot;OrderId&quot;</span>, <span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">            <span class="comment">//消息体。</span></span><br><span class="line">            .setBody(<span class="string">&quot;messageBody&quot;</span>.getBytes())</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">//发送半事务消息</span></span><br><span class="line">    <span class="keyword">final</span> SendReceipt sendReceipt;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sendReceipt = producer.send(message, transaction);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">        <span class="comment">//半事务消息发送失败，事务可以直接退出并回滚。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行本地事务，并确定本地事务结果。</span></span><br><span class="line"><span class="comment">     * 1. 如果本地事务提交成功，则提交消息事务。</span></span><br><span class="line"><span class="comment">     * 2. 如果本地事务提交失败，则回滚消息事务。</span></span><br><span class="line"><span class="comment">     * 3. 如果本地事务未知异常，则不处理，等待事务消息回查。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">localTransactionOk</span> <span class="operator">=</span> doLocalTransaction();</span><br><span class="line">    <span class="keyword">if</span> (localTransactionOk) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transaction.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            <span class="comment">// 业务可以自身对实时性的要求选择是否重试，如果放弃重试，可以依赖事务消息回查机制进行事务状态的提交。</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transaction.rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            <span class="comment">// 建议记录异常信息，回滚异常时可以无需重试，依赖事务消息回查机制进行事务状态的提交。</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="死信消息"><a href="#死信消息" class="headerlink" title="死信消息"></a>死信消息</h1><p>消息消费异常进行消费重试时，达到最大重试次数后会转为死信状态，RocketMQ 支持将这些死信消息（Dead-Letter Message）保存至死信队列（Dead-Letter Queue），方便后续进行业务恢复或回溯。</p><h2 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h2><p>消息重试失败后，可以选择将死信消息存储到指定的死信 topic 中，创建另一个消费者组消费死信消息来处理异常链路或分析死信消息。</p><h2 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h2><ul><li>死信Topic只支持普通消息和顺序消息类型的Topic，事务消息类型和定时消息类型的Topic不能作为死信Topic。</li><li>不支持将生产原消息的Topic作为死信Topic（避免出现循环雪崩的问题）。在死信消息转存流程中，若系统发现死信Topic和生产消息的原Topic相同，则该条消息将被丢弃。</li><li>不同Topic的死信消息可以保存到同一个Topic中。</li><li>删除某个ConsumerGroup时，对应的死信Topic不会被删除。</li><li>若某个Topic被死信策略引用，删除该Topic前，您必须先解除该Topic的死信策略关系</li></ul><p>死信队列具备以下特点:</p><ul><li>RocketMQ会自动为需要死信队列的ConsumerGroup创建死信队列。</li><li>死信队列与ConsumerGroup对应，死信队列中包含该ConsumerGroup所有相关topic的死信消息。</li><li>死信队列中消息的有效期与正常消息相同，默认48小时。</li><li>若要消费死信队列中的消息，需在控制台将死信队列的权限设置为6，即可读可写。</li></ul><h1 id="Kafka、RabbitMQ和RocketMQ"><a href="#Kafka、RabbitMQ和RocketMQ" class="headerlink" title="Kafka、RabbitMQ和RocketMQ"></a>Kafka、RabbitMQ和RocketMQ</h1><table><thead><tr><th>项</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>吞吐量</td><td>万级(5.95w&#x2F;s)</td><td>10万级（17.3w&#x2F;s）</td><td>10万级（11.6w&#x2F;s）</td></tr><tr><td>时效性</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td></tr><tr><td>可用性</td><td>基于主从架构的高可用性。但集群扩展麻烦。</td><td>非常高。支持集群部署</td><td>非常高。分布式架构</td></tr><tr><td>消息可靠性</td><td>经过参数优化配置，可以保证数据不丢失</td><td>kafka收到消息后会写入磁盘缓冲区，没有直接落到物理磁盘上，机器故障可能会导致磁盘缓冲区内数据消失</td><td>经过参数优化配置，可以保证数据不丢失</td></tr><tr><td>性能稳定性</td><td>消息堆积时，性能不稳定</td><td>分区多时性能不稳定</td><td>队列较多、消息堆积时性能稳定</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2023/08/24/%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/08/24/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置一个虚拟头结点，使得链表中所有元素的删除操作都统一</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/design-linked-list/description/">707. 设计链表</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义链表节点结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>); <span class="comment">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; (_size - <span class="number">1</span>) || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = _dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123; <span class="comment">// 如果--index 就会陷入死循环</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        newNode-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表最后面添加一个节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果index大于链表的长度，则返回空</span></span><br><span class="line">    <span class="comment">// 如果index小于0，则置为0，作为链表的新头节点。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    LinkedNode* _dummyHead;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a><br>双指针，把链表的指针翻转一下，其实就是不断把 cur 指向 pre 的过程，画图可理解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode* temp;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line"></span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span>(cur)&#123;</span><br><span class="line"></span><br><span class="line">             temp = cur -&gt; next;</span><br><span class="line"></span><br><span class="line">             cur -&gt; next = pre;</span><br><span class="line"></span><br><span class="line">             pre = cur;</span><br><span class="line"></span><br><span class="line">             cur = temp;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a><br><img src="https://i0.hdslb.com/bfs/openplatform/c4cda20c8b8e708b12e4be6330d41def54e50d28.png" alt="交换节点"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          ListNode* dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          dummyNode -&gt; next = head;</span><br><span class="line"></span><br><span class="line">          ListNode* cur = dummyNode;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span>(cur -&gt; next != <span class="literal">nullptr</span> &amp;&amp; cur -&gt; next -&gt; next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line"></span><br><span class="line">              ListNode* tmp = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">              ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next; <span class="comment">// 记录临时节点</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">              cur-&gt;next = cur -&gt; next -&gt; next;</span><br><span class="line"></span><br><span class="line">              cur -&gt; next -&gt; next = tmp;</span><br><span class="line"></span><br><span class="line">              cur -&gt; next -&gt; next -&gt; next = tmp1;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">               cur = cur-&gt;next-&gt;next; <span class="comment">// cur移动两位，准备下一轮交换</span></span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> dummyNode -&gt; next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">           dummyHead -&gt; next = head;</span><br><span class="line"></span><br><span class="line">           ListNode* fast = dummyHead;</span><br><span class="line"></span><br><span class="line">           ListNode* slow = dummyHead;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span>(n-- &amp;&amp; fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">               fast = fast -&gt; next;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">           fast = fast -&gt; next; <span class="comment">// fast 移动 n + 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">               fast = fast -&gt; next;</span><br><span class="line"></span><br><span class="line">               slow = slow -&gt; next;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         slow -&gt; next = slow -&gt; next -&gt; next;</span><br><span class="line">        <span class="comment">// ListNode *tmp = slow-&gt;next;  C++释放内存的逻辑</span></span><br><span class="line">        <span class="comment">// slow-&gt;next = tmp-&gt;next;</span></span><br><span class="line">        <span class="comment">// delete nth;</span></span><br><span class="line">         <span class="keyword">return</span> dummyHead -&gt; next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a><br>简单题，只要将 A 移动到 与 B 的开端同步时，指针不断加一，判断 A B指向的节点是否相等即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line"></span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求A B长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">            lenA ++;</span><br><span class="line"></span><br><span class="line">            curA = curA -&gt; next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span>(curB != <span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">            lenB ++;</span><br><span class="line"></span><br><span class="line">            curB = curB -&gt; next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curA = headA;</span><br><span class="line"></span><br><span class="line">        curB = headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使得 A 是较长的那个链表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lenA &lt; lenB)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>(lenA,lenB);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>(curA,curB);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A 移动，与 B 齐平</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(gap --)&#123;</span><br><span class="line"></span><br><span class="line">            curA  = curA -&gt; next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curA &amp;&amp; curB)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curA == curB)&#123;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> curA;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curA = curA -&gt; next;</span><br><span class="line"></span><br><span class="line">            curB = curB -&gt; next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a><br>定义快慢指针，快指针一次走两步，慢指针一次走一步，如果有环，则快慢指针一定在环内相遇<br>记录下它们的相遇节点，头节点和相遇节点同时移动，它们的相遇点就是环的入口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode* fast = head;</span><br><span class="line"></span><br><span class="line">        ListNode* slow = head;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast -&gt; next != <span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">            fast = fast -&gt; next -&gt; next;</span><br><span class="line"></span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line"></span><br><span class="line">                ListNode* index2 = fast;</span><br><span class="line"></span><br><span class="line">                ListNode* index1 = head;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line"></span><br><span class="line">                    index1 = index1 -&gt; next;</span><br><span class="line"></span><br><span class="line">                    index2 = index2 -&gt; next;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2023/08/24/%E6%95%B0%E7%BB%84/"/>
      <url>/2023/08/24/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p><a href="https://leetcode.cn/problems/search-insert-position/">35.搜索插入位置</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二分查找  +  target不在数组中, return r + 1;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34.在排序数组中查找元素的第一个和最后一个位置</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[3,4,6] target = 2或7，&#123;-1，-1&#125;</span><br><span class="line">[3,4,6] target = 4     &#123;1,1&#125;</span><br><span class="line">[3,4,6] target = 5     &#123;-1,-1&#125;</span><br><span class="line">2个二分查找 寻找左边界和右边界</span><br><span class="line">寻找左边界，nums[target] == target的时候更新right</span><br><span class="line">寻找右边界，nums[target] == target的时候更新left</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sqrtx/">69.x 的平方根</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接二分查找[0,x] target = x / mid </span><br><span class="line">特判 x == 0 || x == 1</span><br><span class="line">如果没找到 target, 直接返回 r （舍弃算术平方根的小数部分）</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/valid-perfect-square/">367.有效的完全平方数</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二分查找 [0,num] target = num , 判断 mid * mid == num?</span><br><span class="line">注意将变量设为 long long</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用快慢指针，快指针遍历整个数组，慢指针负责寻找不等于val值（本题该移除出来得元素值）的元素，并放进数组里（覆盖）</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26.删除有序数组的重复项</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用快慢指针，快指针遍历整个数组，慢指针负责寻找不等于val值（本题中的前一个元素值），并放数组里（覆盖）</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/move-zeroes/">283.移动零</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用快慢指针，快指针遍历整个数组，慢指针负责寻找不等于0的值，最后再将0值覆盖给剩余的元素（注意边界）</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/backspace-string-compare/">844.比较含退格的字符串</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;#&#x27;为删除键，如果为&#x27;#&#x27;,则出栈，如果不为&#x27;#&#x27;，则入栈</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用双指针，分别在数组的两端，比较两个指针指向的元素的平方，把较大的放在数组的右边，并移动指针（向中间移动）；只能移动两边中较大的元素，因为无论是正数还是负数，平方后最大的元素只能出现在两边，不能出现在中间！！</span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a><br>滑动窗口，通过判断数组元素之间的和，对数组长度进行变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">              subLength = (j - i + <span class="number">1</span>); <span class="comment">// 取子序列的长度</span></span><br><span class="line">              result = result &lt; subLength ? result : subLength;</span><br><span class="line">              sum -= nums[i++]; <span class="comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span></span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a><br>思路与算法</p><p>我们可以使用滑动窗口解决本题，left 和 right 分别表示满足要求的窗口的左右边界，同时我们使用哈希表存储这个窗口内的数以及出现的次数。</p><p>我们每次将 right 移动一个位置，并将 fruits[right] 加入哈希表。如果此时哈希表不满足要求（即哈希表中出现超过两个键值对），那么我们需要不断移动 left，并将 fruits[left] 从哈希表中移除，直到哈希表满足要求为止。</p><p>需要注意的是，将 fruits[left]从哈希表中移除后，如果 fruits[left]在哈希表中的出现次数减少为 0，需要将对应的键值对从哈希表中移除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; <span class="keyword">public</span>: <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span></span>&#123;   </span><br><span class="line">          <span class="type">int</span> n = fruits.<span class="built_in">size</span>(); </span><br><span class="line">          unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt; <span class="type">int</span> left = <span class="number">0</span>, ans = <span class="number">0</span>; </span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right) &#123; </span><br><span class="line">          ++cnt[fruits[right]]; </span><br><span class="line">          <span class="keyword">while</span> (cnt.<span class="built_in">size</span>() &gt; <span class="number">2</span>) &#123; </span><br><span class="line">          <span class="keyword">auto</span> it = cnt.<span class="built_in">find</span>(fruits[left]); </span><br><span class="line">          --it-&gt;second; </span><br><span class="line">          <span class="keyword">if</span> (it-&gt;second == <span class="number">0</span>) &#123; </span><br><span class="line">             cnt.<span class="built_in">erase</span>(it); </span><br><span class="line">              &#125; </span><br><span class="line">          ++left; </span><br><span class="line">      &#125; </span><br><span class="line">       ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> ans; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a><br>滑动窗口—困难</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="type">int</span> <span class="variable">slen</span> <span class="operator">=</span> s.length();</span><br><span class="line"></span><br><span class="line">          <span class="type">int</span> <span class="variable">tlen</span> <span class="operator">=</span> t.length();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(slen == <span class="number">0</span> || tlen == <span class="number">0</span> || slen &lt; tlen)&#123;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="type">char</span>[] charArrayS = s.toCharArray();</span><br><span class="line"></span><br><span class="line">          <span class="type">char</span>[] charArrayT = t.toCharArray();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">          <span class="type">int</span>[] winFreq = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">          <span class="type">int</span>[] tFreq = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="type">char</span> c : charArrayT)&#123;</span><br><span class="line"></span><br><span class="line">              tFreq[c]++; <span class="comment">//收集 t 中字符个数</span></span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 窗口内 t 字符的个数</span></span><br><span class="line"></span><br><span class="line">          <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> slen + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">          <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span>(right &lt; slen)&#123;  <span class="comment">//右边界向右滑动，直到滑动窗口内有 t 中所有字符</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(tFreq[charArrayS[right]] == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                  right++;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(winFreq[charArrayS[right]] &lt; tFreq[charArrayS[right]])&#123;</span><br><span class="line"></span><br><span class="line">                  distance++; <span class="comment">// 标记 distance</span></span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">              winFreq[charArrayS[right]]++; <span class="comment">// 标记滑动窗口此时最右的字符</span></span><br><span class="line"></span><br><span class="line">              right++; <span class="comment">// 向右滑动</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">              <span class="keyword">while</span>(distance == tlen)&#123;  <span class="comment">// 滑动窗口内有 t 中所有字符</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; minLen)&#123;</span><br><span class="line"></span><br><span class="line">                    minLen = right - left;</span><br><span class="line"></span><br><span class="line">                    begin = left;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(tFreq[charArrayS[left]] == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                  left++;  <span class="comment">// 左边界向右滑动</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(winFreq[charArrayS[left]] == tFreq[charArrayS[left]])&#123;</span><br><span class="line"></span><br><span class="line">                  distance--; <span class="comment">//标记完 左边界继续向右滑动跳出此循环</span></span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">              winFreq[charArrayS[left]]--;</span><br><span class="line"></span><br><span class="line">              left++;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(minLen == slen + <span class="number">1</span>)&#123;  <span class="comment">// 没被赋值的情况</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin+minLen);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II </a><br>模拟</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 使用vector定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="type">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span> (loop --) &#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">            <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">            offset += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
