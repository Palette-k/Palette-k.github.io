<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RocketMQ消息消费原理及实战 | Palette</title><meta name="author" content="Palette,1148432487@qq.com"><meta name="copyright" content="Palette"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="DefaultMQPushConsumer 核心参数与工作原理Push模型消息拉取机制 其核心关键点如下：  经过队列负载机制后，会分配给当前消费者一些队列，注意一个消费组可以订阅多个主题，正如上面 pullRequestQueue 中所示，topic_test、topic_test1 这两个主题都分配了一个队列。 轮流从 pullRequestQueue 中取出一个 PullRequest 对象">
<meta property="og:type" content="article">
<meta property="og:title" content="RocketMQ消息消费原理及实战">
<meta property="og:url" content="https://palette-k.github.io/2025/01/24/RocketMQ%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="Palette">
<meta property="og:description" content="DefaultMQPushConsumer 核心参数与工作原理Push模型消息拉取机制 其核心关键点如下：  经过队列负载机制后，会分配给当前消费者一些队列，注意一个消费组可以订阅多个主题，正如上面 pullRequestQueue 中所示，topic_test、topic_test1 这两个主题都分配了一个队列。 轮流从 pullRequestQueue 中取出一个 PullRequest 对象">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i0.hdslb.com/bfs/openplatform/c269474c4aeae541267aedd6fc844a86ca926538.jpg">
<meta property="article:published_time" content="2025-01-24T02:45:52.000Z">
<meta property="article:modified_time" content="2025-10-13T03:34:43.353Z">
<meta property="article:author" content="Palette">
<meta property="article:tag" content="RocketMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i0.hdslb.com/bfs/openplatform/c269474c4aeae541267aedd6fc844a86ca926538.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://palette-k.github.io/2025/01/24/RocketMQ%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"KDCG4Y7LBT","apiKey":"d88d791bb15de311d25affcade475e37","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Palette","link":"链接: ","source":"来源: Palette","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RocketMQ消息消费原理及实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-10-13 11:34:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/article.css"><link rel="stylesheet" href="/css/tag.css"><link rel="stylesheet" href="/css/icon.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Palette" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i0.hdslb.com/bfs/openplatform/bbcfc80924d36130665348ba84604566a29ccdc1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i0.hdslb.com/bfs/openplatform/c269474c4aeae541267aedd6fc844a86ca926538.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Palette"><span class="site-name">Palette</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RocketMQ消息消费原理及实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-24T02:45:52.000Z" title="发表于 2025-01-24 10:45:52">2025-01-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-13T03:34:43.353Z" title="更新于 2025-10-13 11:34:43">2025-10-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/RocketMQ/">RocketMQ</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RocketMQ消息消费原理及实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="DefaultMQPushConsumer-核心参数与工作原理"><a href="#DefaultMQPushConsumer-核心参数与工作原理" class="headerlink" title="DefaultMQPushConsumer 核心参数与工作原理"></a>DefaultMQPushConsumer 核心参数与工作原理</h1><h2 id="Push模型消息拉取机制"><a href="#Push模型消息拉取机制" class="headerlink" title="Push模型消息拉取机制"></a>Push模型消息拉取机制</h2><p><img src="https://i0.hdslb.com/bfs/article/34094d07a066ff7e6475acf99c7d5e6e171301454.png" alt="image-20250126143819864"></p>
<p>其核心关键点如下：</p>
<ol>
<li>经过队列负载机制后，会分配给当前消费者一些队列，注意一个消费组可以订阅多个主题，正如上面 pullRequestQueue 中所示，topic_test、topic_test1 这两个主题都分配了一个队列。</li>
<li>轮流从 pullRequestQueue 中取出一个 PullRequest 对象，根据该对象中的拉取偏移量向 Broker 发起拉取请求，默认拉取 32 条，可通过上文中提到的 pullBatchSize 参数进行改变，该方法不仅会返回消息列表，还会返更改 PullRequest 对象中的下一次拉取的偏移量。</li>
<li>接收到 Broker 返回的消息后，会首先放入 ProccessQueue（处理队列），该队列的内部结构为 TreeMap，key 存放的是消息在消息消费队列（consumequeue）中的偏移量，而 value 为具体的消息对象。</li>
<li>然后将拉取到的消息提交到消费组内部的线程池，并立即返回，并将 PullRequest 对象放入到 pullRequestQueue 中，然后取出下一个 PullRequest 对象继续重复消息拉取的流程，从这里可以看出，消息拉取与消息消费是不同的线程。</li>
<li>消息消费组线程池处理完一条消息后，会将消息从 ProccessQueue 中，然后会向 Broker 汇报消息消费进度，以便下次重启时能从上一次消费的位置开始消费。</li>
</ol>
<h3 id="消息消费进度提交"><a href="#消息消费进度提交" class="headerlink" title="消息消费进度提交"></a>消息消费进度提交</h3><p>通过上面的介绍，想必读者应该对消息消费进度有了一个比较直观的认识，接下来我们再来介绍一下 RocketMQ PUSH 模式的消息消费进度提交机制。</p>
<p>通过上文的消息消费拉取模型可以看出，消息消费组线程池在处理完一条消息后，会将消息从 ProccessQueue 中移除，并向 Broker 汇报消息消费进度，那请大家思考一下下面这个问题：</p>
<p><img src="https://i0.hdslb.com/bfs/article/82c160432118244a2ece7530177c739c171301454.png" alt="image-20250126143838943"></p>
<p>例如现在处理队列中有 5 条消息，并且是线程池并发消费，那如果消息偏移量为 3 的消息（3:msg3）先于偏移量为 0、1、2 的消息处理完，那向 Broker 如何汇报消息消费进度呢？</p>
<p>有读者朋友说，消息 msg3 处理完，当然是向 Broker 汇报 msg3 的偏移量作为消息消费进度呀。但细心思考一下，发现如果提交 msg3 的偏移量为消息消费进度，那汇报完毕后如果消费者发生内存溢出等问题导致 JVM 异常退出，msg1 的消息还未处理，然后重启消费者，由于消息消费进度文件中存储的是 msg3 的消息偏移量，会继续从 msg3 开始消费，会造成<strong>消息丢失</strong>。显然这种方式并不可取。</p>
<p>RocketMQ 采取的方式是处理完 msg3 之后，会将 msg3 从消息处理队列中移除，但在向 Broker 汇报消息消费进度时是<strong>取 ProceeQueue 中最小的偏移量为消息消费进度</strong>，即汇报的消息消费进度是 0。</p>
<p><img src="https://i0.hdslb.com/bfs/article/dba0487f9bf6e1bf234d2f3ce58b14df171301454.png" alt="image-20250126143931458"></p>
<p>即如果处理队列如上图所示，那提交的消息进度为 2。但这种方案也并非完美，有可能会造成消息重复消费，例如如果发生内存溢出等异常情况，消费者重新启动，会继续从消息偏移量为 2 的消息开始消费，msg3 就会被消费多次，故<strong>RocketMQ 不保证消息重复消费</strong>。</p>
<p>消息消费进度具体的提交流程如下图所示：</p>
<p><img src="https://i0.hdslb.com/bfs/article/00a14766630dc1a91146c33fbe28460b171301454.png" alt="image-20250126144455180"></p>
<p>从这里也可以看成，为了减少消费者与 Broker 的网络交互，提高性能，提交消息消费进度时会首先存入到本地缓存表中，然后定时上报到 Broker，同样 Broker 也会首先存储本地缓存表，然后定时刷写到磁盘。</p>
<h2 id="Push模型参数注意事项"><a href="#Push模型参数注意事项" class="headerlink" title="Push模型参数注意事项"></a>Push模型参数注意事项</h2><h3 id="ConsumeFromWhere-注意事项"><a href="#ConsumeFromWhere-注意事项" class="headerlink" title="ConsumeFromWhere 注意事项"></a>ConsumeFromWhere 注意事项</h3><p>下面首先先看一段 RokcetMQ PUSH 模式消费者的常见使用方式：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815222732166.png" alt="1"></p>
<p>构建需要通过 setConsumeFromWhere(…) 指定从哪消费，正如上篇提到的，RocketMQ 支持从最新消息、最早消息、指定时间戳这三种方式进行消费。大家可以思考一下，如果一个消费者启动运行了一段时间，由于版本发布等原因需要先停掉消费者，代码更新后，再启动消费者时消费者还能使用上面这三种策略，从新的一条消息消费吗？如果是这样，在发版期间新发送的消息将全部丢失，这显然是不可接受的，要从上一次开始消费的时候消费，才能保证消息不丢失。</p>
<p><strong>故 ConsumeFromWhere 这个参数的含义是，初次启动从何处开始消费。更准确的表述是，如果查询不到消息消费进度时，从什么地方开始消费</strong>。</p>
<p>所以在实际使用过程中，如果对于一个设置为 CONSUME_FROM_FIRST_OFFSET 的运行良久的消费者，当前版本的业务逻辑进行了重大重构，而且业务希望是从最新的消息开始消费，想通过如下代码来实现其业务意图，则显然是不成功的。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer<span class="selector-class">.setConsumeFromWhere</span>(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);</span><br></pre></td></tr></table></figure>

<p>上面做法是错误的，要达到业务目标，需要使用 RocketMQ 提供的重置位点，其命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh ./mqadmin resetOffsetByTime -n 127.0.0.1:9876  -g CID_CONSUMER_TEST -t TopicTest -s now</span><br></pre></td></tr></table></figure>

<p>其中参数说明如下：</p>
<ul>
<li>-n：NameServer 地址</li>
<li>-g：消费组名称</li>
<li>-t：主题名称</li>
<li>-s：时间戳，可选值为 now、时间戳（毫秒）、yyyy-MM-dd#HH:mm:ss:SSS</li>
</ul>
<p>当然也可以通过 RocketMQ-Console 重置位点，操作如下图所示：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815222739573.png" alt="2"></p>
<h3 id="消费组线程数设置注意事项"><a href="#消费组线程数设置注意事项" class="headerlink" title="消费组线程数设置注意事项"></a>消费组线程数设置注意事项</h3><p>在 RocketMQ 中，每一个消费组都会启动一个线程池用来实现消费端在消费组的隔离，RocketMQ 也提供了 consumeThreadMin、consumeThreadMax 两个参数来设置线程池中的线程个数，但是由于线程池内部持有的队列为一个无界队列，导致 consumeThreadMax 大于 consumeThreadMin，线程个数最大也只能 consumeThreadMin 个线程数量，故在实践中，往往会将这两个值设置为相同，避免给大家带来一种误解，在消息端消息很多的情况，会创建更多的线程来提高消息的处理速率。</p>
<p>小技巧：RocketMQ 中的消费组线程的名称会以 ConsumeMessageThread_ 开头，例如下图。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815222942104.png" alt="9"></p>
<h3 id="批量消费注意事项"><a href="#批量消费注意事项" class="headerlink" title="批量消费注意事项"></a>批量消费注意事项</h3><p>RocketMQ 支持消息批量消费，在消费端与批量消费相关的两个参数分别为：</p>
<ul>
<li><strong>pullBatchSize</strong>：消息客户端一次向 Broker 发送拉取消息每批返回最大的消息条数，默认为 32。</li>
<li><strong>consumeMessageBatchMaxSize</strong>：提交到消息消费监听器中的消息条数，默认为 1。</li>
</ul>
<h4 id="consumeMessageBatchMaxSize"><a href="#consumeMessageBatchMaxSize" class="headerlink" title="consumeMessageBatchMaxSize"></a><strong>consumeMessageBatchMaxSize</strong></h4><p>默认情况下一次消息会拉取 32 条消息，但业务监听器收到的消息默认一条，为了更直观对其了解，现给出如下示例代码：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815222950456.png" alt="10"></p>
<p>如果将 consumeMessageBatchMaxSize 设置 10，其运行效果如下图所示：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815222958233.png" alt="11"></p>
<p>可以看到该参数生效了，consumeMessageBatchMaxSize 这个参数非常适合批处理，例如结合数据库的批处理，能显著提高性能。</p>
<h4 id="pullBatchSize"><a href="#pullBatchSize" class="headerlink" title="pullBatchSize"></a><strong>pullBatchSize</strong></h4><p>大家发现了一个问题，如果单条消息的处理时间较快，通过增加消费组线程个数无法显著提高消息的消费 TPS，并且通过 jstack 命令，看到几乎所有的线程都处于等待处理任务，其截图类似如下：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815223006940.png" alt="12"></p>
<p>此种情况说明线程都“无所事事”，应该增大其工作量，自然而然地需要增大每一批次消息拉取的数量。故尝试每一次消息拉取 100 条，每批消费 50 条。即通过如下代码进行设置：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">consumer<span class="selector-class">.setPullBatchSize</span>(<span class="number">100</span>);</span><br><span class="line">consumer<span class="selector-class">.setConsumeMessageBatchMaxSize</span>(<span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p>这里设置 consumeMessageBatchMaxSize 的值大于 pullBatchSize 的主要目的，就是验证每一次拉取的消息，因为如果 consumeMessageBatchMaxSize 大于 pullBatchSize，那每次批处理的消息条数等于 pullBatchSize，如果 consumeMessageBatchMaxSize 小于 pullBatchSize，会在客户端分页，然后尽最大可能一次传入 consumeMessageBatchMaxSize 条消息。</p>
<p>为了确保有足够的消息，在消息拉取之前，我建议先使用生产者压入大量消息。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815223014316.png" alt="13"></p>
<p>发现每批拉取的条数最多不会超过 32，显然服务端有足够的消息够拉取。</p>
<p>这是因为 Broker 端对消息拉取也提供了保护机制，同样有参数可以控制一次拉取最多返回消息的条数，其参数主要如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxTransferCountOnMessageInMemory</span><br></pre></td></tr></table></figure>

<p>如果此次消息拉取能全部命中，内存允许一次消息拉取的最大条数，默认值为 32 条。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxTransferBytesOnMessageInMemory</span><br></pre></td></tr></table></figure>

<p>如果此次消息拉取能全部命中，内存允许一次消息拉取的最大消息大小，默认为 256K。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxTransferCountOnMessageInDisk</span><br></pre></td></tr></table></figure>

<p>如果此次消息无法命中，内存需要从磁盘读取消息，则每一次拉取允许的最大条数，默认为 8。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxTransferBytesOnMessageInDisk</span><br></pre></td></tr></table></figure>

<p>如果此次消息无法命中，内存需要从磁盘读取消息，则每一次拉取允许的消息总大小，默认为 64K。</p>
<p>故如果需要一次拉取 100 条消息，还需要修改 broker 端相关的配置信息，通常建议修只修改命中内存相关的，如果要从磁盘拉取，为了包含 Broker，maxTransferCountOnMessageInDisk、maxTransferBytesOnMessageInDisk 保持默认值。</p>
<p>如果使用场景是大数据领域，建议的配置如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxTransferCountOnMessageInMemory</span>=<span class="number">5000</span></span><br><span class="line"><span class="attr">maxTransferBytesOnMessageInMemory</span> = <span class="number">5000</span> * <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>如果是业务类场景，建议配置如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxTransferCountOnMessageInMemory</span>=<span class="number">2000</span></span><br><span class="line"><span class="attr">maxTransferBytesOnMessageInMemory</span> = <span class="number">2000</span> * <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>修改 Broker 相关配置后，再运行上面的程序，其返回结果如下：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200815223025190.png" alt="14"></p>
<h3 id="订阅关系不一致导致消息丢失"><a href="#订阅关系不一致导致消息丢失" class="headerlink" title="订阅关系不一致导致消息丢失"></a>订阅关系不一致导致消息丢失</h3><p>在 RocketMQ 中，一个消费组能订阅多个主题，也能订阅多个 Tag，多个 Tag 用 <code>||</code> 分割，但同一个消费组中的所有消费者的订阅关系必须一致，不能一个订阅 TAGA，另外一个消费者却订阅 TAGB</p>
<p>一条消息的 Tag 为 TAGA，并且消费组 dw_tag_test 其中一个消费者有订阅 TAGA，那为什么还会显示 CONSUMED_BUT_FILTERED，这个状态代表的含义是，该条消息不符合消息过滤规则被过滤了，其原理图如下所示：</p>
<p><img src="https://i0.hdslb.com/bfs/article/c70b4316cb1046213a2aad1790d2bd75171301454.png" alt="image-20250126150301779"></p>
<p>其本质原因是，一个队列同一时间只会分配给一个消费者，这样队列上不符合的消息消费会被过滤，并且消息消费进度会向前移动，这样就会造成消息丢失。</p>
<h1 id="DefaultLitePullConsumer-核心参数与实战"><a href="#DefaultLitePullConsumer-核心参数与实战" class="headerlink" title="DefaultLitePullConsumer 核心参数与实战"></a>DefaultLitePullConsumer 核心参数与实战</h1><p>DefaultMQPullConsumer（PULL 模式）的 API 太底层，使用起来及其不方便，RocketMQ 官方设计者也注意到这个问题，为此在 RocketMQ 4.6.0 版本中引入了 PULL 模式的另外一个实现类 DefaultLitePullConsumer，即从 4.6.0 版本后，DefaultMQPullConsumer 已经被标记为废弃，故接下来将重点介绍 DefaultLitePullConsumer，并探究如何在实际中运用它解决相关问题。</p>
<h2 id="Lite-Pull-与-PUSH-模式之对比"><a href="#Lite-Pull-与-PUSH-模式之对比" class="headerlink" title="Lite Pull 与 PUSH 模式之对比"></a>Lite Pull 与 PUSH 模式之对比</h2><p>从上面的示例可以看出 Lite PULL 相关的 API 比 4.6.0 之前的 DefaultMQPullConsumer 的使用上要简便不少，从编程风格上已非常接近了 PUSH 模式，其底层的实现原理是否也一致呢？显然不是的，请听我我慢慢道来。</p>
<p>不知大家是否注意到，Lite PULL 模式下只是通过 poll() 方法拉取一批消息，然后提交给应用程序处理，<strong>采取自动提交模式下位点的提交与消费结果并没有直接挂钩，即消息如果处理失败，其消费位点还是继续向前继续推进，缺乏消息的重试机制。</strong>为了论证笔者的观点，这里给出 DefaultLitePullConsumer 的 poll() 方法执行流程图，请大家重点关注位点提交所处的位置。</p>
<p><img src="https://i0.hdslb.com/bfs/article/3534cd914ea4286dc343cd52a9267d9f171301454.png" alt="image-20250126151333790"></p>
<p><strong>Lite Pull 模式的自动提交位点，一个非常重要的特征是 poll() 方法一返回，这批消息就默认是消费成功了</strong>，一旦没有处理好，就会造成消息丢失，那有没有方法解决上述这个问题呢，<strong>seek 方法就闪亮登场了</strong>，在业务方法处理过程中，如果处理失败，可以通过 seek 方法重置消费位点，即在捕获到消息业务处理后，需要根据返回的第一条消息中（MessageExt）信息构建一个 MessageQueue 对象以及需要重置的位点。</p>
<p>Lite Pull 模式的消费者相比 PUSH 模式的另外一个不同点是 Lite Pull 模式没有消息消费重试机制，PUSH 模式在并发消费模式下默认提供了 16 次重试，并且每一次重试的间隔不一致，极大的简化了编程模型。在这方面 Lite Pull 模型还是会稍显复杂。</p>
<p>Lite Pull 模式针对 PUSH 模式一个非常大亮点是消息拉取线程是以消息消费组为维度的，而且一个消费者默认会创建 20 个拉取任务，在消息拉取效率方面比 PUSH 模型具有无可比拟的优势，特别适合大数据领域的批处理任务，即每隔多久运行一次的拉取任务。</p>
<h3 id="消息位点"><a href="#消息位点" class="headerlink" title="消息位点"></a>消息位点</h3><p>消息是按到达服务端的先后顺序存储在指定主题的多个队列中，每条消息在队列中都有一个唯一的Long类型坐标，这个坐标被定义为消息位点。</p>
<p>队列中最早一条消息的位点为最小消息位点（MinOffset）；最新一条消息的位点为最大消息位点（MaxOffset）。虽然消息队列逻辑上是无限存储，但由于服务端物理节点的存储空间有限，云消息队列 RocketMQ 版会滚动删除队列中存储最早的消息。因此，消息的最小消费位点和最大消费位点会一直递增变化。</p>
<h3 id="消费位点"><a href="#消费位点" class="headerlink" title="消费位点"></a>消费位点</h3><p>每个主题的队列都可以被多个消费者分组订阅。若某条消息被某个消费者消费后直接被删除，则其他订阅了该主题的消费者将无法消费该消息。</p>
<p>因此，云消息队列 RocketMQ 版通过消费位点管理消息的消费进度。每条消息被某个消费者消费完成后不会立即在队列中删除，云消息队列 RocketMQ 版会<strong>基于每个消费者分组维护一份消费记录</strong>，该记录指定消费者分组消费某一个队列时，消费过的最新一条消息的位点，即消费位点。</p>
<p>当消费者客户端离线，又再次重新上线时，会严格按照服务端保存的消费进度继续处理消息。如果服务端保存的历史位点信息已过期被删除，此时消费位点向前移动至服务端存储的最小位点。</p>
<p>因此，不同应用需要设置不同的消费者组，每个应用都能独立地接收和处理该 Topic 下的所有消息，互不干扰。而且消息队列会为每个消费者组独立记录其在 Topic 中的消费位点（offset）。这意味着每个消费者组都可以从自己上次消费的位置继续消费，互不影响。</p>
<h3 id="长轮询实现原理"><a href="#长轮询实现原理" class="headerlink" title="长轮询实现原理"></a>长轮询实现原理</h3><p>PULL 模式通常适合大数据领域的批处理操作，对消息的实时性要求不高，更加看重的是消息的拉取效率，即一次消息需要拉取尽可能多的消息，这样方便一次性对大量数据进行处理，提高数据的处理效率，特别是希望一次消息拉取再不济也要拉取点消息，不要出现太多无效的拉取请求（没有返回消息的拉取请求）。</p>
<p>首先大家来看一下如下这个场景：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200817190929584.png" alt="5"></p>
<p>即 Broker 端没有新消息时，Broker 端采取何种措施呢？我想基本有如下两种策略进行选择：</p>
<ul>
<li>Broker 端没有新消息，立即返回，拉取结果中不包含任何消息。</li>
<li>当前拉取请求在 Broker 端挂起，在 Broker 端挂起，并且轮询 Broker 端是否有新消息，即轮询机制。</li>
</ul>
<p>上面说的第二种方式，有一个“高大上”的名字——<strong>轮询</strong>，根据轮询的方式又可以分为<strong>长轮询、短轮询</strong>。</p>
<ul>
<li><strong>短轮询</strong>：第一次未拉取到消息后等待一个时间间隔后再试，默认为 1s，可以在 Broker 的配置文件中设置 shortPollingTimeMills 改变默认值，即轮询一次，<strong>注意：只轮询一次</strong>。</li>
<li><strong>长轮询</strong>：可以由 PULL 客户端设置在 Broker 端挂起的超时时间，默认为 20s，然后在 Broker 端没有拉取到消息后默认每隔 5s 一次轮询，并且在 Broker 端获取到新消息后，会唤醒拉取线程，结束轮询，尝试一次消息拉取，然后返回一批消息到客户端，长轮询的时序图如下所示：</li>
</ul>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200817190938839.png" alt="6"></p>
<p>从这里可以看出，长轮询比短轮询，轮询等待的时间长，短轮询只轮询一次，并且默认等待时间为 1s，而长轮询默认一次阻塞 5s，但支持被唤醒。</p>
<p>在 broker 端与长轮询相关的参数如下：</p>
<ul>
<li>longPollingEnable：是否开启长轮询，默认为 true。</li>
<li>shortPollingTimeMills：短轮询等待的时间，默认为 1000，表示 1s。</li>
</ul>
<h2 id="结合实际场景顺序消费、消息过滤实战"><a href="#结合实际场景顺序消费、消息过滤实战" class="headerlink" title="结合实际场景顺序消费、消息过滤实战"></a>结合实际场景顺序消费、消息过滤实战</h2><h3 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h3><h4 id="业务场景描述"><a href="#业务场景描述" class="headerlink" title="业务场景描述"></a><strong>业务场景描述</strong></h4><p>现在开发一个银行类项目，对用户的每一笔余额变更都需要发送短信通知到用户。如果用户同时在电商平台下单，转账两个渠道在同一时间进行了余额变更，此时用户收到的短信必须顺序的，例如先网上购物，消费了 128，余额 1000，再转账给朋友 200，剩余余额 800，如果这两条短信的发送顺序颠倒，给用户会带来很大的困扰，故在该场景下必须保证顺序。这里所谓的顺序，是针对同一个账号的，不同的账号无需保证顺序性，例如用户 A 的余额发送变更，用户 B 的余额发生变更，这两条短信的发送其实相互不干扰的，故不同账号之间无需保证顺序。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><p>本篇代码主要采用截图的方式展示其关键代码，并对其进行一些简单的解读。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200823180055930.png" alt="1"></p>
<p>首先这里的主业务是操作账户的余额，然后是余额变更后需要发短信通知给用户，但由于发送短信与账户转载是两个相对独立但又紧密的操作，故这里可以引入消息中间件来解耦这两个操作。但由于发送短信业务，其顺序一定要与扣款的顺序保证一致，故需要使用顺序消费。</p>
<p>由于 RocketMQ 只提供了消息队列的局部有序，故如果要实现某一类消息的顺序执行，就必须将这类消息发送到同一个队列，故这里在消息发送时使用了 MessageQueueSelector，并且使用用户账户进行队列负载，这样同一个账户的消息就会账号余额变更的顺序到达队列，然后队列中的消息就能被顺序消费。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/2020082318010499.png" alt="2"></p>
<p>顺序消费的事件监听器为 MessageListenerOrderly，表示顺序消费。</p>
<p>顺序消费在使用上比较简单，那 RocketMQ 顺序消费是如何实现的？队列重新负载时还能保持顺序消费吗？顺序消费会重复消费吗？</p>
<h4 id="RocketMQ-顺序消费原理简述"><a href="#RocketMQ-顺序消费原理简述" class="headerlink" title="RocketMQ 顺序消费原理简述"></a><strong>RocketMQ 顺序消费原理简述</strong></h4><p>在 RocketMQ 中，PUSH 模式的消息拉取模型如下图所示：</p>
<p><img src="https://i0.hdslb.com/bfs/article/34094d07a066ff7e6475acf99c7d5e6e171301454.png" alt="image-20250126143819864"></p>
<p>上述流程在前面的章节中已做了详述，这里不再累述，这里想重点突出线程池。</p>
<p>RocketMQ 消息消费端按照消费组进行的线程隔离，即每一个消费组都会创建已线程池，由一个线程池负责分配的所有队列中的消息。</p>
<p><strong>所以要保证消费端对单队列中的消息顺序处理，故多线程处理，需要按照消息消费队列进行加锁。</strong>故顺序消费在消费端的并发度并不取决消费端线程池的大小，而是取决于分给给消费者的队列数量，故如果一个 Topic 是用在顺序消费场景中，建议消费者的队列数设置增多，可以适当为非顺序消费的 2~3 倍，这样有利于提高消费端的并发度，方便横向扩容。</p>
<p>消费端的横向扩容或 Broker 端队列个数的变更都会触发消息消费队列的重新负载，在并发消息时在队列负载的时候一个消费队列有可能被多个消费者同时消息，但顺序消费时并不会出现这种情况，因为顺序消息不仅仅在消费消息时会锁定消息消费队列，在分配到消息队列时，<strong>能从该队列拉取消息还需要在 Broker 端申请该消费队列的锁</strong>，即同一个时间只有一个消费者能拉取该队列中的消息，确保顺序消费的语义。</p>
<p>从前面的文章中也介绍到并发消费模式在消费失败是有重试机制，默认重试 16 次，而且重试时是先将消息发送到 Broker，然后再次拉取到消息，这种机制就会丧失其消费的顺序性，故如果是顺序消费模式，消息重试时在消费端不停的重试，重试次数为 Integer.MAX_VALUE，<strong>即如果一条消息如果一直不能消费成功，其消息消费进度就会一直无法向前推进，即会造成消息积压现象。</strong></p>
<blockquote>
<p>温馨提示：顺序消息时一定要捕捉异常，必须能区分是系统异常还是业务异常，更加准确的要能区分哪些异常是通过重试能恢复的，哪些是通过重试无法恢复的。无法恢复的一定要尽量在发送到 MQ 之前就要拦截，并且需要提高告警功能。</p>
</blockquote>
<h3 id="消息过滤实战"><a href="#消息过滤实战" class="headerlink" title="消息过滤实战"></a>消息过滤实战</h3><h4 id="业务场景描述-1"><a href="#业务场景描述-1" class="headerlink" title="业务场景描述"></a><strong>业务场景描述</strong></h4><p>例如公司采用的是微服务架构，分为如下几个子系统，基础数据、订单模块、商家模块，各个模块的数据库都是独立的。微服务带来的架构伸缩性不容质疑，但数据库的相互独立，对于基础数据的 join 操作就不那么方便了，即在订单模块需要使用基础数据，还需要通过 Dubbo 服务的方式去请求接口，为了避免接口的调用，基础数据的数据量又不是特别多的情况，项目组更倾向于将基础数据的数据同步到各个业务模块的数据库，然后基础数据发生变化及时通知订单模块，这样与基础数据的表 join 操作就可以在本库完成。</p>
<h4 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a><strong>技术方案</strong></h4><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200823180123686.png" alt="4"></p>
<p>上述方案的关键思路：</p>
<ol>
<li>基础数据一旦数据发生变化，就向 MQ 的 base_data_topic 发送一条消息。</li>
<li>下游系统例如订单模块、商家模块订阅 base_data_topic 完成数据的同步。</li>
</ol>
<p>问题，如果订单模块出现一些不可预知的错误，导致数据同步出现异常，并且发现的时候，存储在 MQ 中的消息已经被删除，此时需要上游（基础数据）重推数据，这个时候，如果基础数据重推的消息直接发送到 base_data_topic，那该 Topic 的所有消费者都会消费到，这显然是不合适的。怎么解决呢？</p>
<p>通常有两种办法：</p>
<ul>
<li>为各个子模块创建另外一个主题，例如 retry_ods_base_data_topic，这样需要向哪个子系统就向哪个 Topic 发送。</li>
<li>引入 Tag 机制。</li>
</ul>
<p>本节主要来介绍一下 Tag 的思路。</p>
<p>首先，正常情况下，基础模块将数据变更发送到 base_data_topic，并且消息的 Tag 为 all。然后为每一个子系统定义一个单独的重推 Tag，例如 ods、shop。</p>
<p>消费端同时订阅 all 和各自的重推 Tag，完美解决问题。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><p>在消息发送时需要按照需求指定消息的 Tag，其示例代码如下：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200823180130930.png" alt="5"></p>
<p>然后在消息消费时订阅时，更加各自的模块订阅各自关注的 Tag，其示例代码如下：</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/RocketMQ%20%e5%ae%9e%e6%88%98%e4%b8%8e%e8%bf%9b%e9%98%b6%ef%bc%88%e5%ae%8c%ef%bc%89/assets/20200823180139407.png" alt="6"></p>
<p>在消息订阅时一个消费组可以订阅多个 Tag，多个 Tag 使用双竖线分隔。</p>
<h4 id="Topic-与-Tag-之争"><a href="#Topic-与-Tag-之争" class="headerlink" title="Topic 与 Tag 之争"></a><strong>Topic 与 Tag 之争</strong></h4><p>用 Tag 对同一个主题进行区分会引来一个“副作用”，就是在重置消息消费位点时该消费组需要“处理”的是所有标签的数据，虽然在 Broker 端、消息消费端最终会过滤，不符合 Tag 的消息并不会执行业务逻辑，但在消息拉取时还是需要将消息读取到 PageCache 中并进行过滤，会有一定的性能损耗，但这个不是什么大问题。</p>
<p>在数据推送这个场景，除了使用 Tag 机制来区分重推数据外，也可以为重推的数据再申请一个额外的主题，即通过主题来区分不同的数据，这种方案倒不说不可以，但这个在运维管理层面需要申请众多的 Topic，而这类 Topic 存储的其实是一类数据，使用不同的 Topic 存储同类数据，会显得较为松散。当然如果是不同的业务场景，就建议使用 Topic 来隔离。</p>
<h4 id="消息过滤常见问题"><a href="#消息过滤常见问题" class="headerlink" title="消息过滤常见问题"></a>消息过滤常见问题</h4><ol>
<li>多个消费者订阅同一个Topic下的不同Tag，出现消息丢失情况。</li>
</ol>
<p>可能原因：若多个消费者是通过同一个消费者分组（Group ID）订阅的指定Topic，则所有消费者的过滤条件即订阅的Tag要一致，否则会出现订阅关系不一致，导致部分消息丢失。</p>
<ol start="2">
<li>消费者在线无消费消息，但Group有堆积。</li>
</ol>
<p>采用SQL&#x2F;TAG消费过滤的方式，未被过滤条件命中的消息会计算为消息堆积，堆积量的计算如下所示。</p>
<p><img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/0584115371/CAEQTxiBgMDLjcy2jBkiIDhkM2MyMGRmNTI1MDQ1ODNhMTYzZGJiYTRhYTkxNTIw4618633_20240826151619.705.svg" alt="image"></p>
<ul>
<li>SQL消费方式：堆积量 &#x3D; 已就绪的消息量 + 处理中的消息量 - 未被SQL命中的消息数量。</li>
<li>TAG消费方式：堆积量 &#x3D;（已就绪的消息量 + 处理中的消息量）* TAG标签消息百分比。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://palette-k.github.io">Palette</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://palette-k.github.io/2025/01/24/RocketMQ%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/">https://palette-k.github.io/2025/01/24/RocketMQ%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://palette-k.github.io" target="_blank">Palette</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RocketMQ/">RocketMQ</a></div><div class="post_share"><div class="social-share" data-image="https://i0.hdslb.com/bfs/openplatform/c269474c4aeae541267aedd6fc844a86ca926538.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/24/RocketMQ%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%8F%8A%E8%BF%90%E7%BB%B4/" title="RocketMQ集群性能调优及运维"><img class="cover" src="https://i0.hdslb.com/bfs/openplatform/1f92d332b4010b134897787f85f216227212f1c3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RocketMQ集群性能调优及运维</div></div></a></div><div class="next-post pull-right"><a href="/2025/01/23/JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E9%AB%98%E9%97%AE%E9%A2%98/" title="JVM调优实战——解决内存占用高问题"><img class="cover" src="https://i0.hdslb.com/bfs/openplatform/c269474c4aeae541267aedd6fc844a86ca926538.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM调优实战——解决内存占用高问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/11/05/RocketMQ%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%A9%B6/" title="RocketMQ存储方式探究"><img class="cover" src="https://i0.hdslb.com/bfs/openplatform/1f92d332b4010b134897787f85f216227212f1c3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-05</div><div class="title">RocketMQ存储方式探究</div></div></a></div><div><a href="/2025/01/07/RocketMQ%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="RocketMQ消息发送常见错误及解决方案"><img class="cover" src="https://i0.hdslb.com/bfs/openplatform/1f92d332b4010b134897787f85f216227212f1c3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-07</div><div class="title">RocketMQ消息发送常见错误及解决方案</div></div></a></div><div><a href="/2023/11/14/RocketMQ%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/" title="RocketMQ重试机制"><img class="cover" src="https://i0.hdslb.com/bfs/openplatform/1f92d332b4010b134897787f85f216227212f1c3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-14</div><div class="title">RocketMQ重试机制</div></div></a></div><div><a href="/2024/11/11/RocketMQ%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="RocketMQ的最佳实践"><img class="cover" src="https://i0.hdslb.com/bfs/openplatform/1f92d332b4010b134897787f85f216227212f1c3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-11</div><div class="title">RocketMQ的最佳实践</div></div></a></div><div><a href="/2025/10/17/RocketMQ%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B%E6%8F%90%E5%8D%87AI%E9%80%9A%E4%BF%A1%E6%95%88%E7%8E%87/" title="RocketMQ消息模型提升AI通信效率"><img class="cover" src="https://i0.hdslb.com/bfs/openplatform/1f92d332b4010b134897787f85f216227212f1c3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-17</div><div class="title">RocketMQ消息模型提升AI通信效率</div></div></a></div><div><a href="/2025/01/24/RocketMQ%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%8F%8A%E8%BF%90%E7%BB%B4/" title="RocketMQ集群性能调优及运维"><img class="cover" src="https://i0.hdslb.com/bfs/openplatform/1f92d332b4010b134897787f85f216227212f1c3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-24</div><div class="title">RocketMQ集群性能调优及运维</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i0.hdslb.com/bfs/openplatform/bbcfc80924d36130665348ba84604566a29ccdc1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Palette</div><div class="author-info__description">这是一个终身学习的时代</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Palette-k"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Palette-k" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1148432487@gq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><style>
.announcement-card {
    --main-color: #ff00ff;
    --secondary-color: #00ffff;
    --highlight-color: #ff5500;
    position: relative;
    overflow: hidden;
}
.announcement-content {
    font-size: 1rem; 
    line-height: 1.2; 
    color: #000000;
    position: relative;
}
.keyword {
    color: #000000;
    font-weight: 300;
    font-size: 1.1rem; 
}
.highlight {
    color: #000000;
    font-weight: 1000;
    font-size: 1.2rem; 
}
.announcement-content ul {
    list-style-type: none;
    margin: 0.8rem 0; 
    padding-left: 1.5rem;   
}
</style>
<div class="announcement-card">
    <div class="announcement-content">
        <p><span class="highlight">欢迎来到「Palette」个人技术博客</span>！🎉</p>
        <p><strong>本平台专注于：</strong></p>
        <ul>
            <li><span class="keyword">> JAVA后端技术笔记</span></li>
            <li><span class="keyword">> 场景设计解决方案</span></li>
            <li><span class="keyword">> AI应用实践</span></li>
        </ul>
        <p>🌟 <strong>一起钻研技术，共同进步！</strong></p>
    </div>
</div>
</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DefaultMQPushConsumer-%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">DefaultMQPushConsumer 核心参数与工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Push%E6%A8%A1%E5%9E%8B%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.</span> <span class="toc-text">Push模型消息拉取机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%BA%A6%E6%8F%90%E4%BA%A4"><span class="toc-number">1.1.1.</span> <span class="toc-text">消息消费进度提交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Push%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.</span> <span class="toc-text">Push模型参数注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConsumeFromWhere-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">ConsumeFromWhere 注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%BB%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E8%AE%BE%E7%BD%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">消费组线程数设置注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%B6%88%E8%B4%B9%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">批量消费注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#consumeMessageBatchMaxSize"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">consumeMessageBatchMaxSize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pullBatchSize"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">pullBatchSize</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB%E4%B8%8D%E4%B8%80%E8%87%B4%E5%AF%BC%E8%87%B4%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1"><span class="toc-number">1.2.4.</span> <span class="toc-text">订阅关系不一致导致消息丢失</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DefaultLitePullConsumer-%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E4%B8%8E%E5%AE%9E%E6%88%98"><span class="toc-number">2.</span> <span class="toc-text">DefaultLitePullConsumer 核心参数与实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lite-Pull-%E4%B8%8E-PUSH-%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">2.1.</span> <span class="toc-text">Lite Pull 与 PUSH 模式之对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BD%8D%E7%82%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">消息位点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%82%B9"><span class="toc-number">2.1.2.</span> <span class="toc-text">消费位点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E8%BD%AE%E8%AF%A2%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.3.</span> <span class="toc-text">长轮询实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%E3%80%81%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4%E5%AE%9E%E6%88%98"><span class="toc-number">2.2.</span> <span class="toc-text">结合实际场景顺序消费、消息过滤实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9"><span class="toc-number">2.2.1.</span> <span class="toc-text">顺序消费</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">业务场景描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RocketMQ-%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">RocketMQ 顺序消费原理简述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4%E5%AE%9E%E6%88%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">消息过滤实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">业务场景描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">技术方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Topic-%E4%B8%8E-Tag-%E4%B9%8B%E4%BA%89"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">Topic 与 Tag 之争</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">消息过滤常见问题</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/10/17/RocketMQ%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B%E6%8F%90%E5%8D%87AI%E9%80%9A%E4%BF%A1%E6%95%88%E7%8E%87/" title="RocketMQ消息模型提升AI通信效率"><img src="https://i0.hdslb.com/bfs/openplatform/1f92d332b4010b134897787f85f216227212f1c3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ消息模型提升AI通信效率"/></a><div class="content"><a class="title" href="/2025/10/17/RocketMQ%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B%E6%8F%90%E5%8D%87AI%E9%80%9A%E4%BF%A1%E6%95%88%E7%8E%87/" title="RocketMQ消息模型提升AI通信效率">RocketMQ消息模型提升AI通信效率</a><time datetime="2025-10-17T06:49:26.000Z" title="发表于 2025-10-17 14:49:26">2025-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/17/APISIX%E7%9A%84%E4%BD%BF%E7%94%A8/" title="APISIX的使用"><img src="https://i0.hdslb.com/bfs/openplatform/c269474c4aeae541267aedd6fc844a86ca926538.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="APISIX的使用"/></a><div class="content"><a class="title" href="/2025/10/17/APISIX%E7%9A%84%E4%BD%BF%E7%94%A8/" title="APISIX的使用">APISIX的使用</a><time datetime="2025-10-17T02:20:26.000Z" title="发表于 2025-10-17 10:20:26">2025-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/24/MAT%E6%A1%88%E4%BE%8B%E6%95%B4%E7%90%86/" title="MAT案例整理"><img src="https://i0.hdslb.com/bfs/openplatform/1f92d332b4010b134897787f85f216227212f1c3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MAT案例整理"/></a><div class="content"><a class="title" href="/2025/09/24/MAT%E6%A1%88%E4%BE%8B%E6%95%B4%E7%90%86/" title="MAT案例整理">MAT案例整理</a><time datetime="2025-09-24T07:42:27.000Z" title="发表于 2025-09-24 15:42:27">2025-09-24</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By Palette</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'https://palette-k.github.io/2025/01/24/RocketMQ%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/'
    this.page.identifier = '/2025/01/24/RocketMQ%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/'
    this.page.title = 'RocketMQ消息消费原理及实战'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script type="text/javascript" src="/js/article.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:24%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" href="/categories/安全/">安全</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover2.webp);"> <a class="categoryBar-list-link" href="/categories/JVM/">JVM</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover3.webp);"> <a class="categoryBar-list-link" href="/categories/Spring/">Spring</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover4.webp);"> <a class="categoryBar-list-link" href="/categories/场景/">场景</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover5.webp);"> <a class="categoryBar-list-link" href="/categories/k8s/">k8s</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover6.webp);"> <a class="categoryBar-list-link" href="/categories/JUC/">JUC</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" href="/categories/maven/">maven</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover2.webp);"> <a class="categoryBar-list-link" href="/categories/MyBatis/">MyBatis</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover3.webp);"> <a class="categoryBar-list-link" href="/categories/MySQL/">MySQL</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover4.webp);"> <a class="categoryBar-list-link" href="/categories/缓存/">缓存</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover5.webp);"> <a class="categoryBar-list-link" href="/categories/RocketMQ/">RocketMQ</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover6.webp);"> <a class="categoryBar-list-link" href="/categories/SSE/">SSE</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" href="/categories/SSO/">SSO</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover2.webp);"> <a class="categoryBar-list-link" href="/categories/Docker/">Docker</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover3.webp);"> <a class="categoryBar-list-link" href="/categories/java/">java</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover4.webp);"> <a class="categoryBar-list-link" href="/categories/日志/">日志</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover5.webp);"> <a class="categoryBar-list-link" href="/categories/nginx/">nginx</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover6.webp);"> <a class="categoryBar-list-link" href="/categories/算法/">算法</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" href="/categories/WebSocket/">WebSocket</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover2.webp);"> <a class="categoryBar-list-link" href="/categories/xxl-job/">xxl-job</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover3.webp);"> <a class="categoryBar-list-link" href="/categories/netty/">netty</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover4.webp);"> <a class="categoryBar-list-link" href="/categories/git/">git</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover5.webp);"> <a class="categoryBar-list-link" href="/categories/设计模式/">设计模式</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover6.webp);"> <a class="categoryBar-list-link" href="/categories/AI/">AI</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementsByClassName('recent-posts')[0];
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/09/22/玩转AI应用/" alt=""><img width="48" height="48" src="https://i0.hdslb.com/bfs/openplatform/c269474c4aeae541267aedd6fc844a86ca926538.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-22</span><a class="blog-slider__title" href="2025/09/22/玩转AI应用/" alt="">玩转AI应用</a><div class="blog-slider__text">AI基本概念及新玩法</div><a class="blog-slider__button" href="2025/09/22/玩转AI应用/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/09/12/如何设计一个秒杀系统/" alt=""><img width="48" height="48" src="https://i0.hdslb.com/bfs/openplatform/c269474c4aeae541267aedd6fc844a86ca926538.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-12</span><a class="blog-slider__title" href="2025/09/12/如何设计一个秒杀系统/" alt="">如何设计一个秒杀系统</a><div class="blog-slider__text">关于秒杀场景设计思路拓展</div><a class="blog-slider__button" href="2025/09/12/如何设计一个秒杀系统/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/10/17/RocketMQ消息模型提升AI通信效率/" alt=""><img width="48" height="48" src="https://i0.hdslb.com/bfs/openplatform/1f92d332b4010b134897787f85f216227212f1c3.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-17</span><a class="blog-slider__title" href="2025/10/17/RocketMQ消息模型提升AI通信效率/" alt="">RocketMQ消息模型提升AI通信效率</a><div class="blog-slider__text">Apache RocketMQ 顺应AIGC浪潮，针对长时会话、稀缺算力调度及AI Agent协作等挑战，推出专为AI时代打造的消息引擎。</div><a class="blog-slider__button" href="2025/10/17/RocketMQ消息模型提升AI通信效率/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>